{
  "id": "guide/aot-compiler",
  "title": "The Ahead-of-Time (AOT) compiler",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular/edit/master/aio/content/guide/aot-compiler.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"the-ahead-of-time-aot-compiler\">The Ahead-of-Time (AOT) compiler<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#the-ahead-of-time-aot-compiler\"><i class=\"material-icons\">link</i></a></h1>\n<p>An Angular application consists mainly of components and their HTML templates. Because the components and templates provided by Angular cannot be understood by the browser directly, Angular applications require a compilation process before they can run in a browser.</p>\n<p>The Angular Ahead-of-Time (AOT) compiler converts your Angular HTML and TypeScript code into efficient JavaScript code during the build phase <em>before</em> the browser downloads and runs that code. Compiling your application during the build process provides a faster rendering in the browser.</p>\n<p>This guide explains how to specify metadata and apply available compiler options to compile your applications efficiently using the AOT compiler.</p>\n<div class=\"alert is-helpful\" &#x3C;p=\"\">  <a href=\"https://www.youtube.com/watch?v=kW9cJsvcsGo\">Watch compiler author Tobias Bosch explain the Angular compiler</a> at AngularConnect 2016.<p></p>\n</div>\n<a id=\"why-aot\"></a>\n<p>Here are some reasons you might want to use AOT.</p>\n<ul>\n<li>\n<p><em>Faster rendering</em>\nWith AOT, the browser downloads a pre-compiled version of the application.\nThe browser loads executable code so it can render the application immediately, without waiting to compile the app first.</p>\n</li>\n<li>\n<p><em>Fewer asynchronous requests</em>\nThe compiler <em>inlines</em> external HTML templates and CSS style sheets within the application JavaScript,\neliminating separate ajax requests for those source files.</p>\n</li>\n<li>\n<p><em>Smaller Angular framework download size</em>\nThere's no need to download the Angular compiler if the app is already compiled.\nThe compiler is roughly half of Angular itself, so omitting it dramatically reduces the application payload.</p>\n</li>\n<li>\n<p><em>Detect template errors earlier</em>\nThe AOT compiler detects and reports template binding errors during the build step\nbefore users can see them.</p>\n</li>\n<li>\n<p><em>Better security</em>\nAOT compiles HTML templates and components into JavaScript files long before they are served to the client.\nWith no templates to read and no risky client-side HTML or JavaScript evaluation,\nthere are fewer opportunities for injection attacks.</p>\n</li>\n</ul>\n<a id=\"overview\"></a>\n<h2 id=\"choosing-a-compiler\">Choosing a compiler<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#choosing-a-compiler\"><i class=\"material-icons\">link</i></a></h2>\n<p>Angular offers two ways to compile your application:</p>\n<ul>\n<li><strong><em>Just-in-Time</em> (JIT)</strong>, which compiles your app in the browser at runtime.</li>\n<li><strong><em>Ahead-of-Time</em> (AOT)</strong>, which compiles your app at build time.</li>\n</ul>\n<p>JIT compilation is the default when you run the <a href=\"cli/build\"><code>ng build</code></a> (build only) or <a href=\"cli/serve\"><code>ng serve</code></a>  (build and serve locally) CLI commands:</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng build\n  ng serve\n</code-example>\n<a id=\"compile\"></a>\n<p>For AOT compilation, include the <code>--aot</code> option with the <code>ng build</code> or <code>ng serve</code> command:</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng build --aot\n  ng serve --aot\n</code-example>\n<div class=\"alert is-helpful\">\n<p>The <code>ng build</code> command with the <code>--prod</code> meta-flag (<code>ng build --prod</code>) compiles with AOT by default.</p>\n<p>See the <a href=\"cli\">CLI command reference</a> and <a href=\"guide/build\">Building and serving Angular apps</a> for more information.</p>\n</div>\n<h2 id=\"how-aot-works\">How AOT works<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#how-aot-works\"><i class=\"material-icons\">link</i></a></h2>\n<p>The Angular AOT compiler extracts <strong>metadata</strong> to interpret the parts of the application that Angular is supposed to manage.\nYou can specify the metadata explicitly in <strong>decorators</strong> such as <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> and <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, or implicitly in the constructor declarations of the decorated classes.\nThe metadata tells Angular how to construct instances of your application classes and interact with them at runtime.</p>\n<p>In the following example, the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> metadata object and the class constructor tell Angular how to create and display an instance of <code>TypicalComponent</code>.</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-typical',\n  template: '&#x3C;div>A typical component for {{data.name}}&#x3C;/div>'\n)}\nexport class TypicalComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() data: TypicalData;\n  constructor(private someService: SomeService) { ... }\n}\n</code-example>\n<p>The Angular compiler extracts the metadata <em>once</em> and generates a <em>factory</em> for <code>TypicalComponent</code>.\nWhen it needs to create a <code>TypicalComponent</code> instance, Angular calls the factory, which produces a new visual element, bound to a new instance of the component class with its injected dependency.</p>\n<h3 id=\"compilation-phases\">Compilation phases<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#compilation-phases\"><i class=\"material-icons\">link</i></a></h3>\n<p>There are three phases of AOT compilation.</p>\n<ul>\n<li>\n<p>Phase 1 is <em>code analysis</em>.\nIn this phase, the TypeScript compiler and  <em>AOT collector</em> create a representation of the source. The collector does not attempt to interpret the metadata it collects. It represents the metadata as best it can and records errors when it detects a metadata syntax violation.</p>\n</li>\n<li>\n<p>Phase 2 is <em>code generation</em>.\nIn this phase, the compiler's <code>StaticReflector</code> interprets the metadata collected in phase 1, performs additional validation of the metadata, and throws an error if it detects a metadata restriction violation.</p>\n</li>\n<li>\n<p>Phase 3 is <em>template type checking</em>.\nIn this optional phase, the Angular <em>template compiler</em> uses the TypeScript compiler to validate the binding expressions in templates. You can enable this phase explicitly by setting the <code>fullTemplateTypeCheck</code> configuration option; see <a href=\"guide/angular-compiler-options\">Angular compiler options</a>.</p>\n</li>\n</ul>\n<h3 id=\"metadata-restrictions\">Metadata restrictions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#metadata-restrictions\"><i class=\"material-icons\">link</i></a></h3>\n<p>You write metadata in a <em>subset</em> of TypeScript that must conform to the following general constraints:</p>\n<ul>\n<li>Limit <a href=\"guide/aot-compiler#expression-syntax\">expression syntax</a> to the supported subset of JavaScript.</li>\n<li>Only reference exported symbols after <a href=\"guide/aot-compiler#code-folding\">code folding</a>.</li>\n<li>Only call <a href=\"guide/aot-compiler#supported-functions\">functions supported</a> by the compiler.</li>\n<li>Decorated and data-bound class members must be public.</li>\n</ul>\n<p>For additional guidelines and instructions on preparing an application for AOT compilation, see <a href=\"https://medium.com/sparkles-blog/angular-writing-aot-friendly-applications-7b64c8afbe3f\">Angular: Writing AOT-friendly applications</a>.</p>\n<div class=\"alert is-helpful\">\n<p>Errors in AOT compilation commonly occur because of metadata that does not conform to the compiler's requirements (as described more fully below).\nFor help in understanding and resolving these problems, see <a href=\"guide/aot-metadata-errors\">AOT Metadata Errors</a>.</p>\n</div>\n<h3 id=\"configuring-aot-compilation\">Configuring AOT compilation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#configuring-aot-compilation\"><i class=\"material-icons\">link</i></a></h3>\n<p>You can provide options in the <code>tsconfig.json</code> <a href=\"guide/typescript-configuration\">TypeScript configuration file</a> that control the compilation process. See <a href=\"guide/angular-compiler-options\">Angular compiler options</a> for a complete list of available options.</p>\n<h2 id=\"phase-1-code-analysis\">Phase 1: Code analysis<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-1-code-analysis\"><i class=\"material-icons\">link</i></a></h2>\n<p>The TypeScript compiler does some of the analytic work of the first phase. It emits the <code>.d.ts</code> <em>type definition files</em> with type information that the AOT compiler needs to generate application code.\nAt the same time, the AOT <strong>collector</strong> analyzes the metadata recorded in the Angular decorators and outputs metadata information in <strong><code>.metadata.json</code></strong> files, one per <code>.d.ts</code> file.</p>\n<p>You can think of <code>.metadata.json</code> as a diagram of the overall structure of a decorator's metadata, represented as an <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">abstract syntax tree (AST)</a>.</p>\n<div class=\"alert is-helpful\">\n<p>Angular's <a href=\"https://github.com/angular/angular/blob/master/packages/compiler-cli/src/metadata/schema.ts\">schema.ts</a>\ndescribes the JSON format as a collection of TypeScript interfaces.</p>\n</div>\n<a id=\"expression-syntax\"></a>\n<h3 id=\"expression-syntax-limitations\">Expression syntax limitations<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#expression-syntax-limitations\"><i class=\"material-icons\">link</i></a></h3>\n<p>The  AOT collector only understands a subset of JavaScript.\nDefine metadata objects with the following limited syntax:</p>\n<style>\n  td, th {vertical-align: top}\n</style>\n<table>\n  <tbody><tr>\n    <th>Syntax</th>\n    <th>Example</th>\n  </tr>\n  <tr>\n    <td>Literal object </td>\n    <td><code>{cherry: true, apple: true, mincemeat: false}</code></td>\n  </tr>\n  <tr>\n    <td>Literal array  </td>\n    <td><code>['cherries', 'flour', 'sugar']</code></td>\n  </tr>\n  <tr>\n    <td>Spread in literal array</td>\n    <td><code>['apples', 'flour', ...the_rest]</code></td>\n  </tr>\n   <tr>\n    <td>Calls</td>\n    <td><code>bake(ingredients)</code></td>\n  </tr>\n   <tr>\n    <td>New</td>\n    <td><code>new Oven()</code></td>\n  </tr>\n   <tr>\n    <td>Property access</td>\n    <td><code>pie.slice</code></td>\n  </tr>\n   <tr>\n    <td>Array index</td>\n    <td><code>ingredients[0]</code></td>\n  </tr>\n   <tr>\n    <td>Identity reference</td>\n    <td><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code></td>\n  </tr>\n   <tr>\n    <td>A template string</td>\n    <td><code>`pie is ${multiplier} times better than cake`</code></td>\n   </tr><tr>\n    <td>Literal string</td>\n    <td><code>pi</code></td>\n  </tr>\n   <tr>\n    <td>Literal number</td>\n    <td><code>3.14153265</code></td>\n  </tr>\n   <tr>\n    <td>Literal boolean</td>\n    <td><code>true</code></td>\n  </tr>\n   <tr>\n    <td>Literal null</td>\n    <td><code>null</code></td>\n  </tr>\n   <tr>\n    <td>Supported prefix operator </td>\n    <td><code>!cake</code></td>\n  </tr>\n   <tr>\n    <td>Supported binary operator </td>\n    <td><code><a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>+b</code></td>\n  </tr>\n   <tr>\n    <td>Conditional operator</td>\n    <td><code><a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> ? b : c</code></td>\n  </tr>\n   <tr>\n    <td>Parentheses</td>\n    <td><code>(<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>+b)</code></td>\n  </tr>\n</tbody></table>\n<p>If an expression uses unsupported syntax, the collector writes an error node to the <code>.metadata.json</code> file.\nThe compiler later reports the error if it needs that piece of metadata to generate the application code.</p>\n<div class=\"alert is-helpful\">\n<p> If you want <code>ngc</code> to report syntax errors immediately rather than produce a <code>.metadata.json</code> file with errors, set the <code>strictMetadataEmit</code> option in the TypeScript configuration file, <code>tsconfig.json</code>.</p>\n<code-example>\n  \"angularCompilerOptions\": {\n   ...\n   \"strictMetadataEmit\" : true\n }\n</code-example>\n<p>Angular libraries have this option to ensure that all Angular <code>.metadata.json</code> files are clean and it is a best practice to do the same when building your own libraries.</p>\n</div>\n<a id=\"function-expression\"></a>\n<a id=\"arrow-functions\"></a>\n<h3 id=\"no-arrow-functions\">No arrow functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#no-arrow-functions\"><i class=\"material-icons\">link</i></a></h3>\n<p>The AOT compiler does not support <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\">function expressions</a>\nand <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">arrow functions</a>, also called <em>lambda</em> functions.</p>\n<p>Consider the following component decorator:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [{provide: server, <a href=\"api/core/FactorySansProvider#useFactory\" class=\"code-anchor\">useFactory</a>: () => new Server()}]\n})\n</code-example>\n<p>The AOT collector does not support the arrow function, <code>() => new Server()</code>, in a metadata expression.\nIt generates an error node in place of the function.\nWhen the compiler later interprets this node, it reports an error that invites you to turn the arrow function into an <em>exported function</em>.</p>\n<p>You can fix the error by converting to this:</p>\n<code-example language=\"typescript\">\nexport function serverFactory() {\n  return new Server();\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [{provide: server, <a href=\"api/core/FactorySansProvider#useFactory\" class=\"code-anchor\">useFactory</a>: serverFactory}]\n})\n</code-example>\n<p>In version 5 and later, the compiler automatically performs this rewriting while emitting the <code>.js</code> file.</p>\n<a id=\"exported-symbols\"></a>\n<a id=\"code-folding\"></a>\n<h3 id=\"code-folding\">Code folding<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#code-folding\"><i class=\"material-icons\">link</i></a></h3>\n<p>The compiler can only resolve references to <strong><em>exported</em></strong> symbols.\nThe collector, however, can evaluate an expression during collection and record the result in the <code>.metadata.json</code>, rather than the original expression.\nThis allows you to make limited use of non-exported symbols within expressions.</p>\n<p>For example, the collector can evaluate the expression <code>1 + 2 + 3 + 4</code> and replace it with the result, <code>10</code>.\nThis process is called <em>folding</em>. An expression that can be reduced in this manner is <em>foldable</em>.</p>\n<a id=\"var-declaration\"></a>\n<p>The collector can evaluate references to module-local <code>const</code> declarations and initialized <code>var</code> and <code>let</code> declarations, effectively removing them from the <code>.metadata.json</code> file.</p>\n<p>Consider the following component definition:</p>\n<code-example language=\"typescript\">\nconst template = '&#x3C;div>{{hero.name}}&#x3C;/div>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: template\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<p>The compiler could not refer to the <code>template</code> constant because it isn't exported.\nThe collector, however, can fold the <code>template</code> constant into the metadata definition by in-lining its contents.\nThe effect is the same as if you had written:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: '&#x3C;div>{{hero.name}}&#x3C;/div>'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<p>There is no longer a reference to <code>template</code> and, therefore, nothing to trouble the compiler when it later interprets the <em>collector's</em> output in <code>.metadata.json</code>.</p>\n<p>You can take this example a step further by including the <code>template</code> constant in another expression:</p>\n<code-example language=\"typescript\">\nconst template = '&#x3C;div>{{hero.name}}&#x3C;/div>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: template + '&#x3C;div>{{hero.title}}&#x3C;/div>'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<p>The collector reduces this expression to its equivalent <em>folded</em> string:</p>\n<code-example>\n'&#x3C;div>{{hero.name}}&#x3C;/div>&#x3C;div>{{hero.title}}&#x3C;/div>'\n</code-example>\n<h4 id=\"foldable-syntax\">Foldable syntax<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#foldable-syntax\"><i class=\"material-icons\">link</i></a></h4>\n<p>The following table describes which expressions the collector can and cannot fold:</p>\n<style>\n  td, th {vertical-align: top}\n</style>\n<table>\n  <tbody><tr>\n    <th>Syntax</th>\n    <th>Foldable</th>\n  </tr>\n  <tr>\n    <td>Literal object </td>\n    <td>yes</td>\n  </tr>\n  <tr>\n    <td>Literal array  </td>\n    <td>yes</td>\n  </tr>\n  <tr>\n    <td>Spread in literal array</td>\n    <td>no</td>\n  </tr>\n   <tr>\n    <td>Calls</td>\n    <td>no</td>\n  </tr>\n   <tr>\n    <td>New</td>\n    <td>no</td>\n  </tr>\n   <tr>\n    <td>Property access</td>\n    <td>yes, if target is foldable</td>\n  </tr>\n   <tr>\n    <td>Array index</td>\n    <td> yes, if target and index are foldable</td>\n  </tr>\n   <tr>\n    <td>Identity reference</td>\n    <td>yes, if it is a reference to a local</td>\n  </tr>\n   <tr>\n    <td>A template with no substitutions</td>\n    <td>yes</td>\n  </tr>\n   <tr>\n    <td>A template with substitutions</td>\n    <td>yes, if the substitutions are foldable</td>\n  </tr>\n   <tr>\n    <td>Literal string</td>\n    <td>yes</td>\n  </tr>\n   <tr>\n    <td>Literal number</td>\n    <td>yes</td>\n  </tr>\n   <tr>\n    <td>Literal boolean</td>\n    <td>yes</td>\n  </tr>\n   <tr>\n    <td>Literal null</td>\n    <td>yes</td>\n  </tr>\n   <tr>\n    <td>Supported prefix operator </td>\n    <td>yes, if operand is foldable</td>\n  </tr>\n   <tr>\n    <td>Supported binary operator </td>\n    <td>yes, if both left and right are foldable</td>\n  </tr>\n   <tr>\n    <td>Conditional operator</td>\n    <td>yes, if condition is foldable </td>\n  </tr>\n   <tr>\n    <td>Parentheses</td>\n    <td>yes, if the expression is foldable</td>\n  </tr>\n</tbody></table>\n<p>If an expression is not foldable, the collector writes it to <code>.metadata.json</code> as an <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">AST</a> for the compiler to resolve.</p>\n<h2 id=\"phase-2-code-generation\">Phase 2: code generation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-2-code-generation\"><i class=\"material-icons\">link</i></a></h2>\n<p>The collector makes no attempt to understand the metadata that it collects and outputs to <code>.metadata.json</code>.\nIt represents the metadata as best it can and records errors when it detects a metadata syntax violation.\nIt's the compiler's job to interpret the <code>.metadata.json</code> in the code generation phase.</p>\n<p>The compiler understands all syntax forms that the collector supports, but it may reject <em>syntactically</em> correct metadata if the <em>semantics</em> violate compiler rules.</p>\n<h3 id=\"public-symbols\">Public symbols<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#public-symbols\"><i class=\"material-icons\">link</i></a></h3>\n<p>The compiler can only reference <em>exported symbols</em>.</p>\n<ul>\n<li>Decorated component class members must be public. You cannot make an <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> property private or protected.</li>\n<li>Data bound properties must also be public.</li>\n</ul>\n<code-example language=\"typescript\">\n// BAD CODE - title is private\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: '&#x3C;h1>{{title}}&#x3C;/h1>'\n})\nexport class AppComponent {\n  private title = 'My App'; // Bad\n}\n</code-example>\n<a id=\"supported-functions\"></a>\n<h3 id=\"supported-classes-and-functions\">Supported classes and functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#supported-classes-and-functions\"><i class=\"material-icons\">link</i></a></h3>\n<p>The collector can represent a function call or object creation with <code>new</code> as long as the syntax is valid.\nThe compiler, however, can later refuse to generate a call to a <em>particular</em> function or creation of a <em>particular</em> object.</p>\n<p>The compiler can only create instances certain classes, supports only core decorators, and only supports calls to macros (functions or static methods) that return expressions.</p>\n<ul>\n<li>\n<p>New instances</p>\n<p> The compiler only allows metadata that create instances of the class <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> from <code>@angular/core</code>.</p>\n</li>\n<li>\n<p>Supported decorators</p>\n<p> The compiler only supports metadata for the <a href=\"api/core#decorators\">Angular decorators in the <code>@angular/core</code> module</a>.</p>\n</li>\n<li>\n<p>Function calls</p>\n<p> Factory functions must be exported, named functions.\nThe AOT compiler does not support lambda expressions (\"arrow functions\") for factory functions.</p>\n</li>\n</ul>\n<a id=\"function-calls\"></a>\n<h3 id=\"functions-and-static-method-calls\">Functions and static method calls<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#functions-and-static-method-calls\"><i class=\"material-icons\">link</i></a></h3>\n<p>The collector accepts any function or static method that contains a single <code>return</code> statement.\nThe compiler, however, only supports macros in the form of functions or static methods that return an <em>expression</em>.</p>\n<p>For example, consider the following function:</p>\n<code-example language=\"typescript\">\nexport function wrapInArray&#x3C;T>(value: T): T[] {\n  return [value];\n}\n</code-example>\n<p>You can call the <code>wrapInArray</code> in a metadata definition because it returns the value of an expression that conforms to the compiler's restrictive JavaScript subset.</p>\n<p>You might use  <code>wrapInArray()</code> like this:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: wrapInArray(TypicalComponent)\n})\nexport class TypicalModule {}\n</code-example>\n<p>The compiler treats this usage as if you had written:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [TypicalComponent]\n})\nexport class TypicalModule {}\n</code-example>\n<p>The Angular <a href=\"api/router/RouterModule\"><code>RouterModule</code></a> exports two macro static methods, <code>forRoot</code> and <code>forChild</code>, to help declare root and child routes.\nReview the <a href=\"https://github.com/angular/angular/blob/master/packages/router/src/router_module.ts#L139\" title=\"RouterModule.forRoot source code\">source code</a>\nfor these methods to see how macros can simplify configuration of complex <a href=\"guide/ngmodules\">NgModules</a>.</p>\n<a id=\"metadata-rewriting\"></a>\n<h3 id=\"metadata-rewriting\">Metadata rewriting<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#metadata-rewriting\"><i class=\"material-icons\">link</i></a></h3>\n<p>The compiler treats object literals containing the fields <code>useClass</code>, <code><a href=\"api/core/ValueSansProvider#useValue\" class=\"code-anchor\">useValue</a></code>, <code><a href=\"api/core/FactorySansProvider#useFactory\" class=\"code-anchor\">useFactory</a></code>, and <code>data</code> specially, converting the expression initializing one of these fields into an exported variable that replaces the expression.\nThis process of rewriting these expressions removes all the restrictions on what can be in them because\nthe compiler doesn't need to know the expression's value—it just needs to be able to generate a reference to the value.</p>\n<p>You might write something like:</p>\n<code-example language=\"typescript\">\nclass TypicalServer {\n\n}\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, <a href=\"api/core/FactorySansProvider#useFactory\" class=\"code-anchor\">useFactory</a>: () => TypicalServer}]\n})\nexport class TypicalModule {}\n</code-example>\n<p>Without rewriting, this would be invalid because lambdas are not supported and <code>TypicalServer</code> is not exported.\nTo allow this, the compiler automatically rewrites this to something like:</p>\n<code-example language=\"typescript\">\nclass TypicalServer {\n\n}\n\nexport const ɵ0 = () => new TypicalServer();\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, <a href=\"api/core/FactorySansProvider#useFactory\" class=\"code-anchor\">useFactory</a>: ɵ0}]\n})\nexport class TypicalModule {}\n</code-example>\n<p>This allows the compiler to generate a reference to <code>ɵ0</code> in the factory without having to know what the value of <code>ɵ0</code> contains.</p>\n<p>The compiler does the rewriting during the emit of the <code>.js</code> file.\nIt does not, however, rewrite the <code>.d.ts</code> file, so TypeScript doesn't recognize it as being an export. and it does not interfere with the ES module's exported API.</p>\n<a id=\"binding-expression-validation\"></a>\n<h2 id=\"phase-3-template-type-checking\">Phase 3: Template type checking<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-3-template-type-checking\"><i class=\"material-icons\">link</i></a></h2>\n<p>In the template type-checking phase, the Angular template compiler uses the TypeScript compiler to validate the binding expressions in templates.\nEnable this phase explicitly by adding the compiler option <code>\"fullTemplateTypeCheck\"</code> in the <code>\"angularCompilerOptions\"</code> of the project's <code>tsconfig.json</code>\n(see <a href=\"guide/angular-compiler-options\">Angular Compiler Options</a>).</p>\n<p>Template validation produces error messages when a type error is detected in a template binding\nexpression, similar to how type errors are reported by the TypeScript compiler against code in a <code>.ts</code>\nfile.</p>\n<p>For example, consider the following component:</p>\n<code-example language=\"typescript\">\n  @<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n    selector: 'my-component',\n    template: '{{person.addresss.street}}'\n  })\n  class MyComponent {\n    person?: Person;\n  }\n</code-example>\n<p>This produces the following error:</p>\n<code-example>\n  my.component.ts.MyComponent.html(1,1): : Property 'addresss' does not exist on type 'Person'. Did you mean 'address'?\n</code-example>\n<p>The file name reported in the error message, <code>my.component.ts.MyComponent.html</code>, is a synthetic file\ngenerated by the template compiler that holds contents of the <code>MyComponent</code> class template.\nThe compiler never writes this file to disk.\nThe line and column numbers are relative to the template string in the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> annotation of the class, <code>MyComponent</code> in this case.\nIf a component uses <code>templateUrl</code> instead of <code>template</code>, the errors are reported in the HTML file referenced by the <code>templateUrl</code> instead of a synthetic file.</p>\n<p>The error location is the beginning of the text node that contains the interpolation expression with the error.\nIf the error is in an attribute binding such as <code>[value]=\"person.address.street\"</code>, the error\nlocation is the location of the attribute that contains the error.</p>\n<p>The validation uses the TypeScript type checker and the options supplied to the TypeScript compiler to control how detailed the type validation is.\nFor example, if the <code>strictTypeChecks</code> is specified, the error\n<code>my.component.ts.MyComponent.html(1,1): : Object is possibly 'undefined'</code>\nis reported as well as the above error message.</p>\n<h3 id=\"type-narrowing\">Type narrowing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#type-narrowing\"><i class=\"material-icons\">link</i></a></h3>\n<p>The expression used in an <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> directive is used to narrow type unions in the Angular\ntemplate compiler, the same way the <code>if</code> expression does in TypeScript.\nFor example, to avoid <code>Object is possibly 'undefined'</code> error in the template above, modify it to only emit the interpolation if the value of <code>person</code> is initialized as shown below:</p>\n<code-example language=\"typescript\">\n  @<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n    selector: 'my-component',\n    template: '&#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person\"> {{person.addresss.street}} &#x3C;/span>'\n  })\n  class MyComponent {\n    person?: Person;\n  }\n</code-example>\n<p>Using <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> allows the TypeScript compiler to infer that the <code>person</code> used in the binding expression will never be <code>undefined</code>.</p>\n<h4 id=\"custom-ngif-like-directives\">Custom <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> like directives<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#custom-ngif-like-directives\"><i class=\"material-icons\">link</i></a></h4>\n<p>Directives that behave like <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> can declare that they want the same treatment by including a static member marker that is a signal to the template compiler to treat them like <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>. This static member for <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> is:</p>\n<code-example language=\"typescript\">\n    public <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> ngIfUseIfTypeGuard: void;\n</code-example>\n<p>This declares that the input property <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> of the <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> directive should be treated as a guard to the use of its template, implying that the template will only be instantiated if the <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> input property is true.</p>\n<h3 id=\"non-null-type-assertion-operator\">Non-null type assertion operator<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#non-null-type-assertion-operator\"><i class=\"material-icons\">link</i></a></h3>\n<p>Use the <a href=\"guide/template-syntax#non-null-assertion-operator\">non-null type assertion operator</a> to suppress the <code>Object is possibly 'undefined'</code> error when it is inconvenient to use <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> or when some constraint in the component ensures that the expression is always non-null when the binding expression is interpolated.</p>\n<p>In the following example, the <code>person</code> and <code>address</code> properties are always set together, implying that <code>address</code> is always non-null if <code>person</code> is non-null.\nThere is no convenient way to describe this constraint to TypeScript and the template compiler, but the error is suppressed in the example by using <code>address!.street</code>.</p>\n<code-example language=\"typescript\">\n  @<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n    selector: 'my-component',\n    template: '&#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person\"> {{person.name}} lives on {{address!.street}} &#x3C;/span>'\n  })\n  class MyComponent {\n    person?: Person;\n    address?: Address;\n\n    setData(person: Person, address: Address) {\n      this.person = person;\n      this.address = address;\n    }\n  }\n</code-example>\n<p>The non-null assertion operator should be used sparingly as refactoring of the component might break this constraint.</p>\n<p>In this example it is recommended to include the checking of <code>address</code> in the <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>as shown below:</p>\n<code-example language=\"typescript\">\n  @<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n    selector: 'my-component',\n    template: '&#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person &#x26;&#x26; address\"> {{person.name}} lives on {{address.street}} &#x3C;/span>'\n  })\n  class MyComponent {\n    person?: Person;\n    address?: Address;\n\n    setData(person: Person, address: Address) {\n      this.person = person;\n      this.address = address;\n    }\n  }\n</code-example>\n<h3 id=\"disabling-type-checking-using-any\">Disabling type checking using <code>$any()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#disabling-type-checking-using-any\"><i class=\"material-icons\">link</i></a></h3>\n<p>Disable checking of a binding expression by surrounding the expression in a call to the <a href=\"guide/template-syntax\"><code>$any()</code> cast pseudo-function</a>.\nThe compiler treats it as a cast to the <code>any</code> type just like in TypeScript when a <code>&#x3C;any></code> or <code>as any</code> cast is used.</p>\n<p>In the following example, the error <code>Property addresss does not exist</code> is suppressed by casting <code>person</code> to the <code>any</code> type.</p>\n<code-example language=\"typescript\">\n  @<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n    selector: 'my-component',\n    template: '{{$any(person).addresss.street}}'\n  })\n  class MyComponent {\n    person?: Person;\n  }\n</code-example>\n\n</div>\n\n<!-- links to this doc:\n - api/upgrade\n - api/upgrade/UpgradeAdapter\n - api/upgrade/UpgradeAdapterRef\n - guide/angular-compiler-options\n - guide/aot-metadata-errors\n - guide/architecture-next-steps\n - guide/creating-libraries\n - guide/deployment\n - guide/npm-packages\n - guide/template-syntax\n - guide/universal\n - guide/upgrade\n - guide/upgrade-performance\n - guide/upgrade-setup\n-->\n<!-- links from this doc:\n - api/common/NgIf\n - api/core#decorators\n - api/core/Component\n - api/core/FactorySansProvider#useFactory\n - api/core/InjectionToken\n - api/core/Input\n - api/core/NgModule\n - api/core/ValueSansProvider#useValue\n - api/router/RouterLinkWithHref\n - api/router/RouterModule\n - api/upgrade/static\n - cli\n - cli/build\n - cli/serve\n - guide/angular-compiler-options\n - guide/aot-compiler#choosing-a-compiler\n - guide/aot-compiler#code-folding\n - guide/aot-compiler#compilation-phases\n - guide/aot-compiler#configuring-aot-compilation\n - guide/aot-compiler#custom-ngif-like-directives\n - guide/aot-compiler#disabling-type-checking-using-any\n - guide/aot-compiler#expression-syntax\n - guide/aot-compiler#expression-syntax-limitations\n - guide/aot-compiler#foldable-syntax\n - guide/aot-compiler#functions-and-static-method-calls\n - guide/aot-compiler#how-aot-works\n - guide/aot-compiler#metadata-restrictions\n - guide/aot-compiler#metadata-rewriting\n - guide/aot-compiler#no-arrow-functions\n - guide/aot-compiler#non-null-type-assertion-operator\n - guide/aot-compiler#phase-1-code-analysis\n - guide/aot-compiler#phase-2-code-generation\n - guide/aot-compiler#phase-3-template-type-checking\n - guide/aot-compiler#public-symbols\n - guide/aot-compiler#supported-classes-and-functions\n - guide/aot-compiler#supported-functions\n - guide/aot-compiler#the-ahead-of-time-aot-compiler\n - guide/aot-compiler#type-narrowing\n - guide/aot-metadata-errors\n - guide/build\n - guide/ngmodules\n - guide/template-syntax\n - guide/template-syntax#non-null-assertion-operator\n - guide/typescript-configuration\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\n - https://en.wikipedia.org/wiki/Abstract_syntax_tree\n - https://github.com/angular/angular/blob/master/packages/compiler-cli/src/metadata/schema.ts\n - https://github.com/angular/angular/blob/master/packages/router/src/router_module.ts#L139\n - https://github.com/angular/angular/edit/master/aio/content/guide/aot-compiler.md?message=docs%3A%20describe%20your%20change...\n - https://medium.com/sparkles-blog/angular-writing-aot-friendly-applications-7b64c8afbe3f\n - https://www.youtube.com/watch?v=kW9cJsvcsGo\n-->"
}