        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return ANALYZE_FOR_ENTRY_COMPONENTS;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return APP_BOOTSTRAP_LISTENER;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return APP_ID;
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return APP_INITIALIZER;
        })), __webpack_require__.d(__webpack_exports__, "e", (function() {
            return ApplicationInitStatus;
        })), __webpack_require__.d(__webpack_exports__, "f", (function() {
            return ApplicationModule;
        })), __webpack_require__.d(__webpack_exports__, "g", (function() {
            return ApplicationRef;
        })), __webpack_require__.d(__webpack_exports__, "h", (function() {
            return ChangeDetectorRef;
        })), __webpack_require__.d(__webpack_exports__, "i", (function() {
            return Compiler;
        })), __webpack_require__.d(__webpack_exports__, "j", (function() {
            return ComponentFactoryResolver;
        })), __webpack_require__.d(__webpack_exports__, "k", (function() {
            return ElementRef;
        })), __webpack_require__.d(__webpack_exports__, "l", (function() {
            return ErrorHandler;
        })), __webpack_require__.d(__webpack_exports__, "m", (function() {
            return EventEmitter;
        })), __webpack_require__.d(__webpack_exports__, "n", (function() {
            return INJECTOR;
        })), __webpack_require__.d(__webpack_exports__, "o", (function() {
            return Inject;
        })), __webpack_require__.d(__webpack_exports__, "p", (function() {
            return InjectionToken;
        })), __webpack_require__.d(__webpack_exports__, "q", (function() {
            return Injector;
        })), __webpack_require__.d(__webpack_exports__, "r", (function() {
            return IterableDiffers;
        })), __webpack_require__.d(__webpack_exports__, "s", (function() {
            return KeyValueDiffers;
        })), __webpack_require__.d(__webpack_exports__, "t", (function() {
            return LOCALE_ID$1;
        })), __webpack_require__.d(__webpack_exports__, "u", (function() {
            return NgModuleFactory;
        })), __webpack_require__.d(__webpack_exports__, "v", (function() {
            return NgModuleFactoryLoader;
        })), __webpack_require__.d(__webpack_exports__, "w", (function() {
            return NgModuleRef;
        })), __webpack_require__.d(__webpack_exports__, "x", (function() {
            return NgProbeToken;
        })), __webpack_require__.d(__webpack_exports__, "y", (function() {
            return NgZone;
        })), __webpack_require__.d(__webpack_exports__, "z", (function() {
            return Optional;
        })), __webpack_require__.d(__webpack_exports__, "A", (function() {
            return PLATFORM_ID;
        })), __webpack_require__.d(__webpack_exports__, "B", (function() {
            return PLATFORM_INITIALIZER;
        })), __webpack_require__.d(__webpack_exports__, "C", (function() {
            return QueryList;
        })), __webpack_require__.d(__webpack_exports__, "D", (function() {
            return Renderer2;
        })), __webpack_require__.d(__webpack_exports__, "E", (function() {
            return RendererFactory2;
        })), __webpack_require__.d(__webpack_exports__, "F", (function() {
            return RendererStyleFlags2;
        })), __webpack_require__.d(__webpack_exports__, "G", (function() {
            return Sanitizer;
        })), __webpack_require__.d(__webpack_exports__, "H", (function() {
            return SecurityContext;
        })), __webpack_require__.d(__webpack_exports__, "I", (function() {
            return SimpleChange;
        })), __webpack_require__.d(__webpack_exports__, "J", (function() {
            return SkipSelf;
        })), __webpack_require__.d(__webpack_exports__, "K", (function() {
            return SystemJsNgModuleLoader;
        })), __webpack_require__.d(__webpack_exports__, "L", (function() {
            return TemplateRef;
        })), __webpack_require__.d(__webpack_exports__, "M", (function() {
            return Testability;
        })), __webpack_require__.d(__webpack_exports__, "N", (function() {
            return Version;
        })), __webpack_require__.d(__webpack_exports__, "O", (function() {
            return ViewContainerRef;
        })), __webpack_require__.d(__webpack_exports__, "P", (function() {
            return ViewEncapsulation$1;
        })), __webpack_require__.d(__webpack_exports__, "Q", (function() {
            return WrappedValue;
        })), __webpack_require__.d(__webpack_exports__, "R", (function() {
            return createPlatformFactory;
        })), __webpack_require__.d(__webpack_exports__, "S", (function() {
            return enableProdMode;
        })), __webpack_require__.d(__webpack_exports__, "T", (function() {
            return getDebugNode$1;
        })), __webpack_require__.d(__webpack_exports__, "U", (function() {
            return inject;
        })), __webpack_require__.d(__webpack_exports__, "V", (function() {
            return isDevMode;
        })), __webpack_require__.d(__webpack_exports__, "W", (function() {
            return platformCore;
        })), __webpack_require__.d(__webpack_exports__, "X", (function() {
            return setTestabilityGetter;
        })), __webpack_require__.d(__webpack_exports__, "Y", (function() {
            return CodegenComponentFactoryResolver;
        })), __webpack_require__.d(__webpack_exports__, "Z", (function() {
            return Console;
        })), __webpack_require__.d(__webpack_exports__, "ab", (function() {
            return INJECTOR_SCOPE;
        })), __webpack_require__.d(__webpack_exports__, "bb", (function() {
            return LocaleDataIndex;
        })), __webpack_require__.d(__webpack_exports__, "cb", (function() {
            return _sanitizeHtml;
        })), __webpack_require__.d(__webpack_exports__, "db", (function() {
            return _sanitizeStyle;
        })), __webpack_require__.d(__webpack_exports__, "eb", (function() {
            return _sanitizeUrl;
        })), __webpack_require__.d(__webpack_exports__, "fb", (function() {
            return allowSanitizationBypassAndThrow;
        })), __webpack_require__.d(__webpack_exports__, "gb", (function() {
            return anchorDef;
        })), __webpack_require__.d(__webpack_exports__, "hb", (function() {
            return SCHEDULER;
        })), __webpack_require__.d(__webpack_exports__, "ib", (function() {
            return _appIdRandomProviderFactory;
        })), __webpack_require__.d(__webpack_exports__, "jb", (function() {
            return _iterableDiffersFactory;
        })), __webpack_require__.d(__webpack_exports__, "kb", (function() {
            return _keyValueDiffersFactory;
        })), __webpack_require__.d(__webpack_exports__, "lb", (function() {
            return _localeFactory;
        })), __webpack_require__.d(__webpack_exports__, "mb", (function() {
            return zoneSchedulerFactory;
        })), __webpack_require__.d(__webpack_exports__, "nb", (function() {
            return bypassSanitizationTrustHtml;
        })), __webpack_require__.d(__webpack_exports__, "ob", (function() {
            return bypassSanitizationTrustResourceUrl;
        })), __webpack_require__.d(__webpack_exports__, "pb", (function() {
            return bypassSanitizationTrustScript;
        })), __webpack_require__.d(__webpack_exports__, "qb", (function() {
            return bypassSanitizationTrustStyle;
        })), __webpack_require__.d(__webpack_exports__, "rb", (function() {
            return bypassSanitizationTrustUrl;
        })), __webpack_require__.d(__webpack_exports__, "sb", (function() {
            return createComponentFactory;
        })), __webpack_require__.d(__webpack_exports__, "tb", (function() {
            return createNgModuleFactory;
        })), __webpack_require__.d(__webpack_exports__, "ub", (function() {
            return createRendererType2;
        })), __webpack_require__.d(__webpack_exports__, "vb", (function() {
            return directiveDef;
        })), __webpack_require__.d(__webpack_exports__, "wb", (function() {
            return elementDef;
        })), __webpack_require__.d(__webpack_exports__, "xb", (function() {
            return findLocaleData;
        })), __webpack_require__.d(__webpack_exports__, "yb", (function() {
            return getLocalePluralCase;
        })), __webpack_require__.d(__webpack_exports__, "zb", (function() {
            return getSanitizationBypassType;
        })), __webpack_require__.d(__webpack_exports__, "Ab", (function() {
            return _global;
        })), __webpack_require__.d(__webpack_exports__, "Bb", (function() {
            return inlineInterpolate;
        })), __webpack_require__.d(__webpack_exports__, "Cb", (function() {
            return isListLikeIterable$1;
        })), __webpack_require__.d(__webpack_exports__, "Db", (function() {
            return isObservable;
        })), __webpack_require__.d(__webpack_exports__, "Eb", (function() {
            return isPromise;
        })), __webpack_require__.d(__webpack_exports__, "Fb", (function() {
            return looseIdentical;
        })), __webpack_require__.d(__webpack_exports__, "Gb", (function() {
            return moduleDef;
        })), __webpack_require__.d(__webpack_exports__, "Hb", (function() {
            return moduleProvideDef;
        })), __webpack_require__.d(__webpack_exports__, "Ib", (function() {
            return ngContentDef;
        })), __webpack_require__.d(__webpack_exports__, "Jb", (function() {
            return nodeValue;
        })), __webpack_require__.d(__webpack_exports__, "Kb", (function() {
            return pipeDef;
        })), __webpack_require__.d(__webpack_exports__, "Lb", (function() {
            return pureObjectDef;
        })), __webpack_require__.d(__webpack_exports__, "Mb", (function() {
            return providerDef;
        })), __webpack_require__.d(__webpack_exports__, "Nb", (function() {
            return queryDef;
        })), __webpack_require__.d(__webpack_exports__, "Ob", (function() {
            return registerLocaleData;
        })), __webpack_require__.d(__webpack_exports__, "Pb", (function() {
            return setDocument;
        })), __webpack_require__.d(__webpack_exports__, "Qb", (function() {
            return stringify;
        })), __webpack_require__.d(__webpack_exports__, "Rb", (function() {
            return textDef;
        })), __webpack_require__.d(__webpack_exports__, "Sb", (function() {
            return unwrapValue;
        })), __webpack_require__.d(__webpack_exports__, "Tb", (function() {
            return unwrapSafeValue;
        })), __webpack_require__.d(__webpack_exports__, "Ub", (function() {
            return viewDef;
        })), __webpack_require__.d(__webpack_exports__, "Vb", (function() {
            return ɵɵallocHostVars;
        })), __webpack_require__.d(__webpack_exports__, "Wb", (function() {
            return ɵɵclassMap;
        })), __webpack_require__.d(__webpack_exports__, "Xb", (function() {
            return ɵɵdefineDirective;
        })), __webpack_require__.d(__webpack_exports__, "Yb", (function() {
            return ɵɵdefineInjectable;
        })), __webpack_require__.d(__webpack_exports__, "Zb", (function() {
            return ɵɵinject;
        })), __webpack_require__.d(__webpack_exports__, "ac", (function() {
            return ɵɵstyleMap;
        }));
        var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("XNiG"), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("quSY"), rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("HDdC"), rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("VRyK"), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("w1tV");
        const PARAMETERS = "__parameters__";
        function makeParamDecorator(name, props, parentClass) {
            const metaCtor = function(props) {
                return function(...args) {
                    if (props) {
                        const values = props(...args);
                        for (const propName in values) this[propName] = values[propName];
                    }
                };
            }(props);
            function ParamDecoratorFactory(...args) {
                if (this instanceof ParamDecoratorFactory) return metaCtor.apply(this, args), this;
                const annotationInstance = new ParamDecoratorFactory(...args);
                return ParamDecorator.annotation = annotationInstance, ParamDecorator;
                function ParamDecorator(cls, unusedKey, index) {
                    const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, {
                        value: []
                    })[PARAMETERS];
                    for (;parameters.length <= index; ) parameters.push(null);
                    return (parameters[index] = parameters[index] || []).push(annotationInstance), cls;
                }
            }
            return parentClass && (ParamDecoratorFactory.prototype = Object.create(parentClass.prototype)), 
            ParamDecoratorFactory.prototype.ngMetadataName = name, ParamDecoratorFactory.annotationCls = ParamDecoratorFactory, 
            ParamDecoratorFactory;
        }
        const Inject = makeParamDecorator("Inject", token => ({
            token: token
        })), Optional = makeParamDecorator("Optional"), Self = makeParamDecorator("Self"), SkipSelf = makeParamDecorator("SkipSelf");
        var InjectFlags = function(InjectFlags) {
            return InjectFlags[InjectFlags.Default = 0] = "Default", InjectFlags[InjectFlags.Host = 1] = "Host", 
            InjectFlags[InjectFlags.Self = 2] = "Self", InjectFlags[InjectFlags.SkipSelf = 4] = "SkipSelf", 
            InjectFlags[InjectFlags.Optional = 8] = "Optional", InjectFlags;
        }({});
        function getClosureSafeProperty(objWithPropertyToExtract) {
            for (let key in objWithPropertyToExtract) if (objWithPropertyToExtract[key] === getClosureSafeProperty) return key;
            throw Error("Could not find renamed property on target object.");
        }
        function ɵɵdefineInjectable(opts) {
            return {
                token: opts.token,
                providedIn: opts.providedIn || null,
                factory: opts.factory,
                value: void 0
            };
        }
        function getInjectableDef(type) {
            return getOwnDefinition(type, type[NG_PROV_DEF]) || getOwnDefinition(type, type[NG_INJECTABLE_DEF]);
        }
        function getOwnDefinition(type, def) {
            return def && def.token === type ? def : null;
        }
        const NG_PROV_DEF = getClosureSafeProperty({
            "ɵprov": getClosureSafeProperty
        }), NG_INJECTABLE_DEF = getClosureSafeProperty({
            ngInjectableDef: getClosureSafeProperty
        });
        function stringify(token) {
            if ("string" == typeof token) return token;
            if (Array.isArray(token)) return "[" + token.map(stringify).join(", ") + "]";
            if (null == token) return "" + token;
            if (token.overriddenName) return `${token.overriddenName}`;
            if (token.name) return `${token.name}`;
            const res = token.toString();
            if (null == res) return "" + res;
            const newLineIndex = res.indexOf("\n");
            return -1 === newLineIndex ? res : res.substring(0, newLineIndex);
        }
        const __forward_ref__ = getClosureSafeProperty({
            __forward_ref__: getClosureSafeProperty
        });
        function forwardRef(forwardRefFn) {
            return forwardRefFn.__forward_ref__ = forwardRef, forwardRefFn.toString = function() {
                return stringify(this());
            }, forwardRefFn;
        }
        function resolveForwardRef(type) {
            return "function" == typeof (fn = type) && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef ? type() : type;
            var fn;
        }
        const __globalThis = "undefined" != typeof globalThis && globalThis, __window = "undefined" != typeof window && window, __self = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, __global = "undefined" != typeof global && global, _global = __globalThis || __global || __window || __self, NG_COMP_DEF = getClosureSafeProperty({
            "ɵcmp": getClosureSafeProperty
        }), NG_DIR_DEF = getClosureSafeProperty({
            "ɵdir": getClosureSafeProperty
        }), NG_PIPE_DEF = getClosureSafeProperty({
            "ɵpipe": getClosureSafeProperty
        });
        class InjectionToken {
            constructor(_desc, options) {
                this._desc = _desc, this.ngMetadataName = "InjectionToken", this.ɵprov = void 0, 
                "number" == typeof options ? this.__NG_ELEMENT_ID__ = options : void 0 !== options && (this.ɵprov = ɵɵdefineInjectable({
                    token: this,
                    providedIn: options.providedIn || "root",
                    factory: options.factory
                }));
            }
            toString() {
                return `InjectionToken ${this._desc}`;
            }
        }
        const INJECTOR = new InjectionToken("INJECTOR", -1), THROW_IF_NOT_FOUND = new Object, NG_TEMP_TOKEN_PATH = "ngTempTokenPath", NG_TOKEN_PATH = "ngTokenPath", NEW_LINE = /\n/gm, NO_NEW_LINE = "ɵ", SOURCE = "__source", USE_VALUE = getClosureSafeProperty({
            provide: String,
            useValue: getClosureSafeProperty
        });
        let _injectImplementation, _currentInjector = void 0;
        function setCurrentInjector(injector) {
            const former = _currentInjector;
            return _currentInjector = injector, former;
        }
        function injectInjectorOnly(token, flags = InjectFlags.Default) {
            if (void 0 === _currentInjector) throw new Error("inject() must be called from an injection context");
            return null === _currentInjector ? function(token, notFoundValue, flags) {
                const injectableDef = getInjectableDef(token);
                if (injectableDef && "root" == injectableDef.providedIn) return void 0 === injectableDef.value ? injectableDef.value = injectableDef.factory() : injectableDef.value;
                if (flags & InjectFlags.Optional) return null;
                throw new Error(`Injector: NOT_FOUND [${stringify(token)}]`);
            }(token, 0, flags) : _currentInjector.get(token, flags & InjectFlags.Optional ? null : void 0, flags);
        }
        function ɵɵinject(token, flags = InjectFlags.Default) {
            return (_injectImplementation || injectInjectorOnly)(resolveForwardRef(token), flags);
        }
        const inject = ɵɵinject;
        class NullInjector {
            get(token, notFoundValue = THROW_IF_NOT_FOUND) {
                if (notFoundValue === THROW_IF_NOT_FOUND) {
                    const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);
                    throw error.name = "NullInjectorError", error;
                }
                return notFoundValue;
            }
        }
        function formatError(text, obj, injectorErrorName, source = null) {
            text = text && "\n" === text.charAt(0) && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;
            let context = stringify(obj);
            if (Array.isArray(obj)) context = obj.map(stringify).join(" -> "); else if ("object" == typeof obj) {
                let parts = [];
                for (let key in obj) if (obj.hasOwnProperty(key)) {
                    let value = obj[key];
                    parts.push(key + ":" + ("string" == typeof value ? JSON.stringify(value) : stringify(value)));
                }
                context = `{${parts.join(", ")}}`;
            }
            return `${injectorErrorName}${source ? "(" + source + ")" : ""}[${context}]: ${text.replace(NEW_LINE, "\n  ")}`;
        }
        class NgModuleRef {}
        class NgModuleFactory {}
        function addToArray(arr, index, value) {
            index >= arr.length ? arr.push(value) : arr.splice(index, 0, value);
        }
        function removeFromArray(arr, index) {
            return index >= arr.length - 1 ? arr.pop() : arr.splice(index, 1)[0];
        }
        const ChangeDetectionStrategy = function() {
            var ChangeDetectionStrategy = {
                OnPush: 0,
                Default: 1
            };
            return ChangeDetectionStrategy[ChangeDetectionStrategy.OnPush] = "OnPush", ChangeDetectionStrategy[ChangeDetectionStrategy.Default] = "Default", 
            ChangeDetectionStrategy;
        }(), ViewEncapsulation$1 = function() {
            var ViewEncapsulation$1 = {
                Emulated: 0,
                Native: 1,
                None: 2,
                ShadowDom: 3
            };
            return ViewEncapsulation$1[ViewEncapsulation$1.Emulated] = "Emulated", ViewEncapsulation$1[ViewEncapsulation$1.Native] = "Native", 
            ViewEncapsulation$1[ViewEncapsulation$1.None] = "None", ViewEncapsulation$1[ViewEncapsulation$1.ShadowDom] = "ShadowDom", 
            ViewEncapsulation$1;
        }(), EMPTY_OBJ = {}, EMPTY_ARRAY = [];
        let _renderCompCount = 0;
        function extractDirectiveDef(type) {
            return function(type) {
                return type[NG_COMP_DEF] || null;
            }(type) || function(type) {
                return type[NG_DIR_DEF] || null;
            }(type);
        }
        function extractPipeDef(type) {
            return function(type) {
                return type[NG_PIPE_DEF] || null;
            }(type);
        }
        function invertObject(obj, secondary) {
            if (null == obj) return EMPTY_OBJ;
            const newLookup = {};
            for (const minifiedKey in obj) if (obj.hasOwnProperty(minifiedKey)) {
                let publicName = obj[minifiedKey], declaredName = publicName;
                Array.isArray(publicName) && (declaredName = publicName[1], publicName = publicName[0]), 
                newLookup[publicName] = minifiedKey, secondary && (secondary[publicName] = declaredName);
            }
            return newLookup;
        }
        const ɵɵdefineDirective = function(componentDefinition) {
            const type = componentDefinition.type, typePrototype = type.prototype, declaredInputs = {}, def = {
                type: type,
                providersResolver: null,
                decls: componentDefinition.decls,
                vars: componentDefinition.vars,
                factory: null,
                template: componentDefinition.template || null,
                consts: componentDefinition.consts || null,
                ngContentSelectors: componentDefinition.ngContentSelectors,
                hostBindings: componentDefinition.hostBindings || null,
                contentQueries: componentDefinition.contentQueries || null,
                declaredInputs: declaredInputs,
                inputs: null,
                outputs: null,
                exportAs: componentDefinition.exportAs || null,
                onChanges: null,
                onInit: typePrototype.ngOnInit || null,
                doCheck: typePrototype.ngDoCheck || null,
                afterContentInit: typePrototype.ngAfterContentInit || null,
                afterContentChecked: typePrototype.ngAfterContentChecked || null,
                afterViewInit: typePrototype.ngAfterViewInit || null,
                afterViewChecked: typePrototype.ngAfterViewChecked || null,
                onDestroy: typePrototype.ngOnDestroy || null,
                onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
                directiveDefs: null,
                pipeDefs: null,
                selectors: componentDefinition.selectors || EMPTY_ARRAY,
                viewQuery: componentDefinition.viewQuery || null,
                features: componentDefinition.features || null,
                data: componentDefinition.data || {},
                encapsulation: componentDefinition.encapsulation || ViewEncapsulation$1.Emulated,
                id: "c",
                styles: componentDefinition.styles || EMPTY_ARRAY,
                _: null,
                setInput: null,
                schemas: componentDefinition.schemas || null,
                tView: null
            };
            return def._ = "" + {
                toString: () => {
                    const directiveTypes = componentDefinition.directives, feature = componentDefinition.features, pipeTypes = componentDefinition.pipes;
                    def.id += _renderCompCount++, def.inputs = invertObject(componentDefinition.inputs, declaredInputs), 
                    def.outputs = invertObject(componentDefinition.outputs), feature && feature.forEach(fn => fn(def)), 
                    def.directiveDefs = directiveTypes ? () => ("function" == typeof directiveTypes ? directiveTypes() : directiveTypes).map(extractDirectiveDef) : null, 
                    def.pipeDefs = pipeTypes ? () => ("function" == typeof pipeTypes ? pipeTypes() : pipeTypes).map(extractPipeDef) : null;
                }
            }, def;
        }, HOST = 0, TVIEW = 1, RENDERER = 11, HEADER_OFFSET = 18, instructionState = {
            lFrame: createLFrame(null),
            bindingsEnabled: !0,
            elementExitFn: null,
            checkNoChangesMode: !1
        };
        function getLView() {
            const lFrame = instructionState.lFrame;
            return null === lFrame ? null : lFrame.lView;
        }
        function setElementExitFn(fn) {
            instructionState.lFrame.selectedIndex |= 1, null == instructionState.elementExitFn && (instructionState.elementExitFn = fn);
        }
        function getActiveDirectiveId() {
            return instructionState.lFrame.activeDirectiveId;
        }
        function incrementBindingIndex(count) {
            const lFrame = instructionState.lFrame, index = lFrame.bindingIndex;
            return lFrame.bindingIndex = lFrame.bindingIndex + count, index;
        }
        function createLFrame(parent) {
            const lFrame = {
                previousOrParentTNode: null,
                isParent: !0,
                lView: null,
                selectedIndex: 0,
                contextLView: null,
                elementDepthCount: 0,
                currentNamespace: null,
                currentSanitizer: null,
                currentDirectiveDef: null,
                activeDirectiveId: 0,
                bindingRootIndex: -1,
                bindingIndex: -1,
                currentQueryIndex: 0,
                parent: parent,
                child: null
            };
            return null !== parent && (parent.child = lFrame), lFrame;
        }
        function getSelectedIndex() {
            return instructionState.lFrame.selectedIndex >> 1;
        }
        function getCurrentStyleSanitizer() {
            const lFrame = instructionState.lFrame;
            return null === lFrame ? null : lFrame.currentSanitizer;
        }
        let DOCUMENT = void 0;
        function setDocument(document) {
            DOCUMENT = document;
        }
        const RendererStyleFlags3 = function() {
            var RendererStyleFlags3 = {
                Important: 1,
                DashCase: 2
            };
            return RendererStyleFlags3[RendererStyleFlags3.Important] = "Important", RendererStyleFlags3[RendererStyleFlags3.DashCase] = "DashCase", 
            RendererStyleFlags3;
        }();
        function isProceduralRenderer(renderer) {
            return !!renderer.listen;
        }
        const defaultScheduler = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(_global))(), NO_CHANGE = {}, MAP_BASED_ENTRY_PROP_NAME = "[MAP]", TEMPLATE_DIRECTIVE_INDEX = 0, DEFAULT_BINDING_VALUE = null, DEFAULT_BINDING_INDEX = 0, DEFAULT_TOTAL_SOURCES = 1, DEFAULT_GUARD_MASK_VALUE = 1;
        function allocStylingMapArray(value) {
            return [ value ];
        }
        function hasConfig(tNode, flag) {
            return 0 != (tNode.flags & flag);
        }
        function patchConfig(tNode, flag) {
            tNode.flags |= flag;
        }
        function getProp(context, index) {
            return context[index + 3];
        }
        function isSanitizationRequired(context, index) {
            return 0 != (1 & function(context, index) {
                return 1 & context[index + 0];
            }(context, index));
        }
        function getGuardMask(context, index, isHostBinding) {
            return context[index + (isHostBinding ? 2 : 1)];
        }
        function getValuesCount(context) {
            return getTotalSources(context) + 1;
        }
        function getTotalSources(context) {
            return context[0];
        }
        function getBindingValue(context, index, offset) {
            return context[index + 4 + offset];
        }
        function getDefaultValue(context, index) {
            return context[index + 4 + getTotalSources(context)];
        }
        function setValue(data, bindingIndex, value) {
            data[bindingIndex] = value;
        }
        function getValue(data, bindingIndex) {
            return 0 !== bindingIndex ? data[bindingIndex] : null;
        }
        function hasValueChanged(a, b) {
            if (b === NO_CHANGE) return !1;
            const compareValueA = Array.isArray(a) ? a[0] : a, compareValueB = Array.isArray(b) ? b[0] : b;
            return !Object.is(compareValueA, compareValueB);
        }
        function isStylingValueDefined(value) {
            return null != value && "" !== value;
        }
        function concatString(a, b, separator = " ") {
            return a + (b.length && a.length ? separator : "") + b;
        }
        function hyphenate(value) {
            return value.replace(/[a-z][A-Z]/g, v => v.charAt(0) + "-" + v.charAt(1)).toLowerCase();
        }
        function getStylingMapArray(value) {
            return isStylingContext(value) ? value[1] : value;
        }
        function isStylingContext(value) {
            return Array.isArray(value) && value.length >= 2 && "string" != typeof value[1];
        }
        function getInitialStylingValue(context) {
            const map = getStylingMapArray(context);
            return map && map[0] || "";
        }
        function getMapProp(map, index) {
            return map[index + 0];
        }
        const MAP_DIRTY_VALUE = {
            MAP_DIRTY_VALUE: !0
        };
        function setMapValue(map, index, value) {
            map[index + 1] = value;
        }
        function getMapValue(map, index) {
            return map[index + 1];
        }
        function forceStylesAsString(styles, hyphenateProps) {
            if ("string" == typeof styles) return styles;
            let str = "";
            if (styles) {
                const props = Object.keys(styles);
                for (let i = 0; i < props.length; i++) {
                    const prop = props[i], propLabel = hyphenateProps ? hyphenate(prop) : prop, value = styles[prop];
                    null !== value && (str = concatString(str, `${propLabel}:${value}`, ";"));
                }
            }
            return str;
        }
        function isHostStylingActive(directiveOrSourceId) {
            return directiveOrSourceId !== TEMPLATE_DIRECTIVE_INDEX;
        }
        function addItemToStylingMap(stylingMapArr, prop, value, allowOverwrite) {
            for (let j = 1; j < stylingMapArr.length; j += 2) {
                const propAtIndex = getMapProp(stylingMapArr, j);
                if (prop <= propAtIndex) {
                    let applied = !1;
                    if (propAtIndex === prop) {
                        const valueAtIndex = stylingMapArr[j];
                        !allowOverwrite && isStylingValueDefined(valueAtIndex) || (applied = !0, setMapValue(stylingMapArr, j, value));
                    } else applied = !0, stylingMapArr.splice(j, 0, prop, value);
                    return applied;
                }
            }
            return stylingMapArr.push(prop, value), !0;
        }
        function normalizeIntoStylingMap(bindingValue, newValues, normalizeProps) {
            const stylingMapArr = Array.isArray(bindingValue) ? bindingValue : allocStylingMapArray(null);
            stylingMapArr[0] = newValues;
            for (let j = 1; j < stylingMapArr.length; j += 2) setMapValue(stylingMapArr, j, null);
            let map, props = null, allValuesTrue = !1;
            if ("string" == typeof newValues ? allValuesTrue = null !== (props = function(text) {
                let array = null, length = text.length, start = 0, foundChar = !1;
                for (let i = 0; i < length; i++) text.charCodeAt(i) <= 32 ? (foundChar && (null === array && (array = []), 
                array.push(text.substring(start, i)), foundChar = !1), start = i + 1) : foundChar = !0;
                return foundChar && (null === array && (array = []), array.push(text.substring(start, length)), 
                foundChar = !1), array;
            }(newValues)) : (props = newValues ? Object.keys(newValues) : null, map = newValues), 
            props) for (let i = 0; i < props.length; i++) {
                const prop = props[i];
                addItemToStylingMap(stylingMapArr, normalizeProps ? hyphenate(prop) : prop, !!allValuesTrue || map[prop], !0);
            }
            return stylingMapArr;
        }
        function getNativeByTNode(tNode, lView) {
            return function(value) {
                for (;Array.isArray(value); ) value = value[HOST];
                return (value);
            }(lView[tNode.index]);
        }
        function getTNode(index, view) {
            return view[TVIEW].data[index + HEADER_OFFSET];
        }
        const ERROR_DEBUG_CONTEXT = "ngDebugContext", ERROR_ORIGINAL_ERROR = "ngOriginalError", ERROR_LOGGER = "ngErrorLogger";
        function getDebugContext(error) {
            return error[ERROR_DEBUG_CONTEXT];
        }
        function getOriginalError(error) {
            return error[ERROR_ORIGINAL_ERROR];
        }
        function defaultErrorLogger(console, ...values) {
            console.error(...values);
        }
        class ErrorHandler {
            constructor() {
                this._console = console;
            }
            handleError(error) {
                const originalError = this._findOriginalError(error), context = this._findContext(error), errorLogger = function(error) {
                    return error[ERROR_LOGGER] || defaultErrorLogger;
                }(error);
                errorLogger(this._console, "ERROR", error), originalError && errorLogger(this._console, "ORIGINAL ERROR", originalError), 
                context && errorLogger(this._console, "ERROR CONTEXT", context);
            }
            _findContext(error) {
                return error ? getDebugContext(error) ? getDebugContext(error) : this._findContext(getOriginalError(error)) : null;
            }
            _findOriginalError(error) {
                let e = getOriginalError(error);
                for (;e && getOriginalError(e); ) e = getOriginalError(e);
                return e;
            }
        }
        class SafeValueImpl {
            constructor(changingThisBreaksApplicationSecurity) {
                this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
            }
            toString() {
                return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` + " (see http://g.co/ng/security#xss)";
            }
        }
        class SafeHtmlImpl extends SafeValueImpl {
            getTypeName() {
                return "HTML";
            }
        }
        class SafeStyleImpl extends SafeValueImpl {
            getTypeName() {
                return "Style";
            }
        }
        class SafeScriptImpl extends SafeValueImpl {
            getTypeName() {
                return "Script";
            }
        }
        class SafeUrlImpl extends SafeValueImpl {
            getTypeName() {
                return "URL";
            }
        }
        class SafeResourceUrlImpl extends SafeValueImpl {
            getTypeName() {
                return "ResourceURL";
            }
        }
        function unwrapSafeValue(value) {
            return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;
        }
        function allowSanitizationBypassAndThrow(value, type) {
            const actualType = getSanitizationBypassType(value);
            if (null != actualType && actualType !== type) {
                if ("ResourceURL" === actualType && "URL" === type) return !0;
                throw new Error(`Required a safe ${type}, got a ${actualType} (see http://g.co/ng/security#xss)`);
            }
            return actualType === type;
        }
        function getSanitizationBypassType(value) {
            return value instanceof SafeValueImpl && value.getTypeName() || null;
        }
        function bypassSanitizationTrustHtml(trustedHtml) {
            return new SafeHtmlImpl(trustedHtml);
        }
        function bypassSanitizationTrustStyle(trustedStyle) {
            return new SafeStyleImpl(trustedStyle);
        }
        function bypassSanitizationTrustScript(trustedScript) {
            return new SafeScriptImpl(trustedScript);
        }
        function bypassSanitizationTrustUrl(trustedUrl) {
            return new SafeUrlImpl(trustedUrl);
        }
        function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {
            return new SafeResourceUrlImpl(trustedResourceUrl);
        }
        let _devMode = !0, _runModeLocked = !1;
        function isDevMode() {
            return _runModeLocked = !0, _devMode;
        }
        function enableProdMode() {
            if (_runModeLocked) throw new Error("Cannot enable prod mode after platform setup.");
            _devMode = !1;
        }
        class InertBodyHelper {
            constructor(defaultDoc) {
                if (this.defaultDoc = defaultDoc, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), 
                this.inertBodyElement = this.inertDocument.body, null == this.inertBodyElement) {
                    const inertHtml = this.inertDocument.createElement("html");
                    this.inertDocument.appendChild(inertHtml), this.inertBodyElement = this.inertDocument.createElement("body"), 
                    inertHtml.appendChild(this.inertBodyElement);
                }
                this.inertBodyElement.innerHTML = '<svg><g onload="this.parentNode.remove()"></g></svg>', 
                !this.inertBodyElement.querySelector || this.inertBodyElement.querySelector("svg") ? (this.inertBodyElement.innerHTML = '<svg><p><style><img src="</style><img src=x onerror=alert(1)//">', 
                this.getInertBodyElement = this.inertBodyElement.querySelector && this.inertBodyElement.querySelector("svg img") && function() {
                    try {
                        return !!window.DOMParser;
                    } catch (_a) {
                        return !1;
                    }
                }() ? this.getInertBodyElement_DOMParser : this.getInertBodyElement_InertDocument) : this.getInertBodyElement = this.getInertBodyElement_XHR;
            }
            getInertBodyElement_XHR(html) {
                html = "<body><remove></remove>" + html + "</body>";
                try {
                    html = encodeURI(html);
                } catch (_a) {
                    return null;
                }
                const xhr = new XMLHttpRequest;
                xhr.responseType = "document", xhr.open("GET", "data:text/html;charset=utf-8," + html, !1), 
                xhr.send(void 0);
                const body = xhr.response.body;
                return body.removeChild(body.firstChild), body;
            }
            getInertBodyElement_DOMParser(html) {
                html = "<body><remove></remove>" + html + "</body>";
                try {
                    const body = (new window.DOMParser).parseFromString(html, "text/html").body;
                    return body.removeChild(body.firstChild), body;
                } catch (_a) {
                    return null;
                }
            }
            getInertBodyElement_InertDocument(html) {
                const templateEl = this.inertDocument.createElement("template");
                return "content" in templateEl ? (templateEl.innerHTML = html, templateEl) : (this.inertBodyElement.innerHTML = html, 
                this.defaultDoc.documentMode && this.stripCustomNsAttrs(this.inertBodyElement), 
                this.inertBodyElement);
            }
            stripCustomNsAttrs(el) {
                const elAttrs = el.attributes;
                for (let i = elAttrs.length - 1; 0 < i; i--) {
                    const attrName = elAttrs.item(i).name;
                    "xmlns:ns1" !== attrName && 0 !== attrName.indexOf("ns1:") || el.removeAttribute(attrName);
                }
                let childNode = el.firstChild;
                for (;childNode; ) childNode.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(childNode), 
                childNode = childNode.nextSibling;
            }
        }
        const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi, DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
        function _sanitizeUrl(url) {
            return (url = String(url)).match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN) ? url : (isDevMode() && console.warn(`WARNING: sanitizing unsafe URL value ${url} (see http://g.co/ng/security#xss)`), 
            "unsafe:" + url);
        }
        function tagSet(tags) {
            const res = {};
            for (const t of tags.split(",")) res[t] = !0;
            return res;
        }
        function merge(...sets) {
            const res = {};
            for (const s of sets) for (const v in s) s.hasOwnProperty(v) && (res[v] = !0);
            return res;
        }
        const VOID_ELEMENTS = tagSet("area,br,col,hr,img,wbr"), OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet("rp,rt"), OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS), VALID_ELEMENTS = merge(VOID_ELEMENTS, merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), OPTIONAL_END_TAG_ELEMENTS), URI_ATTRS = tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), SRCSET_ATTRS = tagSet("srcset"), VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet("script,style,template");
        class SanitizingHtmlSerializer {
            constructor() {
                this.sanitizedSomething = !1, this.buf = [];
            }
            sanitizeChildren(el) {
                let current = el.firstChild, traverseContent = !0;
                for (;current; ) if (current.nodeType === Node.ELEMENT_NODE ? traverseContent = this.startElement(current) : current.nodeType === Node.TEXT_NODE ? this.chars(current.nodeValue) : this.sanitizedSomething = !0, 
                traverseContent && current.firstChild) current = current.firstChild; else for (;current; ) {
                    current.nodeType === Node.ELEMENT_NODE && this.endElement(current);
                    let next = this.checkClobberedElement(current, current.nextSibling);
                    if (next) {
                        current = next;
                        break;
                    }
                    current = this.checkClobberedElement(current, current.parentNode);
                }
                return this.buf.join("");
            }
            startElement(element) {
                const tagName = element.nodeName.toLowerCase();
                if (!VALID_ELEMENTS.hasOwnProperty(tagName)) return this.sanitizedSomething = !0, 
                !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
                this.buf.push("<"), this.buf.push(tagName);
                const elAttrs = element.attributes;
                for (let i = 0; i < elAttrs.length; i++) {
                    const elAttr = elAttrs.item(i), attrName = elAttr.name, lower = attrName.toLowerCase();
                    if (!VALID_ATTRS.hasOwnProperty(lower)) {
                        this.sanitizedSomething = !0;
                        continue;
                    }
                    let value = elAttr.value;
                    URI_ATTRS[lower] && (value = _sanitizeUrl(value)), SRCSET_ATTRS[lower] && (srcset = value, 
                    value = (srcset = String(srcset)).split(",").map(srcset => _sanitizeUrl(srcset.trim())).join(", ")), 
                    this.buf.push(" ", attrName, '="', encodeEntities(value), '"');
                }
                var srcset;
                return this.buf.push(">"), !0;
            }
            endElement(current) {
                const tagName = current.nodeName.toLowerCase();
                VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName) && (this.buf.push("</"), 
                this.buf.push(tagName), this.buf.push(">"));
            }
            chars(chars) {
                this.buf.push(encodeEntities(chars));
            }
            checkClobberedElement(node, nextNode) {
                if (nextNode && (node.compareDocumentPosition(nextNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);
                return nextNode;
            }
        }
        const SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
        function encodeEntities(value) {
            return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, (function(match) {
                return "&#" + (1024 * (match.charCodeAt(0) - 55296) + (match.charCodeAt(1) - 56320) + 65536) + ";";
            })).replace(NON_ALPHANUMERIC_REGEXP, (function(match) {
                return "&#" + match.charCodeAt(0) + ";";
            })).replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }
        let inertBodyHelper;
        function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
            let inertBodyElement = null;
            try {
                inertBodyHelper = inertBodyHelper || new InertBodyHelper(defaultDoc);
                let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : "";
                inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
                let mXSSAttempts = 5, parsedHtml = unsafeHtml;
                do {
                    if (0 === mXSSAttempts) throw new Error("Failed to sanitize html because the input is unstable");
                    mXSSAttempts--, unsafeHtml = parsedHtml, parsedHtml = inertBodyElement.innerHTML, 
                    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
                } while (unsafeHtml !== parsedHtml);
                const sanitizer = new SanitizingHtmlSerializer, safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
                return isDevMode() && sanitizer.sanitizedSomething && console.warn("WARNING: sanitizing HTML stripped some content, see http://g.co/ng/security#xss"), 
                safeHtml;
            } finally {
                if (inertBodyElement) {
                    const parent = getTemplateContent(inertBodyElement) || inertBodyElement;
                    for (;parent.firstChild; ) parent.removeChild(parent.firstChild);
                }
            }
        }
        function getTemplateContent(el) {
            return "content" in el && function(el) {
                return el.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === el.nodeName;
            }(el) ? el.content : null;
        }
        const SecurityContext = function() {
            var SecurityContext = {
                NONE: 0,
                HTML: 1,
                STYLE: 2,
                SCRIPT: 3,
                URL: 4,
                RESOURCE_URL: 5
            };
            return SecurityContext[SecurityContext.NONE] = "NONE", SecurityContext[SecurityContext.HTML] = "HTML", 
            SecurityContext[SecurityContext.STYLE] = "STYLE", SecurityContext[SecurityContext.SCRIPT] = "SCRIPT", 
            SecurityContext[SecurityContext.URL] = "URL", SecurityContext[SecurityContext.RESOURCE_URL] = "RESOURCE_URL", 
            SecurityContext;
        }(), SAFE_STYLE_VALUE = new RegExp("^([-,.\"'%_!# a-zA-Z0-9]+|(?:(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|Z|3d)?|(?:rgb|hsl)a?|(?:repeating-)?(?:linear|radial)-gradient|(?:calc|attr))\\([-0-9.%, #a-zA-Z]+\\))$", "g"), URL_RE = /^url\(([^)]+)\)$/;
        function _sanitizeStyle(value) {
            if (!(value = String(value).trim())) return "";
            const urlMatch = value.match(URL_RE);
            return urlMatch && _sanitizeUrl(urlMatch[1]) === urlMatch[1] || value.match(SAFE_STYLE_VALUE) && function(value) {
                let outsideSingle = !0, outsideDouble = !0;
                for (let i = 0; i < value.length; i++) {
                    const c = value.charAt(i);
                    "'" === c && outsideDouble ? outsideSingle = !outsideSingle : '"' === c && outsideSingle && (outsideDouble = !outsideDouble);
                }
                return outsideSingle && outsideDouble;
            }(value) ? value : (isDevMode() && console.warn(`WARNING: sanitizing unsafe style value ${value} (see http://g.co/ng/security#xss).`), 
            "unsafe");
        }
        const CAMEL_CASE_REGEXP = /([A-Z])/g;
        function normalizeDebugBindingValue(value) {
            try {
                return null != value ? value.toString().slice(0, 30) : value;
            } catch (e) {
                return "[ERROR] Exception while trying to serialize the value";
            }
        }
        const _state = {
            element: null,
            directiveIndex: -1,
            sourceIndex: -1,
            classesBitMask: -1,
            classesIndex: -1,
            stylesBitMask: -1,
            stylesIndex: -1,
            lastDirectClassMap: null,
            lastDirectStyleMap: null
        }, BIT_MASK_START_VALUE = 0, INDEX_START_VALUE = 1;
        function getStylingState(element, directiveIndex) {
            return _state.element !== element ? (_state.element = element, _state.directiveIndex = directiveIndex, 
            _state.sourceIndex = directiveIndex === TEMPLATE_DIRECTIVE_INDEX ? 0 : 1, _state.classesBitMask = BIT_MASK_START_VALUE, 
            _state.classesIndex = INDEX_START_VALUE, _state.stylesBitMask = BIT_MASK_START_VALUE, 
            _state.stylesIndex = INDEX_START_VALUE, _state.lastDirectClassMap = null, _state.lastDirectStyleMap = null) : _state.directiveIndex !== directiveIndex && (_state.directiveIndex = directiveIndex, 
            _state.sourceIndex++), _state;
        }
        const VALUE_IS_EXTERNALLY_MODIFIED = {}, STYLING_INDEX_FOR_MAP_BINDING = 0;
        function updateBindingData(context, tNode, data, counterIndex, sourceIndex, prop, bindingIndex, value, forceUpdate, sanitizationRequired, firstUpdatePass, isClassBased) {
            const hostBindingsMode = isHostStylingActive(sourceIndex), hostBindingsFlag = isClassBased ? 4096 : 131072;
            firstUpdatePass && registerBinding(context, tNode, counterIndex, sourceIndex, prop, bindingIndex, sanitizationRequired, isClassBased);
            const changed = forceUpdate || hasValueChanged(data[bindingIndex], value);
            return changed && (setValue(data, bindingIndex, value), hasConfig(tNode, hostBindingsFlag) && !hostBindingsMode && (!prop || !value) && function(context, tNode, data, prop, isClassBased) {
                const valuesCount = getValuesCount(context);
                if (null !== prop && hasConfig(tNode, isClassBased ? 4096 : 131072)) {
                    const itemsPerRow = 4 + valuesCount;
                    let i = 2, found = !1;
                    for (;i < context.length; ) {
                        if (getProp(context, i) === prop) {
                            found = !0;
                            break;
                        }
                        i += itemsPerRow;
                    }
                    if (found) {
                        const bindingsStart = i + 4, valuesEnd = bindingsStart + valuesCount - 1;
                        for (let i = bindingsStart + 1; i < valuesEnd; i++) {
                            const bindingIndex = context[i];
                            0 !== bindingIndex && setValue(data, bindingIndex, null);
                        }
                    }
                }
                if (hasConfig(tNode, isClassBased ? 512 : 16384)) {
                    const bindingsStart = 6, valuesEnd = bindingsStart + valuesCount - 1;
                    for (let i = bindingsStart + 1; i < valuesEnd; i++) {
                        const stylingMap = getValue(data, context[i]);
                        stylingMap && (stylingMap[0] = MAP_DIRTY_VALUE);
                    }
                }
            }(context, tNode, data, prop, isClassBased)), changed;
        }
        function registerBinding(context, tNode, countId, sourceIndex, prop, bindingValue, sanitizationRequired, isClassBased) {
            let found = !1;
            prop = prop || MAP_BASED_ENTRY_PROP_NAME;
            let totalSources = getTotalSources(context);
            for (;totalSources <= sourceIndex; ) addNewSourceColumn(context), totalSources++;
            const collisionFlag = isClassBased ? 8192 : 262144, isBindingIndexValue = "number" == typeof bindingValue, entriesPerRow = 4 + getValuesCount(context);
            let i = 2;
            for (;i < context.length; ) {
                const p = getProp(context, i);
                if (prop <= p) {
                    prop < p ? allocateNewContextEntry(context, i, prop, sanitizationRequired) : isBindingIndexValue && patchConfig(tNode, collisionFlag), 
                    addBindingIntoContext(context, i, bindingValue, countId, sourceIndex), found = !0;
                    break;
                }
                i += entriesPerRow;
            }
            found || (allocateNewContextEntry(context, context.length, prop, sanitizationRequired), 
            addBindingIntoContext(context, i, bindingValue, countId, sourceIndex));
        }
        function allocateNewContextEntry(context, index, prop, sanitizationRequired) {
            context.splice(index, 0, sanitizationRequired ? 1 : 0, DEFAULT_GUARD_MASK_VALUE, DEFAULT_GUARD_MASK_VALUE, prop), 
            index += 4;
            const totalBindingsPerEntry = getTotalSources(context);
            for (let i = 0; i < totalBindingsPerEntry; i++) context.splice(index, 0, DEFAULT_BINDING_INDEX), 
            index++;
            context.splice(index, 0, DEFAULT_BINDING_VALUE);
        }
        function addBindingIntoContext(context, index, bindingValue, bitIndex, sourceIndex) {
            if ("number" == typeof bindingValue) {
                const hostBindingsMode = isHostStylingActive(sourceIndex);
                context[index + 4 + sourceIndex] = bindingValue, function(context, index, maskValue, isHostBinding) {
                    context[index + (isHostBinding ? 2 : 1)] = maskValue;
                }(context, index, getGuardMask(context, index, hostBindingsMode) | 1 << bitIndex, hostBindingsMode);
            } else null !== bindingValue && null === getDefaultValue(context, index) && function(context, index, value) {
                context[index + 4 + getTotalSources(context)] = value;
            }(context, index, bindingValue);
        }
        function addNewSourceColumn(context) {
            const insertOffset = 4 + getValuesCount(context) - 1;
            let index = 2;
            for (;index < context.length; ) index += insertOffset, context.splice(index++, 0, DEFAULT_BINDING_INDEX), 
            index++;
            context[0]++;
        }
        function syncContextInitialStyling(context, tNode, isClassBased) {
            !function(context, tNode, initialStyling, isClassBased) {
                let hasInitialStyling = !1;
                for (let i = 1; i < initialStyling.length; i += 2) {
                    const value = getMapValue(initialStyling, i);
                    value && (registerBinding(context, tNode, -1, 0, getMapProp(initialStyling, i), value, !1, isClassBased), 
                    hasInitialStyling = !0);
                }
                hasInitialStyling && patchConfig(tNode, 256);
            }(context, tNode, getStylingMapArray(context), isClassBased);
        }
        function applyStylingViaContext(context, tNode, renderer, element, bindingData, bitMaskValue, applyStylingFn, sanitizer, hostBindingsMode, isClassBased) {
            const bitMask = !0 === (value = bitMaskValue) ? -1 : !1 === value ? 0 : value;
            var value;
            let stylingMapsSyncFn = null, applyAllValues = !1;
            hasConfig(tNode, isClassBased ? 512 : 16384) && (stylingMapsSyncFn = _activeStylingMapApplyFn, 
            applyAllValues = 0 != (bitMask & getGuardMask(context, 2, hostBindingsMode)));
            const valuesCount = getValuesCount(context);
            let totalBindingsToVisit = 1, mapsMode = applyAllValues ? 1 : 0;
            hostBindingsMode && (mapsMode |= 8, totalBindingsToVisit = valuesCount - 1);
            let i = function(context, tNode, isClassBased) {
                let startPosition = 2;
                return hasConfig(tNode, isClassBased ? 512 : 16384) && (startPosition += 4 + getValuesCount(context)), 
                startPosition;
            }(context, tNode, isClassBased);
            for (;i < context.length; ) {
                if (bitMask & getGuardMask(context, i, hostBindingsMode)) {
                    let valueApplied = !1;
                    const prop = getProp(context, i), defaultValue = getDefaultValue(context, i);
                    for (let j = 0; j < totalBindingsToVisit; j++) {
                        const bindingIndex = getBindingValue(context, i, j);
                        if (!valueApplied && 0 !== bindingIndex) {
                            const value = getValue(bindingData, bindingIndex);
                            isStylingValueDefined(value) && (hostBindingsMode && 0 === j || applyStylingFn(renderer, element, prop, sanitizer && isSanitizationRequired(context, i) ? sanitizer(prop, value, 2) : unwrapSafeValue(value), bindingIndex), 
                            valueApplied = !0);
                        }
                        if (stylingMapsSyncFn) {
                            let mode = mapsMode | (valueApplied ? 4 : 2);
                            hostBindingsMode && 0 === j && (mode |= 16);
                            const valueAppliedWithinMap = stylingMapsSyncFn(context, renderer, element, bindingData, j, applyStylingFn, sanitizer, mode, prop, defaultValue);
                            valueApplied = valueApplied || valueAppliedWithinMap;
                        }
                    }
                    valueApplied || applyStylingFn(renderer, element, prop, defaultValue);
                }
                i += 4 + valuesCount;
            }
            stylingMapsSyncFn && (hostBindingsMode && (mapsMode |= 16), stylingMapsSyncFn(context, renderer, element, bindingData, 0, applyStylingFn, sanitizer, mapsMode));
        }
        function applyStylingValue(renderer, element, prop, value, applyFn, bindingIndex, sanitizer) {
            let valueToApply = unwrapSafeValue(value);
            return !!isStylingValueDefined(valueToApply) && (applyFn(renderer, element, prop, valueToApply = sanitizer ? sanitizer(prop, value, 3) : valueToApply, bindingIndex), 
            !0);
        }
        function findAndApplyMapValue(renderer, element, applyFn, map, prop, bindingIndex, sanitizer) {
            for (let i = 1; i < map.length; i += 2) {
                const p = getMapProp(map, i);
                if (p === prop) {
                    let valueToApply = getMapValue(map, i);
                    return applyFn(renderer, element, prop, valueToApply = sanitizer ? sanitizer(prop, valueToApply, 3) : valueToApply, bindingIndex), 
                    !0;
                }
                if (p > prop) break;
            }
            return !1;
        }
        let _activeStylingMapApplyFn = null;
        const setStyle = (renderer, native, prop, value) => {
            if (null !== renderer) if (isStylingValueDefined(value)) if (value = value.toString(), 
            isProceduralRenderer(renderer)) renderer.setStyle(native, prop, value, RendererStyleFlags3.DashCase); else {
                const nativeStyle = native.style;
                null != nativeStyle && nativeStyle.setProperty(prop, value);
            } else if (isProceduralRenderer(renderer)) renderer.removeStyle(native, prop, RendererStyleFlags3.DashCase); else {
                const nativeStyle = native.style;
                null != nativeStyle && nativeStyle.removeProperty(prop);
            }
        }, setClass = (renderer, native, className, value) => {
            if (null !== renderer && "" !== className) if (value) if (isProceduralRenderer(renderer)) renderer.addClass(native, className); else {
                const classList = native.classList;
                null != classList && classList.add(className);
            } else if (isProceduralRenderer(renderer)) renderer.removeClass(native, className); else {
                const classList = native.classList;
                null != classList && classList.remove(className);
            }
        }, setClassName = (renderer, native, className) => {
            null !== renderer && (isProceduralRenderer(renderer) ? renderer.setAttribute(native, "class", className) : native.className = className);
        }, setStyleAttr = (renderer, native, value) => {
            null !== renderer && (isProceduralRenderer(renderer) ? renderer.setAttribute(native, "style", value) : native.setAttribute("style", value));
        }, syncStylingMap = (context, renderer, element, data, sourceIndex, applyStylingFn, sanitizer, mode, targetProp, defaultValue) => {
            let targetPropValueWasApplied = !1;
            if (getValuesCount(context)) {
                let runTheSyncAlgorithm = !0;
                const loopUntilEnd = !targetProp;
                loopUntilEnd && 0 == (1 & mode) && (runTheSyncAlgorithm = !1, targetPropValueWasApplied = !0), 
                runTheSyncAlgorithm && (targetPropValueWasApplied = function innerSyncStylingMap(context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp, currentMapIndex, defaultValue) {
                    const mapsLimit = getValuesCount(context) - 1 - 1, recurseInnerMaps = currentMapIndex < mapsLimit && 0 != (8 & mode), checkValuesOnly = 0 != (16 & mode);
                    checkValuesOnly && (mode &= -17);
                    let targetPropValueWasApplied = !1;
                    if (currentMapIndex <= mapsLimit) {
                        let cursor = ((mapIndex = currentMapIndex) >= MAP_CURSORS.length && MAP_CURSORS.push(1), 
                        MAP_CURSORS[mapIndex]);
                        const bindingIndex = getBindingValue(context, 2, currentMapIndex), stylingMapArr = getValue(data, bindingIndex);
                        if (stylingMapArr) {
                            for (;cursor < stylingMapArr.length; ) {
                                const prop = getMapProp(stylingMapArr, cursor), iteratedTooFar = targetProp && prop > targetProp, isTargetPropMatched = !iteratedTooFar && prop === targetProp, value = getMapValue(stylingMapArr, cursor), valueIsDefined = isStylingValueDefined(value), innerMode = iteratedTooFar ? mode : resolveInnerMapMode(mode, valueIsDefined, isTargetPropMatched), innerProp = iteratedTooFar ? targetProp : prop;
                                let valueApplied = !!recurseInnerMaps && innerSyncStylingMap(context, renderer, element, data, applyStylingFn, sanitizer, innerMode, innerProp, currentMapIndex + 1, defaultValue);
                                if (iteratedTooFar) {
                                    targetPropValueWasApplied || (targetPropValueWasApplied = valueApplied);
                                    break;
                                }
                                if (!valueApplied && isValueAllowedToBeApplied(mode, isTargetPropMatched) && (valueApplied = !0, 
                                !checkValuesOnly)) {
                                    const bindingIndexToApply = isTargetPropMatched ? bindingIndex : null;
                                    let finalValue;
                                    applyStylingFn(renderer, element, prop, finalValue = isTargetPropMatched && !valueIsDefined ? defaultValue : sanitizer ? sanitizer(prop, value, 3) : value ? unwrapSafeValue(value) : null, bindingIndexToApply);
                                }
                                targetPropValueWasApplied = valueApplied && isTargetPropMatched, cursor += 2;
                            }
                            MAP_CURSORS[currentMapIndex] = cursor, !recurseInnerMaps || 1 !== stylingMapArr.length && targetProp || (targetPropValueWasApplied = innerSyncStylingMap(context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp, currentMapIndex + 1, defaultValue));
                        } else recurseInnerMaps && (targetPropValueWasApplied = innerSyncStylingMap(context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp, currentMapIndex + 1, defaultValue));
                    }
                    var mapIndex;
                    return targetPropValueWasApplied;
                }(context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp || null, sourceIndex, defaultValue || null)), 
                loopUntilEnd && function() {
                    for (let i = 0; i < MAP_CURSORS.length; i++) MAP_CURSORS[i] = 1;
                }();
            }
            return targetPropValueWasApplied;
        };
        function resolveInnerMapMode(currentMode, valueIsDefined, isTargetPropMatched) {
            let innerMode = currentMode;
            return !valueIsDefined && (isTargetPropMatched ? 2 & currentMode : 1 & currentMode) ? (innerMode |= 2, 
            innerMode &= -5) : (innerMode |= 4, innerMode &= -3), innerMode;
        }
        function isValueAllowedToBeApplied(mode, isTargetPropMatched) {
            let doApplyValue = 0 != (1 & mode);
            return doApplyValue ? 4 & mode && isTargetPropMatched && (doApplyValue = !1) : 2 & mode && (doApplyValue = isTargetPropMatched), 
            doApplyValue;
        }
        const MAP_CURSORS = [];
        let ChangeDetectorRef = (() => {
            class ChangeDetectorRef {}
            return ChangeDetectorRef.__NG_ELEMENT_ID__ = () => SWITCH_CHANGE_DETECTOR_REF_FACTORY(), 
            ChangeDetectorRef;
        })();
        const SWITCH_CHANGE_DETECTOR_REF_FACTORY = (...args) => {}, INJECTOR_SCOPE = new InjectionToken("Set Injector scope."), INJECTOR_IMPL = function(providers, parent, name) {
            return new StaticInjector(providers, parent, name);
        };
        let Injector = (() => {
            class Injector {
                static create(options, parent) {
                    return Array.isArray(options) ? INJECTOR_IMPL(options, parent, "") : INJECTOR_IMPL(options.providers, options.parent, options.name || "");
                }
            }
            return Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND, Injector.NULL = new NullInjector, 
            Injector.ɵprov = ɵɵdefineInjectable({
                token: Injector,
                providedIn: "any",
                factory: () => ɵɵinject(INJECTOR)
            }), Injector.__NG_ELEMENT_ID__ = -1, Injector;
        })();
        const IDENT = function(value) {
            return value;
        }, EMPTY = [], CIRCULAR$1 = IDENT, MULTI_PROVIDER_FN = function() {
            return Array.prototype.slice.call(arguments);
        }, NO_NEW_LINE$1 = "ɵ";
        class StaticInjector {
            constructor(providers, parent = Injector.NULL, source = null) {
                this.parent = parent, this.source = source;
                const records = this._records = new Map;
                records.set(Injector, {
                    token: Injector,
                    fn: IDENT,
                    deps: EMPTY,
                    value: this,
                    useNew: !1
                }), records.set(INJECTOR, {
                    token: INJECTOR,
                    fn: IDENT,
                    deps: EMPTY,
                    value: this,
                    useNew: !1
                }), this.scope = function recursivelyProcessProviders(records, provider) {
                    let scope = null;
                    if (provider) if (provider = resolveForwardRef(provider), Array.isArray(provider)) for (let i = 0; i < provider.length; i++) scope = recursivelyProcessProviders(records, provider[i]) || scope; else {
                        if ("function" == typeof provider) throw staticError("Function/Class not supported", provider);
                        if (!provider || "object" != typeof provider || !provider.provide) throw staticError("Unexpected provider", provider);
                        {
                            let token = resolveForwardRef(provider.provide);
                            const resolvedProvider = resolveProvider(provider);
                            if (!0 === provider.multi) {
                                let multiProvider = records.get(token);
                                if (multiProvider) {
                                    if (multiProvider.fn !== MULTI_PROVIDER_FN) throw multiProviderMixError(token);
                                } else records.set(token, multiProvider = {
                                    token: provider.provide,
                                    deps: [],
                                    useNew: !1,
                                    fn: MULTI_PROVIDER_FN,
                                    value: EMPTY
                                });
                                multiProvider.deps.push({
                                    token: token = provider,
                                    options: 6
                                });
                            }
                            const record = records.get(token);
                            if (record && record.fn == MULTI_PROVIDER_FN) throw multiProviderMixError(token);
                            token === INJECTOR_SCOPE && (scope = resolvedProvider.value), records.set(token, resolvedProvider);
                        }
                    }
                    return scope;
                }(records, providers);
            }
            get(token, notFoundValue, flags = InjectFlags.Default) {
                const records = this._records;
                let record = records.get(token);
                if (void 0 === record) {
                    const injectableDef = getInjectableDef(token);
                    if (injectableDef) {
                        const providedIn = injectableDef && injectableDef.providedIn;
                        ("any" === providedIn || null != providedIn && providedIn === this.scope) && records.set(token, record = resolveProvider({
                            provide: token,
                            useFactory: injectableDef.factory,
                            deps: EMPTY
                        }));
                    }
                    void 0 === record && records.set(token, null);
                }
                let lastInjector = setCurrentInjector(this);
                try {
                    return function tryResolveToken(token, record, records, parent, notFoundValue, flags) {
                        try {
                            return function(token, record, records, parent, notFoundValue, flags) {
                                let value;
                                if (!record || flags & InjectFlags.SkipSelf) value = flags & InjectFlags.Self ? Injector.NULL.get(token, flags & InjectFlags.Optional ? void 0 !== notFoundValue ? notFoundValue : null : notFoundValue) : parent.get(token, notFoundValue, InjectFlags.Default); else {
                                    if ((value = record.value) == CIRCULAR$1) throw Error(NO_NEW_LINE$1 + "Circular dependency");
                                    if (value === EMPTY) {
                                        record.value = CIRCULAR$1;
                                        let obj = void 0, useNew = record.useNew, fn = record.fn, depRecords = record.deps, deps = EMPTY;
                                        if (depRecords.length) {
                                            deps = [];
                                            for (let i = 0; i < depRecords.length; i++) {
                                                const depRecord = depRecords[i], options = depRecord.options, childRecord = 2 & options ? records.get(depRecord.token) : void 0;
                                                deps.push(tryResolveToken(depRecord.token, childRecord, records, childRecord || 4 & options ? parent : Injector.NULL, 1 & options ? null : Injector.THROW_IF_NOT_FOUND, InjectFlags.Default));
                                            }
                                        }
                                        record.value = value = useNew ? new fn(...deps) : fn.apply(obj, deps);
                                    }
                                }
                                return value;
                            }(token, record, records, parent, notFoundValue, flags);
                        } catch (e) {
                            throw e instanceof Error || (e = new Error(e)), (e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || []).unshift(token), 
                            record && record.value == CIRCULAR$1 && (record.value = EMPTY), e;
                        }
                    }(token, record, records, this.parent, notFoundValue, flags);
                } catch (e) {
                    return function(e, token, injectorErrorName, source) {
                        const tokenPath = e[NG_TEMP_TOKEN_PATH];
                        throw token[SOURCE] && tokenPath.unshift(token[SOURCE]), e.message = formatError("\n" + e.message, tokenPath, "StaticInjectorError", source), 
                        e[NG_TOKEN_PATH] = tokenPath, e[NG_TEMP_TOKEN_PATH] = null, e;
                    }(e, token, 0, this.source);
                } finally {
                    setCurrentInjector(lastInjector);
                }
            }
            toString() {
                const tokens = [];
                return this._records.forEach((v, token) => tokens.push(stringify(token))), `StaticInjector[${tokens.join(", ")}]`;
            }
        }
        function resolveProvider(provider) {
            const deps = function(provider) {
                let deps = EMPTY;
                const providerDeps = provider.deps;
                if (providerDeps && providerDeps.length) {
                    deps = [];
                    for (let i = 0; i < providerDeps.length; i++) {
                        let options = 6, token = resolveForwardRef(providerDeps[i]);
                        if (Array.isArray(token)) for (let j = 0, annotations = token; j < annotations.length; j++) {
                            const annotation = annotations[j];
                            annotation instanceof Optional || annotation == Optional ? options |= 1 : annotation instanceof SkipSelf || annotation == SkipSelf ? options &= -3 : annotation instanceof Self || annotation == Self ? options &= -5 : token = annotation instanceof Inject ? annotation.token : resolveForwardRef(annotation);
                        }
                        deps.push({
                            token: token,
                            options: options
                        });
                    }
                } else if (provider.useExisting) deps = [ {
                    token: resolveForwardRef(provider.useExisting),
                    options: 6
                } ]; else if (!(providerDeps || USE_VALUE in provider)) throw staticError("'deps' required", provider);
                return deps;
            }(provider);
            let fn = IDENT, value = EMPTY, useNew = !1, provide = resolveForwardRef(provider.provide);
            if (USE_VALUE in provider) value = provider.useValue; else if (provider.useFactory) fn = provider.useFactory; else if (provider.useExisting) ; else if (provider.useClass) useNew = !0, 
            fn = resolveForwardRef(provider.useClass); else {
                if ("function" != typeof provide) throw staticError("StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable", provider);
                useNew = !0, fn = provide;
            }
            return {
                deps: deps,
                fn: fn,
                useNew: useNew,
                value: value
            };
        }
        function multiProviderMixError(token) {
            return staticError("Cannot mix multi providers and regular providers", token);
        }
        function staticError(text, obj) {
            return new Error(formatError(text, obj, "StaticInjectorError"));
        }
        const ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken("AnalyzeForEntryComponents");
        function ɵɵallocHostVars(count) {
            const lView = getLView(), tView = lView[TVIEW];
            tView.firstCreatePass && (function(tView, def, hostVars) {
                const expando = tView.expandoInstructions, length = expando.length;
                length >= 2 && expando[length - 2] === def.hostBindings ? expando[length - 1] = expando[length - 1] + hostVars : expando.push(def.hostBindings, hostVars);
            }(tView, instructionState.lFrame.currentDirectiveDef, count), function(tView, lView, totalHostVars) {
                for (let i = 0; i < totalHostVars; i++) lView.push(NO_CHANGE), tView.blueprint.push(NO_CHANGE), 
                tView.data.push(null);
            }(tView, lView, count));
        }
        let _symbolIterator = null;
        function getSymbolIterator() {
            if (!_symbolIterator) {
                const Symbol = _global.Symbol;
                if (Symbol && Symbol.iterator) _symbolIterator = Symbol.iterator; else {
                    const keys = Object.getOwnPropertyNames(Map.prototype);
                    for (let i = 0; i < keys.length; ++i) {
                        const key = keys[i];
                        "entries" !== key && "size" !== key && Map.prototype[key] === Map.prototype.entries && (_symbolIterator = key);
                    }
                }
            }
            return _symbolIterator;
        }
        function looseIdentical(a, b) {
            return a === b || "number" == typeof a && "number" == typeof b && isNaN(a) && isNaN(b);
        }
        function devModeEqual$1(a, b) {
            const isListLikeIterableA = isListLikeIterable$1(a), isListLikeIterableB = isListLikeIterable$1(b);
            if (isListLikeIterableA && isListLikeIterableB) return function(a, b, comparator) {
                const iterator1 = a[getSymbolIterator()](), iterator2 = b[getSymbolIterator()]();
                for (;;) {
                    const item1 = iterator1.next(), item2 = iterator2.next();
                    if (item1.done && item2.done) return !0;
                    if (item1.done || item2.done) return !1;
                    if (!comparator(item1.value, item2.value)) return !1;
                }
            }(a, b, devModeEqual$1);
            {
                const isAObject = a && ("object" == typeof a || "function" == typeof a), isBObject = b && ("object" == typeof b || "function" == typeof b);
                return !(isListLikeIterableA || !isAObject || isListLikeIterableB || !isBObject) || looseIdentical(a, b);
            }
        }
        class WrappedValue {
            constructor(value) {
                this.wrapped = value;
            }
            static wrap(value) {
                return new WrappedValue(value);
            }
            static unwrap(value) {
                return WrappedValue.isWrapped(value) ? value.wrapped : value;
            }
            static isWrapped(value) {
                return value instanceof WrappedValue;
            }
        }
        function isListLikeIterable$1(obj) {
            return !!isJsObject$1(obj) && (Array.isArray(obj) || !(obj instanceof Map) && getSymbolIterator() in obj);
        }
        function isJsObject$1(o) {
            return null !== o && ("function" == typeof o || "object" == typeof o);
        }
        function ɵɵstyleMap(styles) {
            const index = getSelectedIndex(), lView = getLView(), tNode = getTNode(index, lView), firstUpdatePass = lView[TVIEW].firstUpdatePass, context = function(tNode) {
                return getContext(tNode, !1);
            }(tNode), hasDirectiveInput = function(tNode) {
                return 0 != (32 & tNode.flags);
            }(tNode), bindingIndex = incrementBindingIndex(2);
            !isHostStyling() && hasDirectiveInput && styles !== NO_CHANGE && (updateDirectiveInputValue(context, lView, tNode, bindingIndex, styles, !1, firstUpdatePass), 
            styles = NO_CHANGE), firstUpdatePass && (patchConfig(tNode, 16384), patchHostStylingFlag(tNode, isHostStyling(), !1)), 
            stylingMap(context, tNode, firstUpdatePass, lView, bindingIndex, styles, !1, hasDirectiveInput);
        }
        function ɵɵclassMap(classes) {
            !function(elementIndex, classes) {
                const lView = getLView(), tNode = getTNode(elementIndex, lView), firstUpdatePass = lView[TVIEW].firstUpdatePass, context = function(tNode) {
                    return getContext(tNode, !0);
                }(tNode), hasDirectiveInput = function(tNode) {
                    return 0 != (16 & tNode.flags);
                }(tNode), bindingIndex = incrementBindingIndex(2);
                !isHostStyling() && hasDirectiveInput && classes !== NO_CHANGE && (updateDirectiveInputValue(context, lView, tNode, bindingIndex, classes, !0, firstUpdatePass), 
                classes = NO_CHANGE), firstUpdatePass && (patchConfig(tNode, 512), patchHostStylingFlag(tNode, isHostStyling(), !0)), 
                stylingMap(context, tNode, firstUpdatePass, lView, bindingIndex, classes, !0, hasDirectiveInput);
            }(getSelectedIndex(), classes);
        }
        function stylingMap(context, tNode, firstUpdatePass, lView, bindingIndex, value, isClassBased, hasDirectiveInput) {
            const directiveIndex = getActiveDirectiveId(), native = getNativeByTNode(tNode, lView), oldValue = getValue(lView, bindingIndex), sanitizer = getCurrentStyleSanitizer(), valueHasChanged = hasValueChanged(oldValue, value);
            if (function(tNode, isClassBased, firstUpdatePass) {
                let allow = !1;
                if (hasConfig(tNode, 128)) {
                    if (!firstUpdatePass) {
                        const hasDuplicates = hasConfig(tNode, isClassBased ? 8192 : 262144), hasOnlyMapOrPropsFlag = isClassBased ? 1536 : 49152, hasOnlyMapsOrOnlyProps = (tNode.flags & hasOnlyMapOrPropsFlag) !== hasOnlyMapOrPropsFlag;
                        allow = !hasDuplicates && hasOnlyMapsOrOnlyProps;
                    }
                } else allow = !0;
                return allow;
            }(tNode, isClassBased, firstUpdatePass)) {
                const sanitizerToUse = isClassBased ? null : sanitizer;
                (function(renderer, context, tNode, element, data, bindingIndex, value, isClassBased, sanitizer, forceUpdate, bindingValueContainsInitial) {
                    const oldValue = getValue(data, bindingIndex);
                    if (forceUpdate || hasValueChanged(oldValue, value)) {
                        const hasInitial = hasConfig(tNode, 256), initialValue = hasInitial && !bindingValueContainsInitial ? getInitialStylingValue(context) : null;
                        setValue(data, bindingIndex, value);
                        const cachedValueIndex = bindingIndex + 1;
                        let cachedValue = getValue(data, cachedValueIndex);
                        cachedValue === NO_CHANGE && (cachedValue = initialValue), cachedValue = "string" != typeof cachedValue ? "" : cachedValue;
                        let writeToAttrDirectly = !hasConfig(tNode, isClassBased ? 1024 : 32768);
                        if (writeToAttrDirectly && function(element, cachedValue, isClassBased) {
                            return "undefined" === _global.Node || cachedValue === VALUE_IS_EXTERNALLY_MODIFIED || ((isClassBased ? element.className : element.style && element.style.cssText) || "") !== (cachedValue || "");
                        }(element, cachedValue, isClassBased) && (writeToAttrDirectly = !1, oldValue !== VALUE_IS_EXTERNALLY_MODIFIED && (function(renderer, element, values, isClassBased) {
                            let arr;
                            var value;
                            value = values, arr = Array.isArray(value) && "string" == typeof value[1] ? values : normalizeIntoStylingMap(null, values, !isClassBased);
                            const applyFn = isClassBased ? setClass : setStyle;
                            for (let i = 1; i < arr.length; i += 2) getMapValue(arr, i) && applyFn(renderer, element, getMapProp(arr, i), !1);
                        }(renderer, element, oldValue, isClassBased), setValue(data, cachedValueIndex, VALUE_IS_EXTERNALLY_MODIFIED))), 
                        writeToAttrDirectly) setValue(data, cachedValueIndex, function(renderer, element, value, isClassBased, initialValue) {
                            let valueToApply;
                            return isClassBased ? (valueToApply = "string" == typeof value ? value : function(obj) {
                                let str = "";
                                if (obj) for (let key in obj) obj[key] && (str += (str.length ? " " : "") + key);
                                return str;
                            }(value), null !== initialValue && (valueToApply = concatString(initialValue, valueToApply, " ")), 
                            setClassName(renderer, element, valueToApply)) : (valueToApply = forceStylesAsString(value, !0), 
                            null !== initialValue && (valueToApply = initialValue + ";" + valueToApply), setStyleAttr(renderer, element, valueToApply)), 
                            valueToApply;
                        }(renderer, element, value, isClassBased, hasInitial && !bindingValueContainsInitial ? getInitialStylingValue(context) : null) || null); else {
                            const applyFn = isClassBased ? setClass : setStyle, map = normalizeIntoStylingMap(oldValue, value, !isClassBased), initialStyles = hasInitial ? getStylingMapArray(context) : null;
                            for (let i = 1; i < map.length; i += 2) {
                                const prop = getMapProp(map, i);
                                let applied = applyStylingValue(renderer, element, prop, getMapValue(map, i), applyFn, bindingIndex, sanitizer);
                                !applied && initialStyles && (applied = findAndApplyMapValue(renderer, element, applyFn, initialStyles, prop, bindingIndex, sanitizer)), 
                                applied || applyFn(renderer, element, prop, null, bindingIndex);
                            }
                            const state = getStylingState(element, TEMPLATE_DIRECTIVE_INDEX);
                            isClassBased ? state.lastDirectClassMap = map : state.lastDirectStyleMap = map;
                        }
                    }
                })(getRenderer(tNode, lView), context, tNode, native, lView, bindingIndex, value, isClassBased, sanitizerToUse, valueHasChanged, hasDirectiveInput), 
                sanitizerToUse && setElementExitFn(stylingApply);
            } else {
                const stylingMapArr = value === NO_CHANGE ? NO_CHANGE : normalizeIntoStylingMap(oldValue, value, !isClassBased);
                _activeStylingMapApplyFn = syncStylingMap, isClassBased ? function(context, tNode, data, element, directiveIndex, prop, bindingIndex, value, forceUpdate, firstUpdatePass) {
                    const state = getStylingState(element, directiveIndex), countIndex = STYLING_INDEX_FOR_MAP_BINDING;
                    (firstUpdatePass || value !== NO_CHANGE) && (updateBindingData(context, tNode, data, countIndex, state.sourceIndex, null, bindingIndex, value, forceUpdate, !1, firstUpdatePass, !0) || forceUpdate) && (state.classesBitMask |= 1 << countIndex);
                }(context, tNode, lView, native, directiveIndex, 0, bindingIndex, stylingMapArr, valueHasChanged, firstUpdatePass) : function(context, tNode, data, element, directiveIndex, prop, bindingIndex, value, sanitizer, forceUpdate, firstUpdatePass) {
                    const state = getStylingState(element, directiveIndex), countIndex = STYLING_INDEX_FOR_MAP_BINDING;
                    if (firstUpdatePass || value !== NO_CHANGE) {
                        if (updateBindingData(context, tNode, data, countIndex, state.sourceIndex, null, bindingIndex, value, forceUpdate, !0, firstUpdatePass, !1) || forceUpdate) state.stylesBitMask |= 1 << countIndex;
                    }
                }(context, tNode, lView, native, directiveIndex, 0, bindingIndex, stylingMapArr, 0, valueHasChanged, firstUpdatePass), 
                setElementExitFn(stylingApply);
            }
        }
        function updateDirectiveInputValue(context, lView, tNode, bindingIndex, newValue, isClassBased, firstUpdatePass) {
            if (hasValueChanged(getValue(lView, bindingIndex), newValue)) {
                if (isStylingValueDefined(newValue) || !firstUpdatePass) {
                    const inputName = isClassBased ? tNode.inputs.hasOwnProperty("class") ? "class" : "className" : "style";
                    (function(lView, inputs, value) {
                        const tView = lView[TVIEW];
                        for (let i = 0; i < inputs.length; ) {
                            const index = inputs[i++], publicName = inputs[i++], privateName = inputs[i++], instance = lView[index], def = tView.data[index];
                            def.setInput ? def.setInput(instance, value, publicName, privateName) : instance[privateName] = value;
                        }
                    })(lView, tNode.inputs[inputName], function(initialValue, bindingValue, isClassBased) {
                        let value = bindingValue;
                        var classes;
                        return initialValue.length && (value = isClassBased ? concatString(initialValue, ((classes = bindingValue) && "string" != typeof classes && (classes = Object.keys(classes).join(" ")), 
                        classes || "")) : concatString(initialValue, forceStylesAsString(bindingValue, !0), ";")), 
                        value;
                    }(getInitialStylingValue(context), newValue, isClassBased)), setElementExitFn(stylingApply);
                }
                setValue(lView, bindingIndex, newValue);
            }
        }
        function stylingApply() {
            const lView = getLView(), tView = lView[TVIEW], tNode = getTNode(getSelectedIndex(), lView), native = getNativeByTNode(tNode, lView), directiveIndex = getActiveDirectiveId(), renderer = getRenderer(tNode, lView), sanitizer = getCurrentStyleSanitizer();
            (function(renderer, data, tNode, classesContext, stylesContext, element, directiveIndex, styleSanitizer, firstUpdatePass) {
                const state = getStylingState(element, directiveIndex), hostBindingsMode = isHostStylingActive(state.sourceIndex);
                stylesContext && (firstUpdatePass && syncContextInitialStyling(stylesContext, tNode, !1), 
                0 !== state.stylesBitMask && applyStylingViaContext(stylesContext, tNode, renderer, element, data, state.stylesBitMask, setStyle, styleSanitizer, hostBindingsMode, !1)), 
                classesContext && (firstUpdatePass && syncContextInitialStyling(classesContext, tNode, !0), 
                0 !== state.classesBitMask && applyStylingViaContext(classesContext, tNode, renderer, element, data, state.classesBitMask, setClass, null, hostBindingsMode, !0)), 
                _state.element = null;
            })(renderer, lView, tNode, isStylingContext(tNode.classes) ? tNode.classes : null, isStylingContext(tNode.styles) ? tNode.styles : null, native, directiveIndex, sanitizer, tView.firstUpdatePass), 
            instructionState.lFrame.currentSanitizer = null;
        }
        function getRenderer(tNode, lView) {
            return 3 === tNode.type ? lView[RENDERER] : null;
        }
        function getContext(tNode, isClassBased) {
            let context = isClassBased ? tNode.classes : tNode.styles;
            var initialStyling;
            return isStylingContext(context) || (initialStyling = (initialStyling = context) || allocStylingMapArray(null), 
            context = [ DEFAULT_TOTAL_SOURCES, initialStyling ], isClassBased ? tNode.classes = context : tNode.styles = context), 
            context;
        }
        function isHostStyling() {
            return isHostStylingActive(getActiveDirectiveId());
        }
        function patchHostStylingFlag(tNode, hostBindingsMode, isClassBased) {
            patchConfig(tNode, hostBindingsMode ? isClassBased ? 4096 : 131072 : isClassBased ? 2048 : 65536);
        }
        function isPromise(obj) {
            return !!obj && "function" == typeof obj.then;
        }
        function isObservable(obj) {
            return !!obj && "function" == typeof obj.subscribe;
        }
        class SimpleChange {
            constructor(previousValue, currentValue, firstChange) {
                this.previousValue = previousValue, this.currentValue = currentValue, this.firstChange = firstChange;
            }
            isFirstChange() {
                return this.firstChange;
            }
        }
        class ComponentRef {}
        class ComponentFactory {}
        function noComponentFactoryError(component) {
            const error = Error(`No component factory found for ${stringify(component)}. Did you add it to @NgModule.entryComponents?`);
            return error[ERROR_COMPONENT] = component, error;
        }
        const ERROR_COMPONENT = "ngComponent";
        class _NullComponentFactoryResolver {
            resolveComponentFactory(component) {
                throw noComponentFactoryError(component);
            }
        }
        let ComponentFactoryResolver = (() => {
            class ComponentFactoryResolver {}
            return ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver, ComponentFactoryResolver;
        })();
        class CodegenComponentFactoryResolver {
            constructor(factories, _parent, _ngModule) {
                this._parent = _parent, this._ngModule = _ngModule, this._factories = new Map;
                for (let i = 0; i < factories.length; i++) {
                    const factory = factories[i];
                    this._factories.set(factory.componentType, factory);
                }
            }
            resolveComponentFactory(component) {
                let factory = this._factories.get(component);
                if (!factory && this._parent && (factory = this._parent.resolveComponentFactory(component)), 
                !factory) throw noComponentFactoryError(component);
                return new ComponentFactoryBoundToModule(factory, this._ngModule);
            }
        }
        class ComponentFactoryBoundToModule extends ComponentFactory {
            constructor(factory, ngModule) {
                super(), this.factory = factory, this.ngModule = ngModule, this.selector = factory.selector, 
                this.componentType = factory.componentType, this.ngContentSelectors = factory.ngContentSelectors, 
                this.inputs = factory.inputs, this.outputs = factory.outputs;
            }
            create(injector, projectableNodes, rootSelectorOrNode, ngModule) {
                return this.factory.create(injector, projectableNodes, rootSelectorOrNode, ngModule || this.ngModule);
            }
        }
        function noop(...args) {}
        let ElementRef = (() => {
            class ElementRef {
                constructor(nativeElement) {
                    this.nativeElement = nativeElement;
                }
            }
            return ElementRef.__NG_ELEMENT_ID__ = () => SWITCH_ELEMENT_REF_FACTORY(ElementRef), 
            ElementRef;
        })();
        const SWITCH_ELEMENT_REF_FACTORY = noop;
        class RendererFactory2 {}
        const RendererStyleFlags2 = function() {
            var RendererStyleFlags2 = {
                Important: 1,
                DashCase: 2
            };
            return RendererStyleFlags2[RendererStyleFlags2.Important] = "Important", RendererStyleFlags2[RendererStyleFlags2.DashCase] = "DashCase", 
            RendererStyleFlags2;
        }();
        let Renderer2 = (() => {
            class Renderer2 {}
            return Renderer2.__NG_ELEMENT_ID__ = () => SWITCH_RENDERER2_FACTORY(), Renderer2;
        })();
        const SWITCH_RENDERER2_FACTORY = noop;
        let Sanitizer = (() => {
            class Sanitizer {}
            return Sanitizer.ɵprov = ɵɵdefineInjectable({
                token: Sanitizer,
                providedIn: "root",
                factory: () => null
            }), Sanitizer;
        })();
        class Version {
            constructor(full) {
                this.full = full, this.major = full.split(".")[0], this.minor = full.split(".")[1], 
                this.patch = full.split(".").slice(2).join(".");
            }
        }
        const VERSION = new Version("9.0.0-rc.2");
        class DefaultIterableDifferFactory {
            constructor() {}
            supports(obj) {
                return isListLikeIterable$1(obj);
            }
            create(trackByFn) {
                return new DefaultIterableDiffer(trackByFn);
            }
        }
        const trackByIdentity = (index, item) => item;
        class DefaultIterableDiffer {
            constructor(trackByFn) {
                this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, 
                this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, 
                this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, 
                this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = trackByFn || trackByIdentity;
            }
            forEachItem(fn) {
                let record;
                for (record = this._itHead; null !== record; record = record._next) fn(record);
            }
            forEachOperation(fn) {
                let nextIt = this._itHead, nextRemove = this._removalsHead, addRemoveOffset = 0, moveOffsets = null;
                for (;nextIt || nextRemove; ) {
                    const record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove, adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets), currentIndex = record.currentIndex;
                    if (record === nextRemove) addRemoveOffset--, nextRemove = nextRemove._nextRemoved; else if (nextIt = nextIt._next, 
                    null == record.previousIndex) addRemoveOffset++; else {
                        moveOffsets || (moveOffsets = []);
                        const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset, localCurrentIndex = currentIndex - addRemoveOffset;
                        if (localMovePreviousIndex != localCurrentIndex) {
                            for (let i = 0; i < localMovePreviousIndex; i++) {
                                const offset = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0, index = offset + i;
                                localCurrentIndex <= index && index < localMovePreviousIndex && (moveOffsets[i] = offset + 1);
                            }
                            moveOffsets[record.previousIndex] = localCurrentIndex - localMovePreviousIndex;
                        }
                    }
                    adjPreviousIndex !== currentIndex && fn(record, adjPreviousIndex, currentIndex);
                }
            }
            forEachPreviousItem(fn) {
                let record;
                for (record = this._previousItHead; null !== record; record = record._nextPrevious) fn(record);
            }
            forEachAddedItem(fn) {
                let record;
                for (record = this._additionsHead; null !== record; record = record._nextAdded) fn(record);
            }
            forEachMovedItem(fn) {
                let record;
                for (record = this._movesHead; null !== record; record = record._nextMoved) fn(record);
            }
            forEachRemovedItem(fn) {
                let record;
                for (record = this._removalsHead; null !== record; record = record._nextRemoved) fn(record);
            }
            forEachIdentityChange(fn) {
                let record;
                for (record = this._identityChangesHead; null !== record; record = record._nextIdentityChange) fn(record);
            }
            diff(collection) {
                if (null == collection && (collection = []), !isListLikeIterable$1(collection)) throw new Error(`Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`);
                return this.check(collection) ? this : null;
            }
            onDestroy() {}
            check(collection) {
                this._reset();
                let index, item, itemTrackBy, record = this._itHead, mayBeDirty = !1;
                if (Array.isArray(collection)) {
                    this.length = collection.length;
                    for (let index = 0; index < this.length; index++) itemTrackBy = this._trackByFn(index, item = collection[index]), 
                    null !== record && looseIdentical(record.trackById, itemTrackBy) ? (mayBeDirty && (record = this._verifyReinsertion(record, item, itemTrackBy, index)), 
                    looseIdentical(record.item, item) || this._addIdentityChange(record, item)) : (record = this._mismatch(record, item, itemTrackBy, index), 
                    mayBeDirty = !0), record = record._next;
                } else index = 0, function(obj, fn) {
                    if (Array.isArray(obj)) for (let i = 0; i < obj.length; i++) fn(obj[i]); else {
                        const iterator = obj[getSymbolIterator()]();
                        let item;
                        for (;!(item = iterator.next()).done; ) fn(item.value);
                    }
                }(collection, item => {
                    itemTrackBy = this._trackByFn(index, item), null !== record && looseIdentical(record.trackById, itemTrackBy) ? (mayBeDirty && (record = this._verifyReinsertion(record, item, itemTrackBy, index)), 
                    looseIdentical(record.item, item) || this._addIdentityChange(record, item)) : (record = this._mismatch(record, item, itemTrackBy, index), 
                    mayBeDirty = !0), record = record._next, index++;
                }), this.length = index;
                return this._truncate(record), this.collection = collection, this.isDirty;
            }
            get isDirty() {
                return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead;
            }
            _reset() {
                if (this.isDirty) {
                    let record, nextRecord;
                    for (record = this._previousItHead = this._itHead; null !== record; record = record._next) record._nextPrevious = record._next;
                    for (record = this._additionsHead; null !== record; record = record._nextAdded) record.previousIndex = record.currentIndex;
                    for (this._additionsHead = this._additionsTail = null, record = this._movesHead; null !== record; record = nextRecord) record.previousIndex = record.currentIndex, 
                    nextRecord = record._nextMoved;
                    this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, 
                    this._identityChangesHead = this._identityChangesTail = null;
                }
            }
            _mismatch(record, item, itemTrackBy, index) {
                let previousRecord;
                return null === record ? previousRecord = this._itTail : (previousRecord = record._prev, 
                this._remove(record)), null !== (record = null === this._linkedRecords ? null : this._linkedRecords.get(itemTrackBy, index)) ? (looseIdentical(record.item, item) || this._addIdentityChange(record, item), 
                this._moveAfter(record, previousRecord, index)) : null !== (record = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(itemTrackBy, null)) ? (looseIdentical(record.item, item) || this._addIdentityChange(record, item), 
                this._reinsertAfter(record, previousRecord, index)) : record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index), 
                record;
            }
            _verifyReinsertion(record, item, itemTrackBy, index) {
                let reinsertRecord = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(itemTrackBy, null);
                return null !== reinsertRecord ? record = this._reinsertAfter(reinsertRecord, record._prev, index) : record.currentIndex != index && (record.currentIndex = index, 
                this._addToMoves(record, index)), record;
            }
            _truncate(record) {
                for (;null !== record; ) {
                    const nextRecord = record._next;
                    this._addToRemovals(this._unlink(record)), record = nextRecord;
                }
                null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), 
                null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), 
                null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null);
            }
            _reinsertAfter(record, prevRecord, index) {
                null !== this._unlinkedRecords && this._unlinkedRecords.remove(record);
                const prev = record._prevRemoved, next = record._nextRemoved;
                return null === prev ? this._removalsHead = next : prev._nextRemoved = next, null === next ? this._removalsTail = prev : next._prevRemoved = prev, 
                this._insertAfter(record, prevRecord, index), this._addToMoves(record, index), record;
            }
            _moveAfter(record, prevRecord, index) {
                return this._unlink(record), this._insertAfter(record, prevRecord, index), this._addToMoves(record, index), 
                record;
            }
            _addAfter(record, prevRecord, index) {
                return this._insertAfter(record, prevRecord, index), this._additionsTail = null === this._additionsTail ? this._additionsHead = record : this._additionsTail._nextAdded = record, 
                record;
            }
            _insertAfter(record, prevRecord, index) {
                const next = null === prevRecord ? this._itHead : prevRecord._next;
                return record._next = next, record._prev = prevRecord, null === next ? this._itTail = record : next._prev = record, 
                null === prevRecord ? this._itHead = record : prevRecord._next = record, null === this._linkedRecords && (this._linkedRecords = new _DuplicateMap), 
                this._linkedRecords.put(record), record.currentIndex = index, record;
            }
            _remove(record) {
                return this._addToRemovals(this._unlink(record));
            }
            _unlink(record) {
                null !== this._linkedRecords && this._linkedRecords.remove(record);
                const prev = record._prev, next = record._next;
                return null === prev ? this._itHead = next : prev._next = next, null === next ? this._itTail = prev : next._prev = prev, 
                record;
            }
            _addToMoves(record, toIndex) {
                return record.previousIndex === toIndex ? record : (this._movesTail = null === this._movesTail ? this._movesHead = record : this._movesTail._nextMoved = record, 
                record);
            }
            _addToRemovals(record) {
                return null === this._unlinkedRecords && (this._unlinkedRecords = new _DuplicateMap), 
                this._unlinkedRecords.put(record), record.currentIndex = null, record._nextRemoved = null, 
                null === this._removalsTail ? (this._removalsTail = this._removalsHead = record, 
                record._prevRemoved = null) : (record._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = record), 
                record;
            }
            _addIdentityChange(record, item) {
                return record.item = item, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = record : this._identityChangesTail._nextIdentityChange = record, 
                record;
            }
        }
        class IterableChangeRecord_ {
            constructor(item, trackById) {
                this.item = item, this.trackById = trackById, this.currentIndex = null, this.previousIndex = null, 
                this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, 
                this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, 
                this._nextMoved = null, this._nextIdentityChange = null;
            }
        }
        class _DuplicateItemRecordList {
            constructor() {
                this._head = null, this._tail = null;
            }
            add(record) {
                null === this._head ? (this._head = this._tail = record, record._nextDup = null, 
                record._prevDup = null) : (this._tail._nextDup = record, record._prevDup = this._tail, 
                record._nextDup = null, this._tail = record);
            }
            get(trackById, atOrAfterIndex) {
                let record;
                for (record = this._head; null !== record; record = record._nextDup) if ((null === atOrAfterIndex || atOrAfterIndex <= record.currentIndex) && looseIdentical(record.trackById, trackById)) return record;
                return null;
            }
            remove(record) {
                const prev = record._prevDup, next = record._nextDup;
                return null === prev ? this._head = next : prev._nextDup = next, null === next ? this._tail = prev : next._prevDup = prev, 
                null === this._head;
            }
        }
        class _DuplicateMap {
            constructor() {
                this.map = new Map;
            }
            put(record) {
                const key = record.trackById;
                let duplicates = this.map.get(key);
                duplicates || (duplicates = new _DuplicateItemRecordList, this.map.set(key, duplicates)), 
                duplicates.add(record);
            }
            get(trackById, atOrAfterIndex) {
                const recordList = this.map.get(trackById);
                return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
            }
            remove(record) {
                const key = record.trackById;
                return this.map.get(key).remove(record) && this.map.delete(key), record;
            }
            get isEmpty() {
                return 0 === this.map.size;
            }
            clear() {
                this.map.clear();
            }
        }
        function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
            const previousIndex = item.previousIndex;
            if (null === previousIndex) return previousIndex;
            let moveOffset = 0;
            return moveOffsets && previousIndex < moveOffsets.length && (moveOffset = moveOffsets[previousIndex]), 
            previousIndex + addRemoveOffset + moveOffset;
        }
        class DefaultKeyValueDifferFactory {
            constructor() {}
            supports(obj) {
                return obj instanceof Map || isJsObject$1(obj);
            }
            create() {
                return new DefaultKeyValueDiffer;
            }
        }
        class DefaultKeyValueDiffer {
            constructor() {
                this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, 
                this._changesHead = null, this._changesTail = null, this._additionsHead = null, 
                this._additionsTail = null, this._removalsHead = null, this._removalsTail = null;
            }
            get isDirty() {
                return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead;
            }
            forEachItem(fn) {
                let record;
                for (record = this._mapHead; null !== record; record = record._next) fn(record);
            }
            forEachPreviousItem(fn) {
                let record;
                for (record = this._previousMapHead; null !== record; record = record._nextPrevious) fn(record);
            }
            forEachChangedItem(fn) {
                let record;
                for (record = this._changesHead; null !== record; record = record._nextChanged) fn(record);
            }
            forEachAddedItem(fn) {
                let record;
                for (record = this._additionsHead; null !== record; record = record._nextAdded) fn(record);
            }
            forEachRemovedItem(fn) {
                let record;
                for (record = this._removalsHead; null !== record; record = record._nextRemoved) fn(record);
            }
            diff(map) {
                if (map) {
                    if (!(map instanceof Map || isJsObject$1(map))) throw new Error(`Error trying to diff '${stringify(map)}'. Only maps and objects are allowed`);
                } else map = new Map;
                return this.check(map) ? this : null;
            }
            onDestroy() {}
            check(map) {
                this._reset();
                let insertBefore = this._mapHead;
                if (this._appendAfter = null, this._forEach(map, (value, key) => {
                    if (insertBefore && insertBefore.key === key) this._maybeAddToChanges(insertBefore, value), 
                    this._appendAfter = insertBefore, insertBefore = insertBefore._next; else {
                        const record = this._getOrCreateRecordForKey(key, value);
                        insertBefore = this._insertBeforeOrAppend(insertBefore, record);
                    }
                }), insertBefore) {
                    insertBefore._prev && (insertBefore._prev._next = null), this._removalsHead = insertBefore;
                    for (let record = insertBefore; null !== record; record = record._nextRemoved) record === this._mapHead && (this._mapHead = null), 
                    this._records.delete(record.key), record._nextRemoved = record._next, record.previousValue = record.currentValue, 
                    record.currentValue = null, record._prev = null, record._next = null;
                }
                return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), 
                this.isDirty;
            }
            _insertBeforeOrAppend(before, record) {
                if (before) {
                    const prev = before._prev;
                    return record._next = before, record._prev = prev, before._prev = record, prev && (prev._next = record), 
                    before === this._mapHead && (this._mapHead = record), this._appendAfter = before, 
                    before;
                }
                return this._appendAfter ? (this._appendAfter._next = record, record._prev = this._appendAfter) : this._mapHead = record, 
                this._appendAfter = record, null;
            }
            _getOrCreateRecordForKey(key, value) {
                if (this._records.has(key)) {
                    const record = this._records.get(key);
                    this._maybeAddToChanges(record, value);
                    const prev = record._prev, next = record._next;
                    return prev && (prev._next = next), next && (next._prev = prev), record._next = null, 
                    record._prev = null, record;
                }
                const record = new KeyValueChangeRecord_(key);
                return this._records.set(key, record), record.currentValue = value, this._addToAdditions(record), 
                record;
            }
            _reset() {
                if (this.isDirty) {
                    let record;
                    for (this._previousMapHead = this._mapHead, record = this._previousMapHead; null !== record; record = record._next) record._nextPrevious = record._next;
                    for (record = this._changesHead; null !== record; record = record._nextChanged) record.previousValue = record.currentValue;
                    for (record = this._additionsHead; null != record; record = record._nextAdded) record.previousValue = record.currentValue;
                    this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, 
                    this._removalsHead = null;
                }
            }
            _maybeAddToChanges(record, newValue) {
                looseIdentical(newValue, record.currentValue) || (record.previousValue = record.currentValue, 
                record.currentValue = newValue, this._addToChanges(record));
            }
            _addToAdditions(record) {
                null === this._additionsHead ? this._additionsHead = this._additionsTail = record : (this._additionsTail._nextAdded = record, 
                this._additionsTail = record);
            }
            _addToChanges(record) {
                null === this._changesHead ? this._changesHead = this._changesTail = record : (this._changesTail._nextChanged = record, 
                this._changesTail = record);
            }
            _forEach(obj, fn) {
                obj instanceof Map ? obj.forEach(fn) : Object.keys(obj).forEach(k => fn(obj[k], k));
            }
        }
        class KeyValueChangeRecord_ {
            constructor(key) {
                this.key = key, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, 
                this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, 
                this._nextChanged = null;
            }
        }
        let IterableDiffers = (() => {
            class IterableDiffers {
                constructor(factories) {
                    this.factories = factories;
                }
                static create(factories, parent) {
                    if (null != parent) {
                        const copied = parent.factories.slice();
                        factories = factories.concat(copied);
                    }
                    return new IterableDiffers(factories);
                }
                static extend(factories) {
                    return {
                        provide: IterableDiffers,
                        useFactory: parent => {
                            if (!parent) throw new Error("Cannot extend IterableDiffers without a parent injector");
                            return IterableDiffers.create(factories, parent);
                        },
                        deps: [ [ IterableDiffers, new SkipSelf, new Optional ] ]
                    };
                }
                find(iterable) {
                    const factory = this.factories.find(f => f.supports(iterable));
                    if (null != factory) return factory;
                    throw new Error(`Cannot find a differ supporting object '${iterable}' of type '${type = iterable, 
                    type.name || typeof type}'`);
                    var type;
                }
            }
            return IterableDiffers.ɵprov = ɵɵdefineInjectable({
                token: IterableDiffers,
                providedIn: "root",
                factory: () => new IterableDiffers([ new DefaultIterableDifferFactory ])
            }), IterableDiffers;
        })(), KeyValueDiffers = (() => {
            class KeyValueDiffers {
                constructor(factories) {
                    this.factories = factories;
                }
                static create(factories, parent) {
                    if (parent) {
                        const copied = parent.factories.slice();
                        factories = factories.concat(copied);
                    }
                    return new KeyValueDiffers(factories);
                }
                static extend(factories) {
                    return {
                        provide: KeyValueDiffers,
                        useFactory: parent => {
                            if (!parent) throw new Error("Cannot extend KeyValueDiffers without a parent injector");
                            return KeyValueDiffers.create(factories, parent);
                        },
                        deps: [ [ KeyValueDiffers, new SkipSelf, new Optional ] ]
                    };
                }
                find(kv) {
                    const factory = this.factories.find(f => f.supports(kv));
                    if (factory) return factory;
                    throw new Error(`Cannot find a differ supporting object '${kv}'`);
                }
            }
            return KeyValueDiffers.ɵprov = ɵɵdefineInjectable({
                token: KeyValueDiffers,
                providedIn: "root",
                factory: () => new KeyValueDiffers([ new DefaultKeyValueDifferFactory ])
            }), KeyValueDiffers;
        })();
        const keyValDiff = [ new DefaultKeyValueDifferFactory ], defaultIterableDiffers = new IterableDiffers([ new DefaultIterableDifferFactory ]), defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
        let TemplateRef = (() => {
            class TemplateRef {}
            return TemplateRef.__NG_ELEMENT_ID__ = () => SWITCH_TEMPLATE_REF_FACTORY(TemplateRef, ElementRef), 
            TemplateRef;
        })();
        const SWITCH_TEMPLATE_REF_FACTORY = noop;
        let ViewContainerRef = (() => {
            class ViewContainerRef {}
            return ViewContainerRef.__NG_ELEMENT_ID__ = () => SWITCH_VIEW_CONTAINER_REF_FACTORY(ViewContainerRef, ElementRef), 
            ViewContainerRef;
        })();
        const SWITCH_VIEW_CONTAINER_REF_FACTORY = noop;
        function expressionChangedAfterItHasBeenCheckedError(context, oldValue, currValue, isFirstCheck) {
            let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: '${oldValue}'. Current value: '${currValue}'.`;
            return isFirstCheck && (msg += " It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook ?"), 
            function(msg, context) {
                const err = new Error(msg);
                return _addDebugContext(err, context), err;
            }(msg, context);
        }
        function _addDebugContext(err, context) {
            err[ERROR_DEBUG_CONTEXT] = context, err[ERROR_LOGGER] = context.logError.bind(context);
        }
        function viewDestroyedError(action) {
            return new Error(`ViewDestroyedError: Attempt to use a destroyed view: ${action}`);
        }
        function shiftInitState(view, priorInitState, newInitState) {
            const state = view.state, initState = 1792 & state;
            return initState === priorInitState ? (view.state = -1793 & state | newInitState, 
            view.initIndex = -1, !0) : initState === newInitState;
        }
        function shouldCallLifecycleInitHook(view, initState, index) {
            return (1792 & view.state) === initState && view.initIndex <= index && (view.initIndex = index + 1, 
            !0);
        }
        function asTextData(view, index) {
            return view.nodes[index];
        }
        function asElementData(view, index) {
            return view.nodes[index];
        }
        function asProviderData(view, index) {
            return view.nodes[index];
        }
        function asPureExpressionData(view, index) {
            return view.nodes[index];
        }
        function asQueryList(view, index) {
            return view.nodes[index];
        }
        const Services = {
            setCurrentNode: void 0,
            createRootView: void 0,
            createEmbeddedView: void 0,
            createComponentView: void 0,
            createNgModuleRef: void 0,
            overrideProvider: void 0,
            overrideComponentView: void 0,
            clearOverrides: void 0,
            checkAndUpdateView: void 0,
            checkNoChangesView: void 0,
            destroyView: void 0,
            resolveDep: void 0,
            createDebugContext: void 0,
            handleEvent: void 0,
            updateDirectives: void 0,
            updateRenderer: void 0,
            dirtyParentQueries: void 0
        }, NOOP = () => {}, _tokenKeyCache = new Map;
        function tokenKey(token) {
            let key = _tokenKeyCache.get(token);
            return key || (key = stringify(token) + "_" + _tokenKeyCache.size, _tokenKeyCache.set(token, key)), 
            key;
        }
        function unwrapValue(view, nodeIdx, bindingIdx, value) {
            if (WrappedValue.isWrapped(value)) {
                value = WrappedValue.unwrap(value);
                const globalBindingIdx = view.def.nodes[nodeIdx].bindingIndex + bindingIdx, oldValue = WrappedValue.unwrap(view.oldValues[globalBindingIdx]);
                view.oldValues[globalBindingIdx] = new WrappedValue(oldValue);
            }
            return value;
        }
        const UNDEFINED_RENDERER_TYPE_ID = "$$undefined", EMPTY_RENDERER_TYPE_ID = "$$empty";
        function createRendererType2(values) {
            return {
                id: UNDEFINED_RENDERER_TYPE_ID,
                styles: values.styles,
                encapsulation: values.encapsulation,
                data: values.data
            };
        }
        let _renderCompCount$1 = 0;
        function checkBinding(view, def, bindingIdx, value) {
            return !(!(2 & view.state) && looseIdentical(view.oldValues[def.bindingIndex + bindingIdx], value));
        }
        function checkAndUpdateBinding(view, def, bindingIdx, value) {
            return !!checkBinding(view, def, bindingIdx, value) && (view.oldValues[def.bindingIndex + bindingIdx] = value, 
            !0);
        }
        function checkBindingNoChanges(view, def, bindingIdx, value) {
            const oldValue = view.oldValues[def.bindingIndex + bindingIdx];
            if (1 & view.state || !devModeEqual$1(oldValue, value)) {
                const bindingName = def.bindings[bindingIdx].name;
                throw expressionChangedAfterItHasBeenCheckedError(Services.createDebugContext(view, def.nodeIndex), `${bindingName}: ${oldValue}`, `${bindingName}: ${value}`, 0 != (1 & view.state));
            }
        }
        function markParentViewsForCheck(view) {
            let currView = view;
            for (;currView; ) 2 & currView.def.flags && (currView.state |= 8), currView = currView.viewContainerParent || currView.parent;
        }
        function markParentViewsForCheckProjectedViews(view, endView) {
            let currView = view;
            for (;currView && currView !== endView; ) currView.state |= 64, currView = currView.viewContainerParent || currView.parent;
        }
        function dispatchEvent(view, nodeIndex, eventName, event) {
            try {
                return markParentViewsForCheck(33554432 & view.def.nodes[nodeIndex].flags ? asElementData(view, nodeIndex).componentView : view), 
                Services.handleEvent(view, nodeIndex, eventName, event);
            } catch (e) {
                view.root.errorHandler.handleError(e);
            }
        }
        function declaredViewContainer(view) {
            return view.parent ? asElementData(view.parent, view.parentNodeDef.nodeIndex) : null;
        }
        function viewParentEl(view) {
            return view.parent ? view.parentNodeDef.parent : null;
        }
        function renderNode(view, def) {
            switch (201347067 & def.flags) {
              case 1:
                return asElementData(view, def.nodeIndex).renderElement;

              case 2:
                return asTextData(view, def.nodeIndex).renderText;
            }
        }
        function isComponentView(view) {
            return !!view.parent && !!(32768 & view.parentNodeDef.flags);
        }
        function isEmbeddedView(view) {
            return !(!view.parent || 32768 & view.parentNodeDef.flags);
        }
        function filterQueryId(queryId) {
            return 1 << queryId % 32;
        }
        function splitMatchedQueriesDsl(matchedQueriesDsl) {
            const matchedQueries = {};
            let matchedQueryIds = 0;
            const references = {};
            return matchedQueriesDsl && matchedQueriesDsl.forEach(([queryId, valueType]) => {
                "number" == typeof queryId ? (matchedQueries[queryId] = valueType, matchedQueryIds |= filterQueryId(queryId)) : references[queryId] = valueType;
            }), {
                matchedQueries: matchedQueries,
                references: references,
                matchedQueryIds: matchedQueryIds
            };
        }
        function splitDepsDsl(deps, sourceName) {
            return deps.map(value => {
                let token, flags;
                return Array.isArray(value) ? [flags, token] = value : (flags = 0, token = value), 
                token && ("function" == typeof token || "object" == typeof token) && sourceName && Object.defineProperty(token, SOURCE, {
                    value: sourceName,
                    configurable: !0
                }), {
                    flags: flags,
                    token: token,
                    tokenKey: tokenKey(token)
                };
            });
        }
        function getParentRenderElement(view, renderHost, def) {
            let renderParent = def.renderParent;
            return renderParent ? 0 == (1 & renderParent.flags) || 0 == (33554432 & renderParent.flags) || renderParent.element.componentRendererType && renderParent.element.componentRendererType.encapsulation === ViewEncapsulation$1.Native ? asElementData(view, def.renderParent.nodeIndex).renderElement : void 0 : renderHost;
        }
        const DEFINITION_CACHE = new WeakMap;
        function resolveDefinition(factory) {
            let value = DEFINITION_CACHE.get(factory);
            return value || ((value = factory(() => NOOP)).factory = factory, DEFINITION_CACHE.set(factory, value)), 
            value;
        }
        function visitRootRenderNodes(view, action, parentNode, nextSibling, target) {
            3 === action && (parentNode = view.renderer.parentNode(renderNode(view, view.def.lastRenderRootNode))), 
            visitSiblingRenderNodes(view, action, 0, view.def.nodes.length - 1, parentNode, nextSibling, target);
        }
        function visitSiblingRenderNodes(view, action, startIndex, endIndex, parentNode, nextSibling, target) {
            for (let i = startIndex; i <= endIndex; i++) {
                const nodeDef = view.def.nodes[i];
                11 & nodeDef.flags && visitRenderNode(view, nodeDef, action, parentNode, nextSibling, target), 
                i += nodeDef.childCount;
            }
        }
        function visitProjectedRenderNodes(view, ngContentIndex, action, parentNode, nextSibling, target) {
            let compView = view;
            for (;compView && !isComponentView(compView); ) compView = compView.parent;
            const hostView = compView.parent, hostElDef = viewParentEl(compView), endIndex = hostElDef.nodeIndex + hostElDef.childCount;
            for (let i = hostElDef.nodeIndex + 1; i <= endIndex; i++) {
                const nodeDef = hostView.def.nodes[i];
                nodeDef.ngContentIndex === ngContentIndex && visitRenderNode(hostView, nodeDef, action, parentNode, nextSibling, target), 
                i += nodeDef.childCount;
            }
            if (!hostView.parent) {
                const projectedNodes = view.root.projectableNodes[ngContentIndex];
                if (projectedNodes) for (let i = 0; i < projectedNodes.length; i++) execRenderNodeAction(view, projectedNodes[i], action, parentNode, nextSibling, target);
            }
        }
        function visitRenderNode(view, nodeDef, action, parentNode, nextSibling, target) {
            if (8 & nodeDef.flags) visitProjectedRenderNodes(view, nodeDef.ngContent.index, action, parentNode, nextSibling, target); else {
                const rn = renderNode(view, nodeDef);
                if (3 === action && 33554432 & nodeDef.flags && 48 & nodeDef.bindingFlags ? (16 & nodeDef.bindingFlags && execRenderNodeAction(view, rn, action, parentNode, nextSibling, target), 
                32 & nodeDef.bindingFlags && execRenderNodeAction(asElementData(view, nodeDef.nodeIndex).componentView, rn, action, parentNode, nextSibling, target)) : execRenderNodeAction(view, rn, action, parentNode, nextSibling, target), 
                16777216 & nodeDef.flags) {
                    const embeddedViews = asElementData(view, nodeDef.nodeIndex).viewContainer._embeddedViews;
                    for (let k = 0; k < embeddedViews.length; k++) visitRootRenderNodes(embeddedViews[k], action, parentNode, nextSibling, target);
                }
                1 & nodeDef.flags && !nodeDef.element.name && visitSiblingRenderNodes(view, action, nodeDef.nodeIndex + 1, nodeDef.nodeIndex + nodeDef.childCount, parentNode, nextSibling, target);
            }
        }
        function execRenderNodeAction(view, renderNode, action, parentNode, nextSibling, target) {
            const renderer = view.renderer;
            switch (action) {
              case 1:
                renderer.appendChild(parentNode, renderNode);
                break;

              case 2:
                renderer.insertBefore(parentNode, renderNode, nextSibling);
                break;

              case 3:
                renderer.removeChild(parentNode, renderNode);
                break;

              case 0:
                target.push(renderNode);
            }
        }
        const NS_PREFIX_RE = /^:([^:]+):(.+)$/;
        function splitNamespace(name) {
            if (":" === name[0]) {
                const match = name.match(NS_PREFIX_RE);
                return [ match[1], match[2] ];
            }
            return [ "", name ];
        }
        function calcBindingFlags(bindings) {
            let flags = 0;
            for (let i = 0; i < bindings.length; i++) flags |= bindings[i].flags;
            return flags;
        }
        function inlineInterpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {
            switch (valueCount) {
              case 1:
                return c0 + _toStringWithNull(a1) + c1;

              case 2:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;

              case 3:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3;

              case 4:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4;

              case 5:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;

              case 6:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;

              case 7:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6 + _toStringWithNull(a7) + c7;

              case 8:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;

              case 9:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;

              default:
                throw new Error("Does not support more than 9 expressions");
            }
        }
        function _toStringWithNull(v) {
            return null != v ? v.toString() : "";
        }
        const UNDEFINED_VALUE = new Object, InjectorRefTokenKey = tokenKey(Injector), INJECTORRefTokenKey = tokenKey(INJECTOR), NgModuleRefTokenKey = tokenKey(NgModuleRef);
        function moduleProvideDef(flags, token, value, deps) {
            return value = resolveForwardRef(value), {
                index: -1,
                deps: splitDepsDsl(deps, stringify(token)),
                flags: flags,
                token: token,
                value: value
            };
        }
        function moduleDef(providers) {
            const providersByKey = {}, modules = [];
            let scope = null;
            for (let i = 0; i < providers.length; i++) {
                const provider = providers[i];
                provider.token === INJECTOR_SCOPE && (scope = provider.value), 1073741824 & provider.flags && modules.push(provider.token), 
                provider.index = i, providersByKey[tokenKey(provider.token)] = provider;
            }
            return {
                factory: null,
                providersByKey: providersByKey,
                providers: providers,
                modules: modules,
                scope: scope
            };
        }
        function resolveNgModuleDep(data, depDef, notFoundValue = Injector.THROW_IF_NOT_FOUND) {
            const former = setCurrentInjector(data);
            try {
                if (8 & depDef.flags) return depDef.token;
                if (2 & depDef.flags && (notFoundValue = null), 1 & depDef.flags) return data._parent.get(depDef.token, notFoundValue);
                const tokenKey = depDef.tokenKey;
                switch (tokenKey) {
                  case InjectorRefTokenKey:
                  case INJECTORRefTokenKey:
                  case NgModuleRefTokenKey:
                    return data;
                }
                const providerDef = data._def.providersByKey[tokenKey];
                let injectableDef;
                if (providerDef) {
                    let providerInstance = data._providers[providerDef.index];
                    return void 0 === providerInstance && (providerInstance = data._providers[providerDef.index] = _createProviderInstance(data, providerDef)), 
                    providerInstance === UNDEFINED_VALUE ? void 0 : providerInstance;
                }
                if ((injectableDef = getInjectableDef(depDef.token)) && function(ngModule, def) {
                    const providedIn = def.providedIn;
                    return null != providedIn && ("any" === providedIn || providedIn === ngModule._def.scope || function(ngModule, scope) {
                        return ngModule._def.modules.indexOf(scope) > -1;
                    }(ngModule, providedIn));
                }(data, injectableDef)) {
                    const index = data._providers.length;
                    return data._def.providers[index] = data._def.providersByKey[depDef.tokenKey] = {
                        flags: 5120,
                        value: injectableDef.factory,
                        deps: [],
                        index: index,
                        token: depDef.token
                    }, data._providers[index] = UNDEFINED_VALUE, data._providers[index] = _createProviderInstance(data, data._def.providersByKey[depDef.tokenKey]);
                }
                return 4 & depDef.flags ? notFoundValue : data._parent.get(depDef.token, notFoundValue);
            } finally {
                setCurrentInjector(former);
            }
        }
        function _createProviderInstance(ngModule, providerDef) {
            let injectable;
            switch (201347067 & providerDef.flags) {
              case 512:
                injectable = function(ngModule, ctor, deps) {
                    const len = deps.length;
                    switch (len) {
                      case 0:
                        return new ctor;

                      case 1:
                        return new ctor(resolveNgModuleDep(ngModule, deps[0]));

                      case 2:
                        return new ctor(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]));

                      case 3:
                        return new ctor(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]), resolveNgModuleDep(ngModule, deps[2]));

                      default:
                        const depValues = [];
                        for (let i = 0; i < len; i++) depValues[i] = resolveNgModuleDep(ngModule, deps[i]);
                        return new ctor(...depValues);
                    }
                }(ngModule, providerDef.value, providerDef.deps);
                break;

              case 1024:
                injectable = function(ngModule, factory, deps) {
                    const len = deps.length;
                    switch (len) {
                      case 0:
                        return factory();

                      case 1:
                        return factory(resolveNgModuleDep(ngModule, deps[0]));

                      case 2:
                        return factory(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]));

                      case 3:
                        return factory(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]), resolveNgModuleDep(ngModule, deps[2]));

                      default:
                        const depValues = [];
                        for (let i = 0; i < len; i++) depValues[i] = resolveNgModuleDep(ngModule, deps[i]);
                        return factory(...depValues);
                    }
                }(ngModule, providerDef.value, providerDef.deps);
                break;

              case 2048:
                injectable = resolveNgModuleDep(ngModule, providerDef.deps[0]);
                break;

              case 256:
                injectable = providerDef.value;
            }
            return injectable === UNDEFINED_VALUE || null === injectable || "object" != typeof injectable || 131072 & providerDef.flags || "function" != typeof injectable.ngOnDestroy || (providerDef.flags |= 131072), 
            void 0 === injectable ? UNDEFINED_VALUE : injectable;
        }
        function detachEmbeddedView(elementData, viewIndex) {
            const embeddedViews = elementData.viewContainer._embeddedViews;
            if ((null == viewIndex || viewIndex >= embeddedViews.length) && (viewIndex = embeddedViews.length - 1), 
            viewIndex < 0) return null;
            const view = embeddedViews[viewIndex];
            return view.viewContainerParent = null, removeFromArray(embeddedViews, viewIndex), 
            Services.dirtyParentQueries(view), renderDetachView$1(view), view;
        }
        function renderAttachEmbeddedView(elementData, prevView, view) {
            const prevRenderNode = prevView ? renderNode(prevView, prevView.def.lastRenderRootNode) : elementData.renderElement, parentNode = view.renderer.parentNode(prevRenderNode), nextSibling = view.renderer.nextSibling(prevRenderNode);
            visitRootRenderNodes(view, 2, parentNode, nextSibling, void 0);
        }
        function renderDetachView$1(view) {
            visitRootRenderNodes(view, 3, null, null, void 0);
        }
        const EMPTY_CONTEXT = new Object;
        function createComponentFactory(selector, componentType, viewDefFactory, inputs, outputs, ngContentSelectors) {
            return new ComponentFactory_(selector, componentType, viewDefFactory, inputs, outputs, ngContentSelectors);
        }
        class ComponentFactory_ extends ComponentFactory {
            constructor(selector, componentType, viewDefFactory, _inputs, _outputs, ngContentSelectors) {
                super(), this.selector = selector, this.componentType = componentType, this._inputs = _inputs, 
                this._outputs = _outputs, this.ngContentSelectors = ngContentSelectors, this.viewDefFactory = viewDefFactory;
            }
            get inputs() {
                const inputsArr = [], inputs = this._inputs;
                for (let propName in inputs) inputsArr.push({
                    propName: propName,
                    templateName: inputs[propName]
                });
                return inputsArr;
            }
            get outputs() {
                const outputsArr = [];
                for (let propName in this._outputs) outputsArr.push({
                    propName: propName,
                    templateName: this._outputs[propName]
                });
                return outputsArr;
            }
            create(injector, projectableNodes, rootSelectorOrNode, ngModule) {
                if (!ngModule) throw new Error("ngModule should be provided");
                const viewDef = resolveDefinition(this.viewDefFactory), componentNodeIndex = viewDef.nodes[0].element.componentProvider.nodeIndex, view = Services.createRootView(injector, projectableNodes || [], rootSelectorOrNode, viewDef, ngModule, EMPTY_CONTEXT), component = asProviderData(view, componentNodeIndex).instance;
                return rootSelectorOrNode && view.renderer.setAttribute(asElementData(view, 0).renderElement, "ng-version", VERSION.full), 
                new ComponentRef_(view, new ViewRef_(view), component);
            }
        }
        class ComponentRef_ extends ComponentRef {
            constructor(_view, _viewRef, _component) {
                super(), this._view = _view, this._viewRef = _viewRef, this._component = _component, 
                this._elDef = this._view.def.nodes[0], this.hostView = _viewRef, this.changeDetectorRef = _viewRef, 
                this.instance = _component;
            }
            get location() {
                return new ElementRef(asElementData(this._view, this._elDef.nodeIndex).renderElement);
            }
            get injector() {
                return new Injector_(this._view, this._elDef);
            }
            get componentType() {
                return this._component.constructor;
            }
            destroy() {
                this._viewRef.destroy();
            }
            onDestroy(callback) {
                this._viewRef.onDestroy(callback);
            }
        }
        function createViewContainerData(view, elDef, elData) {
            return new ViewContainerRef_(view, elDef, elData);
        }
        class ViewContainerRef_ {
            constructor(_view, _elDef, _data) {
                this._view = _view, this._elDef = _elDef, this._data = _data, this._embeddedViews = [];
            }
            get element() {
                return new ElementRef(this._data.renderElement);
            }
            get injector() {
                return new Injector_(this._view, this._elDef);
            }
            get parentInjector() {
                let view = this._view, elDef = this._elDef.parent;
                for (;!elDef && view; ) elDef = viewParentEl(view), view = view.parent;
                return view ? new Injector_(view, elDef) : new Injector_(this._view, null);
            }
            clear() {
                for (let i = this._embeddedViews.length - 1; i >= 0; i--) {
                    const view = detachEmbeddedView(this._data, i);
                    Services.destroyView(view);
                }
            }
            get(index) {
                const view = this._embeddedViews[index];
                if (view) {
                    const ref = new ViewRef_(view);
                    return ref.attachToViewContainerRef(this), ref;
                }
                return null;
            }
            get length() {
                return this._embeddedViews.length;
            }
            createEmbeddedView(templateRef, context, index) {
                const viewRef = templateRef.createEmbeddedView(context || {});
                return this.insert(viewRef, index), viewRef;
            }
            createComponent(componentFactory, index, injector, projectableNodes, ngModuleRef) {
                const contextInjector = injector || this.parentInjector;
                ngModuleRef || componentFactory instanceof ComponentFactoryBoundToModule || (ngModuleRef = contextInjector.get(NgModuleRef));
                const componentRef = componentFactory.create(contextInjector, projectableNodes, void 0, ngModuleRef);
                return this.insert(componentRef.hostView, index), componentRef;
            }
            insert(viewRef, index) {
                if (viewRef.destroyed) throw new Error("Cannot insert a destroyed View in a ViewContainer!");
                const viewRef_ = viewRef;
                return function(parentView, elementData, viewIndex, view) {
                    let embeddedViews = elementData.viewContainer._embeddedViews;
                    null == viewIndex && (viewIndex = embeddedViews.length), view.viewContainerParent = parentView, 
                    addToArray(embeddedViews, viewIndex, view), function(vcElementData, view) {
                        const dvcElementData = declaredViewContainer(view);
                        if (!dvcElementData || dvcElementData === vcElementData || 16 & view.state) return;
                        view.state |= 16;
                        let projectedViews = dvcElementData.template._projectedViews;
                        projectedViews || (projectedViews = dvcElementData.template._projectedViews = []), 
                        projectedViews.push(view), function(viewDef, nodeDef) {
                            if (4 & nodeDef.flags) return;
                            viewDef.nodeFlags |= 4, nodeDef.flags |= 4;
                            let parentNodeDef = nodeDef.parent;
                            for (;parentNodeDef; ) parentNodeDef.childFlags |= 4, parentNodeDef = parentNodeDef.parent;
                        }(view.parent.def, view.parentNodeDef);
                    }(elementData, view), Services.dirtyParentQueries(view), renderAttachEmbeddedView(elementData, viewIndex > 0 ? embeddedViews[viewIndex - 1] : null, view);
                }(this._view, this._data, index, viewRef_._view), viewRef_.attachToViewContainerRef(this), 
                viewRef;
            }
            move(viewRef, currentIndex) {
                if (viewRef.destroyed) throw new Error("Cannot move a destroyed View in a ViewContainer!");
                const previousIndex = this._embeddedViews.indexOf(viewRef._view);
                return function(elementData, oldViewIndex, newViewIndex) {
                    const embeddedViews = elementData.viewContainer._embeddedViews, view = embeddedViews[oldViewIndex];
                    removeFromArray(embeddedViews, oldViewIndex), null == newViewIndex && (newViewIndex = embeddedViews.length), 
                    addToArray(embeddedViews, newViewIndex, view), Services.dirtyParentQueries(view), 
                    renderDetachView$1(view), renderAttachEmbeddedView(elementData, newViewIndex > 0 ? embeddedViews[newViewIndex - 1] : null, view);
                }(this._data, previousIndex, currentIndex), viewRef;
            }
            indexOf(viewRef) {
                return this._embeddedViews.indexOf(viewRef._view);
            }
            remove(index) {
                const viewData = detachEmbeddedView(this._data, index);
                viewData && Services.destroyView(viewData);
            }
            detach(index) {
                const view = detachEmbeddedView(this._data, index);
                return view ? new ViewRef_(view) : null;
            }
        }
        function createChangeDetectorRef(view) {
            return new ViewRef_(view);
        }
        class ViewRef_ {
            constructor(_view) {
                this._view = _view, this._viewContainerRef = null, this._appRef = null;
            }
            get rootNodes() {
                return function(view) {
                    const renderNodes = [];
                    return visitRootRenderNodes(view, 0, void 0, void 0, renderNodes), renderNodes;
                }(this._view);
            }
            get context() {
                return this._view.context;
            }
            get destroyed() {
                return 0 != (128 & this._view.state);
            }
            markForCheck() {
                markParentViewsForCheck(this._view);
            }
            detach() {
                this._view.state &= -5;
            }
            detectChanges() {
                const fs = this._view.root.rendererFactory;
                fs.begin && fs.begin();
                try {
                    Services.checkAndUpdateView(this._view);
                } finally {
                    fs.end && fs.end();
                }
            }
            checkNoChanges() {
                Services.checkNoChangesView(this._view);
            }
            reattach() {
                this._view.state |= 4;
            }
            onDestroy(callback) {
                this._view.disposables || (this._view.disposables = []), this._view.disposables.push(callback);
            }
            destroy() {
                this._appRef ? this._appRef.detachView(this) : this._viewContainerRef && this._viewContainerRef.detach(this._viewContainerRef.indexOf(this)), 
                Services.destroyView(this._view);
            }
            detachFromAppRef() {
                this._appRef = null, renderDetachView$1(this._view), Services.dirtyParentQueries(this._view);
            }
            attachToAppRef(appRef) {
                if (this._viewContainerRef) throw new Error("This view is already attached to a ViewContainer!");
                this._appRef = appRef;
            }
            attachToViewContainerRef(vcRef) {
                if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!");
                this._viewContainerRef = vcRef;
            }
        }
        function createTemplateData(view, def) {
            return new TemplateRef_(view, def);
        }
        class TemplateRef_ extends TemplateRef {
            constructor(_parentView, _def) {
                super(), this._parentView = _parentView, this._def = _def;
            }
            createEmbeddedView(context) {
                return new ViewRef_(Services.createEmbeddedView(this._parentView, this._def, this._def.element.template, context));
            }
            get elementRef() {
                return new ElementRef(asElementData(this._parentView, this._def.nodeIndex).renderElement);
            }
        }
        function createInjector$1(view, elDef) {
            return new Injector_(view, elDef);
        }
        class Injector_ {
            constructor(view, elDef) {
                this.view = view, this.elDef = elDef;
            }
            get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND) {
                return Services.resolveDep(this.view, this.elDef, !!this.elDef && 0 != (33554432 & this.elDef.flags), {
                    flags: 0,
                    token: token,
                    tokenKey: tokenKey(token)
                }, notFoundValue);
            }
        }
        function nodeValue(view, index) {
            const def = view.def.nodes[index];
            if (1 & def.flags) {
                const elData = asElementData(view, def.nodeIndex);
                return (def.element.template ? elData.template : elData.renderElement);
            }
            if (2 & def.flags) return asTextData(view, def.nodeIndex).renderText;
            if (20240 & def.flags) return asProviderData(view, def.nodeIndex).instance;
            throw new Error(`Illegal state: read nodeValue for node index ${index}`);
        }
        function createNgModuleRef(moduleType, parent, bootstrapComponents, def) {
            return new NgModuleRef_(moduleType, parent, bootstrapComponents, def);
        }
        class NgModuleRef_ {
            constructor(_moduleType, _parent, _bootstrapComponents, _def) {
                this._moduleType = _moduleType, this._parent = _parent, this._bootstrapComponents = _bootstrapComponents, 
                this._def = _def, this._destroyListeners = [], this._destroyed = !1, this.injector = this, 
                function(data) {
                    const def = data._def, providers = data._providers = function(size, value) {
                        const list = [];
                        for (let i = 0; i < size; i++) list.push(void 0);
                        return list;
                    }(def.providers.length);
                    for (let i = 0; i < def.providers.length; i++) {
                        const provDef = def.providers[i];
                        4096 & provDef.flags || void 0 === providers[i] && (providers[i] = _createProviderInstance(data, provDef));
                    }
                }(this);
            }
            get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, injectFlags = InjectFlags.Default) {
                let flags = 0;
                return injectFlags & InjectFlags.SkipSelf ? flags |= 1 : injectFlags & InjectFlags.Self && (flags |= 4), 
                resolveNgModuleDep(this, {
                    token: token,
                    tokenKey: tokenKey(token),
                    flags: flags
                }, notFoundValue);
            }
            get instance() {
                return this.get(this._moduleType);
            }
            get componentFactoryResolver() {
                return this.get(ComponentFactoryResolver);
            }
            destroy() {
                if (this._destroyed) throw new Error(`The ng module ${stringify(this.instance.constructor)} has already been destroyed.`);
                this._destroyed = !0, function(ngModule, lifecycles) {
                    const def = ngModule._def, destroyed = new Set;
                    for (let i = 0; i < def.providers.length; i++) if (131072 & def.providers[i].flags) {
                        const instance = ngModule._providers[i];
                        if (instance && instance !== UNDEFINED_VALUE) {
                            const onDestroy = instance.ngOnDestroy;
                            "function" != typeof onDestroy || destroyed.has(instance) || (onDestroy.apply(instance), 
                            destroyed.add(instance));
                        }
                    }
                }(this), this._destroyListeners.forEach(listener => listener());
            }
            onDestroy(callback) {
                this._destroyListeners.push(callback);
            }
        }
        const Renderer2TokenKey = tokenKey(Renderer2), ElementRefTokenKey = tokenKey(ElementRef), ViewContainerRefTokenKey = tokenKey(ViewContainerRef), TemplateRefTokenKey = tokenKey(TemplateRef), ChangeDetectorRefTokenKey = tokenKey(ChangeDetectorRef), InjectorRefTokenKey$1 = tokenKey(Injector), INJECTORRefTokenKey$1 = tokenKey(INJECTOR);
        function directiveDef(checkIndex, flags, matchedQueries, childCount, ctor, deps, props, outputs) {
            const bindings = [];
            if (props) for (let prop in props) {
                const [bindingIndex, nonMinifiedName] = props[prop];
                bindings[bindingIndex] = {
                    flags: 8,
                    name: prop,
                    nonMinifiedName: nonMinifiedName,
                    ns: null,
                    securityContext: null,
                    suffix: null
                };
            }
            const outputDefs = [];
            if (outputs) for (let propName in outputs) outputDefs.push({
                type: 1,
                propName: propName,
                target: null,
                eventName: outputs[propName]
            });
            return _def(checkIndex, flags |= 16384, matchedQueries, childCount, ctor, ctor, deps, bindings, outputDefs);
        }
        function pipeDef(flags, ctor, deps) {
            return _def(-1, flags |= 16, null, 0, ctor, ctor, deps);
        }
        function providerDef(flags, matchedQueries, token, value, deps) {
            return _def(-1, flags, matchedQueries, 0, token, value, deps);
        }
        function _def(checkIndex, flags, matchedQueriesDsl, childCount, token, value, deps, bindings, outputs) {
            const {matchedQueries: matchedQueries, references: references, matchedQueryIds: matchedQueryIds} = splitMatchedQueriesDsl(matchedQueriesDsl);
            outputs || (outputs = []), bindings || (bindings = []), value = resolveForwardRef(value);
            const depDefs = splitDepsDsl(deps, stringify(token));
            return {
                nodeIndex: -1,
                parent: null,
                renderParent: null,
                bindingIndex: -1,
                outputIndex: -1,
                checkIndex: checkIndex,
                flags: flags,
                childFlags: 0,
                directChildFlags: 0,
                childMatchedQueries: 0,
                matchedQueries: matchedQueries,
                matchedQueryIds: matchedQueryIds,
                references: references,
                ngContentIndex: -1,
                childCount: childCount,
                bindings: bindings,
                bindingFlags: calcBindingFlags(bindings),
                outputs: outputs,
                element: null,
                provider: {
                    token: token,
                    value: value,
                    deps: depDefs
                },
                text: null,
                query: null,
                ngContent: null
            };
        }
        function createProviderInstance(view, def) {
            return _createProviderInstance$1(view, def);
        }
        function createPipeInstance(view, def) {
            let compView = view;
            for (;compView.parent && !isComponentView(compView); ) compView = compView.parent;
            return createClass(compView.parent, viewParentEl(compView), !0, def.provider.value, def.provider.deps);
        }
        function createDirectiveInstance(view, def) {
            const instance = createClass(view, def.parent, (32768 & def.flags) > 0, def.provider.value, def.provider.deps);
            if (def.outputs.length) for (let i = 0; i < def.outputs.length; i++) {
                const output = def.outputs[i], outputObservable = instance[output.propName];
                if (!isObservable(outputObservable)) throw new Error(`@Output ${output.propName} not initialized in '${instance.constructor.name}'.`);
                {
                    const subscription = outputObservable.subscribe(eventHandlerClosure(view, def.parent.nodeIndex, output.eventName));
                    view.disposables[def.outputIndex + i] = subscription.unsubscribe.bind(subscription);
                }
            }
            return instance;
        }
        function eventHandlerClosure(view, index, eventName) {
            return event => dispatchEvent(view, index, eventName, event);
        }
        function _createProviderInstance$1(view, def) {
            const allowPrivateServices = (8192 & def.flags) > 0, providerDef = def.provider;
            switch (201347067 & def.flags) {
              case 512:
                return createClass(view, def.parent, allowPrivateServices, providerDef.value, providerDef.deps);

              case 1024:
                return function(view, elDef, allowPrivateServices, factory, deps) {
                    const len = deps.length;
                    switch (len) {
                      case 0:
                        return factory();

                      case 1:
                        return factory(resolveDep(view, elDef, allowPrivateServices, deps[0]));

                      case 2:
                        return factory(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]));

                      case 3:
                        return factory(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]), resolveDep(view, elDef, allowPrivateServices, deps[2]));

                      default:
                        const depValues = [];
                        for (let i = 0; i < len; i++) depValues.push(resolveDep(view, elDef, allowPrivateServices, deps[i]));
                        return factory(...depValues);
                    }
                }(view, def.parent, allowPrivateServices, providerDef.value, providerDef.deps);

              case 2048:
                return resolveDep(view, def.parent, allowPrivateServices, providerDef.deps[0]);

              case 256:
                return providerDef.value;
            }
        }
        function createClass(view, elDef, allowPrivateServices, ctor, deps) {
            const len = deps.length;
            switch (len) {
              case 0:
                return new ctor;

              case 1:
                return new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]));

              case 2:
                return new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]));

              case 3:
                return new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]), resolveDep(view, elDef, allowPrivateServices, deps[2]));

              default:
                const depValues = [];
                for (let i = 0; i < len; i++) depValues.push(resolveDep(view, elDef, allowPrivateServices, deps[i]));
                return new ctor(...depValues);
            }
        }
        const NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
        function resolveDep(view, elDef, allowPrivateServices, depDef, notFoundValue = Injector.THROW_IF_NOT_FOUND) {
            if (8 & depDef.flags) return depDef.token;
            const startView = view;
            2 & depDef.flags && (notFoundValue = null);
            const tokenKey = depDef.tokenKey;
            tokenKey === ChangeDetectorRefTokenKey && (allowPrivateServices = !(!elDef || !elDef.element.componentView)), 
            elDef && 1 & depDef.flags && (allowPrivateServices = !1, elDef = elDef.parent);
            let searchView = view;
            for (;searchView; ) {
                if (elDef) switch (tokenKey) {
                  case Renderer2TokenKey:
                    return findCompView(searchView, elDef, allowPrivateServices).renderer;

                  case ElementRefTokenKey:
                    return new ElementRef(asElementData(searchView, elDef.nodeIndex).renderElement);

                  case ViewContainerRefTokenKey:
                    return asElementData(searchView, elDef.nodeIndex).viewContainer;

                  case TemplateRefTokenKey:
                    if (elDef.element.template) return asElementData(searchView, elDef.nodeIndex).template;
                    break;

                  case ChangeDetectorRefTokenKey:
                    return createChangeDetectorRef(findCompView(searchView, elDef, allowPrivateServices));

                  case InjectorRefTokenKey$1:
                  case INJECTORRefTokenKey$1:
                    return createInjector$1(searchView, elDef);

                  default:
                    const providerDef = (allowPrivateServices ? elDef.element.allProviders : elDef.element.publicProviders)[tokenKey];
                    if (providerDef) {
                        let providerData = asProviderData(searchView, providerDef.nodeIndex);
                        return providerData || (providerData = {
                            instance: _createProviderInstance$1(searchView, providerDef)
                        }, searchView.nodes[providerDef.nodeIndex] = providerData), providerData.instance;
                    }
                }
                allowPrivateServices = isComponentView(searchView), elDef = viewParentEl(searchView), 
                searchView = searchView.parent, 4 & depDef.flags && (searchView = null);
            }
            const value = startView.root.injector.get(depDef.token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR);
            return value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ? value : startView.root.ngModule.injector.get(depDef.token, notFoundValue);
        }
        function findCompView(view, elDef, allowPrivateServices) {
            let compView;
            if (allowPrivateServices) compView = asElementData(view, elDef.nodeIndex).componentView; else for (compView = view; compView.parent && !isComponentView(compView); ) compView = compView.parent;
            return compView;
        }
        function updateProp(view, providerData, def, bindingIdx, value, changes) {
            if (32768 & def.flags) {
                const compView = asElementData(view, def.parent.nodeIndex).componentView;
                2 & compView.def.flags && (compView.state |= 8);
            }
            if (providerData.instance[def.bindings[bindingIdx].name] = value, 524288 & def.flags) {
                changes = changes || {};
                const oldValue = WrappedValue.unwrap(view.oldValues[def.bindingIndex + bindingIdx]);
                changes[def.bindings[bindingIdx].nonMinifiedName] = new SimpleChange(oldValue, value, 0 != (2 & view.state));
            }
            return view.oldValues[def.bindingIndex + bindingIdx] = value, changes;
        }
        function callLifecycleHooksChildrenFirst(view, lifecycles) {
            if (!(view.def.nodeFlags & lifecycles)) return;
            const nodes = view.def.nodes;
            let initIndex = 0;
            for (let i = 0; i < nodes.length; i++) {
                const nodeDef = nodes[i];
                let parent = nodeDef.parent;
                for (!parent && nodeDef.flags & lifecycles && callProviderLifecycles(view, i, nodeDef.flags & lifecycles, initIndex++), 
                0 == (nodeDef.childFlags & lifecycles) && (i += nodeDef.childCount); parent && 1 & parent.flags && i === parent.nodeIndex + parent.childCount; ) parent.directChildFlags & lifecycles && (initIndex = callElementProvidersLifecycles(view, parent, lifecycles, initIndex)), 
                parent = parent.parent;
            }
        }
        function callElementProvidersLifecycles(view, elDef, lifecycles, initIndex) {
            for (let i = elDef.nodeIndex + 1; i <= elDef.nodeIndex + elDef.childCount; i++) {
                const nodeDef = view.def.nodes[i];
                nodeDef.flags & lifecycles && callProviderLifecycles(view, i, nodeDef.flags & lifecycles, initIndex++), 
                i += nodeDef.childCount;
            }
            return initIndex;
        }
        function callProviderLifecycles(view, index, lifecycles, initIndex) {
            const providerData = asProviderData(view, index);
            if (!providerData) return;
            const provider = providerData.instance;
            provider && (Services.setCurrentNode(view, index), 1048576 & lifecycles && shouldCallLifecycleInitHook(view, 512, initIndex) && provider.ngAfterContentInit(), 
            2097152 & lifecycles && provider.ngAfterContentChecked(), 4194304 & lifecycles && shouldCallLifecycleInitHook(view, 768, initIndex) && provider.ngAfterViewInit(), 
            8388608 & lifecycles && provider.ngAfterViewChecked(), 131072 & lifecycles && provider.ngOnDestroy());
        }
        const SCHEDULER = new InjectionToken("SCHEDULER_TOKEN", {
            providedIn: "root",
            factory: () => defaultScheduler
        }), u = void 0;
        var localeEn = [ "en", [ [ "a", "p" ], [ "AM", "PM" ], u ], [ [ "AM", "PM" ], u, u ], [ [ "S", "M", "T", "W", "T", "F", "S" ], [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ] ], u, [ [ "J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D" ], [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ] ], u, [ [ "B", "A" ], [ "BC", "AD" ], [ "Before Christ", "Anno Domini" ] ], 0, [ 6, 0 ], [ "M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y" ], [ "h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz" ], [ "{1}, {0}", u, "{1} 'at' {0}", u ], [ ".", ",", ";", "%", "+", "-", "E", "×", "‰", "∞", "NaN", ":" ], [ "#,##0.###", "#,##0%", "¤#,##0.00", "#E0" ], "$", "US Dollar", {}, function(n) {
            let i = Math.floor(Math.abs(n)), v = n.toString().replace(/^[^.]*\.?/, "").length;
            return 1 === i && 0 === v ? 1 : 5;
        } ];
        let LOCALE_DATA = {};
        function registerLocaleData(data, localeId, extraData) {
            "string" != typeof localeId && (extraData = localeId, localeId = data[LocaleDataIndex.LocaleId]), 
            localeId = localeId.toLowerCase().replace(/_/g, "-"), LOCALE_DATA[localeId] = data, 
            extraData && (LOCALE_DATA[localeId][LocaleDataIndex.ExtraData] = extraData);
        }
        function findLocaleData(locale) {
            const normalizedLocale = function(locale) {
                return locale.toLowerCase().replace(/_/g, "-");
            }(locale);
            let match = getLocaleData(normalizedLocale);
            if (match) return match;
            const parentLocale = normalizedLocale.split("-")[0];
            if (match = getLocaleData(parentLocale)) return match;
            if ("en" === parentLocale) return localeEn;
            throw new Error(`Missing locale data for the locale "${locale}".`);
        }
        function getLocalePluralCase(locale) {
            return findLocaleData(locale)[LocaleDataIndex.PluralCase];
        }
        function getLocaleData(normalizedLocale) {
            return normalizedLocale in LOCALE_DATA || (LOCALE_DATA[normalizedLocale] = _global.ng && _global.ng.common && _global.ng.common.locales && _global.ng.common.locales[normalizedLocale]), 
            LOCALE_DATA[normalizedLocale];
        }
        const LocaleDataIndex = function() {
            var LocaleDataIndex = {
                LocaleId: 0,
                DayPeriodsFormat: 1,
                DayPeriodsStandalone: 2,
                DaysFormat: 3,
                DaysStandalone: 4,
                MonthsFormat: 5,
                MonthsStandalone: 6,
                Eras: 7,
                FirstDayOfWeek: 8,
                WeekendRange: 9,
                DateFormat: 10,
                TimeFormat: 11,
                DateTimeFormat: 12,
                NumberSymbols: 13,
                NumberFormats: 14,
                CurrencySymbol: 15,
                CurrencyName: 16,
                Currencies: 17,
                PluralCase: 18,
                ExtraData: 19
            };
            return LocaleDataIndex[LocaleDataIndex.LocaleId] = "LocaleId", LocaleDataIndex[LocaleDataIndex.DayPeriodsFormat] = "DayPeriodsFormat", 
            LocaleDataIndex[LocaleDataIndex.DayPeriodsStandalone] = "DayPeriodsStandalone", 
            LocaleDataIndex[LocaleDataIndex.DaysFormat] = "DaysFormat", LocaleDataIndex[LocaleDataIndex.DaysStandalone] = "DaysStandalone", 
            LocaleDataIndex[LocaleDataIndex.MonthsFormat] = "MonthsFormat", LocaleDataIndex[LocaleDataIndex.MonthsStandalone] = "MonthsStandalone", 
            LocaleDataIndex[LocaleDataIndex.Eras] = "Eras", LocaleDataIndex[LocaleDataIndex.FirstDayOfWeek] = "FirstDayOfWeek", 
            LocaleDataIndex[LocaleDataIndex.WeekendRange] = "WeekendRange", LocaleDataIndex[LocaleDataIndex.DateFormat] = "DateFormat", 
            LocaleDataIndex[LocaleDataIndex.TimeFormat] = "TimeFormat", LocaleDataIndex[LocaleDataIndex.DateTimeFormat] = "DateTimeFormat", 
            LocaleDataIndex[LocaleDataIndex.NumberSymbols] = "NumberSymbols", LocaleDataIndex[LocaleDataIndex.NumberFormats] = "NumberFormats", 
            LocaleDataIndex[LocaleDataIndex.CurrencySymbol] = "CurrencySymbol", LocaleDataIndex[LocaleDataIndex.CurrencyName] = "CurrencyName", 
            LocaleDataIndex[LocaleDataIndex.Currencies] = "Currencies", LocaleDataIndex[LocaleDataIndex.PluralCase] = "PluralCase", 
            LocaleDataIndex[LocaleDataIndex.ExtraData] = "ExtraData", LocaleDataIndex;
        }(), DEFAULT_LOCALE_ID = "en-US";
        let LOCALE_ID = DEFAULT_LOCALE_ID;
        function setLocaleId(localeId) {
            var msg;
            msg = "Expected localeId to be defined", null == localeId && function(msg) {
                throw new Error(`ASSERTION ERROR: ${msg}`);
            }(msg), "string" == typeof localeId && (LOCALE_ID = localeId.toLowerCase().replace(/_/g, "-"));
        }
        class EventEmitter extends rxjs__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(isAsync = !1) {
                super(), this.__isAsync = isAsync;
            }
            emit(value) {
                super.next(value);
            }
            subscribe(generatorOrNext, error, complete) {
                let schedulerFn, errorFn = err => null, completeFn = () => null;
                generatorOrNext && "object" == typeof generatorOrNext ? (schedulerFn = this.__isAsync ? value => {
                    setTimeout(() => generatorOrNext.next(value));
                } : value => {
                    generatorOrNext.next(value);
                }, generatorOrNext.error && (errorFn = this.__isAsync ? err => {
                    setTimeout(() => generatorOrNext.error(err));
                } : err => {
                    generatorOrNext.error(err);
                }), generatorOrNext.complete && (completeFn = this.__isAsync ? () => {
                    setTimeout(() => generatorOrNext.complete());
                } : () => {
                    generatorOrNext.complete();
                })) : (schedulerFn = this.__isAsync ? value => {
                    setTimeout(() => generatorOrNext(value));
                } : value => {
                    generatorOrNext(value);
                }, error && (errorFn = this.__isAsync ? err => {
                    setTimeout(() => error(err));
                } : err => {
                    error(err);
                }), complete && (completeFn = this.__isAsync ? () => {
                    setTimeout(() => complete());
                } : () => {
                    complete();
                }));
                const sink = super.subscribe(schedulerFn, errorFn, completeFn);
                return generatorOrNext instanceof rxjs__WEBPACK_IMPORTED_MODULE_1__.a && generatorOrNext.add(sink), 
                sink;
            }
        }
        function symbolIterator() {
            return this._results[getSymbolIterator()]();
        }
        class QueryList {
            constructor() {
                this.dirty = !0, this._results = [], this.changes = new EventEmitter, this.length = 0;
                const symbol = getSymbolIterator(), proto = QueryList.prototype;
                proto[symbol] || (proto[symbol] = symbolIterator);
            }
            map(fn) {
                return this._results.map(fn);
            }
            filter(fn) {
                return this._results.filter(fn);
            }
            find(fn) {
                return this._results.find(fn);
            }
            reduce(fn, init) {
                return this._results.reduce(fn, init);
            }
            forEach(fn) {
                this._results.forEach(fn);
            }
            some(fn) {
                return this._results.some(fn);
            }
            toArray() {
                return this._results.slice();
            }
            toString() {
                return this._results.toString();
            }
            reset(resultsTree) {
                this._results = function flatten(list, dst) {
                    void 0 === dst && (dst = list);
                    for (let i = 0; i < list.length; i++) {
                        let item = list[i];
                        Array.isArray(item) ? (dst === list && (dst = list.slice(0, i)), flatten(item, dst)) : dst !== list && dst.push(item);
                    }
                    return dst;
                }(resultsTree), this.dirty = !1, this.length = this._results.length, this.last = this._results[this.length - 1], 
                this.first = this._results[0];
            }
            notifyOnChanges() {
                this.changes.emit(this);
            }
            setDirty() {
                this.dirty = !0;
            }
            destroy() {
                this.changes.complete(), this.changes.unsubscribe();
            }
        }
        const APP_INITIALIZER = new InjectionToken("Application Initializer");
        class ApplicationInitStatus {
            constructor(appInits) {
                this.appInits = appInits, this.initialized = !1, this.done = !1, this.donePromise = new Promise((res, rej) => {
                    this.resolve = res, this.reject = rej;
                });
            }
            runInitializers() {
                if (this.initialized) return;
                const asyncInitPromises = [], complete = () => {
                    this.done = !0, this.resolve();
                };
                if (this.appInits) for (let i = 0; i < this.appInits.length; i++) {
                    const initResult = this.appInits[i]();
                    isPromise(initResult) && asyncInitPromises.push(initResult);
                }
                Promise.all(asyncInitPromises).then(() => {
                    complete();
                }).catch(e => {
                    this.reject(e);
                }), 0 === asyncInitPromises.length && complete(), this.initialized = !0;
            }
        }
        const APP_ID = new InjectionToken("AppId");
        function _appIdRandomProviderFactory() {
            return `${_randomChar()}${_randomChar()}${_randomChar()}`;
        }
        function _randomChar() {
            return String.fromCharCode(97 + Math.floor(25 * Math.random()));
        }
        const PLATFORM_INITIALIZER = new InjectionToken("Platform Initializer"), PLATFORM_ID = new InjectionToken("Platform ID"), APP_BOOTSTRAP_LISTENER = new InjectionToken("appBootstrapListener");
        class Console {
            log(message) {
                console.log(message);
            }
            warn(message) {
                console.warn(message);
            }
        }
        const LOCALE_ID$1 = new InjectionToken("LocaleId"), ivyEnabled = !1;
        function _throwError() {
            throw new Error("Runtime compiler is not loaded");
        }
        const Compiler_compileModuleSync = _throwError, Compiler_compileModuleAsync = _throwError, Compiler_compileModuleAndAllComponentsSync = _throwError, Compiler_compileModuleAndAllComponentsAsync = _throwError;
        class Compiler {
            constructor() {
                this.compileModuleSync = Compiler_compileModuleSync, this.compileModuleAsync = Compiler_compileModuleAsync, 
                this.compileModuleAndAllComponentsSync = Compiler_compileModuleAndAllComponentsSync, 
                this.compileModuleAndAllComponentsAsync = Compiler_compileModuleAndAllComponentsAsync;
            }
            clearCache() {}
            clearCacheFor(type) {}
            getModuleId(moduleType) {}
        }
        class CompilerFactory {}
        let trace, events;
        function detectWTF() {
            const wtf = _global.wtf;
            return !(!wtf || !(trace = wtf.trace) || (events = trace.events, 0));
        }
        const wtfEnabled = detectWTF();
        function noopScope(arg0, arg1) {
            return null;
        }
        const wtfCreateScope = wtfEnabled ? function(signature, flags = null) {
            return events.createScope(signature, flags);
        } : (signature, flags) => noopScope, wtfLeave = wtfEnabled ? function(scope, returnValue) {
            return trace.leaveScope(scope, returnValue), returnValue;
        } : (s, r) => r, promise = (() => Promise.resolve(0))();
        function scheduleMicroTask(fn) {
            "undefined" == typeof Zone ? promise.then(() => {
                fn && fn.apply(null, null);
            }) : Zone.current.scheduleMicroTask("scheduleMicrotask", fn);
        }
        class NgZone {
            constructor({enableLongStackTrace: enableLongStackTrace = !1, shouldCoalesceEventChangeDetection: shouldCoalesceEventChangeDetection = !1}) {
                if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, 
                this.onUnstable = new EventEmitter(!1), this.onMicrotaskEmpty = new EventEmitter(!1), 
                this.onStable = new EventEmitter(!1), this.onError = new EventEmitter(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js");
                Zone.assertZonePatched(), this._nesting = 0, this._outer = this._inner = Zone.current, 
                Zone.wtfZoneSpec && (this._inner = this._inner.fork(Zone.wtfZoneSpec)), Zone.TaskTrackingZoneSpec && (this._inner = this._inner.fork(new Zone.TaskTrackingZoneSpec)), 
                enableLongStackTrace && Zone.longStackTraceZoneSpec && (this._inner = this._inner.fork(Zone.longStackTraceZoneSpec)), 
                this.shouldCoalesceEventChangeDetection = shouldCoalesceEventChangeDetection, this.lastRequestAnimationFrameId = -1, 
                this.nativeRequestAnimationFrame = function() {
                    let nativeRequestAnimationFrame = _global.requestAnimationFrame, nativeCancelAnimationFrame = _global.cancelAnimationFrame;
                    if ("undefined" != typeof Zone && nativeRequestAnimationFrame && nativeCancelAnimationFrame) {
                        const unpatchedRequestAnimationFrame = nativeRequestAnimationFrame[Zone.__symbol__("OriginalDelegate")];
                        unpatchedRequestAnimationFrame && (nativeRequestAnimationFrame = unpatchedRequestAnimationFrame);
                        const unpatchedCancelAnimationFrame = nativeCancelAnimationFrame[Zone.__symbol__("OriginalDelegate")];
                        unpatchedCancelAnimationFrame && (nativeCancelAnimationFrame = unpatchedCancelAnimationFrame);
                    }
                    return {
                        nativeRequestAnimationFrame: nativeRequestAnimationFrame,
                        nativeCancelAnimationFrame: nativeCancelAnimationFrame
                    };
                }().nativeRequestAnimationFrame, function(zone) {
                    const maybeDelayChangeDetection = !!zone.shouldCoalesceEventChangeDetection && zone.nativeRequestAnimationFrame && (() => {
                        !function(zone) {
                            -1 === zone.lastRequestAnimationFrameId && (zone.lastRequestAnimationFrameId = zone.nativeRequestAnimationFrame.call(_global, () => {
                                zone.lastRequestAnimationFrameId = -1, updateMicroTaskStatus(zone), checkStable(zone);
                            }), updateMicroTaskStatus(zone));
                        }(zone);
                    });
                    zone._inner = zone._inner.fork({
                        name: "angular",
                        properties: {
                            isAngularZone: !0,
                            maybeDelayChangeDetection: maybeDelayChangeDetection
                        },
                        onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
                            try {
                                return onEnter(zone), delegate.invokeTask(target, task, applyThis, applyArgs);
                            } finally {
                                maybeDelayChangeDetection && "eventTask" === task.type && maybeDelayChangeDetection(), 
                                onLeave(zone);
                            }
                        },
                        onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
                            try {
                                return onEnter(zone), delegate.invoke(target, callback, applyThis, applyArgs, source);
                            } finally {
                                onLeave(zone);
                            }
                        },
                        onHasTask: (delegate, current, target, hasTaskState) => {
                            delegate.hasTask(target, hasTaskState), current === target && ("microTask" == hasTaskState.change ? (zone._hasPendingMicrotasks = hasTaskState.microTask, 
                            updateMicroTaskStatus(zone), checkStable(zone)) : "macroTask" == hasTaskState.change && (zone.hasPendingMacrotasks = hasTaskState.macroTask));
                        },
                        onHandleError: (delegate, current, target, error) => (delegate.handleError(target, error), 
                        zone.runOutsideAngular(() => zone.onError.emit(error)), !1)
                    });
                }(this);
            }
            static isInAngularZone() {
                return !0 === Zone.current.get("isAngularZone");
            }
            static assertInAngularZone() {
                if (!NgZone.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!");
            }
            static assertNotInAngularZone() {
                if (NgZone.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!");
            }
            run(fn, applyThis, applyArgs) {
                return this._inner.run(fn, applyThis, applyArgs);
            }
            runTask(fn, applyThis, applyArgs, name) {
                const zone = this._inner, task = zone.scheduleEventTask("NgZoneEvent: " + name, fn, EMPTY_PAYLOAD, noop$1, noop$1);
                try {
                    return zone.runTask(task, applyThis, applyArgs);
                } finally {
                    zone.cancelTask(task);
                }
            }
            runGuarded(fn, applyThis, applyArgs) {
                return this._inner.runGuarded(fn, applyThis, applyArgs);
            }
            runOutsideAngular(fn) {
                return this._outer.run(fn);
            }
        }
        function noop$1() {}
        const EMPTY_PAYLOAD = {};
        function checkStable(zone) {
            if (0 == zone._nesting && !zone.hasPendingMicrotasks && !zone.isStable) try {
                zone._nesting++, zone.onMicrotaskEmpty.emit(null);
            } finally {
                if (zone._nesting--, !zone.hasPendingMicrotasks) try {
                    zone.runOutsideAngular(() => zone.onStable.emit(null));
                } finally {
                    zone.isStable = !0;
                }
            }
        }
        function updateMicroTaskStatus(zone) {
            zone.hasPendingMicrotasks = !!(zone._hasPendingMicrotasks || zone.shouldCoalesceEventChangeDetection && -1 !== zone.lastRequestAnimationFrameId);
        }
        function onEnter(zone) {
            zone._nesting++, zone.isStable && (zone.isStable = !1, zone.onUnstable.emit(null));
        }
        function onLeave(zone) {
            zone._nesting--, checkStable(zone);
        }
        class NoopNgZone {
            constructor() {
                this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, 
                this.onUnstable = new EventEmitter, this.onMicrotaskEmpty = new EventEmitter, this.onStable = new EventEmitter, 
                this.onError = new EventEmitter;
            }
            run(fn, applyThis, applyArgs) {
                return fn.apply(applyThis, applyArgs);
            }
            runGuarded(fn, applyThis, applyArgs) {
                return fn.apply(applyThis, applyArgs);
            }
            runOutsideAngular(fn) {
                return fn();
            }
            runTask(fn, applyThis, applyArgs, name) {
                return fn.apply(applyThis, applyArgs);
            }
        }
        class Testability {
            constructor(_ngZone) {
                this._ngZone = _ngZone, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, 
                this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), 
                _ngZone.run(() => {
                    this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone");
                });
            }
            _watchAngularEvents() {
                this._ngZone.onUnstable.subscribe({
                    next: () => {
                        this._didWork = !0, this._isZoneStable = !1;
                    }
                }), this._ngZone.runOutsideAngular(() => {
                    this._ngZone.onStable.subscribe({
                        next: () => {
                            NgZone.assertNotInAngularZone(), scheduleMicroTask(() => {
                                this._isZoneStable = !0, this._runCallbacksIfReady();
                            });
                        }
                    });
                });
            }
            increasePendingRequestCount() {
                return this._pendingCount += 1, this._didWork = !0, this._pendingCount;
            }
            decreasePendingRequestCount() {
                if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero");
                return this._runCallbacksIfReady(), this._pendingCount;
            }
            isStable() {
                return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks;
            }
            _runCallbacksIfReady() {
                if (this.isStable()) scheduleMicroTask(() => {
                    for (;0 !== this._callbacks.length; ) {
                        let cb = this._callbacks.pop();
                        clearTimeout(cb.timeoutId), cb.doneCb(this._didWork);
                    }
                    this._didWork = !1;
                }); else {
                    let pending = this.getPendingTasks();
                    this._callbacks = this._callbacks.filter(cb => !cb.updateCb || !cb.updateCb(pending) || (clearTimeout(cb.timeoutId), 
                    !1)), this._didWork = !0;
                }
            }
            getPendingTasks() {
                return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(t => ({
                    source: t.source,
                    creationLocation: t.creationLocation,
                    data: t.data
                })) : [];
            }
            addCallback(cb, timeout, updateCb) {
                let timeoutId = -1;
                timeout && timeout > 0 && (timeoutId = setTimeout(() => {
                    this._callbacks = this._callbacks.filter(cb => cb.timeoutId !== timeoutId), cb(this._didWork, this.getPendingTasks());
                }, timeout)), this._callbacks.push({
                    doneCb: cb,
                    timeoutId: timeoutId,
                    updateCb: updateCb
                });
            }
            whenStable(doneCb, timeout, updateCb) {
                if (updateCb && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');
                this.addCallback(doneCb, timeout, updateCb), this._runCallbacksIfReady();
            }
            getPendingRequestCount() {
                return this._pendingCount;
            }
            findProviders(using, provider, exactMatch) {
                return [];
            }
        }
        class TestabilityRegistry {
            constructor() {
                this._applications = new Map, _testabilityGetter.addToWindow(this);
            }
            registerApplication(token, testability) {
                this._applications.set(token, testability);
            }
            unregisterApplication(token) {
                this._applications.delete(token);
            }
            unregisterAllApplications() {
                this._applications.clear();
            }
            getTestability(elem) {
                return this._applications.get(elem) || null;
            }
            getAllTestabilities() {
                return Array.from(this._applications.values());
            }
            getAllRootElements() {
                return Array.from(this._applications.keys());
            }
            findTestabilityInTree(elem, findInAncestors = !0) {
                return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
            }
        }
        class _NoopGetTestability {
            addToWindow(registry) {}
            findTestabilityInTree(registry, elem, findInAncestors) {
                return null;
            }
        }
        function setTestabilityGetter(getter) {
            _testabilityGetter = getter;
        }
        let _platform, _testabilityGetter = new _NoopGetTestability, compileNgModuleFactory = function(injector, options, moduleType) {
            return injector.get(CompilerFactory).createCompiler([ options ]).compileModuleAsync(moduleType);
        }, publishDefaultGlobalUtils$1 = function() {}, isBoundToModule = function(cf) {
            return cf instanceof ComponentFactoryBoundToModule;
        };
        const ALLOW_MULTIPLE_PLATFORMS = new InjectionToken("AllowMultipleToken");
        class NgProbeToken {
            constructor(name, token) {
                this.name = name, this.token = token;
            }
        }
        function createPlatformFactory(parentPlatformFactory, name, providers = []) {
            const desc = `Platform: ${name}`, marker = new InjectionToken(desc);
            return (extraProviders = []) => {
                let platform = getPlatform();
                if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, !1)) if (parentPlatformFactory) parentPlatformFactory(providers.concat(extraProviders).concat({
                    provide: marker,
                    useValue: !0
                })); else {
                    const injectedProviders = providers.concat(extraProviders).concat({
                        provide: marker,
                        useValue: !0
                    }, {
                        provide: INJECTOR_SCOPE,
                        useValue: "platform"
                    });
                    !function(injector) {
                        if (_platform && !_platform.destroyed && !_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one.");
                        publishDefaultGlobalUtils$1(), _platform = injector.get(PlatformRef);
                        const inits = injector.get(PLATFORM_INITIALIZER, null);
                        inits && inits.forEach(init => init());
                    }(Injector.create({
                        providers: injectedProviders,
                        name: desc
                    }));
                }
                return function(requiredToken) {
                    const platform = getPlatform();
                    if (!platform) throw new Error("No platform exists!");
                    if (!platform.injector.get(requiredToken, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first.");
                    return platform;
                }(marker);
            };
        }
        function getPlatform() {
            return _platform && !_platform.destroyed ? _platform : null;
        }
        class PlatformRef {
            constructor(_injector) {
                this._injector = _injector, this._modules = [], this._destroyListeners = [], this._destroyed = !1;
            }
            bootstrapModuleFactory(moduleFactory, options) {
                const ngZone = (ngZoneEventCoalescing = options && options.ngZoneEventCoalescing || !1, 
                "noop" === (ngZoneOption = options ? options.ngZone : void 0) ? new NoopNgZone : ("zone.js" === ngZoneOption ? void 0 : ngZoneOption) || new NgZone({
                    enableLongStackTrace: isDevMode(),
                    shouldCoalesceEventChangeDetection: ngZoneEventCoalescing
                })), providers = [ {
                    provide: NgZone,
                    useValue: ngZone
                } ];
                var ngZoneOption, ngZoneEventCoalescing;
                return ngZone.run(() => {
                    const ngZoneInjector = Injector.create({
                        providers: providers,
                        parent: this.injector,
                        name: moduleFactory.moduleType.name
                    }), moduleRef = moduleFactory.create(ngZoneInjector), exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
                    if (!exceptionHandler) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");
                    return ivyEnabled && setLocaleId(moduleRef.injector.get(LOCALE_ID$1, DEFAULT_LOCALE_ID) || DEFAULT_LOCALE_ID), 
                    moduleRef.onDestroy(() => remove(this._modules, moduleRef)), ngZone.runOutsideAngular(() => ngZone.onError.subscribe({
                        next: error => {
                            exceptionHandler.handleError(error);
                        }
                    })), function(errorHandler, ngZone, callback) {
                        try {
                            const result = callback();
                            return isPromise(result) ? result.catch(e => {
                                throw ngZone.runOutsideAngular(() => errorHandler.handleError(e)), e;
                            }) : result;
                        } catch (e) {
                            throw ngZone.runOutsideAngular(() => errorHandler.handleError(e)), e;
                        }
                    }(exceptionHandler, ngZone, () => {
                        const initStatus = moduleRef.injector.get(ApplicationInitStatus);
                        return initStatus.runInitializers(), initStatus.donePromise.then(() => (this._moduleDoBootstrap(moduleRef), 
                        moduleRef));
                    });
                });
            }
            bootstrapModule(moduleType, compilerOptions = []) {
                const options = optionsReducer({}, compilerOptions);
                return compileNgModuleFactory(this.injector, options, moduleType).then(moduleFactory => this.bootstrapModuleFactory(moduleFactory, options));
            }
            _moduleDoBootstrap(moduleRef) {
                const appRef = moduleRef.injector.get(ApplicationRef);
                if (moduleRef._bootstrapComponents.length > 0) moduleRef._bootstrapComponents.forEach(f => appRef.bootstrap(f)); else {
                    if (!moduleRef.instance.ngDoBootstrap) throw new Error(`The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. ` + "Please define one of these.");
                    moduleRef.instance.ngDoBootstrap(appRef);
                }
                this._modules.push(moduleRef);
            }
            onDestroy(callback) {
                this._destroyListeners.push(callback);
            }
            get injector() {
                return this._injector;
            }
            destroy() {
                if (this._destroyed) throw new Error("The platform has already been destroyed!");
                this._modules.slice().forEach(module => module.destroy()), this._destroyListeners.forEach(listener => listener()), 
                this._destroyed = !0;
            }
            get destroyed() {
                return this._destroyed;
            }
        }
        function optionsReducer(dst, objs) {
            return Array.isArray(objs) ? objs.reduce(optionsReducer, dst) : Object.assign(Object.assign({}, dst), objs);
        }
        let ApplicationRef = (() => {
            class ApplicationRef {
                constructor(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus) {
                    this._zone = _zone, this._console = _console, this._injector = _injector, this._exceptionHandler = _exceptionHandler, 
                    this._componentFactoryResolver = _componentFactoryResolver, this._initStatus = _initStatus, 
                    this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._enforceNoNewChanges = !1, 
                    this._stable = !0, this.componentTypes = [], this.components = [], this._enforceNoNewChanges = isDevMode(), 
                    this._zone.onMicrotaskEmpty.subscribe({
                        next: () => {
                            this._zone.run(() => {
                                this.tick();
                            });
                        }
                    });
                    const isCurrentlyStable = new rxjs__WEBPACK_IMPORTED_MODULE_2__.a(observer => {
                        this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, 
                        this._zone.runOutsideAngular(() => {
                            observer.next(this._stable), observer.complete();
                        });
                    }), isStable = new rxjs__WEBPACK_IMPORTED_MODULE_2__.a(observer => {
                        let stableSub;
                        this._zone.runOutsideAngular(() => {
                            stableSub = this._zone.onStable.subscribe(() => {
                                NgZone.assertNotInAngularZone(), scheduleMicroTask(() => {
                                    this._stable || this._zone.hasPendingMacrotasks || this._zone.hasPendingMicrotasks || (this._stable = !0, 
                                    observer.next(!0));
                                });
                            });
                        });
                        const unstableSub = this._zone.onUnstable.subscribe(() => {
                            NgZone.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => {
                                observer.next(!1);
                            }));
                        });
                        return (() => {
                            stableSub.unsubscribe(), unstableSub.unsubscribe();
                        });
                    });
                    this.isStable = Object(rxjs__WEBPACK_IMPORTED_MODULE_3__.a)(isCurrentlyStable, isStable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)()));
                }
                bootstrap(componentOrFactory, rootSelectorOrNode) {
                    if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");
                    let componentFactory;
                    componentFactory = componentOrFactory instanceof ComponentFactory ? componentOrFactory : this._componentFactoryResolver.resolveComponentFactory(componentOrFactory), 
                    this.componentTypes.push(componentFactory.componentType);
                    const ngModule = isBoundToModule(componentFactory) ? void 0 : this._injector.get(NgModuleRef), compRef = componentFactory.create(Injector.NULL, [], rootSelectorOrNode || componentFactory.selector, ngModule);
                    compRef.onDestroy(() => {
                        this._unloadComponent(compRef);
                    });
                    const testability = compRef.injector.get(Testability, null);
                    return testability && compRef.injector.get(TestabilityRegistry).registerApplication(compRef.location.nativeElement, testability), 
                    this._loadComponent(compRef), isDevMode() && this._console.log("Angular is running in the development mode. Call enableProdMode() to enable the production mode."), 
                    compRef;
                }
                tick() {
                    if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively");
                    const scope = ApplicationRef._tickScope();
                    try {
                        this._runningTick = !0;
                        for (let view of this._views) view.detectChanges();
                        if (this._enforceNoNewChanges) for (let view of this._views) view.checkNoChanges();
                    } catch (e) {
                        this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(e));
                    } finally {
                        this._runningTick = !1, wtfLeave(scope);
                    }
                }
                attachView(viewRef) {
                    const view = viewRef;
                    this._views.push(view), view.attachToAppRef(this);
                }
                detachView(viewRef) {
                    const view = viewRef;
                    remove(this._views, view), view.detachFromAppRef();
                }
                _loadComponent(componentRef) {
                    this.attachView(componentRef.hostView), this.tick(), this.components.push(componentRef), 
                    this._injector.get(APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners).forEach(listener => listener(componentRef));
                }
                _unloadComponent(componentRef) {
                    this.detachView(componentRef.hostView), remove(this.components, componentRef);
                }
                ngOnDestroy() {
                    this._views.slice().forEach(view => view.destroy());
                }
                get viewCount() {
                    return this._views.length;
                }
            }
            return ApplicationRef._tickScope = wtfCreateScope("ApplicationRef#tick()"), ApplicationRef;
        })();
        function remove(list, el) {
            const index = list.indexOf(el);
            index > -1 && list.splice(index, 1);
        }
        class NgModuleFactoryLoader {}
        const _SEPARATOR = "#", FACTORY_CLASS_SUFFIX = "NgFactory", DEFAULT_CONFIG = {
            factoryPathPrefix: "",
            factoryPathSuffix: ".ngfactory"
        };
        class SystemJsNgModuleLoader {
            constructor(_compiler, config) {
                this._compiler = _compiler, this._config = config || DEFAULT_CONFIG;
            }
            load(path) {
                return !ivyEnabled && this._compiler instanceof Compiler ? this.loadFactory(path) : this.loadAndCompile(path);
            }
            loadAndCompile(path) {
                let [module, exportName] = path.split(_SEPARATOR);
                return void 0 === exportName && (exportName = "default"), __webpack_require__("zn8P")(module).then(module => module[exportName]).then(type => checkNotEmpty(type, module, exportName)).then(type => this._compiler.compileModuleAsync(type));
            }
            loadFactory(path) {
                let [module, exportName] = path.split(_SEPARATOR), factoryClassSuffix = FACTORY_CLASS_SUFFIX;
                return void 0 === exportName && (exportName = "default", factoryClassSuffix = ""), 
                __webpack_require__("zn8P")(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix).then(module => module[exportName + factoryClassSuffix]).then(factory => checkNotEmpty(factory, module, exportName));
            }
        }
        function checkNotEmpty(value, modulePath, exportName) {
            if (!value) throw new Error(`Cannot find '${exportName}' in '${modulePath}'`);
            return value;
        }
        class DebugEventListener {
            constructor(name, callback) {
                this.name = name, this.callback = callback;
            }
        }
        class DebugNode__PRE_R3__ {
            constructor(nativeNode, parent, _debugContext) {
                this.listeners = [], this.parent = null, this._debugContext = _debugContext, this.nativeNode = nativeNode, 
                parent && parent instanceof DebugElement__PRE_R3__ && parent.addChild(this);
            }
            get injector() {
                return this._debugContext.injector;
            }
            get componentInstance() {
                return this._debugContext.component;
            }
            get context() {
                return this._debugContext.context;
            }
            get references() {
                return this._debugContext.references;
            }
            get providerTokens() {
                return this._debugContext.providerTokens;
            }
        }
        class DebugElement__PRE_R3__ extends DebugNode__PRE_R3__ {
            constructor(nativeNode, parent, _debugContext) {
                super(nativeNode, parent, _debugContext), this.properties = {}, this.attributes = {}, 
                this.classes = {}, this.styles = {}, this.childNodes = [], this.nativeElement = nativeNode;
            }
            addChild(child) {
                child && (this.childNodes.push(child), child.parent = this);
            }
            removeChild(child) {
                const childIndex = this.childNodes.indexOf(child);
                -1 !== childIndex && (child.parent = null, this.childNodes.splice(childIndex, 1));
            }
            insertChildrenAfter(child, newChildren) {
                const siblingIndex = this.childNodes.indexOf(child);
                -1 !== siblingIndex && (this.childNodes.splice(siblingIndex + 1, 0, ...newChildren), 
                newChildren.forEach(c => {
                    c.parent && c.parent.removeChild(c), child.parent = this;
                }));
            }
            insertBefore(refChild, newChild) {
                const refIndex = this.childNodes.indexOf(refChild);
                -1 === refIndex ? this.addChild(newChild) : (newChild.parent && newChild.parent.removeChild(newChild), 
                newChild.parent = this, this.childNodes.splice(refIndex, 0, newChild));
            }
            query(predicate) {
                return this.queryAll(predicate)[0] || null;
            }
            queryAll(predicate) {
                const matches = [];
                return function _queryElementChildren(element, predicate, matches) {
                    element.childNodes.forEach(node => {
                        node instanceof DebugElement__PRE_R3__ && (predicate(node) && matches.push(node), 
                        _queryElementChildren(node, predicate, matches));
                    });
                }(this, predicate, matches), matches;
            }
            queryAllNodes(predicate) {
                const matches = [];
                return function _queryNodeChildren(parentNode, predicate, matches) {
                    parentNode instanceof DebugElement__PRE_R3__ && parentNode.childNodes.forEach(node => {
                        predicate(node) && matches.push(node), node instanceof DebugElement__PRE_R3__ && _queryNodeChildren(node, predicate, matches);
                    });
                }(this, predicate, matches), matches;
            }
            get children() {
                return this.childNodes.filter(node => node instanceof DebugElement__PRE_R3__);
            }
            triggerEventHandler(eventName, eventObj) {
                this.listeners.forEach(listener => {
                    listener.name == eventName && listener.callback(eventObj);
                });
            }
        }
        const _nativeNodeToDebugNode = new Map, getDebugNode$1 = function(nativeNode) {
            return _nativeNodeToDebugNode.get(nativeNode) || null;
        };
        function indexDebugNode(node) {
            _nativeNodeToDebugNode.set(node.nativeNode, node);
        }
        const platformCore = createPlatformFactory(null, "core", [ {
            provide: PLATFORM_ID,
            useValue: "unknown"
        }, {
            provide: PlatformRef,
            deps: [ Injector ]
        }, {
            provide: TestabilityRegistry,
            deps: []
        }, {
            provide: Console,
            deps: []
        } ]);
        function _iterableDiffersFactory() {
            return defaultIterableDiffers;
        }
        function _keyValueDiffersFactory() {
            return defaultKeyValueDiffers;
        }
        function _localeFactory(locale) {
            return locale = locale || ivyEnabled && "undefined" != typeof $localize && $localize.locale || DEFAULT_LOCALE_ID, 
            ivyEnabled && setLocaleId(locale), locale;
        }
        function zoneSchedulerFactory(ngZone) {
            let queue = [];
            return ngZone.onStable.subscribe(() => {
                for (;queue.length; ) queue.pop()();
            }), function(fn) {
                queue.push(fn);
            };
        }
        class ApplicationModule {
            constructor(appRef) {}
        }
        function anchorDef(flags, matchedQueriesDsl, ngContentIndex, childCount, handleEvent, templateFactory) {
            flags |= 1;
            const {matchedQueries: matchedQueries, references: references, matchedQueryIds: matchedQueryIds} = splitMatchedQueriesDsl(matchedQueriesDsl);
            return {
                nodeIndex: -1,
                parent: null,
                renderParent: null,
                bindingIndex: -1,
                outputIndex: -1,
                flags: flags,
                checkIndex: -1,
                childFlags: 0,
                directChildFlags: 0,
                childMatchedQueries: 0,
                matchedQueries: matchedQueries,
                matchedQueryIds: matchedQueryIds,
                references: references,
                ngContentIndex: ngContentIndex,
                childCount: childCount,
                bindings: [],
                bindingFlags: 0,
                outputs: [],
                element: {
                    ns: null,
                    name: null,
                    attrs: null,
                    template: templateFactory ? resolveDefinition(templateFactory) : null,
                    componentProvider: null,
                    componentView: null,
                    componentRendererType: null,
                    publicProviders: null,
                    allProviders: null,
                    handleEvent: handleEvent || NOOP
                },
                provider: null,
                text: null,
                query: null,
                ngContent: null
            };
        }
        function elementDef(checkIndex, flags, matchedQueriesDsl, ngContentIndex, childCount, namespaceAndName, fixedAttrs = [], bindings, outputs, handleEvent, componentView, componentRendererType) {
            handleEvent || (handleEvent = NOOP);
            const {matchedQueries: matchedQueries, references: references, matchedQueryIds: matchedQueryIds} = splitMatchedQueriesDsl(matchedQueriesDsl);
            let ns = null, name = null;
            namespaceAndName && ([ns, name] = splitNamespace(namespaceAndName)), bindings = bindings || [];
            const bindingDefs = [];
            for (let i = 0; i < bindings.length; i++) {
                const [bindingFlags, namespaceAndName, suffixOrSecurityContext] = bindings[i], [ns, name] = splitNamespace(namespaceAndName);
                let securityContext = void 0, suffix = void 0;
                switch (15 & bindingFlags) {
                  case 4:
                    suffix = suffixOrSecurityContext;
                    break;

                  case 1:
                  case 8:
                    securityContext = suffixOrSecurityContext;
                }
                bindingDefs[i] = {
                    flags: bindingFlags,
                    ns: ns,
                    name: name,
                    nonMinifiedName: name,
                    securityContext: securityContext,
                    suffix: suffix
                };
            }
            outputs = outputs || [];
            const outputDefs = [];
            for (let i = 0; i < outputs.length; i++) {
                const [target, eventName] = outputs[i];
                outputDefs[i] = {
                    type: 0,
                    target: target,
                    eventName: eventName,
                    propName: null
                };
            }
            const attrs = (fixedAttrs = fixedAttrs || []).map(([namespaceAndName, value]) => {
                const [ns, name] = splitNamespace(namespaceAndName);
                return [ ns, name, value ];
            });
            return componentRendererType = function(type) {
                if (type && type.id === UNDEFINED_RENDERER_TYPE_ID) {
                    const isFilled = null != type.encapsulation && type.encapsulation !== ViewEncapsulation$1.None || type.styles.length || Object.keys(type.data).length;
                    type.id = isFilled ? `c${_renderCompCount$1++}` : EMPTY_RENDERER_TYPE_ID;
                }
                return type && type.id === EMPTY_RENDERER_TYPE_ID && (type = null), type || null;
            }(componentRendererType), componentView && (flags |= 33554432), {
                nodeIndex: -1,
                parent: null,
                renderParent: null,
                bindingIndex: -1,
                outputIndex: -1,
                checkIndex: checkIndex,
                flags: flags |= 1,
                childFlags: 0,
                directChildFlags: 0,
                childMatchedQueries: 0,
                matchedQueries: matchedQueries,
                matchedQueryIds: matchedQueryIds,
                references: references,
                ngContentIndex: ngContentIndex,
                childCount: childCount,
                bindings: bindingDefs,
                bindingFlags: calcBindingFlags(bindingDefs),
                outputs: outputDefs,
                element: {
                    ns: ns,
                    name: name,
                    attrs: attrs,
                    template: null,
                    componentProvider: null,
                    componentView: componentView || null,
                    componentRendererType: componentRendererType,
                    publicProviders: null,
                    allProviders: null,
                    handleEvent: handleEvent || NOOP
                },
                provider: null,
                text: null,
                query: null,
                ngContent: null
            };
        }
        function createElement(view, renderHost, def) {
            const elDef = def.element, rootSelectorOrNode = view.root.selectorOrNode, renderer = view.renderer;
            let el;
            if (view.parent || !rootSelectorOrNode) {
                el = elDef.name ? renderer.createElement(elDef.name, elDef.ns) : renderer.createComment("");
                const parentEl = getParentRenderElement(view, renderHost, def);
                parentEl && renderer.appendChild(parentEl, el);
            } else el = renderer.selectRootElement(rootSelectorOrNode, !!elDef.componentRendererType && elDef.componentRendererType.encapsulation === ViewEncapsulation$1.ShadowDom);
            if (elDef.attrs) for (let i = 0; i < elDef.attrs.length; i++) {
                const [ns, name, value] = elDef.attrs[i];
                renderer.setAttribute(el, name, value, ns);
            }
            return el;
        }
        function listenToElementOutputs(view, compView, def, el) {
            for (let i = 0; i < def.outputs.length; i++) {
                const output = def.outputs[i], handleEventClosure = renderEventHandlerClosure(view, def.nodeIndex, (name = output.eventName, 
                (target = output.target) ? `${target}:${name}` : name));
                let listenTarget = output.target, listenerView = view;
                "component" === output.target && (listenTarget = null, listenerView = compView);
                const disposable = listenerView.renderer.listen(listenTarget || el, output.eventName, handleEventClosure);
                view.disposables[def.outputIndex + i] = disposable;
            }
            var target, name;
        }
        function renderEventHandlerClosure(view, index, eventName) {
            return event => dispatchEvent(view, index, eventName, event);
        }
        function checkAndUpdateElementValue(view, def, bindingIdx, value) {
            if (!checkAndUpdateBinding(view, def, bindingIdx, value)) return !1;
            const binding = def.bindings[bindingIdx], elData = asElementData(view, def.nodeIndex), renderNode = elData.renderElement, name = binding.name;
            switch (15 & binding.flags) {
              case 1:
                !function(view, binding, renderNode, ns, name, value) {
                    const securityContext = binding.securityContext;
                    let renderValue = securityContext ? view.root.sanitizer.sanitize(securityContext, value) : value;
                    renderValue = null != renderValue ? renderValue.toString() : null;
                    const renderer = view.renderer;
                    null != value ? renderer.setAttribute(renderNode, name, renderValue, ns) : renderer.removeAttribute(renderNode, name, ns);
                }(view, binding, renderNode, binding.ns, name, value);
                break;

              case 2:
                !function(view, renderNode, name, value) {
                    const renderer = view.renderer;
                    value ? renderer.addClass(renderNode, name) : renderer.removeClass(renderNode, name);
                }(view, renderNode, name, value);
                break;

              case 4:
                !function(view, binding, renderNode, name, value) {
                    let renderValue = view.root.sanitizer.sanitize(SecurityContext.STYLE, value);
                    if (null != renderValue) {
                        renderValue = renderValue.toString();
                        const unit = binding.suffix;
                        null != unit && (renderValue += unit);
                    } else renderValue = null;
                    const renderer = view.renderer;
                    null != renderValue ? renderer.setStyle(renderNode, name, renderValue) : renderer.removeStyle(renderNode, name);
                }(view, binding, renderNode, name, value);
                break;

              case 8:
                !function(view, binding, renderNode, name, value) {
                    const securityContext = binding.securityContext;
                    let renderValue = securityContext ? view.root.sanitizer.sanitize(securityContext, value) : value;
                    view.renderer.setProperty(renderNode, name, renderValue);
                }(33554432 & def.flags && 32 & binding.flags ? elData.componentView : view, binding, renderNode, name, value);
            }
            return !0;
        }
        function queryDef(flags, id, bindings) {
            let bindingDefs = [];
            for (let propName in bindings) bindingDefs.push({
                propName: propName,
                bindingType: bindings[propName]
            });
            return {
                nodeIndex: -1,
                parent: null,
                renderParent: null,
                bindingIndex: -1,
                outputIndex: -1,
                checkIndex: -1,
                flags: flags,
                childFlags: 0,
                directChildFlags: 0,
                childMatchedQueries: 0,
                ngContentIndex: -1,
                matchedQueries: {},
                matchedQueryIds: 0,
                references: {},
                childCount: 0,
                bindings: [],
                bindingFlags: 0,
                outputs: [],
                element: null,
                provider: null,
                text: null,
                query: {
                    id: id,
                    filterId: filterQueryId(id),
                    bindings: bindingDefs
                },
                ngContent: null
            };
        }
        function dirtyParentQueries(view) {
            const queryIds = view.def.nodeMatchedQueries;
            for (;view.parent && isEmbeddedView(view); ) {
                let tplDef = view.parentNodeDef;
                view = view.parent;
                const end = tplDef.nodeIndex + tplDef.childCount;
                for (let i = 0; i <= end; i++) {
                    const nodeDef = view.def.nodes[i];
                    67108864 & nodeDef.flags && 536870912 & nodeDef.flags && (nodeDef.query.filterId & queryIds) === nodeDef.query.filterId && asQueryList(view, i).setDirty(), 
                    !(1 & nodeDef.flags && i + nodeDef.childCount < tplDef.nodeIndex) && 67108864 & nodeDef.childFlags && 536870912 & nodeDef.childFlags || (i += nodeDef.childCount);
                }
            }
            if (134217728 & view.def.nodeFlags) for (let i = 0; i < view.def.nodes.length; i++) {
                const nodeDef = view.def.nodes[i];
                134217728 & nodeDef.flags && 536870912 & nodeDef.flags && asQueryList(view, i).setDirty(), 
                i += nodeDef.childCount;
            }
        }
        function checkAndUpdateQuery(view, nodeDef) {
            const queryList = asQueryList(view, nodeDef.nodeIndex);
            if (!queryList.dirty) return;
            let directiveInstance, newValues = void 0;
            if (67108864 & nodeDef.flags) {
                const elementDef = nodeDef.parent.parent;
                newValues = calcQueryValues(view, elementDef.nodeIndex, elementDef.nodeIndex + elementDef.childCount, nodeDef.query, []), 
                directiveInstance = asProviderData(view, nodeDef.parent.nodeIndex).instance;
            } else 134217728 & nodeDef.flags && (newValues = calcQueryValues(view, 0, view.def.nodes.length - 1, nodeDef.query, []), 
            directiveInstance = view.component);
            queryList.reset(newValues);
            const bindings = nodeDef.query.bindings;
            let notify = !1;
            for (let i = 0; i < bindings.length; i++) {
                const binding = bindings[i];
                let boundValue;
                switch (binding.bindingType) {
                  case 0:
                    boundValue = queryList.first;
                    break;

                  case 1:
                    boundValue = queryList, notify = !0;
                }
                directiveInstance[binding.propName] = boundValue;
            }
            notify && queryList.notifyOnChanges();
        }
        function calcQueryValues(view, startIndex, endIndex, queryDef, values) {
            for (let i = startIndex; i <= endIndex; i++) {
                const nodeDef = view.def.nodes[i], valueType = nodeDef.matchedQueries[queryDef.id];
                if (null != valueType && values.push(getQueryValue(view, nodeDef, valueType)), 1 & nodeDef.flags && nodeDef.element.template && (nodeDef.element.template.nodeMatchedQueries & queryDef.filterId) === queryDef.filterId) {
                    const elementData = asElementData(view, i);
                    if ((nodeDef.childMatchedQueries & queryDef.filterId) === queryDef.filterId && (calcQueryValues(view, i + 1, i + nodeDef.childCount, queryDef, values), 
                    i += nodeDef.childCount), 16777216 & nodeDef.flags) {
                        const embeddedViews = elementData.viewContainer._embeddedViews;
                        for (let k = 0; k < embeddedViews.length; k++) {
                            const embeddedView = embeddedViews[k], dvc = declaredViewContainer(embeddedView);
                            dvc && dvc === elementData && calcQueryValues(embeddedView, 0, embeddedView.def.nodes.length - 1, queryDef, values);
                        }
                    }
                    const projectedViews = elementData.template._projectedViews;
                    if (projectedViews) for (let k = 0; k < projectedViews.length; k++) {
                        const projectedView = projectedViews[k];
                        calcQueryValues(projectedView, 0, projectedView.def.nodes.length - 1, queryDef, values);
                    }
                }
                (nodeDef.childMatchedQueries & queryDef.filterId) !== queryDef.filterId && (i += nodeDef.childCount);
            }
            return values;
        }
        function getQueryValue(view, nodeDef, queryValueType) {
            if (null != queryValueType) switch (queryValueType) {
              case 1:
                return asElementData(view, nodeDef.nodeIndex).renderElement;

              case 0:
                return new ElementRef(asElementData(view, nodeDef.nodeIndex).renderElement);

              case 2:
                return asElementData(view, nodeDef.nodeIndex).template;

              case 3:
                return asElementData(view, nodeDef.nodeIndex).viewContainer;

              case 4:
                return asProviderData(view, nodeDef.nodeIndex).instance;
            }
        }
        function ngContentDef(ngContentIndex, index) {
            return {
                nodeIndex: -1,
                parent: null,
                renderParent: null,
                bindingIndex: -1,
                outputIndex: -1,
                checkIndex: -1,
                flags: 8,
                childFlags: 0,
                directChildFlags: 0,
                childMatchedQueries: 0,
                matchedQueries: {},
                matchedQueryIds: 0,
                references: {},
                ngContentIndex: ngContentIndex,
                childCount: 0,
                bindings: [],
                bindingFlags: 0,
                outputs: [],
                element: null,
                provider: null,
                text: null,
                query: null,
                ngContent: {
                    index: index
                }
            };
        }
        function appendNgContent(view, renderHost, def) {
            const parentEl = getParentRenderElement(view, renderHost, def);
            parentEl && visitProjectedRenderNodes(view, def.ngContent.index, 1, parentEl, null, void 0);
        }
        function pureObjectDef(checkIndex, propToIndex) {
            const keys = Object.keys(propToIndex), nbKeys = keys.length, propertyNames = [];
            for (let i = 0; i < nbKeys; i++) propertyNames.push(keys[i]);
            return function(flags, checkIndex, propertyNames) {
                const bindings = [];
                for (let i = 0; i < propertyNames.length; i++) {
                    const prop = propertyNames[i];
                    bindings.push({
                        flags: 8,
                        name: prop,
                        ns: null,
                        nonMinifiedName: prop,
                        securityContext: null,
                        suffix: null
                    });
                }
                return {
                    nodeIndex: -1,
                    parent: null,
                    renderParent: null,
                    bindingIndex: -1,
                    outputIndex: -1,
                    checkIndex: checkIndex,
                    flags: 64,
                    childFlags: 0,
                    directChildFlags: 0,
                    childMatchedQueries: 0,
                    matchedQueries: {},
                    matchedQueryIds: 0,
                    references: {},
                    ngContentIndex: -1,
                    childCount: 0,
                    bindings: bindings,
                    bindingFlags: calcBindingFlags(bindings),
                    outputs: [],
                    element: null,
                    provider: null,
                    text: null,
                    query: null,
                    ngContent: null
                };
            }(0, checkIndex, propertyNames);
        }
        function textDef(checkIndex, ngContentIndex, staticText) {
            const bindings = [];
            for (let i = 1; i < staticText.length; i++) bindings[i - 1] = {
                flags: 8,
                name: null,
                ns: null,
                nonMinifiedName: null,
                securityContext: null,
                suffix: staticText[i]
            };
            return {
                nodeIndex: -1,
                parent: null,
                renderParent: null,
                bindingIndex: -1,
                outputIndex: -1,
                checkIndex: checkIndex,
                flags: 2,
                childFlags: 0,
                directChildFlags: 0,
                childMatchedQueries: 0,
                matchedQueries: {},
                matchedQueryIds: 0,
                references: {},
                ngContentIndex: ngContentIndex,
                childCount: 0,
                bindings: bindings,
                bindingFlags: 8,
                outputs: [],
                element: null,
                provider: null,
                text: {
                    prefix: staticText[0]
                },
                query: null,
                ngContent: null
            };
        }
        function createText(view, renderHost, def) {
            let renderNode;
            const renderer = view.renderer;
            renderNode = renderer.createText(def.text.prefix);
            const parentEl = getParentRenderElement(view, renderHost, def);
            return parentEl && renderer.appendChild(parentEl, renderNode), {
                renderText: renderNode
            };
        }
        function _addInterpolationPart(value, binding) {
            return (null != value ? value.toString() : "") + binding.suffix;
        }
        function viewDef(flags, nodes, updateDirectives, updateRenderer) {
            let viewBindingCount = 0, viewDisposableCount = 0, viewNodeFlags = 0, viewRootNodeFlags = 0, viewMatchedQueries = 0, currentParent = null, currentRenderParent = null, currentElementHasPublicProviders = !1, currentElementHasPrivateProviders = !1, lastRenderRootNode = null;
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                if (node.nodeIndex = i, node.parent = currentParent, node.bindingIndex = viewBindingCount, 
                node.outputIndex = viewDisposableCount, node.renderParent = currentRenderParent, 
                viewNodeFlags |= node.flags, viewMatchedQueries |= node.matchedQueryIds, node.element) {
                    const elDef = node.element;
                    elDef.publicProviders = currentParent ? currentParent.element.publicProviders : Object.create(null), 
                    elDef.allProviders = elDef.publicProviders, currentElementHasPublicProviders = !1, 
                    currentElementHasPrivateProviders = !1, node.element.template && (viewMatchedQueries |= node.element.template.nodeMatchedQueries);
                }
                if (validateNode(currentParent, node, nodes.length), viewBindingCount += node.bindings.length, 
                viewDisposableCount += node.outputs.length, !currentRenderParent && 3 & node.flags && (lastRenderRootNode = node), 
                20224 & node.flags) {
                    currentElementHasPublicProviders || (currentElementHasPublicProviders = !0, currentParent.element.publicProviders = Object.create(currentParent.element.publicProviders), 
                    currentParent.element.allProviders = currentParent.element.publicProviders);
                    const isComponent = 0 != (32768 & node.flags);
                    0 == (8192 & node.flags) || isComponent ? currentParent.element.publicProviders[tokenKey(node.provider.token)] = node : (currentElementHasPrivateProviders || (currentElementHasPrivateProviders = !0, 
                    currentParent.element.allProviders = Object.create(currentParent.element.publicProviders)), 
                    currentParent.element.allProviders[tokenKey(node.provider.token)] = node), isComponent && (currentParent.element.componentProvider = node);
                }
                if (currentParent ? (currentParent.childFlags |= node.flags, currentParent.directChildFlags |= node.flags, 
                currentParent.childMatchedQueries |= node.matchedQueryIds, node.element && node.element.template && (currentParent.childMatchedQueries |= node.element.template.nodeMatchedQueries)) : viewRootNodeFlags |= node.flags, 
                node.childCount > 0) currentParent = node, isNgContainer(node) || (currentRenderParent = node); else for (;currentParent && i === currentParent.nodeIndex + currentParent.childCount; ) {
                    const newParent = currentParent.parent;
                    newParent && (newParent.childFlags |= currentParent.childFlags, newParent.childMatchedQueries |= currentParent.childMatchedQueries), 
                    currentRenderParent = (currentParent = newParent) && isNgContainer(currentParent) ? currentParent.renderParent : currentParent;
                }
            }
            return {
                factory: null,
                nodeFlags: viewNodeFlags,
                rootNodeFlags: viewRootNodeFlags,
                nodeMatchedQueries: viewMatchedQueries,
                flags: flags,
                nodes: nodes,
                updateDirectives: updateDirectives || NOOP,
                updateRenderer: updateRenderer || NOOP,
                handleEvent: (view, nodeIndex, eventName, event) => nodes[nodeIndex].element.handleEvent(view, eventName, event),
                bindingCount: viewBindingCount,
                outputCount: viewDisposableCount,
                lastRenderRootNode: lastRenderRootNode
            };
        }
        function isNgContainer(node) {
            return 0 != (1 & node.flags) && null === node.element.name;
        }
        function validateNode(parent, node, nodeCount) {
            const template = node.element && node.element.template;
            if (template) {
                if (!template.lastRenderRootNode) throw new Error("Illegal State: Embedded templates without nodes are not allowed!");
                if (template.lastRenderRootNode && 16777216 & template.lastRenderRootNode.flags) throw new Error(`Illegal State: Last root node of a template can't have embedded views, at index ${node.nodeIndex}!`);
            }
            if (20224 & node.flags && 0 == (1 & (parent ? parent.flags : 0))) throw new Error(`Illegal State: StaticProvider/Directive nodes need to be children of elements or anchors, at index ${node.nodeIndex}!`);
            if (node.query) {
                if (67108864 & node.flags && (!parent || 0 == (16384 & parent.flags))) throw new Error(`Illegal State: Content Query nodes need to be children of directives, at index ${node.nodeIndex}!`);
                if (134217728 & node.flags && parent) throw new Error(`Illegal State: View Query nodes have to be top level nodes, at index ${node.nodeIndex}!`);
            }
            if (node.childCount) {
                const parentEnd = parent ? parent.nodeIndex + parent.childCount : nodeCount - 1;
                if (node.nodeIndex <= parentEnd && node.nodeIndex + node.childCount > parentEnd) throw new Error(`Illegal State: childCount of node leads outside of parent, at index ${node.nodeIndex}!`);
            }
        }
        function createEmbeddedView(parent, anchorDef, viewDef, context) {
            const view = createView(parent.root, parent.renderer, parent, anchorDef, viewDef);
            return initView(view, parent.component, context), createViewNodes(view), view;
        }
        function createRootView(root, def, context) {
            const view = createView(root, root.renderer, null, null, def);
            return initView(view, context, context), createViewNodes(view), view;
        }
        function createComponentView(parentView, nodeDef, viewDef, hostElement) {
            const rendererType = nodeDef.element.componentRendererType;
            let compRenderer;
            return compRenderer = rendererType ? parentView.root.rendererFactory.createRenderer(hostElement, rendererType) : parentView.root.renderer, 
            createView(parentView.root, compRenderer, parentView, nodeDef.element.componentProvider, viewDef);
        }
        function createView(root, renderer, parent, parentNodeDef, def) {
            const nodes = new Array(def.nodes.length), disposables = def.outputCount ? new Array(def.outputCount) : null;
            return {
                def: def,
                parent: parent,
                viewContainerParent: null,
                parentNodeDef: parentNodeDef,
                context: null,
                component: null,
                nodes: nodes,
                state: 13,
                root: root,
                renderer: renderer,
                oldValues: new Array(def.bindingCount),
                disposables: disposables,
                initIndex: -1
            };
        }
        function initView(view, component, context) {
            view.component = component, view.context = context;
        }
        function createViewNodes(view) {
            let renderHost;
            isComponentView(view) && (renderHost = asElementData(view.parent, view.parentNodeDef.parent.nodeIndex).renderElement);
            const def = view.def, nodes = view.nodes;
            for (let i = 0; i < def.nodes.length; i++) {
                const nodeDef = def.nodes[i];
                let nodeData;
                switch (Services.setCurrentNode(view, i), 201347067 & nodeDef.flags) {
                  case 1:
                    const el = createElement(view, renderHost, nodeDef);
                    let componentView = void 0;
                    if (33554432 & nodeDef.flags) {
                        const compViewDef = resolveDefinition(nodeDef.element.componentView);
                        componentView = Services.createComponentView(view, nodeDef, compViewDef, el);
                    }
                    listenToElementOutputs(view, componentView, nodeDef, el), nodeData = {
                        renderElement: el,
                        componentView: componentView,
                        viewContainer: null,
                        template: nodeDef.element.template ? createTemplateData(view, nodeDef) : void 0
                    }, 16777216 & nodeDef.flags && (nodeData.viewContainer = createViewContainerData(view, nodeDef, nodeData));
                    break;

                  case 2:
                    nodeData = createText(view, renderHost, nodeDef);
                    break;

                  case 512:
                  case 1024:
                  case 2048:
                  case 256:
                    (nodeData = nodes[i]) || 4096 & nodeDef.flags || (nodeData = {
                        instance: createProviderInstance(view, nodeDef)
                    });
                    break;

                  case 16:
                    nodeData = {
                        instance: createPipeInstance(view, nodeDef)
                    };
                    break;

                  case 16384:
                    (nodeData = nodes[i]) || (nodeData = {
                        instance: createDirectiveInstance(view, nodeDef)
                    }), 32768 & nodeDef.flags && initView(asElementData(view, nodeDef.parent.nodeIndex).componentView, nodeData.instance, nodeData.instance);
                    break;

                  case 32:
                  case 64:
                  case 128:
                    nodeData = {
                        value: void 0
                    };
                    break;

                  case 67108864:
                  case 134217728:
                    nodeData = new QueryList;
                    break;

                  case 8:
                    appendNgContent(view, renderHost, nodeDef), nodeData = void 0;
                }
                nodes[i] = nodeData;
            }
            execComponentViewsAction(view, ViewAction.CreateViewNodes), execQueriesAction(view, 201326592, 268435456, 0);
        }
        function checkNoChangesView(view) {
            markProjectedViewsForCheck(view), Services.updateDirectives(view, 1), execEmbeddedViewsAction(view, ViewAction.CheckNoChanges), 
            Services.updateRenderer(view, 1), execComponentViewsAction(view, ViewAction.CheckNoChanges), 
            view.state &= -97;
        }
        function checkAndUpdateView(view) {
            1 & view.state ? (view.state &= -2, view.state |= 2) : view.state &= -3, shiftInitState(view, 0, 256), 
            markProjectedViewsForCheck(view), Services.updateDirectives(view, 0), execEmbeddedViewsAction(view, ViewAction.CheckAndUpdate), 
            execQueriesAction(view, 67108864, 536870912, 0);
            let callInit = shiftInitState(view, 256, 512);
            callLifecycleHooksChildrenFirst(view, 2097152 | (callInit ? 1048576 : 0)), Services.updateRenderer(view, 0), 
            execComponentViewsAction(view, ViewAction.CheckAndUpdate), execQueriesAction(view, 134217728, 536870912, 0), 
            callLifecycleHooksChildrenFirst(view, 8388608 | ((callInit = shiftInitState(view, 512, 768)) ? 4194304 : 0)), 
            2 & view.def.flags && (view.state &= -9), view.state &= -97, shiftInitState(view, 768, 1024);
        }
        function checkAndUpdateNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
            return 0 === argStyle ? function(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
                switch (201347067 & nodeDef.flags) {
                  case 1:
                    return function(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
                        const bindLen = def.bindings.length;
                        let changed = !1;
                        return bindLen > 0 && checkAndUpdateElementValue(view, def, 0, v0) && (changed = !0), 
                        bindLen > 1 && checkAndUpdateElementValue(view, def, 1, v1) && (changed = !0), bindLen > 2 && checkAndUpdateElementValue(view, def, 2, v2) && (changed = !0), 
                        bindLen > 3 && checkAndUpdateElementValue(view, def, 3, v3) && (changed = !0), bindLen > 4 && checkAndUpdateElementValue(view, def, 4, v4) && (changed = !0), 
                        bindLen > 5 && checkAndUpdateElementValue(view, def, 5, v5) && (changed = !0), bindLen > 6 && checkAndUpdateElementValue(view, def, 6, v6) && (changed = !0), 
                        bindLen > 7 && checkAndUpdateElementValue(view, def, 7, v7) && (changed = !0), bindLen > 8 && checkAndUpdateElementValue(view, def, 8, v8) && (changed = !0), 
                        bindLen > 9 && checkAndUpdateElementValue(view, def, 9, v9) && (changed = !0), changed;
                    }(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);

                  case 2:
                    return function(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
                        let changed = !1;
                        const bindings = def.bindings, bindLen = bindings.length;
                        if (bindLen > 0 && checkAndUpdateBinding(view, def, 0, v0) && (changed = !0), bindLen > 1 && checkAndUpdateBinding(view, def, 1, v1) && (changed = !0), 
                        bindLen > 2 && checkAndUpdateBinding(view, def, 2, v2) && (changed = !0), bindLen > 3 && checkAndUpdateBinding(view, def, 3, v3) && (changed = !0), 
                        bindLen > 4 && checkAndUpdateBinding(view, def, 4, v4) && (changed = !0), bindLen > 5 && checkAndUpdateBinding(view, def, 5, v5) && (changed = !0), 
                        bindLen > 6 && checkAndUpdateBinding(view, def, 6, v6) && (changed = !0), bindLen > 7 && checkAndUpdateBinding(view, def, 7, v7) && (changed = !0), 
                        bindLen > 8 && checkAndUpdateBinding(view, def, 8, v8) && (changed = !0), bindLen > 9 && checkAndUpdateBinding(view, def, 9, v9) && (changed = !0), 
                        changed) {
                            let value = def.text.prefix;
                            bindLen > 0 && (value += _addInterpolationPart(v0, bindings[0])), bindLen > 1 && (value += _addInterpolationPart(v1, bindings[1])), 
                            bindLen > 2 && (value += _addInterpolationPart(v2, bindings[2])), bindLen > 3 && (value += _addInterpolationPart(v3, bindings[3])), 
                            bindLen > 4 && (value += _addInterpolationPart(v4, bindings[4])), bindLen > 5 && (value += _addInterpolationPart(v5, bindings[5])), 
                            bindLen > 6 && (value += _addInterpolationPart(v6, bindings[6])), bindLen > 7 && (value += _addInterpolationPart(v7, bindings[7])), 
                            bindLen > 8 && (value += _addInterpolationPart(v8, bindings[8])), bindLen > 9 && (value += _addInterpolationPart(v9, bindings[9]));
                            const renderNode = asTextData(view, def.nodeIndex).renderText;
                            view.renderer.setValue(renderNode, value);
                        }
                        return changed;
                    }(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);

                  case 16384:
                    return function(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
                        const providerData = asProviderData(view, def.nodeIndex), directive = providerData.instance;
                        let changed = !1, changes = void 0;
                        const bindLen = def.bindings.length;
                        return bindLen > 0 && checkBinding(view, def, 0, v0) && (changed = !0, changes = updateProp(view, providerData, def, 0, v0, changes)), 
                        bindLen > 1 && checkBinding(view, def, 1, v1) && (changed = !0, changes = updateProp(view, providerData, def, 1, v1, changes)), 
                        bindLen > 2 && checkBinding(view, def, 2, v2) && (changed = !0, changes = updateProp(view, providerData, def, 2, v2, changes)), 
                        bindLen > 3 && checkBinding(view, def, 3, v3) && (changed = !0, changes = updateProp(view, providerData, def, 3, v3, changes)), 
                        bindLen > 4 && checkBinding(view, def, 4, v4) && (changed = !0, changes = updateProp(view, providerData, def, 4, v4, changes)), 
                        bindLen > 5 && checkBinding(view, def, 5, v5) && (changed = !0, changes = updateProp(view, providerData, def, 5, v5, changes)), 
                        bindLen > 6 && checkBinding(view, def, 6, v6) && (changed = !0, changes = updateProp(view, providerData, def, 6, v6, changes)), 
                        bindLen > 7 && checkBinding(view, def, 7, v7) && (changed = !0, changes = updateProp(view, providerData, def, 7, v7, changes)), 
                        bindLen > 8 && checkBinding(view, def, 8, v8) && (changed = !0, changes = updateProp(view, providerData, def, 8, v8, changes)), 
                        bindLen > 9 && checkBinding(view, def, 9, v9) && (changed = !0, changes = updateProp(view, providerData, def, 9, v9, changes)), 
                        changes && directive.ngOnChanges(changes), 65536 & def.flags && shouldCallLifecycleInitHook(view, 256, def.nodeIndex) && directive.ngOnInit(), 
                        262144 & def.flags && directive.ngDoCheck(), changed;
                    }(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);

                  case 32:
                  case 64:
                  case 128:
                    return function(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
                        const bindings = def.bindings;
                        let changed = !1;
                        const bindLen = bindings.length;
                        if (bindLen > 0 && checkAndUpdateBinding(view, def, 0, v0) && (changed = !0), bindLen > 1 && checkAndUpdateBinding(view, def, 1, v1) && (changed = !0), 
                        bindLen > 2 && checkAndUpdateBinding(view, def, 2, v2) && (changed = !0), bindLen > 3 && checkAndUpdateBinding(view, def, 3, v3) && (changed = !0), 
                        bindLen > 4 && checkAndUpdateBinding(view, def, 4, v4) && (changed = !0), bindLen > 5 && checkAndUpdateBinding(view, def, 5, v5) && (changed = !0), 
                        bindLen > 6 && checkAndUpdateBinding(view, def, 6, v6) && (changed = !0), bindLen > 7 && checkAndUpdateBinding(view, def, 7, v7) && (changed = !0), 
                        bindLen > 8 && checkAndUpdateBinding(view, def, 8, v8) && (changed = !0), bindLen > 9 && checkAndUpdateBinding(view, def, 9, v9) && (changed = !0), 
                        changed) {
                            const data = asPureExpressionData(view, def.nodeIndex);
                            let value;
                            switch (201347067 & def.flags) {
                              case 32:
                                value = [], bindLen > 0 && value.push(v0), bindLen > 1 && value.push(v1), bindLen > 2 && value.push(v2), 
                                bindLen > 3 && value.push(v3), bindLen > 4 && value.push(v4), bindLen > 5 && value.push(v5), 
                                bindLen > 6 && value.push(v6), bindLen > 7 && value.push(v7), bindLen > 8 && value.push(v8), 
                                bindLen > 9 && value.push(v9);
                                break;

                              case 64:
                                value = {}, bindLen > 0 && (value[bindings[0].name] = v0), bindLen > 1 && (value[bindings[1].name] = v1), 
                                bindLen > 2 && (value[bindings[2].name] = v2), bindLen > 3 && (value[bindings[3].name] = v3), 
                                bindLen > 4 && (value[bindings[4].name] = v4), bindLen > 5 && (value[bindings[5].name] = v5), 
                                bindLen > 6 && (value[bindings[6].name] = v6), bindLen > 7 && (value[bindings[7].name] = v7), 
                                bindLen > 8 && (value[bindings[8].name] = v8), bindLen > 9 && (value[bindings[9].name] = v9);
                                break;

                              case 128:
                                const pipe = v0;
                                switch (bindLen) {
                                  case 1:
                                    value = pipe.transform(v0);
                                    break;

                                  case 2:
                                    value = pipe.transform(v1);
                                    break;

                                  case 3:
                                    value = pipe.transform(v1, v2);
                                    break;

                                  case 4:
                                    value = pipe.transform(v1, v2, v3);
                                    break;

                                  case 5:
                                    value = pipe.transform(v1, v2, v3, v4);
                                    break;

                                  case 6:
                                    value = pipe.transform(v1, v2, v3, v4, v5);
                                    break;

                                  case 7:
                                    value = pipe.transform(v1, v2, v3, v4, v5, v6);
                                    break;

                                  case 8:
                                    value = pipe.transform(v1, v2, v3, v4, v5, v6, v7);
                                    break;

                                  case 9:
                                    value = pipe.transform(v1, v2, v3, v4, v5, v6, v7, v8);
                                    break;

                                  case 10:
                                    value = pipe.transform(v1, v2, v3, v4, v5, v6, v7, v8, v9);
                                }
                            }
                            data.value = value;
                        }
                        return changed;
                    }(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);

                  default:
                    throw "unreachable";
                }
            }(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) : function(view, nodeDef, values) {
                switch (201347067 & nodeDef.flags) {
                  case 1:
                    return function(view, def, values) {
                        let changed = !1;
                        for (let i = 0; i < values.length; i++) checkAndUpdateElementValue(view, def, i, values[i]) && (changed = !0);
                        return changed;
                    }(view, nodeDef, values);

                  case 2:
                    return function(view, def, values) {
                        const bindings = def.bindings;
                        let changed = !1;
                        for (let i = 0; i < values.length; i++) checkAndUpdateBinding(view, def, i, values[i]) && (changed = !0);
                        if (changed) {
                            let value = "";
                            for (let i = 0; i < values.length; i++) value += _addInterpolationPart(values[i], bindings[i]);
                            value = def.text.prefix + value;
                            const renderNode = asTextData(view, def.nodeIndex).renderText;
                            view.renderer.setValue(renderNode, value);
                        }
                        return changed;
                    }(view, nodeDef, values);

                  case 16384:
                    return function(view, def, values) {
                        const providerData = asProviderData(view, def.nodeIndex), directive = providerData.instance;
                        let changed = !1, changes = void 0;
                        for (let i = 0; i < values.length; i++) checkBinding(view, def, i, values[i]) && (changed = !0, 
                        changes = updateProp(view, providerData, def, i, values[i], changes));
                        return changes && directive.ngOnChanges(changes), 65536 & def.flags && shouldCallLifecycleInitHook(view, 256, def.nodeIndex) && directive.ngOnInit(), 
                        262144 & def.flags && directive.ngDoCheck(), changed;
                    }(view, nodeDef, values);

                  case 32:
                  case 64:
                  case 128:
                    return function(view, def, values) {
                        const bindings = def.bindings;
                        let changed = !1;
                        for (let i = 0; i < values.length; i++) checkAndUpdateBinding(view, def, i, values[i]) && (changed = !0);
                        if (changed) {
                            const data = asPureExpressionData(view, def.nodeIndex);
                            let value;
                            switch (201347067 & def.flags) {
                              case 32:
                                value = values;
                                break;

                              case 64:
                                value = {};
                                for (let i = 0; i < values.length; i++) value[bindings[i].name] = values[i];
                                break;

                              case 128:
                                const pipe = values[0], params = values.slice(1);
                                value = pipe.transform(...params);
                            }
                            data.value = value;
                        }
                        return changed;
                    }(view, nodeDef, values);

                  default:
                    throw "unreachable";
                }
            }(view, nodeDef, v0);
        }
        function markProjectedViewsForCheck(view) {
            const def = view.def;
            if (4 & def.nodeFlags) for (let i = 0; i < def.nodes.length; i++) {
                const nodeDef = def.nodes[i];
                if (4 & nodeDef.flags) {
                    const projectedViews = asElementData(view, i).template._projectedViews;
                    if (projectedViews) for (let i = 0; i < projectedViews.length; i++) {
                        const projectedView = projectedViews[i];
                        projectedView.state |= 32, markParentViewsForCheckProjectedViews(projectedView, view);
                    }
                } else 0 == (4 & nodeDef.childFlags) && (i += nodeDef.childCount);
            }
        }
        function checkNoChangesNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
            return 0 === argStyle ? function(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
                const bindLen = nodeDef.bindings.length;
                bindLen > 0 && checkBindingNoChanges(view, nodeDef, 0, v0), bindLen > 1 && checkBindingNoChanges(view, nodeDef, 1, v1), 
                bindLen > 2 && checkBindingNoChanges(view, nodeDef, 2, v2), bindLen > 3 && checkBindingNoChanges(view, nodeDef, 3, v3), 
                bindLen > 4 && checkBindingNoChanges(view, nodeDef, 4, v4), bindLen > 5 && checkBindingNoChanges(view, nodeDef, 5, v5), 
                bindLen > 6 && checkBindingNoChanges(view, nodeDef, 6, v6), bindLen > 7 && checkBindingNoChanges(view, nodeDef, 7, v7), 
                bindLen > 8 && checkBindingNoChanges(view, nodeDef, 8, v8), bindLen > 9 && checkBindingNoChanges(view, nodeDef, 9, v9);
            }(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) : function(view, nodeDef, values) {
                for (let i = 0; i < values.length; i++) checkBindingNoChanges(view, nodeDef, i, values[i]);
            }(view, nodeDef, v0), !1;
        }
        function checkNoChangesQuery(view, nodeDef) {
            if (asQueryList(view, nodeDef.nodeIndex).dirty) throw expressionChangedAfterItHasBeenCheckedError(Services.createDebugContext(view, nodeDef.nodeIndex), `Query ${nodeDef.query.id} not dirty`, `Query ${nodeDef.query.id} dirty`, 0 != (1 & view.state));
        }
        function destroyView(view) {
            if (!(128 & view.state)) {
                if (execEmbeddedViewsAction(view, ViewAction.Destroy), execComponentViewsAction(view, ViewAction.Destroy), 
                callLifecycleHooksChildrenFirst(view, 131072), view.disposables) for (let i = 0; i < view.disposables.length; i++) view.disposables[i]();
                !function(view) {
                    if (!(16 & view.state)) return;
                    const dvcElementData = declaredViewContainer(view);
                    if (dvcElementData) {
                        const projectedViews = dvcElementData.template._projectedViews;
                        projectedViews && (removeFromArray(projectedViews, projectedViews.indexOf(view)), 
                        Services.dirtyParentQueries(view));
                    }
                }(view), view.renderer.destroyNode && function(view) {
                    const len = view.def.nodes.length;
                    for (let i = 0; i < len; i++) {
                        const def = view.def.nodes[i];
                        1 & def.flags ? view.renderer.destroyNode(asElementData(view, i).renderElement) : 2 & def.flags ? view.renderer.destroyNode(asTextData(view, i).renderText) : (67108864 & def.flags || 134217728 & def.flags) && asQueryList(view, i).destroy();
                    }
                }(view), isComponentView(view) && view.renderer.destroy(), view.state |= 128;
            }
        }
        const ViewAction = function() {
            var ViewAction = {
                CreateViewNodes: 0,
                CheckNoChanges: 1,
                CheckNoChangesProjectedViews: 2,
                CheckAndUpdate: 3,
                CheckAndUpdateProjectedViews: 4,
                Destroy: 5
            };
            return ViewAction[ViewAction.CreateViewNodes] = "CreateViewNodes", ViewAction[ViewAction.CheckNoChanges] = "CheckNoChanges", 
            ViewAction[ViewAction.CheckNoChangesProjectedViews] = "CheckNoChangesProjectedViews", 
            ViewAction[ViewAction.CheckAndUpdate] = "CheckAndUpdate", ViewAction[ViewAction.CheckAndUpdateProjectedViews] = "CheckAndUpdateProjectedViews", 
            ViewAction[ViewAction.Destroy] = "Destroy", ViewAction;
        }();
        function execComponentViewsAction(view, action) {
            const def = view.def;
            if (33554432 & def.nodeFlags) for (let i = 0; i < def.nodes.length; i++) {
                const nodeDef = def.nodes[i];
                33554432 & nodeDef.flags ? callViewAction(asElementData(view, i).componentView, action) : 0 == (33554432 & nodeDef.childFlags) && (i += nodeDef.childCount);
            }
        }
        function execEmbeddedViewsAction(view, action) {
            const def = view.def;
            if (16777216 & def.nodeFlags) for (let i = 0; i < def.nodes.length; i++) {
                const nodeDef = def.nodes[i];
                if (16777216 & nodeDef.flags) {
                    const embeddedViews = asElementData(view, i).viewContainer._embeddedViews;
                    for (let k = 0; k < embeddedViews.length; k++) callViewAction(embeddedViews[k], action);
                } else 0 == (16777216 & nodeDef.childFlags) && (i += nodeDef.childCount);
            }
        }
        function callViewAction(view, action) {
            const viewState = view.state;
            switch (action) {
              case ViewAction.CheckNoChanges:
                0 == (128 & viewState) && (12 == (12 & viewState) ? checkNoChangesView(view) : 64 & viewState && execProjectedViewsAction(view, ViewAction.CheckNoChangesProjectedViews));
                break;

              case ViewAction.CheckNoChangesProjectedViews:
                0 == (128 & viewState) && (32 & viewState ? checkNoChangesView(view) : 64 & viewState && execProjectedViewsAction(view, action));
                break;

              case ViewAction.CheckAndUpdate:
                0 == (128 & viewState) && (12 == (12 & viewState) ? checkAndUpdateView(view) : 64 & viewState && execProjectedViewsAction(view, ViewAction.CheckAndUpdateProjectedViews));
                break;

              case ViewAction.CheckAndUpdateProjectedViews:
                0 == (128 & viewState) && (32 & viewState ? checkAndUpdateView(view) : 64 & viewState && execProjectedViewsAction(view, action));
                break;

              case ViewAction.Destroy:
                destroyView(view);
                break;

              case ViewAction.CreateViewNodes:
                createViewNodes(view);
            }
        }
        function execProjectedViewsAction(view, action) {
            execEmbeddedViewsAction(view, action), execComponentViewsAction(view, action);
        }
        function execQueriesAction(view, queryFlags, staticDynamicQueryFlag, checkType) {
            if (!(view.def.nodeFlags & queryFlags && view.def.nodeFlags & staticDynamicQueryFlag)) return;
            const nodeCount = view.def.nodes.length;
            for (let i = 0; i < nodeCount; i++) {
                const nodeDef = view.def.nodes[i];
                if (nodeDef.flags & queryFlags && nodeDef.flags & staticDynamicQueryFlag) switch (Services.setCurrentNode(view, nodeDef.nodeIndex), 
                checkType) {
                  case 0:
                    checkAndUpdateQuery(view, nodeDef);
                    break;

                  case 1:
                    checkNoChangesQuery(view, nodeDef);
                }
                nodeDef.childFlags & queryFlags && nodeDef.childFlags & staticDynamicQueryFlag || (i += nodeDef.childCount);
            }
        }
        let initialized = !1;
        function createProdRootView(elInjector, projectableNodes, rootSelectorOrNode, def, ngModule, context) {
            const rendererFactory = ngModule.injector.get(RendererFactory2);
            return createRootView(createRootData(elInjector, ngModule, rendererFactory, projectableNodes, rootSelectorOrNode), def, context);
        }
        function debugCreateRootView(elInjector, projectableNodes, rootSelectorOrNode, def, ngModule, context) {
            const rendererFactory = ngModule.injector.get(RendererFactory2), root = createRootData(elInjector, ngModule, new DebugRendererFactory2(rendererFactory), projectableNodes, rootSelectorOrNode), defWithOverride = applyProviderOverridesToView(def);
            return callWithDebugContext(DebugAction.create, createRootView, null, [ root, defWithOverride, context ]);
        }
        function createRootData(elInjector, ngModule, rendererFactory, projectableNodes, rootSelectorOrNode) {
            const sanitizer = ngModule.injector.get(Sanitizer), errorHandler = ngModule.injector.get(ErrorHandler), renderer = rendererFactory.createRenderer(null, null);
            return {
                ngModule: ngModule,
                injector: elInjector,
                projectableNodes: projectableNodes,
                selectorOrNode: rootSelectorOrNode,
                sanitizer: sanitizer,
                rendererFactory: rendererFactory,
                renderer: renderer,
                errorHandler: errorHandler
            };
        }
        function debugCreateEmbeddedView(parentView, anchorDef, viewDef, context) {
            const defWithOverride = applyProviderOverridesToView(viewDef);
            return callWithDebugContext(DebugAction.create, createEmbeddedView, null, [ parentView, anchorDef, defWithOverride, context ]);
        }
        function debugCreateComponentView(parentView, nodeDef, viewDef, hostElement) {
            return viewDef = viewDefOverrides.get(nodeDef.element.componentProvider.provider.token) || applyProviderOverridesToView(viewDef), 
            callWithDebugContext(DebugAction.create, createComponentView, null, [ parentView, nodeDef, viewDef, hostElement ]);
        }
        function debugCreateNgModuleRef(moduleType, parentInjector, bootstrapComponents, def) {
            return createNgModuleRef(moduleType, parentInjector, bootstrapComponents, function(def) {
                const {hasOverrides: hasOverrides, hasDeprecatedOverrides: hasDeprecatedOverrides} = function(def) {
                    let hasOverrides = !1, hasDeprecatedOverrides = !1;
                    return 0 === providerOverrides.size ? {
                        hasOverrides: hasOverrides,
                        hasDeprecatedOverrides: hasDeprecatedOverrides
                    } : (def.providers.forEach(node => {
                        const override = providerOverrides.get(node.token);
                        3840 & node.flags && override && (hasOverrides = !0, hasDeprecatedOverrides = hasDeprecatedOverrides || override.deprecatedBehavior);
                    }), def.modules.forEach(module => {
                        providerOverridesWithScope.forEach((override, token) => {
                            getInjectableDef(token).providedIn === module && (hasOverrides = !0, hasDeprecatedOverrides = hasDeprecatedOverrides || override.deprecatedBehavior);
                        });
                    }), {
                        hasOverrides: hasOverrides,
                        hasDeprecatedOverrides: hasDeprecatedOverrides
                    });
                }(def);
                return hasOverrides ? (function(def) {
                    for (let i = 0; i < def.providers.length; i++) {
                        const provider = def.providers[i];
                        hasDeprecatedOverrides && (provider.flags |= 4096);
                        const override = providerOverrides.get(provider.token);
                        override && (provider.flags = -3841 & provider.flags | override.flags, provider.deps = splitDepsDsl(override.deps), 
                        provider.value = override.value);
                    }
                    if (providerOverridesWithScope.size > 0) {
                        let moduleSet = new Set(def.modules);
                        providerOverridesWithScope.forEach((override, token) => {
                            if (moduleSet.has(getInjectableDef(token).providedIn)) {
                                let provider = {
                                    token: token,
                                    flags: override.flags | (hasDeprecatedOverrides ? 4096 : 0),
                                    deps: splitDepsDsl(override.deps),
                                    value: override.value,
                                    index: def.providers.length
                                };
                                def.providers.push(provider), def.providersByKey[tokenKey(token)] = provider;
                            }
                        });
                    }
                }(def = def.factory(() => NOOP)), def) : def;
            }(def));
        }
        const providerOverrides = new Map, providerOverridesWithScope = new Map, viewDefOverrides = new Map;
        function debugOverrideProvider(override) {
            let injectableDef;
            providerOverrides.set(override.token, override), "function" == typeof override.token && (injectableDef = getInjectableDef(override.token)) && "function" == typeof injectableDef.providedIn && providerOverridesWithScope.set(override.token, override);
        }
        function debugOverrideComponentView(comp, compFactory) {
            const hostViewDef = resolveDefinition(compFactory.viewDefFactory), compViewDef = resolveDefinition(hostViewDef.nodes[0].element.componentView);
            viewDefOverrides.set(comp, compViewDef);
        }
        function debugClearOverrides() {
            providerOverrides.clear(), providerOverridesWithScope.clear(), viewDefOverrides.clear();
        }
        function applyProviderOverridesToView(def) {
            if (0 === providerOverrides.size) return def;
            const elementIndicesWithOverwrittenProviders = function(def) {
                const elIndicesWithOverwrittenProviders = [];
                let lastElementDef = null;
                for (let i = 0; i < def.nodes.length; i++) {
                    const nodeDef = def.nodes[i];
                    1 & nodeDef.flags && (lastElementDef = nodeDef), lastElementDef && 3840 & nodeDef.flags && providerOverrides.has(nodeDef.provider.token) && (elIndicesWithOverwrittenProviders.push(lastElementDef.nodeIndex), 
                    lastElementDef = null);
                }
                return elIndicesWithOverwrittenProviders;
            }(def);
            if (0 === elementIndicesWithOverwrittenProviders.length) return def;
            def = def.factory(() => NOOP);
            for (let i = 0; i < elementIndicesWithOverwrittenProviders.length; i++) applyProviderOverridesToElement(def, elementIndicesWithOverwrittenProviders[i]);
            return def;
            function applyProviderOverridesToElement(viewDef, elIndex) {
                for (let i = elIndex + 1; i < viewDef.nodes.length; i++) {
                    const nodeDef = viewDef.nodes[i];
                    if (1 & nodeDef.flags) return;
                    if (3840 & nodeDef.flags) {
                        const provider = nodeDef.provider, override = providerOverrides.get(provider.token);
                        override && (nodeDef.flags = -3841 & nodeDef.flags | override.flags, provider.deps = splitDepsDsl(override.deps), 
                        provider.value = override.value);
                    }
                }
            }
        }
        function prodCheckAndUpdateNode(view, checkIndex, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
            const nodeDef = view.def.nodes[checkIndex];
            return checkAndUpdateNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9), 
            224 & nodeDef.flags ? asPureExpressionData(view, checkIndex).value : void 0;
        }
        function prodCheckNoChangesNode(view, checkIndex, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
            const nodeDef = view.def.nodes[checkIndex];
            return checkNoChangesNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9), 
            224 & nodeDef.flags ? asPureExpressionData(view, checkIndex).value : void 0;
        }
        function debugCheckAndUpdateView(view) {
            return callWithDebugContext(DebugAction.detectChanges, checkAndUpdateView, null, [ view ]);
        }
        function debugCheckNoChangesView(view) {
            return callWithDebugContext(DebugAction.checkNoChanges, checkNoChangesView, null, [ view ]);
        }
        function debugDestroyView(view) {
            return callWithDebugContext(DebugAction.destroy, destroyView, null, [ view ]);
        }
        const DebugAction = function() {
            var DebugAction = {
                create: 0,
                detectChanges: 1,
                checkNoChanges: 2,
                destroy: 3,
                handleEvent: 4
            };
            return DebugAction[DebugAction.create] = "create", DebugAction[DebugAction.detectChanges] = "detectChanges", 
            DebugAction[DebugAction.checkNoChanges] = "checkNoChanges", DebugAction[DebugAction.destroy] = "destroy", 
            DebugAction[DebugAction.handleEvent] = "handleEvent", DebugAction;
        }();
        let _currentAction, _currentView, _currentNodeIndex;
        function debugSetCurrentNode(view, nodeIndex) {
            _currentView = view, _currentNodeIndex = nodeIndex;
        }
        function debugHandleEvent(view, nodeIndex, eventName, event) {
            return debugSetCurrentNode(view, nodeIndex), callWithDebugContext(DebugAction.handleEvent, view.def.handleEvent, null, [ view, nodeIndex, eventName, event ]);
        }
        function debugUpdateDirectives(view, checkType) {
            if (128 & view.state) throw viewDestroyedError(DebugAction[_currentAction]);
            return debugSetCurrentNode(view, nextDirectiveWithBinding(view, 0)), view.def.updateDirectives((function(view, nodeIndex, argStyle, ...values) {
                const nodeDef = view.def.nodes[nodeIndex];
                return 0 === checkType ? debugCheckAndUpdateNode(view, nodeDef, argStyle, values) : debugCheckNoChangesNode(view, nodeDef, argStyle, values), 
                16384 & nodeDef.flags && debugSetCurrentNode(view, nextDirectiveWithBinding(view, nodeIndex)), 
                224 & nodeDef.flags ? asPureExpressionData(view, nodeDef.nodeIndex).value : void 0;
            }), view);
        }
        function debugUpdateRenderer(view, checkType) {
            if (128 & view.state) throw viewDestroyedError(DebugAction[_currentAction]);
            return debugSetCurrentNode(view, nextRenderNodeWithBinding(view, 0)), view.def.updateRenderer((function(view, nodeIndex, argStyle, ...values) {
                const nodeDef = view.def.nodes[nodeIndex];
                return 0 === checkType ? debugCheckAndUpdateNode(view, nodeDef, argStyle, values) : debugCheckNoChangesNode(view, nodeDef, argStyle, values), 
                3 & nodeDef.flags && debugSetCurrentNode(view, nextRenderNodeWithBinding(view, nodeIndex)), 
                224 & nodeDef.flags ? asPureExpressionData(view, nodeDef.nodeIndex).value : void 0;
            }), view);
        }
        function debugCheckAndUpdateNode(view, nodeDef, argStyle, givenValues) {
            if (checkAndUpdateNode(view, nodeDef, argStyle, ...givenValues)) {
                const values = 1 === argStyle ? givenValues[0] : givenValues;
                if (16384 & nodeDef.flags) {
                    const bindingValues = {};
                    for (let i = 0; i < nodeDef.bindings.length; i++) {
                        const binding = nodeDef.bindings[i], value = values[i];
                        8 & binding.flags && (bindingValues[(name = binding.nonMinifiedName, input = void 0, 
                        input = name.replace(/[$@]/g, "_"), `ng-reflect-${name = input.replace(CAMEL_CASE_REGEXP, (...m) => "-" + m[1].toLowerCase())}`)] = normalizeDebugBindingValue(value));
                    }
                    const elDef = nodeDef.parent, el = asElementData(view, elDef.nodeIndex).renderElement;
                    if (elDef.element.name) for (let attr in bindingValues) {
                        const value = bindingValues[attr];
                        null != value ? view.renderer.setAttribute(el, attr, value) : view.renderer.removeAttribute(el, attr);
                    } else view.renderer.setValue(el, `bindings=${JSON.stringify(bindingValues, null, 2)}`);
                }
            }
            var name, input;
        }
        function debugCheckNoChangesNode(view, nodeDef, argStyle, values) {
            checkNoChangesNode(view, nodeDef, argStyle, ...values);
        }
        function nextDirectiveWithBinding(view, nodeIndex) {
            for (let i = nodeIndex; i < view.def.nodes.length; i++) {
                const nodeDef = view.def.nodes[i];
                if (16384 & nodeDef.flags && nodeDef.bindings && nodeDef.bindings.length) return i;
            }
            return null;
        }
        function nextRenderNodeWithBinding(view, nodeIndex) {
            for (let i = nodeIndex; i < view.def.nodes.length; i++) {
                const nodeDef = view.def.nodes[i];
                if (3 & nodeDef.flags && nodeDef.bindings && nodeDef.bindings.length) return i;
            }
            return null;
        }
        class DebugContext_ {
            constructor(view, nodeIndex) {
                this.view = view, this.nodeIndex = nodeIndex, null == nodeIndex && (this.nodeIndex = nodeIndex = 0), 
                this.nodeDef = view.def.nodes[nodeIndex];
                let elDef = this.nodeDef, elView = view;
                for (;elDef && 0 == (1 & elDef.flags); ) elDef = elDef.parent;
                if (!elDef) for (;!elDef && elView; ) elDef = viewParentEl(elView), elView = elView.parent;
                this.elDef = elDef, this.elView = elView;
            }
            get elOrCompView() {
                return asElementData(this.elView, this.elDef.nodeIndex).componentView || this.view;
            }
            get injector() {
                return createInjector$1(this.elView, this.elDef);
            }
            get component() {
                return this.elOrCompView.component;
            }
            get context() {
                return this.elOrCompView.context;
            }
            get providerTokens() {
                const tokens = [];
                if (this.elDef) for (let i = this.elDef.nodeIndex + 1; i <= this.elDef.nodeIndex + this.elDef.childCount; i++) {
                    const childDef = this.elView.def.nodes[i];
                    20224 & childDef.flags && tokens.push(childDef.provider.token), i += childDef.childCount;
                }
                return tokens;
            }
            get references() {
                const references = {};
                if (this.elDef) {
                    collectReferences(this.elView, this.elDef, references);
                    for (let i = this.elDef.nodeIndex + 1; i <= this.elDef.nodeIndex + this.elDef.childCount; i++) {
                        const childDef = this.elView.def.nodes[i];
                        20224 & childDef.flags && collectReferences(this.elView, childDef, references), 
                        i += childDef.childCount;
                    }
                }
                return references;
            }
            get componentRenderElement() {
                const elData = function(view) {
                    for (;view && !isComponentView(view); ) view = view.parent;
                    return view.parent ? asElementData(view.parent, viewParentEl(view).nodeIndex) : null;
                }(this.elOrCompView);
                return elData ? elData.renderElement : void 0;
            }
            get renderNode() {
                return 2 & this.nodeDef.flags ? renderNode(this.view, this.nodeDef) : renderNode(this.elView, this.elDef);
            }
            logError(console, ...values) {
                let logViewDef, logNodeIndex;
                2 & this.nodeDef.flags ? (logViewDef = this.view.def, logNodeIndex = this.nodeDef.nodeIndex) : (logViewDef = this.elView.def, 
                logNodeIndex = this.elDef.nodeIndex);
                const renderNodeIndex = function(viewDef, nodeIndex) {
                    let renderNodeIndex = -1;
                    for (let i = 0; i <= nodeIndex; i++) 3 & viewDef.nodes[i].flags && renderNodeIndex++;
                    return renderNodeIndex;
                }(logViewDef, logNodeIndex);
                let currRenderNodeIndex = -1;
                logViewDef.factory(() => ++currRenderNodeIndex === renderNodeIndex ? console.error.bind(console, ...values) : NOOP), 
                currRenderNodeIndex < renderNodeIndex && (console.error("Illegal state: the ViewDefinitionFactory did not call the logger!"), 
                console.error(...values));
            }
        }
        function collectReferences(view, nodeDef, references) {
            for (let refName in nodeDef.references) references[refName] = getQueryValue(view, nodeDef, nodeDef.references[refName]);
        }
        function callWithDebugContext(action, fn, self, args) {
            const oldAction = _currentAction, oldView = _currentView, oldNodeIndex = _currentNodeIndex;
            try {
                _currentAction = action;
                const result = fn.apply(self, args);
                return _currentView = oldView, _currentNodeIndex = oldNodeIndex, _currentAction = oldAction, 
                result;
            } catch (e) {
                if (getDebugContext(e) || !_currentView) throw e;
                throw err = e, context = getCurrentDebugContext(), err instanceof Error || (err = new Error(err.toString())), 
                _addDebugContext(err, context), err;
            }
            var err, context;
        }
        function getCurrentDebugContext() {
            return _currentView ? new DebugContext_(_currentView, _currentNodeIndex) : null;
        }
        class DebugRendererFactory2 {
            constructor(delegate) {
                this.delegate = delegate;
            }
            createRenderer(element, renderData) {
                return new DebugRenderer2(this.delegate.createRenderer(element, renderData));
            }
            begin() {
                this.delegate.begin && this.delegate.begin();
            }
            end() {
                this.delegate.end && this.delegate.end();
            }
            whenRenderingDone() {
                return this.delegate.whenRenderingDone ? this.delegate.whenRenderingDone() : Promise.resolve(null);
            }
        }
        class DebugRenderer2 {
            constructor(delegate) {
                this.delegate = delegate, this.debugContextFactory = getCurrentDebugContext, this.data = this.delegate.data;
            }
            createDebugContext(nativeElement) {
                return this.debugContextFactory(nativeElement);
            }
            destroyNode(node) {
                const debugNode = getDebugNode$1(node);
                !function(node) {
                    _nativeNodeToDebugNode.delete(node.nativeNode);
                }(debugNode), debugNode instanceof DebugNode__PRE_R3__ && (debugNode.listeners.length = 0), 
                this.delegate.destroyNode && this.delegate.destroyNode(node);
            }
            destroy() {
                this.delegate.destroy();
            }
            createElement(name, namespace) {
                const el = this.delegate.createElement(name, namespace), debugCtx = this.createDebugContext(el);
                if (debugCtx) {
                    const debugEl = new DebugElement__PRE_R3__(el, null, debugCtx);
                    debugEl.name = name, indexDebugNode(debugEl);
                }
                return el;
            }
            createComment(value) {
                const comment = this.delegate.createComment(value), debugCtx = this.createDebugContext(comment);
                return debugCtx && indexDebugNode(new DebugNode__PRE_R3__(comment, null, debugCtx)), 
                comment;
            }
            createText(value) {
                const text = this.delegate.createText(value), debugCtx = this.createDebugContext(text);
                return debugCtx && indexDebugNode(new DebugNode__PRE_R3__(text, null, debugCtx)), 
                text;
            }
            appendChild(parent, newChild) {
                const debugEl = getDebugNode$1(parent), debugChildEl = getDebugNode$1(newChild);
                debugEl && debugChildEl && debugEl instanceof DebugElement__PRE_R3__ && debugEl.addChild(debugChildEl), 
                this.delegate.appendChild(parent, newChild);
            }
            insertBefore(parent, newChild, refChild) {
                const debugEl = getDebugNode$1(parent), debugChildEl = getDebugNode$1(newChild), debugRefEl = getDebugNode$1(refChild);
                debugEl && debugChildEl && debugEl instanceof DebugElement__PRE_R3__ && debugEl.insertBefore(debugRefEl, debugChildEl), 
                this.delegate.insertBefore(parent, newChild, refChild);
            }
            removeChild(parent, oldChild) {
                const debugEl = getDebugNode$1(parent), debugChildEl = getDebugNode$1(oldChild);
                debugEl && debugChildEl && debugEl instanceof DebugElement__PRE_R3__ && debugEl.removeChild(debugChildEl), 
                this.delegate.removeChild(parent, oldChild);
            }
            selectRootElement(selectorOrNode, preserveContent) {
                const el = this.delegate.selectRootElement(selectorOrNode, preserveContent), debugCtx = getCurrentDebugContext();
                return debugCtx && indexDebugNode(new DebugElement__PRE_R3__(el, null, debugCtx)), 
                el;
            }
            setAttribute(el, name, value, namespace) {
                const debugEl = getDebugNode$1(el);
                debugEl && debugEl instanceof DebugElement__PRE_R3__ && (debugEl.attributes[namespace ? namespace + ":" + name : name] = value), 
                this.delegate.setAttribute(el, name, value, namespace);
            }
            removeAttribute(el, name, namespace) {
                const debugEl = getDebugNode$1(el);
                debugEl && debugEl instanceof DebugElement__PRE_R3__ && (debugEl.attributes[namespace ? namespace + ":" + name : name] = null), 
                this.delegate.removeAttribute(el, name, namespace);
            }
            addClass(el, name) {
                const debugEl = getDebugNode$1(el);
                debugEl && debugEl instanceof DebugElement__PRE_R3__ && (debugEl.classes[name] = !0), 
                this.delegate.addClass(el, name);
            }
            removeClass(el, name) {
                const debugEl = getDebugNode$1(el);
                debugEl && debugEl instanceof DebugElement__PRE_R3__ && (debugEl.classes[name] = !1), 
                this.delegate.removeClass(el, name);
            }
            setStyle(el, style, value, flags) {
                const debugEl = getDebugNode$1(el);
                debugEl && debugEl instanceof DebugElement__PRE_R3__ && (debugEl.styles[style] = value), 
                this.delegate.setStyle(el, style, value, flags);
            }
            removeStyle(el, style, flags) {
                const debugEl = getDebugNode$1(el);
                debugEl && debugEl instanceof DebugElement__PRE_R3__ && (debugEl.styles[style] = null), 
                this.delegate.removeStyle(el, style, flags);
            }
            setProperty(el, name, value) {
                const debugEl = getDebugNode$1(el);
                debugEl && debugEl instanceof DebugElement__PRE_R3__ && (debugEl.properties[name] = value), 
                this.delegate.setProperty(el, name, value);
            }
            listen(target, eventName, callback) {
                if ("string" != typeof target) {
                    const debugEl = getDebugNode$1(target);
                    debugEl && debugEl.listeners.push(new DebugEventListener(eventName, callback));
                }
                return this.delegate.listen(target, eventName, callback);
            }
            parentNode(node) {
                return this.delegate.parentNode(node);
            }
            nextSibling(node) {
                return this.delegate.nextSibling(node);
            }
            setValue(node, value) {
                return this.delegate.setValue(node, value);
            }
        }
        function createNgModuleFactory(ngModuleType, bootstrapComponents, defFactory) {
            return new NgModuleFactory_(ngModuleType, bootstrapComponents, defFactory);
        }
        class NgModuleFactory_ extends NgModuleFactory {
            constructor(moduleType, _bootstrapComponents, _ngModuleDefFactory) {
                super(), this.moduleType = moduleType, this._bootstrapComponents = _bootstrapComponents, 
                this._ngModuleDefFactory = _ngModuleDefFactory;
            }
            create(parentInjector) {
                !function() {
                    if (initialized) return;
                    initialized = !0;
                    const services = isDevMode() ? {
                        setCurrentNode: debugSetCurrentNode,
                        createRootView: debugCreateRootView,
                        createEmbeddedView: debugCreateEmbeddedView,
                        createComponentView: debugCreateComponentView,
                        createNgModuleRef: debugCreateNgModuleRef,
                        overrideProvider: debugOverrideProvider,
                        overrideComponentView: debugOverrideComponentView,
                        clearOverrides: debugClearOverrides,
                        checkAndUpdateView: debugCheckAndUpdateView,
                        checkNoChangesView: debugCheckNoChangesView,
                        destroyView: debugDestroyView,
                        createDebugContext: (view, nodeIndex) => new DebugContext_(view, nodeIndex),
                        handleEvent: debugHandleEvent,
                        updateDirectives: debugUpdateDirectives,
                        updateRenderer: debugUpdateRenderer
                    } : {
                        setCurrentNode: () => {},
                        createRootView: createProdRootView,
                        createEmbeddedView: createEmbeddedView,
                        createComponentView: createComponentView,
                        createNgModuleRef: createNgModuleRef,
                        overrideProvider: NOOP,
                        overrideComponentView: NOOP,
                        clearOverrides: NOOP,
                        checkAndUpdateView: checkAndUpdateView,
                        checkNoChangesView: checkNoChangesView,
                        destroyView: destroyView,
                        createDebugContext: (view, nodeIndex) => new DebugContext_(view, nodeIndex),
                        handleEvent: (view, nodeIndex, eventName, event) => view.def.handleEvent(view, nodeIndex, eventName, event),
                        updateDirectives: (view, checkType) => view.def.updateDirectives(0 === checkType ? prodCheckAndUpdateNode : prodCheckNoChangesNode, view),
                        updateRenderer: (view, checkType) => view.def.updateRenderer(0 === checkType ? prodCheckAndUpdateNode : prodCheckNoChangesNode, view)
                    };
                    Services.setCurrentNode = services.setCurrentNode, Services.createRootView = services.createRootView, 
                    Services.createEmbeddedView = services.createEmbeddedView, Services.createComponentView = services.createComponentView, 
                    Services.createNgModuleRef = services.createNgModuleRef, Services.overrideProvider = services.overrideProvider, 
                    Services.overrideComponentView = services.overrideComponentView, Services.clearOverrides = services.clearOverrides, 
                    Services.checkAndUpdateView = services.checkAndUpdateView, Services.checkNoChangesView = services.checkNoChangesView, 
                    Services.destroyView = services.destroyView, Services.resolveDep = resolveDep, Services.createDebugContext = services.createDebugContext, 
                    Services.handleEvent = services.handleEvent, Services.updateDirectives = services.updateDirectives, 
                    Services.updateRenderer = services.updateRenderer, Services.dirtyParentQueries = dirtyParentQueries;
                }();
                const def = function(def) {
                    const providers = Array.from(def.providers), modules = Array.from(def.modules), providersByKey = {};
                    for (const key in def.providersByKey) providersByKey[key] = def.providersByKey[key];
                    return {
                        factory: def.factory,
                        scope: def.scope,
                        providers: providers,
                        modules: modules,
                        providersByKey: providersByKey
                    };
                }(resolveDefinition(this._ngModuleDefFactory));
                return Services.createNgModuleRef(this.moduleType, parentInjector || Injector.NULL, this._bootstrapComponents, def);
            }
        }
    