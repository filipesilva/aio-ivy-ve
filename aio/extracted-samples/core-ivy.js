        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return ANALYZE_FOR_ENTRY_COMPONENTS;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return APP_BOOTSTRAP_LISTENER;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return APP_ID;
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return APP_INITIALIZER;
        })), __webpack_require__.d(__webpack_exports__, "e", (function() {
            return ApplicationInitStatus;
        })), __webpack_require__.d(__webpack_exports__, "f", (function() {
            return ApplicationModule;
        })), __webpack_require__.d(__webpack_exports__, "g", (function() {
            return ApplicationRef;
        })), __webpack_require__.d(__webpack_exports__, "h", (function() {
            return ChangeDetectorRef;
        })), __webpack_require__.d(__webpack_exports__, "i", (function() {
            return Compiler;
        })), __webpack_require__.d(__webpack_exports__, "j", (function() {
            return ComponentFactoryResolver;
        })), __webpack_require__.d(__webpack_exports__, "k", (function() {
            return ElementRef;
        })), __webpack_require__.d(__webpack_exports__, "l", (function() {
            return ErrorHandler;
        })), __webpack_require__.d(__webpack_exports__, "m", (function() {
            return EventEmitter;
        })), __webpack_require__.d(__webpack_exports__, "n", (function() {
            return INJECTOR;
        })), __webpack_require__.d(__webpack_exports__, "o", (function() {
            return Inject;
        })), __webpack_require__.d(__webpack_exports__, "p", (function() {
            return InjectionToken;
        })), __webpack_require__.d(__webpack_exports__, "q", (function() {
            return Injector;
        })), __webpack_require__.d(__webpack_exports__, "r", (function() {
            return IterableDiffers;
        })), __webpack_require__.d(__webpack_exports__, "s", (function() {
            return KeyValueDiffers;
        })), __webpack_require__.d(__webpack_exports__, "t", (function() {
            return LOCALE_ID$1;
        })), __webpack_require__.d(__webpack_exports__, "u", (function() {
            return NgModuleFactory;
        })), __webpack_require__.d(__webpack_exports__, "v", (function() {
            return NgModuleFactoryLoader;
        })), __webpack_require__.d(__webpack_exports__, "w", (function() {
            return NgModuleRef;
        })), __webpack_require__.d(__webpack_exports__, "x", (function() {
            return NgProbeToken;
        })), __webpack_require__.d(__webpack_exports__, "y", (function() {
            return NgZone;
        })), __webpack_require__.d(__webpack_exports__, "z", (function() {
            return Optional;
        })), __webpack_require__.d(__webpack_exports__, "A", (function() {
            return PLATFORM_ID;
        })), __webpack_require__.d(__webpack_exports__, "B", (function() {
            return PLATFORM_INITIALIZER;
        })), __webpack_require__.d(__webpack_exports__, "C", (function() {
            return QueryList;
        })), __webpack_require__.d(__webpack_exports__, "D", (function() {
            return Renderer2;
        })), __webpack_require__.d(__webpack_exports__, "E", (function() {
            return RendererFactory2;
        })), __webpack_require__.d(__webpack_exports__, "F", (function() {
            return RendererStyleFlags2;
        })), __webpack_require__.d(__webpack_exports__, "G", (function() {
            return Sanitizer;
        })), __webpack_require__.d(__webpack_exports__, "H", (function() {
            return SecurityContext;
        })), __webpack_require__.d(__webpack_exports__, "I", (function() {
            return SimpleChange;
        })), __webpack_require__.d(__webpack_exports__, "J", (function() {
            return SkipSelf;
        })), __webpack_require__.d(__webpack_exports__, "K", (function() {
            return SystemJsNgModuleLoader;
        })), __webpack_require__.d(__webpack_exports__, "L", (function() {
            return TemplateRef;
        })), __webpack_require__.d(__webpack_exports__, "M", (function() {
            return Testability;
        })), __webpack_require__.d(__webpack_exports__, "N", (function() {
            return Version;
        })), __webpack_require__.d(__webpack_exports__, "O", (function() {
            return ViewContainerRef;
        })), __webpack_require__.d(__webpack_exports__, "P", (function() {
            return ViewEncapsulation$1;
        })), __webpack_require__.d(__webpack_exports__, "Q", (function() {
            return WrappedValue;
        })), __webpack_require__.d(__webpack_exports__, "R", (function() {
            return createPlatformFactory;
        })), __webpack_require__.d(__webpack_exports__, "S", (function() {
            return enableProdMode;
        })), __webpack_require__.d(__webpack_exports__, "T", (function() {
            return forwardRef;
        })), __webpack_require__.d(__webpack_exports__, "U", (function() {
            return getDebugNode$1;
        })), __webpack_require__.d(__webpack_exports__, "V", (function() {
            return inject;
        })), __webpack_require__.d(__webpack_exports__, "W", (function() {
            return isDevMode;
        })), __webpack_require__.d(__webpack_exports__, "X", (function() {
            return platformCore;
        })), __webpack_require__.d(__webpack_exports__, "Y", (function() {
            return setTestabilityGetter;
        })), __webpack_require__.d(__webpack_exports__, "Z", (function() {
            return Console;
        })), __webpack_require__.d(__webpack_exports__, "ab", (function() {
            return INJECTOR_SCOPE;
        })), __webpack_require__.d(__webpack_exports__, "bb", (function() {
            return LocaleDataIndex;
        })), __webpack_require__.d(__webpack_exports__, "cb", (function() {
            return _sanitizeHtml;
        })), __webpack_require__.d(__webpack_exports__, "db", (function() {
            return _sanitizeStyle;
        })), __webpack_require__.d(__webpack_exports__, "eb", (function() {
            return _sanitizeUrl;
        })), __webpack_require__.d(__webpack_exports__, "fb", (function() {
            return allowSanitizationBypassAndThrow;
        })), __webpack_require__.d(__webpack_exports__, "gb", (function() {
            return bypassSanitizationTrustHtml;
        })), __webpack_require__.d(__webpack_exports__, "hb", (function() {
            return bypassSanitizationTrustResourceUrl;
        })), __webpack_require__.d(__webpack_exports__, "ib", (function() {
            return bypassSanitizationTrustScript;
        })), __webpack_require__.d(__webpack_exports__, "jb", (function() {
            return bypassSanitizationTrustStyle;
        })), __webpack_require__.d(__webpack_exports__, "kb", (function() {
            return bypassSanitizationTrustUrl;
        })), __webpack_require__.d(__webpack_exports__, "lb", (function() {
            return findLocaleData;
        })), __webpack_require__.d(__webpack_exports__, "mb", (function() {
            return getLocalePluralCase;
        })), __webpack_require__.d(__webpack_exports__, "nb", (function() {
            return getSanitizationBypassType;
        })), __webpack_require__.d(__webpack_exports__, "ob", (function() {
            return _global;
        })), __webpack_require__.d(__webpack_exports__, "pb", (function() {
            return isListLikeIterable$1;
        })), __webpack_require__.d(__webpack_exports__, "qb", (function() {
            return isObservable;
        })), __webpack_require__.d(__webpack_exports__, "rb", (function() {
            return isPromise;
        })), __webpack_require__.d(__webpack_exports__, "sb", (function() {
            return looseIdentical;
        })), __webpack_require__.d(__webpack_exports__, "tb", (function() {
            return registerLocaleData;
        })), __webpack_require__.d(__webpack_exports__, "ub", (function() {
            return setDocument;
        })), __webpack_require__.d(__webpack_exports__, "vb", (function() {
            return stringify;
        })), __webpack_require__.d(__webpack_exports__, "wb", (function() {
            return unwrapSafeValue;
        })), __webpack_require__.d(__webpack_exports__, "xb", (function() {
            return ɵɵInheritDefinitionFeature;
        })), __webpack_require__.d(__webpack_exports__, "yb", (function() {
            return ɵɵNgOnChangesFeature;
        })), __webpack_require__.d(__webpack_exports__, "zb", (function() {
            return ɵɵProvidersFeature;
        })), __webpack_require__.d(__webpack_exports__, "Ab", (function() {
            return ɵɵadvance;
        })), __webpack_require__.d(__webpack_exports__, "Bb", (function() {
            return ɵɵallocHostVars;
        })), __webpack_require__.d(__webpack_exports__, "Cb", (function() {
            return ɵɵattribute;
        })), __webpack_require__.d(__webpack_exports__, "Db", (function() {
            return ɵɵclassMap;
        })), __webpack_require__.d(__webpack_exports__, "Eb", (function() {
            return ɵɵclassMapInterpolate1;
        })), __webpack_require__.d(__webpack_exports__, "Fb", (function() {
            return ɵɵclassProp;
        })), __webpack_require__.d(__webpack_exports__, "Gb", (function() {
            return ɵɵcomponentHostSyntheticListener;
        })), __webpack_require__.d(__webpack_exports__, "Hb", (function() {
            return ɵɵcontentQuery;
        })), __webpack_require__.d(__webpack_exports__, "Ib", (function() {
            return ɵɵdefaultStyleSanitizer;
        })), __webpack_require__.d(__webpack_exports__, "Jb", (function() {
            return ɵɵdefineComponent;
        })), __webpack_require__.d(__webpack_exports__, "Kb", (function() {
            return ɵɵdefineDirective;
        })), __webpack_require__.d(__webpack_exports__, "Lb", (function() {
            return ɵɵdefineInjectable;
        })), __webpack_require__.d(__webpack_exports__, "Mb", (function() {
            return ɵɵdefineInjector;
        })), __webpack_require__.d(__webpack_exports__, "Nb", (function() {
            return ɵɵdefineNgModule;
        })), __webpack_require__.d(__webpack_exports__, "Ob", (function() {
            return ɵɵdefinePipe;
        })), __webpack_require__.d(__webpack_exports__, "Pb", (function() {
            return ɵɵdirectiveInject;
        })), __webpack_require__.d(__webpack_exports__, "Qb", (function() {
            return ɵɵelement;
        })), __webpack_require__.d(__webpack_exports__, "Rb", (function() {
            return ɵɵelementContainerEnd;
        })), __webpack_require__.d(__webpack_exports__, "Sb", (function() {
            return ɵɵelementContainerStart;
        })), __webpack_require__.d(__webpack_exports__, "Tb", (function() {
            return ɵɵelementEnd;
        })), __webpack_require__.d(__webpack_exports__, "Ub", (function() {
            return ɵɵelementHostAttrs;
        })), __webpack_require__.d(__webpack_exports__, "Vb", (function() {
            return ɵɵelementStart;
        })), __webpack_require__.d(__webpack_exports__, "Wb", (function() {
            return ɵɵgetCurrentView;
        })), __webpack_require__.d(__webpack_exports__, "Xb", (function() {
            return ɵɵgetInheritedFactory;
        })), __webpack_require__.d(__webpack_exports__, "Yb", (function() {
            return ɵɵhostProperty;
        })), __webpack_require__.d(__webpack_exports__, "Zb", (function() {
            return ɵɵinject;
        })), __webpack_require__.d(__webpack_exports__, "ac", (function() {
            return ɵɵinjectAttribute;
        })), __webpack_require__.d(__webpack_exports__, "bc", (function() {
            return ɵɵinvalidFactory;
        })), __webpack_require__.d(__webpack_exports__, "cc", (function() {
            return ɵɵlistener;
        })), __webpack_require__.d(__webpack_exports__, "dc", (function() {
            return ɵɵloadQuery;
        })), __webpack_require__.d(__webpack_exports__, "ec", (function() {
            return ɵɵnamespaceHTML;
        })), __webpack_require__.d(__webpack_exports__, "fc", (function() {
            return ɵɵnamespaceSVG;
        })), __webpack_require__.d(__webpack_exports__, "gc", (function() {
            return ɵɵnextContext;
        })), __webpack_require__.d(__webpack_exports__, "hc", (function() {
            return ɵɵpipe;
        })), __webpack_require__.d(__webpack_exports__, "ic", (function() {
            return ɵɵpipeBind1;
        })), __webpack_require__.d(__webpack_exports__, "jc", (function() {
            return ɵɵprojection;
        })), __webpack_require__.d(__webpack_exports__, "kc", (function() {
            return ɵɵprojectionDef;
        })), __webpack_require__.d(__webpack_exports__, "lc", (function() {
            return ɵɵproperty;
        })), __webpack_require__.d(__webpack_exports__, "mc", (function() {
            return ɵɵpropertyInterpolate;
        })), __webpack_require__.d(__webpack_exports__, "nc", (function() {
            return ɵɵpropertyInterpolate1;
        })), __webpack_require__.d(__webpack_exports__, "oc", (function() {
            return ɵɵpureFunction1;
        })), __webpack_require__.d(__webpack_exports__, "pc", (function() {
            return ɵɵpureFunction2;
        })), __webpack_require__.d(__webpack_exports__, "qc", (function() {
            return ɵɵqueryRefresh;
        })), __webpack_require__.d(__webpack_exports__, "rc", (function() {
            return ɵɵreference;
        })), __webpack_require__.d(__webpack_exports__, "sc", (function() {
            return ɵɵresolveDocument;
        })), __webpack_require__.d(__webpack_exports__, "tc", (function() {
            return ɵɵresolveWindow;
        })), __webpack_require__.d(__webpack_exports__, "uc", (function() {
            return ɵɵrestoreView;
        })), __webpack_require__.d(__webpack_exports__, "vc", (function() {
            return ɵɵsanitizeHtml;
        })), __webpack_require__.d(__webpack_exports__, "wc", (function() {
            return ɵɵsanitizeUrl;
        })), __webpack_require__.d(__webpack_exports__, "xc", (function() {
            return ɵɵstaticContentQuery;
        })), __webpack_require__.d(__webpack_exports__, "yc", (function() {
            return ɵɵstaticViewQuery;
        })), __webpack_require__.d(__webpack_exports__, "zc", (function() {
            return ɵɵstyleMap;
        })), __webpack_require__.d(__webpack_exports__, "Ac", (function() {
            return ɵɵstyleProp;
        })), __webpack_require__.d(__webpack_exports__, "Bc", (function() {
            return ɵɵstyleSanitizer;
        })), __webpack_require__.d(__webpack_exports__, "Cc", (function() {
            return ɵɵtemplate;
        })), __webpack_require__.d(__webpack_exports__, "Dc", (function() {
            return ɵɵtemplateRefExtractor;
        })), __webpack_require__.d(__webpack_exports__, "Ec", (function() {
            return ɵɵtext;
        })), __webpack_require__.d(__webpack_exports__, "Fc", (function() {
            return ɵɵtextInterpolate;
        })), __webpack_require__.d(__webpack_exports__, "Gc", (function() {
            return ɵɵtextInterpolate1;
        })), __webpack_require__.d(__webpack_exports__, "Hc", (function() {
            return ɵɵtextInterpolate2;
        })), __webpack_require__.d(__webpack_exports__, "Ic", (function() {
            return ɵɵupdateSyntheticHostBinding;
        })), __webpack_require__.d(__webpack_exports__, "Jc", (function() {
            return ɵɵviewQuery;
        }));
        var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("XNiG"), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("quSY"), rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("HDdC"), rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("VRyK"), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("w1tV");
        const PARAMETERS = "__parameters__";
        function makeParamDecorator(name, props, parentClass) {
            const metaCtor = function(props) {
                return function(...args) {
                    if (props) {
                        const values = props(...args);
                        for (const propName in values) this[propName] = values[propName];
                    }
                };
            }(props);
            function ParamDecoratorFactory(...args) {
                if (this instanceof ParamDecoratorFactory) return metaCtor.apply(this, args), this;
                const annotationInstance = new ParamDecoratorFactory(...args);
                return ParamDecorator.annotation = annotationInstance, ParamDecorator;
                function ParamDecorator(cls, unusedKey, index) {
                    const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, {
                        value: []
                    })[PARAMETERS];
                    for (;parameters.length <= index; ) parameters.push(null);
                    return (parameters[index] = parameters[index] || []).push(annotationInstance), cls;
                }
            }
            return parentClass && (ParamDecoratorFactory.prototype = Object.create(parentClass.prototype)), 
            ParamDecoratorFactory.prototype.ngMetadataName = name, ParamDecoratorFactory.annotationCls = ParamDecoratorFactory, 
            ParamDecoratorFactory;
        }
        const Inject = makeParamDecorator("Inject", token => ({
            token: token
        })), Optional = makeParamDecorator("Optional"), Self = makeParamDecorator("Self"), SkipSelf = makeParamDecorator("SkipSelf");
        var InjectFlags = function(InjectFlags) {
            return InjectFlags[InjectFlags.Default = 0] = "Default", InjectFlags[InjectFlags.Host = 1] = "Host", 
            InjectFlags[InjectFlags.Self = 2] = "Self", InjectFlags[InjectFlags.SkipSelf = 4] = "SkipSelf", 
            InjectFlags[InjectFlags.Optional = 8] = "Optional", InjectFlags;
        }({});
        function getClosureSafeProperty(objWithPropertyToExtract) {
            for (let key in objWithPropertyToExtract) if (objWithPropertyToExtract[key] === getClosureSafeProperty) return key;
            throw Error("Could not find renamed property on target object.");
        }
        function fillProperties(target, source) {
            for (const key in source) source.hasOwnProperty(key) && !target.hasOwnProperty(key) && (target[key] = source[key]);
        }
        function ɵɵdefineInjectable(opts) {
            return {
                token: opts.token,
                providedIn: opts.providedIn || null,
                factory: opts.factory,
                value: void 0
            };
        }
        function ɵɵdefineInjector(options) {
            return {
                factory: options.factory,
                providers: options.providers || [],
                imports: options.imports || []
            };
        }
        function getInjectableDef(type) {
            return getOwnDefinition(type, type[NG_PROV_DEF]) || getOwnDefinition(type, type[NG_INJECTABLE_DEF]);
        }
        function getOwnDefinition(type, def) {
            return def && def.token === type ? def : null;
        }
        function getInjectorDef(type) {
            return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ? type[NG_INJ_DEF] : null;
        }
        const NG_PROV_DEF = getClosureSafeProperty({
            "ɵprov": getClosureSafeProperty
        }), NG_INJ_DEF = getClosureSafeProperty({
            "ɵinj": getClosureSafeProperty
        }), NG_INJECTABLE_DEF = getClosureSafeProperty({
            ngInjectableDef: getClosureSafeProperty
        }), NG_INJECTOR_DEF = getClosureSafeProperty({
            ngInjectorDef: getClosureSafeProperty
        });
        function stringify(token) {
            if ("string" == typeof token) return token;
            if (Array.isArray(token)) return "[" + token.map(stringify).join(", ") + "]";
            if (null == token) return "" + token;
            if (token.overriddenName) return `${token.overriddenName}`;
            if (token.name) return `${token.name}`;
            const res = token.toString();
            if (null == res) return "" + res;
            const newLineIndex = res.indexOf("\n");
            return -1 === newLineIndex ? res : res.substring(0, newLineIndex);
        }
        const __forward_ref__ = getClosureSafeProperty({
            __forward_ref__: getClosureSafeProperty
        });
        function forwardRef(forwardRefFn) {
            return forwardRefFn.__forward_ref__ = forwardRef, forwardRefFn.toString = function() {
                return stringify(this());
            }, forwardRefFn;
        }
        function resolveForwardRef(type) {
            return isForwardRef(type) ? type() : type;
        }
        function isForwardRef(fn) {
            return "function" == typeof fn && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;
        }
        const __globalThis = "undefined" != typeof globalThis && globalThis, __window = "undefined" != typeof window && window, __self = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, __global = "undefined" != typeof global && global, _global = __globalThis || __global || __window || __self, NG_COMP_DEF = getClosureSafeProperty({
            "ɵcmp": getClosureSafeProperty
        }), NG_DIR_DEF = getClosureSafeProperty({
            "ɵdir": getClosureSafeProperty
        }), NG_PIPE_DEF = getClosureSafeProperty({
            "ɵpipe": getClosureSafeProperty
        }), NG_MOD_DEF = getClosureSafeProperty({
            "ɵmod": getClosureSafeProperty
        }), NG_LOC_ID_DEF = getClosureSafeProperty({
            "ɵloc": getClosureSafeProperty
        }), NG_FACTORY_DEF = getClosureSafeProperty({
            "ɵfac": getClosureSafeProperty
        }), NG_ELEMENT_ID = getClosureSafeProperty({
            __NG_ELEMENT_ID__: getClosureSafeProperty
        });
        class InjectionToken {
            constructor(_desc, options) {
                this._desc = _desc, this.ngMetadataName = "InjectionToken", this.ɵprov = void 0, 
                "number" == typeof options ? this.__NG_ELEMENT_ID__ = options : void 0 !== options && (this.ɵprov = ɵɵdefineInjectable({
                    token: this,
                    providedIn: options.providedIn || "root",
                    factory: options.factory
                }));
            }
            toString() {
                return `InjectionToken ${this._desc}`;
            }
        }
        const INJECTOR = new InjectionToken("INJECTOR", -1), THROW_IF_NOT_FOUND = new Object, NG_TEMP_TOKEN_PATH = "ngTempTokenPath", NG_TOKEN_PATH = "ngTokenPath", NEW_LINE = /\n/gm, NO_NEW_LINE = "ɵ", SOURCE = "__source", USE_VALUE = getClosureSafeProperty({
            provide: String,
            useValue: getClosureSafeProperty
        });
        let _injectImplementation, _currentInjector = void 0;
        function setCurrentInjector(injector) {
            const former = _currentInjector;
            return _currentInjector = injector, former;
        }
        function setInjectImplementation(impl) {
            const previous = _injectImplementation;
            return _injectImplementation = impl, previous;
        }
        function injectInjectorOnly(token, flags = InjectFlags.Default) {
            if (void 0 === _currentInjector) throw new Error("inject() must be called from an injection context");
            return null === _currentInjector ? injectRootLimpMode(token, void 0, flags) : _currentInjector.get(token, flags & InjectFlags.Optional ? null : void 0, flags);
        }
        function ɵɵinject(token, flags = InjectFlags.Default) {
            return (_injectImplementation || injectInjectorOnly)(resolveForwardRef(token), flags);
        }
        const inject = ɵɵinject;
        function injectRootLimpMode(token, notFoundValue, flags) {
            const injectableDef = getInjectableDef(token);
            if (injectableDef && "root" == injectableDef.providedIn) return void 0 === injectableDef.value ? injectableDef.value = injectableDef.factory() : injectableDef.value;
            if (flags & InjectFlags.Optional) return null;
            if (void 0 !== notFoundValue) return notFoundValue;
            throw new Error(`Injector: NOT_FOUND [${stringify(token)}]`);
        }
        function injectArgs(types) {
            const args = [];
            for (let i = 0; i < types.length; i++) {
                const arg = resolveForwardRef(types[i]);
                if (Array.isArray(arg)) {
                    if (0 === arg.length) throw new Error("Arguments array must have arguments.");
                    let type = void 0, flags = InjectFlags.Default;
                    for (let j = 0; j < arg.length; j++) {
                        const meta = arg[j];
                        meta instanceof Optional || "Optional" === meta.ngMetadataName || meta === Optional ? flags |= InjectFlags.Optional : meta instanceof SkipSelf || "SkipSelf" === meta.ngMetadataName || meta === SkipSelf ? flags |= InjectFlags.SkipSelf : meta instanceof Self || "Self" === meta.ngMetadataName || meta === Self ? flags |= InjectFlags.Self : type = meta instanceof Inject || meta === Inject ? meta.token : meta;
                    }
                    args.push(ɵɵinject(type, flags));
                } else args.push(ɵɵinject(arg));
            }
            return args;
        }
        class NullInjector {
            get(token, notFoundValue = THROW_IF_NOT_FOUND) {
                if (notFoundValue === THROW_IF_NOT_FOUND) {
                    const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);
                    throw error.name = "NullInjectorError", error;
                }
                return notFoundValue;
            }
        }
        class NgModuleRef {}
        class NgModuleFactory {}
        function deepForEach(input, fn) {
            input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));
        }
        function addToArray(arr, index, value) {
            index >= arr.length ? arr.push(value) : arr.splice(index, 0, value);
        }
        function removeFromArray(arr, index) {
            return index >= arr.length - 1 ? arr.pop() : arr.splice(index, 1)[0];
        }
        function newArray(size, value) {
            const list = [];
            for (let i = 0; i < size; i++) list.push(value);
            return list;
        }
        const ChangeDetectionStrategy = function() {
            var ChangeDetectionStrategy = {
                OnPush: 0,
                Default: 1
            };
            return ChangeDetectionStrategy[ChangeDetectionStrategy.OnPush] = "OnPush", ChangeDetectionStrategy[ChangeDetectionStrategy.Default] = "Default", 
            ChangeDetectionStrategy;
        }(), ViewEncapsulation$1 = function() {
            var ViewEncapsulation$1 = {
                Emulated: 0,
                Native: 1,
                None: 2,
                ShadowDom: 3
            };
            return ViewEncapsulation$1[ViewEncapsulation$1.Emulated] = "Emulated", ViewEncapsulation$1[ViewEncapsulation$1.Native] = "Native", 
            ViewEncapsulation$1[ViewEncapsulation$1.None] = "None", ViewEncapsulation$1[ViewEncapsulation$1.ShadowDom] = "ShadowDom", 
            ViewEncapsulation$1;
        }();
        function noSideEffects(fn) {
            return "" + {
                toString: fn
            };
        }
        const EMPTY_OBJ = {}, EMPTY_ARRAY = [];
        let _renderCompCount = 0;
        function ɵɵdefineComponent(componentDefinition) {
            const type = componentDefinition.type, typePrototype = type.prototype, declaredInputs = {}, def = {
                type: type,
                providersResolver: null,
                decls: componentDefinition.decls,
                vars: componentDefinition.vars,
                factory: null,
                template: componentDefinition.template || null,
                consts: componentDefinition.consts || null,
                ngContentSelectors: componentDefinition.ngContentSelectors,
                hostBindings: componentDefinition.hostBindings || null,
                contentQueries: componentDefinition.contentQueries || null,
                declaredInputs: declaredInputs,
                inputs: null,
                outputs: null,
                exportAs: componentDefinition.exportAs || null,
                onChanges: null,
                onInit: typePrototype.ngOnInit || null,
                doCheck: typePrototype.ngDoCheck || null,
                afterContentInit: typePrototype.ngAfterContentInit || null,
                afterContentChecked: typePrototype.ngAfterContentChecked || null,
                afterViewInit: typePrototype.ngAfterViewInit || null,
                afterViewChecked: typePrototype.ngAfterViewChecked || null,
                onDestroy: typePrototype.ngOnDestroy || null,
                onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
                directiveDefs: null,
                pipeDefs: null,
                selectors: componentDefinition.selectors || EMPTY_ARRAY,
                viewQuery: componentDefinition.viewQuery || null,
                features: componentDefinition.features || null,
                data: componentDefinition.data || {},
                encapsulation: componentDefinition.encapsulation || ViewEncapsulation$1.Emulated,
                id: "c",
                styles: componentDefinition.styles || EMPTY_ARRAY,
                _: null,
                setInput: null,
                schemas: componentDefinition.schemas || null,
                tView: null
            };
            return def._ = noSideEffects(() => {
                const directiveTypes = componentDefinition.directives, feature = componentDefinition.features, pipeTypes = componentDefinition.pipes;
                def.id += _renderCompCount++, def.inputs = invertObject(componentDefinition.inputs, declaredInputs), 
                def.outputs = invertObject(componentDefinition.outputs), feature && feature.forEach(fn => fn(def)), 
                def.directiveDefs = directiveTypes ? () => ("function" == typeof directiveTypes ? directiveTypes() : directiveTypes).map(extractDirectiveDef) : null, 
                def.pipeDefs = pipeTypes ? () => ("function" == typeof pipeTypes ? pipeTypes() : pipeTypes).map(extractPipeDef) : null;
            }), def;
        }
        function extractDirectiveDef(type) {
            return getComponentDef(type) || function(type) {
                return type[NG_DIR_DEF] || null;
            }(type);
        }
        function extractPipeDef(type) {
            return function(type) {
                return type[NG_PIPE_DEF] || null;
            }(type);
        }
        const autoRegisterModuleById = {};
        function ɵɵdefineNgModule(def) {
            const res = {
                type: def.type,
                bootstrap: def.bootstrap || EMPTY_ARRAY,
                declarations: def.declarations || EMPTY_ARRAY,
                imports: def.imports || EMPTY_ARRAY,
                exports: def.exports || EMPTY_ARRAY,
                transitiveCompileScopes: null,
                schemas: def.schemas || null,
                id: def.id || null
            };
            return null != def.id && noSideEffects(() => {
                autoRegisterModuleById[def.id] = def.type;
            }), res;
        }
        function invertObject(obj, secondary) {
            if (null == obj) return EMPTY_OBJ;
            const newLookup = {};
            for (const minifiedKey in obj) if (obj.hasOwnProperty(minifiedKey)) {
                let publicName = obj[minifiedKey], declaredName = publicName;
                Array.isArray(publicName) && (declaredName = publicName[1], publicName = publicName[0]), 
                newLookup[publicName] = minifiedKey, secondary && (secondary[publicName] = declaredName);
            }
            return newLookup;
        }
        const ɵɵdefineDirective = ɵɵdefineComponent;
        function ɵɵdefinePipe(pipeDef) {
            return {
                type: pipeDef.type,
                name: pipeDef.name,
                factory: null,
                pure: !1 !== pipeDef.pure,
                onDestroy: pipeDef.type.prototype.ngOnDestroy || null
            };
        }
        function getComponentDef(type) {
            return type[NG_COMP_DEF] || null;
        }
        function getFactoryDef(type, throwNotFound) {
            return type.hasOwnProperty(NG_FACTORY_DEF) ? type[NG_FACTORY_DEF] : null;
        }
        function getNgModuleDef(type, throwNotFound) {
            const ngModuleDef = type[NG_MOD_DEF] || null;
            if (!ngModuleDef && !0 === throwNotFound) throw new Error(`Type ${stringify(type)} does not have 'ɵmod' property.`);
            return ngModuleDef;
        }
        const HOST = 0, TVIEW = 1, FLAGS = 2, PARENT = 3, NEXT = 4, QUERIES = 5, T_HOST = 6, CLEANUP = 7, CONTEXT = 8, INJECTOR$1 = 9, RENDERER_FACTORY = 10, RENDERER = 11, SANITIZER = 12, CHILD_HEAD = 13, CHILD_TAIL = 14, DECLARATION_VIEW = 15, DECLARATION_LCONTAINER = 16, PREORDER_HOOK_FLAGS = 17, HEADER_OFFSET = 18, TYPE = 1, ACTIVE_INDEX = 2, MOVED_VIEWS = 5, NATIVE = 7, VIEW_REFS = 8, CONTAINER_HEADER_OFFSET = 9;
        function isLView(value) {
            return Array.isArray(value) && "object" == typeof value[TYPE];
        }
        function isLContainer(value) {
            return Array.isArray(value) && !0 === value[TYPE];
        }
        function isContentQueryHost(tNode) {
            return 0 != (8 & tNode.flags);
        }
        function isComponentHost(tNode) {
            return 2 == (2 & tNode.flags);
        }
        function isDirectiveHost(tNode) {
            return 1 == (1 & tNode.flags);
        }
        function isComponentDef(def) {
            return null !== def.template;
        }
        function isRootView(target) {
            return 0 != (512 & target[FLAGS]);
        }
        const TNODE = 8, PARENT_INJECTOR = 8, INJECTOR_BLOOM_PARENT_SIZE = 9, NO_PARENT_INJECTOR = -1;
        class NodeInjectorFactory {
            constructor(factory, isViewProvider, injectImplementation) {
                this.factory = factory, this.resolving = !1, this.canSeeViewProviders = isViewProvider, 
                this.injectImpl = injectImplementation;
            }
        }
        const instructionState = {
            lFrame: createLFrame(null),
            bindingsEnabled: !0,
            elementExitFn: null,
            checkNoChangesMode: !1
        };
        function setCurrentDirectiveDef(def) {
            instructionState.lFrame.currentDirectiveDef = def;
        }
        function getBindingsEnabled() {
            return instructionState.bindingsEnabled;
        }
        function getLView() {
            const lFrame = instructionState.lFrame;
            return null === lFrame ? null : lFrame.lView;
        }
        function hasActiveElementFlag(flag) {
            return (instructionState.lFrame.selectedIndex & flag) === flag;
        }
        function setActiveHostElement(elementIndex = null) {
            hasActiveElementFlag(1) && executeElementExitFn(), setSelectedIndex(null === elementIndex ? -1 : elementIndex), 
            instructionState.lFrame.activeDirectiveId = 0;
        }
        function executeElementExitFn() {
            instructionState.elementExitFn(), instructionState.lFrame.selectedIndex &= -2;
        }
        function setElementExitFn(fn) {
            instructionState.lFrame.selectedIndex |= 1, null == instructionState.elementExitFn && (instructionState.elementExitFn = fn);
        }
        function getActiveDirectiveId() {
            return instructionState.lFrame.activeDirectiveId;
        }
        function incrementActiveDirectiveId() {
            instructionState.lFrame.activeDirectiveId += 1;
        }
        function ɵɵrestoreView(viewToRestore) {
            instructionState.lFrame.contextLView = viewToRestore;
        }
        function getPreviousOrParentTNode() {
            return instructionState.lFrame.previousOrParentTNode;
        }
        function setPreviousOrParentTNode(tNode, _isParent) {
            instructionState.lFrame.previousOrParentTNode = tNode, instructionState.lFrame.isParent = _isParent;
        }
        function getIsParent() {
            return instructionState.lFrame.isParent;
        }
        function setIsNotParent() {
            instructionState.lFrame.isParent = !1;
        }
        function getCheckNoChangesMode() {
            return instructionState.checkNoChangesMode;
        }
        function setCheckNoChangesMode(mode) {
            instructionState.checkNoChangesMode = mode;
        }
        function getBindingRoot() {
            const lFrame = instructionState.lFrame;
            let index = lFrame.bindingRootIndex;
            return -1 === index && (index = lFrame.bindingRootIndex = lFrame.lView[TVIEW].bindingStartIndex), 
            index;
        }
        function getBindingIndex() {
            return instructionState.lFrame.bindingIndex;
        }
        function setBindingIndex(value) {
            return instructionState.lFrame.bindingIndex = value;
        }
        function nextBindingIndex() {
            return instructionState.lFrame.bindingIndex++;
        }
        function incrementBindingIndex(count) {
            const lFrame = instructionState.lFrame, index = lFrame.bindingIndex;
            return lFrame.bindingIndex = lFrame.bindingIndex + count, index;
        }
        function setBindingRoot(value) {
            instructionState.lFrame.bindingRootIndex = value;
        }
        function getCurrentQueryIndex() {
            return instructionState.lFrame.currentQueryIndex;
        }
        function setCurrentQueryIndex(value) {
            instructionState.lFrame.currentQueryIndex = value;
        }
        function enterDI(newView, tNode) {
            const newLFrame = allocLFrame();
            instructionState.lFrame = newLFrame, newLFrame.previousOrParentTNode = tNode, newLFrame.lView = newView;
        }
        const leaveDI = leaveView;
        function enterView(newView, tNode) {
            const newLFrame = allocLFrame();
            instructionState.lFrame = newLFrame, newLFrame.previousOrParentTNode = tNode, newLFrame.isParent = !0, 
            newLFrame.lView = newView, newLFrame.selectedIndex = 0, newLFrame.contextLView = newView, 
            newLFrame.elementDepthCount = 0, newLFrame.currentNamespace = null, newLFrame.currentSanitizer = null, 
            newLFrame.currentDirectiveDef = null, newLFrame.activeDirectiveId = 0, newLFrame.bindingRootIndex = -1, 
            newLFrame.bindingIndex = null === newView ? -1 : newView[TVIEW].bindingStartIndex, 
            newLFrame.currentQueryIndex = 0;
        }
        function allocLFrame() {
            const currentLFrame = instructionState.lFrame, childLFrame = null === currentLFrame ? null : currentLFrame.child;
            return null === childLFrame ? createLFrame(currentLFrame) : childLFrame;
        }
        function createLFrame(parent) {
            const lFrame = {
                previousOrParentTNode: null,
                isParent: !0,
                lView: null,
                selectedIndex: 0,
                contextLView: null,
                elementDepthCount: 0,
                currentNamespace: null,
                currentSanitizer: null,
                currentDirectiveDef: null,
                activeDirectiveId: 0,
                bindingRootIndex: -1,
                bindingIndex: -1,
                currentQueryIndex: 0,
                parent: parent,
                child: null
            };
            return null !== parent && (parent.child = lFrame), lFrame;
        }
        function leaveView() {
            instructionState.lFrame = instructionState.lFrame.parent;
        }
        function getSelectedIndex() {
            return instructionState.lFrame.selectedIndex >> 1;
        }
        function setSelectedIndex(index) {
            instructionState.lFrame.selectedIndex = index << 1;
        }
        function ɵɵnamespaceSVG() {
            instructionState.lFrame.currentNamespace = "http://www.w3.org/2000/svg";
        }
        function ɵɵnamespaceHTML() {
            instructionState.lFrame.currentNamespace = null;
        }
        function setCurrentStyleSanitizer(sanitizer) {
            instructionState.lFrame.currentSanitizer = sanitizer;
        }
        function getCurrentStyleSanitizer() {
            const lFrame = instructionState.lFrame;
            return null === lFrame ? null : lFrame.currentSanitizer;
        }
        let DOCUMENT = void 0;
        function setDocument(document) {
            DOCUMENT = document;
        }
        function getDocument() {
            return void 0 !== DOCUMENT ? DOCUMENT : "undefined" != typeof document ? document : void 0;
        }
        const RendererStyleFlags3 = function() {
            var RendererStyleFlags3 = {
                Important: 1,
                DashCase: 2
            };
            return RendererStyleFlags3[RendererStyleFlags3.Important] = "Important", RendererStyleFlags3[RendererStyleFlags3.DashCase] = "DashCase", 
            RendererStyleFlags3;
        }();
        function isProceduralRenderer(renderer) {
            return !!renderer.listen;
        }
        const domRendererFactory3 = {
            createRenderer: (hostElement, rendererType) => getDocument()
        };
        function setUpAttributes(renderer, native, attrs) {
            const isProc = isProceduralRenderer(renderer);
            let i = 0;
            for (;i < attrs.length; ) {
                const value = attrs[i];
                if ("number" == typeof value) {
                    if (0 !== value) break;
                    i++;
                    const namespaceURI = attrs[i++], attrName = attrs[i++], attrVal = attrs[i++];
                    isProc ? renderer.setAttribute(native, attrName, attrVal, namespaceURI) : native.setAttributeNS(namespaceURI, attrName, attrVal);
                } else {
                    const attrName = value, attrVal = attrs[++i];
                    isAnimationProp(attrName) ? isProc && renderer.setProperty(native, attrName, attrVal) : isProc ? renderer.setAttribute(native, attrName, attrVal) : native.setAttribute(attrName, attrVal), 
                    i++;
                }
            }
            return i;
        }
        function isNameOnlyAttributeMarker(marker) {
            return 3 === marker || 4 === marker || 6 === marker;
        }
        function isAnimationProp(name) {
            return 64 === name.charCodeAt(0);
        }
        function hasParentInjector(parentLocation) {
            return parentLocation !== NO_PARENT_INJECTOR;
        }
        function getParentInjectorIndex(parentLocation) {
            return 32767 & parentLocation;
        }
        function getParentInjectorViewOffset(parentLocation) {
            return parentLocation >> 16;
        }
        function getParentInjectorView(location, startView) {
            let viewOffset = getParentInjectorViewOffset(location), parentView = startView;
            for (;viewOffset > 0; ) parentView = parentView[DECLARATION_VIEW], viewOffset--;
            return parentView;
        }
        function renderStringify(value) {
            return "string" == typeof value ? value : null == value ? "" : "" + value;
        }
        function stringifyForError(value) {
            return "function" == typeof value ? value.name || value.toString() : "object" == typeof value && null != value && "function" == typeof value.type ? value.type.name || value.type.toString() : renderStringify(value);
        }
        const defaultScheduler = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(_global))();
        function ɵɵresolveWindow(element) {
            return {
                name: "window",
                target: element.ownerDocument.defaultView
            };
        }
        function ɵɵresolveDocument(element) {
            return {
                name: "document",
                target: element.ownerDocument
            };
        }
        const INTERPOLATION_DELIMITER = "�";
        function maybeUnwrapFn(value) {
            return value instanceof Function ? value() : value;
        }
        const NO_CHANGE = {}, MAP_BASED_ENTRY_PROP_NAME = "[MAP]", TEMPLATE_DIRECTIVE_INDEX = 0, DEFAULT_BINDING_VALUE = null, DEFAULT_BINDING_INDEX = 0, DEFAULT_TOTAL_SOURCES = 1, DEFAULT_GUARD_MASK_VALUE = 1;
        function allocStylingMapArray(value) {
            return [ value ];
        }
        function hasConfig(tNode, flag) {
            return 0 != (tNode.flags & flag);
        }
        function allowDirectStyling(tNode, isClassBased, firstUpdatePass) {
            let allow = !1;
            if (hasConfig(tNode, 128)) {
                if (!firstUpdatePass) {
                    const hasDuplicates = hasConfig(tNode, isClassBased ? 8192 : 262144), hasOnlyMapOrPropsFlag = isClassBased ? 1536 : 49152, hasOnlyMapsOrOnlyProps = (tNode.flags & hasOnlyMapOrPropsFlag) !== hasOnlyMapOrPropsFlag;
                    allow = !hasDuplicates && hasOnlyMapsOrOnlyProps;
                }
            } else allow = !0;
            return allow;
        }
        function patchConfig(tNode, flag) {
            tNode.flags |= flag;
        }
        function getProp(context, index) {
            return context[index + 3];
        }
        function isSanitizationRequired(context, index) {
            return 0 != (1 & function(context, index) {
                return 1 & context[index + 0];
            }(context, index));
        }
        function getGuardMask(context, index, isHostBinding) {
            return context[index + (isHostBinding ? 2 : 1)];
        }
        function getValuesCount(context) {
            return getTotalSources(context) + 1;
        }
        function getTotalSources(context) {
            return context[0];
        }
        function getBindingValue(context, index, offset) {
            return context[index + 4 + offset];
        }
        function getDefaultValue(context, index) {
            return context[index + 4 + getTotalSources(context)];
        }
        function setValue(data, bindingIndex, value) {
            data[bindingIndex] = value;
        }
        function getValue(data, bindingIndex) {
            return 0 !== bindingIndex ? data[bindingIndex] : null;
        }
        function hasValueChanged(a, b) {
            if (b === NO_CHANGE) return !1;
            const compareValueA = Array.isArray(a) ? a[0] : a, compareValueB = Array.isArray(b) ? b[0] : b;
            return !Object.is(compareValueA, compareValueB);
        }
        function isStylingValueDefined(value) {
            return null != value && "" !== value;
        }
        function concatString(a, b, separator = " ") {
            return a + (b.length && a.length ? separator : "") + b;
        }
        function hyphenate(value) {
            return value.replace(/[a-z][A-Z]/g, v => v.charAt(0) + "-" + v.charAt(1)).toLowerCase();
        }
        function getStylingMapArray(value) {
            return isStylingContext(value) ? value[1] : value;
        }
        function isStylingContext(value) {
            return Array.isArray(value) && value.length >= 2 && "string" != typeof value[1];
        }
        function getInitialStylingValue(context) {
            const map = getStylingMapArray(context);
            return map && map[0] || "";
        }
        function hasClassInput(tNode) {
            return 0 != (16 & tNode.flags);
        }
        function hasStyleInput(tNode) {
            return 0 != (32 & tNode.flags);
        }
        function getMapProp(map, index) {
            return map[index + 0];
        }
        const MAP_DIRTY_VALUE = {
            MAP_DIRTY_VALUE: !0
        };
        function setMapValue(map, index, value) {
            map[index + 1] = value;
        }
        function getMapValue(map, index) {
            return map[index + 1];
        }
        function forceStylesAsString(styles, hyphenateProps) {
            if ("string" == typeof styles) return styles;
            let str = "";
            if (styles) {
                const props = Object.keys(styles);
                for (let i = 0; i < props.length; i++) {
                    const prop = props[i], propLabel = hyphenateProps ? hyphenate(prop) : prop, value = styles[prop];
                    null !== value && (str = concatString(str, `${propLabel}:${value}`, ";"));
                }
            }
            return str;
        }
        function isHostStylingActive(directiveOrSourceId) {
            return directiveOrSourceId !== TEMPLATE_DIRECTIVE_INDEX;
        }
        function stylingMapToString(map, isClassBased) {
            let str = "";
            for (let i = 1; i < map.length; i += 2) {
                const prop = getMapProp(map, i), value = getMapValue(map, i), attrValue = concatString(prop, isClassBased ? "" : value, ":");
                str = concatString(str, attrValue, isClassBased ? " " : "; ");
            }
            return str;
        }
        function addItemToStylingMap(stylingMapArr, prop, value, allowOverwrite) {
            for (let j = 1; j < stylingMapArr.length; j += 2) {
                const propAtIndex = getMapProp(stylingMapArr, j);
                if (prop <= propAtIndex) {
                    let applied = !1;
                    if (propAtIndex === prop) {
                        const valueAtIndex = stylingMapArr[j];
                        !allowOverwrite && isStylingValueDefined(valueAtIndex) || (applied = !0, setMapValue(stylingMapArr, j, value));
                    } else applied = !0, stylingMapArr.splice(j, 0, prop, value);
                    return applied;
                }
            }
            return stylingMapArr.push(prop, value), !0;
        }
        function normalizeIntoStylingMap(bindingValue, newValues, normalizeProps) {
            const stylingMapArr = Array.isArray(bindingValue) ? bindingValue : allocStylingMapArray(null);
            stylingMapArr[0] = newValues;
            for (let j = 1; j < stylingMapArr.length; j += 2) setMapValue(stylingMapArr, j, null);
            let map, props = null, allValuesTrue = !1;
            if ("string" == typeof newValues ? allValuesTrue = null !== (props = function(text) {
                let array = null, length = text.length, start = 0, foundChar = !1;
                for (let i = 0; i < length; i++) text.charCodeAt(i) <= 32 ? (foundChar && (null === array && (array = []), 
                array.push(text.substring(start, i)), foundChar = !1), start = i + 1) : foundChar = !0;
                return foundChar && (null === array && (array = []), array.push(text.substring(start, length)), 
                foundChar = !1), array;
            }(newValues)) : (props = newValues ? Object.keys(newValues) : null, map = newValues), 
            props) for (let i = 0; i < props.length; i++) {
                const prop = props[i];
                addItemToStylingMap(stylingMapArr, normalizeProps ? hyphenate(prop) : prop, !!allValuesTrue || map[prop], !0);
            }
            return stylingMapArr;
        }
        function selectClassBasedInputName(inputs) {
            return inputs.hasOwnProperty("class") ? "class" : "className";
        }
        const MONKEY_PATCH_KEY_NAME = "__ngContext__";
        function unwrapRNode(value) {
            for (;Array.isArray(value); ) value = value[HOST];
            return (value);
        }
        function getNativeByIndex(index, lView) {
            return unwrapRNode(lView[index + HEADER_OFFSET]);
        }
        function getNativeByTNode(tNode, lView) {
            return unwrapRNode(lView[tNode.index]);
        }
        function getNativeByTNodeOrNull(tNode, lView) {
            const index = tNode.index;
            return -1 !== index ? unwrapRNode(lView[index]) : null;
        }
        function getTNode(index, view) {
            return view[TVIEW].data[index + HEADER_OFFSET];
        }
        function load(view, index) {
            return view[index + HEADER_OFFSET];
        }
        function getComponentLViewByIndex(nodeIndex, hostView) {
            const slotValue = hostView[nodeIndex];
            return isLView(slotValue) ? slotValue : slotValue[HOST];
        }
        function readPatchedData(target) {
            return target[MONKEY_PATCH_KEY_NAME] || null;
        }
        function readPatchedLView(target) {
            const value = readPatchedData(target);
            return value ? Array.isArray(value) ? value : value.lView : null;
        }
        function isCreationMode(view) {
            return 4 == (4 & view[FLAGS]);
        }
        function getConstant(consts, index) {
            return null === consts || null == index ? null : consts[index];
        }
        function resetPreOrderHookFlags(lView) {
            lView[PREORDER_HOOK_FLAGS] = 0;
        }
        function getLViewParent(lView) {
            const parent = lView[PARENT];
            return isLContainer(parent) ? parent[PARENT] : parent;
        }
        function findComponentView(lView) {
            let declaredView, rootTNode = lView[T_HOST];
            for (;null !== rootTNode && 2 === rootTNode.type && null !== (declaredView = lView[DECLARATION_VIEW]); ) rootTNode = (lView = declaredView)[T_HOST];
            return lView;
        }
        let includeViewProviders = !0;
        function setIncludeViewProviders(v) {
            const oldValue = includeViewProviders;
            return includeViewProviders = v, oldValue;
        }
        const BLOOM_MASK = 255;
        let nextNgElementId = 0;
        function getOrCreateNodeInjectorForNode(tNode, hostView) {
            const existingInjectorIndex = getInjectorIndex(tNode, hostView);
            if (-1 !== existingInjectorIndex) return existingInjectorIndex;
            const tView = hostView[TVIEW];
            tView.firstCreatePass && (tNode.injectorIndex = hostView.length, insertBloom(tView.data, tNode), 
            insertBloom(hostView, null), insertBloom(tView.blueprint, null));
            const parentLoc = getParentInjectorLocation(tNode, hostView), injectorIndex = tNode.injectorIndex;
            if (hasParentInjector(parentLoc)) {
                const parentIndex = getParentInjectorIndex(parentLoc), parentLView = getParentInjectorView(parentLoc, hostView), parentData = parentLView[TVIEW].data;
                for (let i = 0; i < 8; i++) hostView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];
            }
            return hostView[injectorIndex + PARENT_INJECTOR] = parentLoc, injectorIndex;
        }
        function insertBloom(arr, footer) {
            arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
        }
        function getInjectorIndex(tNode, hostView) {
            return -1 === tNode.injectorIndex || tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || null == hostView[tNode.injectorIndex + PARENT_INJECTOR] ? -1 : tNode.injectorIndex;
        }
        function getParentInjectorLocation(tNode, view) {
            if (tNode.parent && -1 !== tNode.parent.injectorIndex) return tNode.parent.injectorIndex;
            let hostTNode = view[T_HOST], viewOffset = 1;
            for (;hostTNode && -1 === hostTNode.injectorIndex; ) hostTNode = (view = view[DECLARATION_VIEW]) ? view[T_HOST] : null, 
            viewOffset++;
            return hostTNode ? hostTNode.injectorIndex | viewOffset << 16 : -1;
        }
        function diPublicInInjector(injectorIndex, tView, token) {
            !function(injectorIndex, tView, type) {
                let id = "string" != typeof type ? type[NG_ELEMENT_ID] : type.charCodeAt(0) || 0;
                null == id && (id = type[NG_ELEMENT_ID] = nextNgElementId++);
                const bloomBit = id & BLOOM_MASK, mask = 1 << bloomBit, b6 = 64 & bloomBit, b5 = 32 & bloomBit, tData = tView.data;
                128 & bloomBit ? b6 ? b5 ? tData[injectorIndex + 7] |= mask : tData[injectorIndex + 6] |= mask : b5 ? tData[injectorIndex + 5] |= mask : tData[injectorIndex + 4] |= mask : b6 ? b5 ? tData[injectorIndex + 3] |= mask : tData[injectorIndex + 2] |= mask : b5 ? tData[injectorIndex + 1] |= mask : tData[injectorIndex] |= mask;
            }(injectorIndex, tView, token);
        }
        function getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {
            if (tNode) {
                const bloomHash = function(token) {
                    if ("string" == typeof token) return token.charCodeAt(0) || 0;
                    const tokenId = token[NG_ELEMENT_ID];
                    return "number" == typeof tokenId && tokenId > 0 ? tokenId & BLOOM_MASK : tokenId;
                }(token);
                if ("function" == typeof bloomHash) {
                    enterDI(lView, tNode);
                    try {
                        const value = bloomHash();
                        if (null != value || flags & InjectFlags.Optional) return value;
                        throw new Error(`No provider for ${stringifyForError(token)}!`);
                    } finally {
                        leaveDI();
                    }
                } else if ("number" == typeof bloomHash) {
                    if (-1 === bloomHash) return new NodeInjector(tNode, lView);
                    let previousTView = null, injectorIndex = getInjectorIndex(tNode, lView), parentLocation = NO_PARENT_INJECTOR, hostTElementNode = flags & InjectFlags.Host ? findComponentView(lView)[T_HOST] : null;
                    for ((-1 === injectorIndex || flags & InjectFlags.SkipSelf) && (parentLocation = -1 === injectorIndex ? getParentInjectorLocation(tNode, lView) : lView[injectorIndex + PARENT_INJECTOR], 
                    shouldSearchParent(flags, !1) ? (previousTView = lView[TVIEW], injectorIndex = getParentInjectorIndex(parentLocation), 
                    lView = getParentInjectorView(parentLocation, lView)) : injectorIndex = -1); -1 !== injectorIndex; ) {
                        parentLocation = lView[injectorIndex + PARENT_INJECTOR];
                        const tView = lView[TVIEW];
                        if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
                            const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
                            if (instance !== NOT_FOUND) return instance;
                        }
                        shouldSearchParent(flags, lView[TVIEW].data[injectorIndex + TNODE] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView) ? (previousTView = tView, 
                        injectorIndex = getParentInjectorIndex(parentLocation), lView = getParentInjectorView(parentLocation, lView)) : injectorIndex = -1;
                    }
                }
            }
            if (flags & InjectFlags.Optional && void 0 === notFoundValue && (notFoundValue = null), 
            0 == (flags & (InjectFlags.Self | InjectFlags.Host))) {
                const moduleInjector = lView[INJECTOR$1], previousInjectImplementation = setInjectImplementation(void 0);
                try {
                    return moduleInjector ? moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional) : injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);
                } finally {
                    setInjectImplementation(previousInjectImplementation);
                }
            }
            if (flags & InjectFlags.Optional) return notFoundValue;
            throw new Error(`NodeInjector: NOT_FOUND [${stringifyForError(token)}]`);
        }
        const NOT_FOUND = {};
        function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
            const currentTView = lView[TVIEW], tNode = currentTView.data[injectorIndex + TNODE], injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, null == previousTView ? isComponentHost(tNode) && includeViewProviders : previousTView != currentTView && 3 === tNode.type, flags & InjectFlags.Host && hostTElementNode === tNode);
            return null !== injectableIdx ? getNodeInjectable(currentTView.data, lView, injectableIdx, tNode) : NOT_FOUND;
        }
        function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
            const nodeProviderIndexes = tNode.providerIndexes, tInjectables = tView.data, injectablesStart = 65535 & nodeProviderIndexes, directivesStart = tNode.directiveStart, cptViewProvidersCount = nodeProviderIndexes >> 16, endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : tNode.directiveEnd;
            for (let i = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount; i < endIndex; i++) {
                const providerTokenOrDef = tInjectables[i];
                if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) return i;
            }
            if (isHostSpecialCase) {
                const dirDef = tInjectables[directivesStart];
                if (dirDef && isComponentDef(dirDef) && dirDef.type === token) return directivesStart;
            }
            return null;
        }
        function getNodeInjectable(tData, lView, index, tNode) {
            let value = lView[index];
            if (value instanceof NodeInjectorFactory) {
                const factory = value;
                if (factory.resolving) throw new Error(`Circular dep for ${stringifyForError(tData[index])}`);
                const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
                let previousInjectImplementation;
                factory.resolving = !0, factory.injectImpl && (previousInjectImplementation = setInjectImplementation(factory.injectImpl)), 
                enterDI(lView, tNode);
                try {
                    value = lView[index] = factory.factory(void 0, tData, lView, tNode);
                } finally {
                    factory.injectImpl && setInjectImplementation(previousInjectImplementation), setIncludeViewProviders(previousIncludeViewProviders), 
                    factory.resolving = !1, leaveDI();
                }
            }
            return value;
        }
        function bloomHasToken(bloomHash, injectorIndex, injectorView) {
            const b6 = 64 & bloomHash, b5 = 32 & bloomHash;
            let value;
            return !!((value = 128 & bloomHash ? b6 ? b5 ? injectorView[injectorIndex + 7] : injectorView[injectorIndex + 6] : b5 ? injectorView[injectorIndex + 5] : injectorView[injectorIndex + 4] : b6 ? b5 ? injectorView[injectorIndex + 3] : injectorView[injectorIndex + 2] : b5 ? injectorView[injectorIndex + 1] : injectorView[injectorIndex]) & 1 << bloomHash);
        }
        function shouldSearchParent(flags, isFirstHostTNode) {
            return !(flags & InjectFlags.Self || flags & InjectFlags.Host && isFirstHostTNode);
        }
        class NodeInjector {
            constructor(_tNode, _lView) {
                this._tNode = _tNode, this._lView = _lView;
            }
            get(token, notFoundValue) {
                return getOrCreateInjectable(this._tNode, this._lView, token, void 0, notFoundValue);
            }
        }
        function ɵɵgetInheritedFactory(type) {
            const proto = Object.getPrototypeOf(type.prototype).constructor, factory = proto[NG_FACTORY_DEF] || function ɵɵgetFactoryOf(type) {
                const typeAny = type;
                if (isForwardRef(type)) return () => {
                    const factory = ɵɵgetFactoryOf(resolveForwardRef(typeAny));
                    return factory ? factory() : null;
                };
                let factory = getFactoryDef(typeAny);
                if (null === factory) {
                    const injectorDef = getInjectorDef(typeAny);
                    factory = injectorDef && injectorDef.factory;
                }
                return factory || null;
            }(proto);
            return null !== factory ? factory : t => new t;
        }
        const ERROR_DEBUG_CONTEXT = "ngDebugContext", ERROR_ORIGINAL_ERROR = "ngOriginalError", ERROR_LOGGER = "ngErrorLogger";
        function getDebugContext(error) {
            return error[ERROR_DEBUG_CONTEXT];
        }
        function getOriginalError(error) {
            return error[ERROR_ORIGINAL_ERROR];
        }
        function defaultErrorLogger(console, ...values) {
            console.error(...values);
        }
        class ErrorHandler {
            constructor() {
                this._console = console;
            }
            handleError(error) {
                const originalError = this._findOriginalError(error), context = this._findContext(error), errorLogger = function(error) {
                    return error[ERROR_LOGGER] || defaultErrorLogger;
                }(error);
                errorLogger(this._console, "ERROR", error), originalError && errorLogger(this._console, "ORIGINAL ERROR", originalError), 
                context && errorLogger(this._console, "ERROR CONTEXT", context);
            }
            _findContext(error) {
                return error ? getDebugContext(error) ? getDebugContext(error) : this._findContext(getOriginalError(error)) : null;
            }
            _findOriginalError(error) {
                let e = getOriginalError(error);
                for (;e && getOriginalError(e); ) e = getOriginalError(e);
                return e;
            }
        }
        class SafeValueImpl {
            constructor(changingThisBreaksApplicationSecurity) {
                this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
            }
            toString() {
                return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` + " (see http://g.co/ng/security#xss)";
            }
        }
        class SafeHtmlImpl extends SafeValueImpl {
            getTypeName() {
                return "HTML";
            }
        }
        class SafeStyleImpl extends SafeValueImpl {
            getTypeName() {
                return "Style";
            }
        }
        class SafeScriptImpl extends SafeValueImpl {
            getTypeName() {
                return "Script";
            }
        }
        class SafeUrlImpl extends SafeValueImpl {
            getTypeName() {
                return "URL";
            }
        }
        class SafeResourceUrlImpl extends SafeValueImpl {
            getTypeName() {
                return "ResourceURL";
            }
        }
        function unwrapSafeValue(value) {
            return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;
        }
        function allowSanitizationBypassAndThrow(value, type) {
            const actualType = getSanitizationBypassType(value);
            if (null != actualType && actualType !== type) {
                if ("ResourceURL" === actualType && "URL" === type) return !0;
                throw new Error(`Required a safe ${type}, got a ${actualType} (see http://g.co/ng/security#xss)`);
            }
            return actualType === type;
        }
        function getSanitizationBypassType(value) {
            return value instanceof SafeValueImpl && value.getTypeName() || null;
        }
        function bypassSanitizationTrustHtml(trustedHtml) {
            return new SafeHtmlImpl(trustedHtml);
        }
        function bypassSanitizationTrustStyle(trustedStyle) {
            return new SafeStyleImpl(trustedStyle);
        }
        function bypassSanitizationTrustScript(trustedScript) {
            return new SafeScriptImpl(trustedScript);
        }
        function bypassSanitizationTrustUrl(trustedUrl) {
            return new SafeUrlImpl(trustedUrl);
        }
        function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {
            return new SafeResourceUrlImpl(trustedResourceUrl);
        }
        let _devMode = !0, _runModeLocked = !1;
        function isDevMode() {
            return _runModeLocked = !0, _devMode;
        }
        function enableProdMode() {
            if (_runModeLocked) throw new Error("Cannot enable prod mode after platform setup.");
            _devMode = !1;
        }
        class InertBodyHelper {
            constructor(defaultDoc) {
                if (this.defaultDoc = defaultDoc, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), 
                this.inertBodyElement = this.inertDocument.body, null == this.inertBodyElement) {
                    const inertHtml = this.inertDocument.createElement("html");
                    this.inertDocument.appendChild(inertHtml), this.inertBodyElement = this.inertDocument.createElement("body"), 
                    inertHtml.appendChild(this.inertBodyElement);
                }
                this.inertBodyElement.innerHTML = '<svg><g onload="this.parentNode.remove()"></g></svg>', 
                !this.inertBodyElement.querySelector || this.inertBodyElement.querySelector("svg") ? (this.inertBodyElement.innerHTML = '<svg><p><style><img src="</style><img src=x onerror=alert(1)//">', 
                this.getInertBodyElement = this.inertBodyElement.querySelector && this.inertBodyElement.querySelector("svg img") && function() {
                    try {
                        return !!window.DOMParser;
                    } catch (_a) {
                        return !1;
                    }
                }() ? this.getInertBodyElement_DOMParser : this.getInertBodyElement_InertDocument) : this.getInertBodyElement = this.getInertBodyElement_XHR;
            }
            getInertBodyElement_XHR(html) {
                html = "<body><remove></remove>" + html + "</body>";
                try {
                    html = encodeURI(html);
                } catch (_a) {
                    return null;
                }
                const xhr = new XMLHttpRequest;
                xhr.responseType = "document", xhr.open("GET", "data:text/html;charset=utf-8," + html, !1), 
                xhr.send(void 0);
                const body = xhr.response.body;
                return body.removeChild(body.firstChild), body;
            }
            getInertBodyElement_DOMParser(html) {
                html = "<body><remove></remove>" + html + "</body>";
                try {
                    const body = (new window.DOMParser).parseFromString(html, "text/html").body;
                    return body.removeChild(body.firstChild), body;
                } catch (_a) {
                    return null;
                }
            }
            getInertBodyElement_InertDocument(html) {
                const templateEl = this.inertDocument.createElement("template");
                return "content" in templateEl ? (templateEl.innerHTML = html, templateEl) : (this.inertBodyElement.innerHTML = html, 
                this.defaultDoc.documentMode && this.stripCustomNsAttrs(this.inertBodyElement), 
                this.inertBodyElement);
            }
            stripCustomNsAttrs(el) {
                const elAttrs = el.attributes;
                for (let i = elAttrs.length - 1; 0 < i; i--) {
                    const attrName = elAttrs.item(i).name;
                    "xmlns:ns1" !== attrName && 0 !== attrName.indexOf("ns1:") || el.removeAttribute(attrName);
                }
                let childNode = el.firstChild;
                for (;childNode; ) childNode.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(childNode), 
                childNode = childNode.nextSibling;
            }
        }
        const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi, DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
        function _sanitizeUrl(url) {
            return (url = String(url)).match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN) ? url : (isDevMode() && console.warn(`WARNING: sanitizing unsafe URL value ${url} (see http://g.co/ng/security#xss)`), 
            "unsafe:" + url);
        }
        function tagSet(tags) {
            const res = {};
            for (const t of tags.split(",")) res[t] = !0;
            return res;
        }
        function merge(...sets) {
            const res = {};
            for (const s of sets) for (const v in s) s.hasOwnProperty(v) && (res[v] = !0);
            return res;
        }
        const VOID_ELEMENTS = tagSet("area,br,col,hr,img,wbr"), OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet("rp,rt"), OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS), VALID_ELEMENTS = merge(VOID_ELEMENTS, merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), OPTIONAL_END_TAG_ELEMENTS), URI_ATTRS = tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), SRCSET_ATTRS = tagSet("srcset"), VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet("script,style,template");
        class SanitizingHtmlSerializer {
            constructor() {
                this.sanitizedSomething = !1, this.buf = [];
            }
            sanitizeChildren(el) {
                let current = el.firstChild, traverseContent = !0;
                for (;current; ) if (current.nodeType === Node.ELEMENT_NODE ? traverseContent = this.startElement(current) : current.nodeType === Node.TEXT_NODE ? this.chars(current.nodeValue) : this.sanitizedSomething = !0, 
                traverseContent && current.firstChild) current = current.firstChild; else for (;current; ) {
                    current.nodeType === Node.ELEMENT_NODE && this.endElement(current);
                    let next = this.checkClobberedElement(current, current.nextSibling);
                    if (next) {
                        current = next;
                        break;
                    }
                    current = this.checkClobberedElement(current, current.parentNode);
                }
                return this.buf.join("");
            }
            startElement(element) {
                const tagName = element.nodeName.toLowerCase();
                if (!VALID_ELEMENTS.hasOwnProperty(tagName)) return this.sanitizedSomething = !0, 
                !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
                this.buf.push("<"), this.buf.push(tagName);
                const elAttrs = element.attributes;
                for (let i = 0; i < elAttrs.length; i++) {
                    const elAttr = elAttrs.item(i), attrName = elAttr.name, lower = attrName.toLowerCase();
                    if (!VALID_ATTRS.hasOwnProperty(lower)) {
                        this.sanitizedSomething = !0;
                        continue;
                    }
                    let value = elAttr.value;
                    URI_ATTRS[lower] && (value = _sanitizeUrl(value)), SRCSET_ATTRS[lower] && (srcset = value, 
                    value = (srcset = String(srcset)).split(",").map(srcset => _sanitizeUrl(srcset.trim())).join(", ")), 
                    this.buf.push(" ", attrName, '="', encodeEntities(value), '"');
                }
                var srcset;
                return this.buf.push(">"), !0;
            }
            endElement(current) {
                const tagName = current.nodeName.toLowerCase();
                VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName) && (this.buf.push("</"), 
                this.buf.push(tagName), this.buf.push(">"));
            }
            chars(chars) {
                this.buf.push(encodeEntities(chars));
            }
            checkClobberedElement(node, nextNode) {
                if (nextNode && (node.compareDocumentPosition(nextNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);
                return nextNode;
            }
        }
        const SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
        function encodeEntities(value) {
            return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, (function(match) {
                return "&#" + (1024 * (match.charCodeAt(0) - 55296) + (match.charCodeAt(1) - 56320) + 65536) + ";";
            })).replace(NON_ALPHANUMERIC_REGEXP, (function(match) {
                return "&#" + match.charCodeAt(0) + ";";
            })).replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }
        let inertBodyHelper;
        function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
            let inertBodyElement = null;
            try {
                inertBodyHelper = inertBodyHelper || new InertBodyHelper(defaultDoc);
                let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : "";
                inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
                let mXSSAttempts = 5, parsedHtml = unsafeHtml;
                do {
                    if (0 === mXSSAttempts) throw new Error("Failed to sanitize html because the input is unstable");
                    mXSSAttempts--, unsafeHtml = parsedHtml, parsedHtml = inertBodyElement.innerHTML, 
                    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
                } while (unsafeHtml !== parsedHtml);
                const sanitizer = new SanitizingHtmlSerializer, safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
                return isDevMode() && sanitizer.sanitizedSomething && console.warn("WARNING: sanitizing HTML stripped some content, see http://g.co/ng/security#xss"), 
                safeHtml;
            } finally {
                if (inertBodyElement) {
                    const parent = getTemplateContent(inertBodyElement) || inertBodyElement;
                    for (;parent.firstChild; ) parent.removeChild(parent.firstChild);
                }
            }
        }
        function getTemplateContent(el) {
            return "content" in el && function(el) {
                return el.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === el.nodeName;
            }(el) ? el.content : null;
        }
        const SecurityContext = function() {
            var SecurityContext = {
                NONE: 0,
                HTML: 1,
                STYLE: 2,
                SCRIPT: 3,
                URL: 4,
                RESOURCE_URL: 5
            };
            return SecurityContext[SecurityContext.NONE] = "NONE", SecurityContext[SecurityContext.HTML] = "HTML", 
            SecurityContext[SecurityContext.STYLE] = "STYLE", SecurityContext[SecurityContext.SCRIPT] = "SCRIPT", 
            SecurityContext[SecurityContext.URL] = "URL", SecurityContext[SecurityContext.RESOURCE_URL] = "RESOURCE_URL", 
            SecurityContext;
        }(), SAFE_STYLE_VALUE = new RegExp("^([-,.\"'%_!# a-zA-Z0-9]+|(?:(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|Z|3d)?|(?:rgb|hsl)a?|(?:repeating-)?(?:linear|radial)-gradient|(?:calc|attr))\\([-0-9.%, #a-zA-Z]+\\))$", "g"), URL_RE = /^url\(([^)]+)\)$/;
        function _sanitizeStyle(value) {
            if (!(value = String(value).trim())) return "";
            const urlMatch = value.match(URL_RE);
            return urlMatch && _sanitizeUrl(urlMatch[1]) === urlMatch[1] || value.match(SAFE_STYLE_VALUE) && function(value) {
                let outsideSingle = !0, outsideDouble = !0;
                for (let i = 0; i < value.length; i++) {
                    const c = value.charAt(i);
                    "'" === c && outsideDouble ? outsideSingle = !outsideSingle : '"' === c && outsideSingle && (outsideDouble = !outsideDouble);
                }
                return outsideSingle && outsideDouble;
            }(value) ? value : (isDevMode() && console.warn(`WARNING: sanitizing unsafe style value ${value} (see http://g.co/ng/security#xss).`), 
            "unsafe");
        }
        function ɵɵsanitizeHtml(unsafeHtml) {
            const sanitizer = getSanitizer();
            return sanitizer ? sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || "" : allowSanitizationBypassAndThrow(unsafeHtml, "HTML") ? unwrapSafeValue(unsafeHtml) : _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));
        }
        function ɵɵsanitizeUrl(unsafeUrl) {
            const sanitizer = getSanitizer();
            return sanitizer ? sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || "" : allowSanitizationBypassAndThrow(unsafeUrl, "URL") ? unwrapSafeValue(unsafeUrl) : _sanitizeUrl(renderStringify(unsafeUrl));
        }
        const ɵɵdefaultStyleSanitizer = function(prop, value, mode) {
            let doSanitizeValue = !0;
            return 1 & (mode = mode || 3) && (doSanitizeValue = "background-image" === prop || "background" === prop || "border-image" === prop || "filter" === prop || "list-style" === prop || "list-style-image" === prop || "clip-path" === prop), 
            2 & mode ? doSanitizeValue ? function(unsafeStyle) {
                const sanitizer = getSanitizer();
                return sanitizer ? sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || "" : allowSanitizationBypassAndThrow(unsafeStyle, "Style") ? unwrapSafeValue(unsafeStyle) : _sanitizeStyle(renderStringify(unsafeStyle));
            }(value) : value : doSanitizeValue;
        };
        function getSanitizer() {
            const lView = getLView();
            return lView && lView[SANITIZER];
        }
        function createLContext(lView, nodeIndex, native) {
            return {
                lView: lView,
                nodeIndex: nodeIndex,
                native: native,
                component: void 0,
                directives: void 0,
                localRefs: void 0
            };
        }
        function attachPatchData(target, data) {
            target[MONKEY_PATCH_KEY_NAME] = data;
        }
        function findViaNativeElement(lView, target) {
            let tNode = lView[TVIEW].firstChild;
            for (;tNode; ) {
                if (getNativeByTNodeOrNull(tNode, lView) === target) return tNode.index;
                tNode = traverseNextElement(tNode);
            }
            return -1;
        }
        function traverseNextElement(tNode) {
            if (tNode.child) return tNode.child;
            if (tNode.next) return tNode.next;
            for (;tNode.parent && !tNode.parent.next; ) tNode = tNode.parent;
            return tNode.parent && tNode.parent.next;
        }
        function throwMultipleComponentError(tNode) {
            throw new Error(`Multiple components match node with tagname ${tNode.tagName}`);
        }
        function throwMixedMultiProviderError() {
            throw new Error("Cannot mix multi providers and regular providers");
        }
        function registerPreOrderHooks(directiveIndex, directiveDef, tView, nodeIndex, initialPreOrderHooksLength, initialPreOrderCheckHooksLength) {
            const {onChanges: onChanges, onInit: onInit, doCheck: doCheck} = directiveDef;
            initialPreOrderHooksLength >= 0 && (!tView.preOrderHooks || initialPreOrderHooksLength === tView.preOrderHooks.length) && (onChanges || onInit || doCheck) && (tView.preOrderHooks || (tView.preOrderHooks = [])).push(nodeIndex), 
            initialPreOrderCheckHooksLength >= 0 && (!tView.preOrderCheckHooks || initialPreOrderCheckHooksLength === tView.preOrderCheckHooks.length) && (onChanges || doCheck) && (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(nodeIndex), 
            onChanges && ((tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, onChanges), 
            (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, onChanges)), 
            onInit && (tView.preOrderHooks || (tView.preOrderHooks = [])).push(-directiveIndex, onInit), 
            doCheck && ((tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, doCheck), 
            (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, doCheck));
        }
        function registerPostOrderHooks(tView, tNode) {
            for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {
                const directiveDef = tView.data[i];
                directiveDef.afterContentInit && (tView.contentHooks || (tView.contentHooks = [])).push(-i, directiveDef.afterContentInit), 
                directiveDef.afterContentChecked && ((tView.contentHooks || (tView.contentHooks = [])).push(i, directiveDef.afterContentChecked), 
                (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, directiveDef.afterContentChecked)), 
                directiveDef.afterViewInit && (tView.viewHooks || (tView.viewHooks = [])).push(-i, directiveDef.afterViewInit), 
                directiveDef.afterViewChecked && ((tView.viewHooks || (tView.viewHooks = [])).push(i, directiveDef.afterViewChecked), 
                (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, directiveDef.afterViewChecked)), 
                null != directiveDef.onDestroy && (tView.destroyHooks || (tView.destroyHooks = [])).push(i, directiveDef.onDestroy);
            }
        }
        function executeCheckHooks(lView, hooks, nodeIndex) {
            callHooks(lView, hooks, 3, nodeIndex);
        }
        function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
            (3 & lView[FLAGS]) === initPhase && callHooks(lView, hooks, initPhase, nodeIndex);
        }
        function incrementInitPhaseFlags(lView, initPhase) {
            let flags = lView[FLAGS];
            (3 & flags) === initPhase && (flags &= 1023, lView[FLAGS] = flags += 1);
        }
        function callHooks(currentView, arr, initPhase, currentNodeIndex) {
            const nodeIndexLimit = null != currentNodeIndex ? currentNodeIndex : -1;
            let lastNodeIndexFound = 0;
            for (let i = void 0 !== currentNodeIndex ? 65535 & currentView[PREORDER_HOOK_FLAGS] : 0; i < arr.length; i++) if ("number" == typeof arr[i + 1]) {
                if (lastNodeIndexFound = arr[i], null != currentNodeIndex && lastNodeIndexFound >= currentNodeIndex) break;
            } else arr[i] < 0 && (currentView[PREORDER_HOOK_FLAGS] += 65536), (lastNodeIndexFound < nodeIndexLimit || -1 == nodeIndexLimit) && (callHook(currentView, initPhase, arr, i), 
            currentView[PREORDER_HOOK_FLAGS] = (4294901760 & currentView[PREORDER_HOOK_FLAGS]) + i + 2), 
            i++;
        }
        function callHook(currentView, initPhase, arr, i) {
            const isInitHook = arr[i] < 0, hook = arr[i + 1], directive = currentView[isInitHook ? -arr[i] : arr[i]];
            isInitHook ? currentView[FLAGS] >> 10 < currentView[PREORDER_HOOK_FLAGS] >> 16 && (3 & currentView[FLAGS]) === initPhase && (currentView[FLAGS] += 1024, 
            hook.call(directive)) : hook.call(directive);
        }
        const NG_TEMPLATE_SELECTOR = "ng-template";
        function isCssClassMatching(nodeClassAttrVal, cssClassToMatch) {
            const nodeClassesLen = nodeClassAttrVal.length, matchIndex = nodeClassAttrVal.toLowerCase().indexOf(cssClassToMatch), matchEndIdx = matchIndex + cssClassToMatch.length;
            return !(-1 === matchIndex || matchIndex > 0 && " " !== nodeClassAttrVal[matchIndex - 1] || matchEndIdx < nodeClassesLen && " " !== nodeClassAttrVal[matchEndIdx]);
        }
        function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
            return currentSelector === (0 !== tNode.type || isProjectionMode ? tNode.tagName : NG_TEMPLATE_SELECTOR);
        }
        function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
            let mode = 4;
            const nodeAttrs = tNode.attrs || [], nameOnlyMarkerIdx = function(nodeAttrs) {
                for (let i = 0; i < nodeAttrs.length; i++) if (isNameOnlyAttributeMarker(nodeAttrs[i])) return i;
                return nodeAttrs.length;
            }(nodeAttrs);
            let skipToNextSelector = !1;
            for (let i = 0; i < selector.length; i++) {
                const current = selector[i];
                if ("number" != typeof current) {
                    if (!skipToNextSelector) if (4 & mode) {
                        if (mode = 2 | 1 & mode, "" !== current && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || "" === current && 1 === selector.length) {
                            if (isPositive(mode)) return !1;
                            skipToNextSelector = !0;
                        }
                    } else {
                        const selectorAttrValue = 8 & mode ? current : selector[++i];
                        if (8 & mode && tNode.classes) {
                            if (!isCssClassMatching(getInitialStylingValue(tNode.classes), selectorAttrValue)) {
                                if (isPositive(mode)) return !1;
                                skipToNextSelector = !0;
                            }
                            continue;
                        }
                        const attrIndexInNode = findAttrIndexInNode(8 & mode ? "class" : current, nodeAttrs, 0 == tNode.type && tNode.tagName !== NG_TEMPLATE_SELECTOR, isProjectionMode);
                        if (-1 === attrIndexInNode) {
                            if (isPositive(mode)) return !1;
                            skipToNextSelector = !0;
                            continue;
                        }
                        if ("" !== selectorAttrValue) {
                            let nodeAttrValue;
                            nodeAttrValue = attrIndexInNode > nameOnlyMarkerIdx ? "" : nodeAttrs[attrIndexInNode + 1].toLowerCase();
                            const compareAgainstClassName = 8 & mode ? nodeAttrValue : null;
                            if (compareAgainstClassName && !isCssClassMatching(compareAgainstClassName, selectorAttrValue) || 2 & mode && selectorAttrValue !== nodeAttrValue) {
                                if (isPositive(mode)) return !1;
                                skipToNextSelector = !0;
                            }
                        }
                    }
                } else {
                    if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) return !1;
                    if (skipToNextSelector && isPositive(current)) continue;
                    skipToNextSelector = !1, mode = current | 1 & mode;
                }
            }
            return isPositive(mode) || skipToNextSelector;
        }
        function isPositive(mode) {
            return 0 == (1 & mode);
        }
        function findAttrIndexInNode(name, attrs, isInlineTemplate, isProjectionMode) {
            if (null === attrs) return -1;
            let i = 0;
            if (isProjectionMode || !isInlineTemplate) {
                let bindingsMode = !1;
                for (;i < attrs.length; ) {
                    const maybeAttrName = attrs[i];
                    if (maybeAttrName === name) return i;
                    if (3 === maybeAttrName || 6 === maybeAttrName) bindingsMode = !0; else {
                        if (1 === maybeAttrName || 2 === maybeAttrName) {
                            let value = attrs[++i];
                            for (;"string" == typeof value; ) value = attrs[++i];
                            continue;
                        }
                        if (4 === maybeAttrName) break;
                        if (0 === maybeAttrName) {
                            i += 4;
                            continue;
                        }
                    }
                    i += bindingsMode ? 1 : 2;
                }
                return -1;
            }
            return function(attrs, name) {
                let i = attrs.indexOf(4);
                if (i > -1) for (i++; i < attrs.length; ) {
                    if (attrs[i] === name) return i;
                    i++;
                }
                return -1;
            }(attrs, name);
        }
        function isNodeMatchingSelectorList(tNode, selector, isProjectionMode = !1) {
            for (let i = 0; i < selector.length; i++) if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) return !0;
            return !1;
        }
        function isSelectorInSelectorList(selector, list) {
            selectorListLoop: for (let i = 0; i < list.length; i++) {
                const currentSelectorInList = list[i];
                if (selector.length === currentSelectorInList.length) {
                    for (let j = 0; j < selector.length; j++) if (selector[j] !== currentSelectorInList[j]) continue selectorListLoop;
                    return !0;
                }
            }
            return !1;
        }
        const _state = {
            element: null,
            directiveIndex: -1,
            sourceIndex: -1,
            classesBitMask: -1,
            classesIndex: -1,
            stylesBitMask: -1,
            stylesIndex: -1,
            lastDirectClassMap: null,
            lastDirectStyleMap: null
        }, BIT_MASK_START_VALUE = 0, INDEX_START_VALUE = 1;
        function getStylingState(element, directiveIndex) {
            return _state.element !== element ? (_state.element = element, _state.directiveIndex = directiveIndex, 
            _state.sourceIndex = directiveIndex === TEMPLATE_DIRECTIVE_INDEX ? 0 : 1, _state.classesBitMask = BIT_MASK_START_VALUE, 
            _state.classesIndex = INDEX_START_VALUE, _state.stylesBitMask = BIT_MASK_START_VALUE, 
            _state.stylesIndex = INDEX_START_VALUE, _state.lastDirectClassMap = null, _state.lastDirectStyleMap = null) : _state.directiveIndex !== directiveIndex && (_state.directiveIndex = directiveIndex, 
            _state.sourceIndex++), _state;
        }
        const VALUE_IS_EXTERNALLY_MODIFIED = {}, STYLING_INDEX_FOR_MAP_BINDING = 0;
        function updateClassViaContext(context, tNode, data, element, directiveIndex, prop, bindingIndex, value, forceUpdate, firstUpdatePass) {
            const isMapBased = !prop, state = getStylingState(element, directiveIndex), countIndex = isMapBased ? STYLING_INDEX_FOR_MAP_BINDING : state.classesIndex++;
            return !(!firstUpdatePass && value === NO_CHANGE || !updateBindingData(context, tNode, data, countIndex, state.sourceIndex, prop, bindingIndex, value, forceUpdate, !1, firstUpdatePass, !0) && !forceUpdate || (state.classesBitMask |= 1 << countIndex, 
            0));
        }
        function updateStyleViaContext(context, tNode, data, element, directiveIndex, prop, bindingIndex, value, sanitizer, forceUpdate, firstUpdatePass) {
            const isMapBased = !prop, state = getStylingState(element, directiveIndex), countIndex = isMapBased ? STYLING_INDEX_FOR_MAP_BINDING : state.stylesIndex++;
            if (firstUpdatePass || value !== NO_CHANGE) {
                const sanitizationRequired = !!isMapBased || !!sanitizer && sanitizer(prop, null, 1);
                if (updateBindingData(context, tNode, data, countIndex, state.sourceIndex, prop, bindingIndex, value, forceUpdate, sanitizationRequired, firstUpdatePass, !1) || forceUpdate) return state.stylesBitMask |= 1 << countIndex, 
                !0;
            }
            return !1;
        }
        function updateBindingData(context, tNode, data, counterIndex, sourceIndex, prop, bindingIndex, value, forceUpdate, sanitizationRequired, firstUpdatePass, isClassBased) {
            const hostBindingsMode = isHostStylingActive(sourceIndex), hostBindingsFlag = isClassBased ? 4096 : 131072;
            firstUpdatePass && registerBinding(context, tNode, counterIndex, sourceIndex, prop, bindingIndex, sanitizationRequired, isClassBased);
            const changed = forceUpdate || hasValueChanged(data[bindingIndex], value);
            return changed && (setValue(data, bindingIndex, value), hasConfig(tNode, hostBindingsFlag) && !hostBindingsMode && (!prop || !value) && function(context, tNode, data, prop, isClassBased) {
                const valuesCount = getValuesCount(context);
                if (null !== prop && hasConfig(tNode, isClassBased ? 4096 : 131072)) {
                    const itemsPerRow = 4 + valuesCount;
                    let i = 2, found = !1;
                    for (;i < context.length; ) {
                        if (getProp(context, i) === prop) {
                            found = !0;
                            break;
                        }
                        i += itemsPerRow;
                    }
                    if (found) {
                        const bindingsStart = i + 4, valuesEnd = bindingsStart + valuesCount - 1;
                        for (let i = bindingsStart + 1; i < valuesEnd; i++) {
                            const bindingIndex = context[i];
                            0 !== bindingIndex && setValue(data, bindingIndex, null);
                        }
                    }
                }
                if (hasConfig(tNode, isClassBased ? 512 : 16384)) {
                    const bindingsStart = 6, valuesEnd = bindingsStart + valuesCount - 1;
                    for (let i = bindingsStart + 1; i < valuesEnd; i++) {
                        const stylingMap = getValue(data, context[i]);
                        stylingMap && (stylingMap[0] = MAP_DIRTY_VALUE);
                    }
                }
            }(context, tNode, data, prop, isClassBased)), changed;
        }
        function registerBinding(context, tNode, countId, sourceIndex, prop, bindingValue, sanitizationRequired, isClassBased) {
            let found = !1;
            prop = prop || MAP_BASED_ENTRY_PROP_NAME;
            let totalSources = getTotalSources(context);
            for (;totalSources <= sourceIndex; ) addNewSourceColumn(context), totalSources++;
            const collisionFlag = isClassBased ? 8192 : 262144, isBindingIndexValue = "number" == typeof bindingValue, entriesPerRow = 4 + getValuesCount(context);
            let i = 2;
            for (;i < context.length; ) {
                const p = getProp(context, i);
                if (prop <= p) {
                    prop < p ? allocateNewContextEntry(context, i, prop, sanitizationRequired) : isBindingIndexValue && patchConfig(tNode, collisionFlag), 
                    addBindingIntoContext(context, i, bindingValue, countId, sourceIndex), found = !0;
                    break;
                }
                i += entriesPerRow;
            }
            found || (allocateNewContextEntry(context, context.length, prop, sanitizationRequired), 
            addBindingIntoContext(context, i, bindingValue, countId, sourceIndex));
        }
        function allocateNewContextEntry(context, index, prop, sanitizationRequired) {
            context.splice(index, 0, sanitizationRequired ? 1 : 0, DEFAULT_GUARD_MASK_VALUE, DEFAULT_GUARD_MASK_VALUE, prop), 
            index += 4;
            const totalBindingsPerEntry = getTotalSources(context);
            for (let i = 0; i < totalBindingsPerEntry; i++) context.splice(index, 0, DEFAULT_BINDING_INDEX), 
            index++;
            context.splice(index, 0, DEFAULT_BINDING_VALUE);
        }
        function addBindingIntoContext(context, index, bindingValue, bitIndex, sourceIndex) {
            if ("number" == typeof bindingValue) {
                const hostBindingsMode = isHostStylingActive(sourceIndex);
                context[index + 4 + sourceIndex] = bindingValue, function(context, index, maskValue, isHostBinding) {
                    context[index + (isHostBinding ? 2 : 1)] = maskValue;
                }(context, index, getGuardMask(context, index, hostBindingsMode) | 1 << bitIndex, hostBindingsMode);
            } else null !== bindingValue && null === getDefaultValue(context, index) && function(context, index, value) {
                context[index + 4 + getTotalSources(context)] = value;
            }(context, index, bindingValue);
        }
        function addNewSourceColumn(context) {
            const insertOffset = 4 + getValuesCount(context) - 1;
            let index = 2;
            for (;index < context.length; ) index += insertOffset, context.splice(index++, 0, DEFAULT_BINDING_INDEX), 
            index++;
            context[0]++;
        }
        function syncContextInitialStyling(context, tNode, isClassBased) {
            !function(context, tNode, initialStyling, isClassBased) {
                let hasInitialStyling = !1;
                for (let i = 1; i < initialStyling.length; i += 2) {
                    const value = getMapValue(initialStyling, i);
                    value && (registerBinding(context, tNode, -1, 0, getMapProp(initialStyling, i), value, !1, isClassBased), 
                    hasInitialStyling = !0);
                }
                hasInitialStyling && patchConfig(tNode, 256);
            }(context, tNode, getStylingMapArray(context), isClassBased);
        }
        function applyStylingViaContext(context, tNode, renderer, element, bindingData, bitMaskValue, applyStylingFn, sanitizer, hostBindingsMode, isClassBased) {
            const bitMask = !0 === (value = bitMaskValue) ? -1 : !1 === value ? 0 : value;
            var value;
            let stylingMapsSyncFn = null, applyAllValues = !1;
            hasConfig(tNode, isClassBased ? 512 : 16384) && (stylingMapsSyncFn = _activeStylingMapApplyFn, 
            applyAllValues = 0 != (bitMask & getGuardMask(context, 2, hostBindingsMode)));
            const valuesCount = getValuesCount(context);
            let totalBindingsToVisit = 1, mapsMode = applyAllValues ? 1 : 0;
            hostBindingsMode && (mapsMode |= 8, totalBindingsToVisit = valuesCount - 1);
            let i = function(context, tNode, isClassBased) {
                let startPosition = 2;
                return hasConfig(tNode, isClassBased ? 512 : 16384) && (startPosition += 4 + getValuesCount(context)), 
                startPosition;
            }(context, tNode, isClassBased);
            for (;i < context.length; ) {
                if (bitMask & getGuardMask(context, i, hostBindingsMode)) {
                    let valueApplied = !1;
                    const prop = getProp(context, i), defaultValue = getDefaultValue(context, i);
                    for (let j = 0; j < totalBindingsToVisit; j++) {
                        const bindingIndex = getBindingValue(context, i, j);
                        if (!valueApplied && 0 !== bindingIndex) {
                            const value = getValue(bindingData, bindingIndex);
                            isStylingValueDefined(value) && (hostBindingsMode && 0 === j || applyStylingFn(renderer, element, prop, sanitizer && isSanitizationRequired(context, i) ? sanitizer(prop, value, 2) : unwrapSafeValue(value), bindingIndex), 
                            valueApplied = !0);
                        }
                        if (stylingMapsSyncFn) {
                            let mode = mapsMode | (valueApplied ? 4 : 2);
                            hostBindingsMode && 0 === j && (mode |= 16);
                            const valueAppliedWithinMap = stylingMapsSyncFn(context, renderer, element, bindingData, j, applyStylingFn, sanitizer, mode, prop, defaultValue);
                            valueApplied = valueApplied || valueAppliedWithinMap;
                        }
                    }
                    valueApplied || applyStylingFn(renderer, element, prop, defaultValue);
                }
                i += 4 + valuesCount;
            }
            stylingMapsSyncFn && (hostBindingsMode && (mapsMode |= 16), stylingMapsSyncFn(context, renderer, element, bindingData, 0, applyStylingFn, sanitizer, mapsMode));
        }
        function writeStylingValueDirectly(renderer, element, value, isClassBased, initialValue) {
            let valueToApply;
            return isClassBased ? (valueToApply = "string" == typeof value ? value : function(obj) {
                let str = "";
                if (obj) for (let key in obj) obj[key] && (str += (str.length ? " " : "") + key);
                return str;
            }(value), null !== initialValue && (valueToApply = concatString(initialValue, valueToApply, " ")), 
            setClassName(renderer, element, valueToApply)) : (valueToApply = forceStylesAsString(value, !0), 
            null !== initialValue && (valueToApply = initialValue + ";" + valueToApply), setStyleAttr(renderer, element, valueToApply)), 
            valueToApply;
        }
        function applyStylingValue(renderer, element, prop, value, applyFn, bindingIndex, sanitizer) {
            let valueToApply = unwrapSafeValue(value);
            return !!isStylingValueDefined(valueToApply) && (applyFn(renderer, element, prop, valueToApply = sanitizer ? sanitizer(prop, value, 3) : valueToApply, bindingIndex), 
            !0);
        }
        function findAndApplyMapValue(renderer, element, applyFn, map, prop, bindingIndex, sanitizer) {
            for (let i = 1; i < map.length; i += 2) {
                const p = getMapProp(map, i);
                if (p === prop) {
                    let valueToApply = getMapValue(map, i);
                    return applyFn(renderer, element, prop, valueToApply = sanitizer ? sanitizer(prop, valueToApply, 3) : valueToApply, bindingIndex), 
                    !0;
                }
                if (p > prop) break;
            }
            return !1;
        }
        let _activeStylingMapApplyFn = null;
        const setStyle = (renderer, native, prop, value) => {
            if (null !== renderer) if (isStylingValueDefined(value)) if (value = value.toString(), 
            isProceduralRenderer(renderer)) renderer.setStyle(native, prop, value, RendererStyleFlags3.DashCase); else {
                const nativeStyle = native.style;
                null != nativeStyle && nativeStyle.setProperty(prop, value);
            } else if (isProceduralRenderer(renderer)) renderer.removeStyle(native, prop, RendererStyleFlags3.DashCase); else {
                const nativeStyle = native.style;
                null != nativeStyle && nativeStyle.removeProperty(prop);
            }
        }, setClass = (renderer, native, className, value) => {
            if (null !== renderer && "" !== className) if (value) if (isProceduralRenderer(renderer)) renderer.addClass(native, className); else {
                const classList = native.classList;
                null != classList && classList.add(className);
            } else if (isProceduralRenderer(renderer)) renderer.removeClass(native, className); else {
                const classList = native.classList;
                null != classList && classList.remove(className);
            }
        }, setClassName = (renderer, native, className) => {
            null !== renderer && (isProceduralRenderer(renderer) ? renderer.setAttribute(native, "class", className) : native.className = className);
        }, setStyleAttr = (renderer, native, value) => {
            null !== renderer && (isProceduralRenderer(renderer) ? renderer.setAttribute(native, "style", value) : native.setAttribute("style", value));
        };
        function renderStylingMap(renderer, element, stylingValues, isClassBased) {
            const stylingMapArr = getStylingMapArray(stylingValues);
            if (stylingMapArr) for (let i = 1; i < stylingMapArr.length; i += 2) {
                const prop = getMapProp(stylingMapArr, i), value = getMapValue(stylingMapArr, i);
                isClassBased ? setClass(renderer, element, prop, value, null) : setStyle(renderer, element, prop, value, null);
            }
        }
        function ɵɵadvance(delta) {
            selectIndexInternal(getLView(), getSelectedIndex() + delta, getCheckNoChangesMode());
        }
        function selectIndexInternal(lView, index, checkNoChangesMode) {
            if (hasActiveElementFlag(1) && executeElementExitFn(), !checkNoChangesMode) if (3 == (3 & lView[FLAGS])) {
                const preOrderCheckHooks = lView[TVIEW].preOrderCheckHooks;
                null !== preOrderCheckHooks && executeCheckHooks(lView, preOrderCheckHooks, index);
            } else {
                const preOrderHooks = lView[TVIEW].preOrderHooks;
                null !== preOrderHooks && executeInitAndCheckHooks(lView, preOrderHooks, 0, index);
            }
            setSelectedIndex(index);
        }
        const syncStylingMap = (context, renderer, element, data, sourceIndex, applyStylingFn, sanitizer, mode, targetProp, defaultValue) => {
            let targetPropValueWasApplied = !1;
            if (getValuesCount(context)) {
                let runTheSyncAlgorithm = !0;
                const loopUntilEnd = !targetProp;
                loopUntilEnd && 0 == (1 & mode) && (runTheSyncAlgorithm = !1, targetPropValueWasApplied = !0), 
                runTheSyncAlgorithm && (targetPropValueWasApplied = function innerSyncStylingMap(context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp, currentMapIndex, defaultValue) {
                    const mapsLimit = getValuesCount(context) - 1 - 1, recurseInnerMaps = currentMapIndex < mapsLimit && 0 != (8 & mode), checkValuesOnly = 0 != (16 & mode);
                    checkValuesOnly && (mode &= -17);
                    let targetPropValueWasApplied = !1;
                    if (currentMapIndex <= mapsLimit) {
                        let cursor = ((mapIndex = currentMapIndex) >= MAP_CURSORS.length && MAP_CURSORS.push(1), 
                        MAP_CURSORS[mapIndex]);
                        const bindingIndex = getBindingValue(context, 2, currentMapIndex), stylingMapArr = getValue(data, bindingIndex);
                        if (stylingMapArr) {
                            for (;cursor < stylingMapArr.length; ) {
                                const prop = getMapProp(stylingMapArr, cursor), iteratedTooFar = targetProp && prop > targetProp, isTargetPropMatched = !iteratedTooFar && prop === targetProp, value = getMapValue(stylingMapArr, cursor), valueIsDefined = isStylingValueDefined(value), innerMode = iteratedTooFar ? mode : resolveInnerMapMode(mode, valueIsDefined, isTargetPropMatched), innerProp = iteratedTooFar ? targetProp : prop;
                                let valueApplied = !!recurseInnerMaps && innerSyncStylingMap(context, renderer, element, data, applyStylingFn, sanitizer, innerMode, innerProp, currentMapIndex + 1, defaultValue);
                                if (iteratedTooFar) {
                                    targetPropValueWasApplied || (targetPropValueWasApplied = valueApplied);
                                    break;
                                }
                                if (!valueApplied && isValueAllowedToBeApplied(mode, isTargetPropMatched) && (valueApplied = !0, 
                                !checkValuesOnly)) {
                                    const bindingIndexToApply = isTargetPropMatched ? bindingIndex : null;
                                    let finalValue;
                                    applyStylingFn(renderer, element, prop, finalValue = isTargetPropMatched && !valueIsDefined ? defaultValue : sanitizer ? sanitizer(prop, value, 3) : value ? unwrapSafeValue(value) : null, bindingIndexToApply);
                                }
                                targetPropValueWasApplied = valueApplied && isTargetPropMatched, cursor += 2;
                            }
                            MAP_CURSORS[currentMapIndex] = cursor, !recurseInnerMaps || 1 !== stylingMapArr.length && targetProp || (targetPropValueWasApplied = innerSyncStylingMap(context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp, currentMapIndex + 1, defaultValue));
                        } else recurseInnerMaps && (targetPropValueWasApplied = innerSyncStylingMap(context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp, currentMapIndex + 1, defaultValue));
                    }
                    var mapIndex;
                    return targetPropValueWasApplied;
                }(context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp || null, sourceIndex, defaultValue || null)), 
                loopUntilEnd && function() {
                    for (let i = 0; i < MAP_CURSORS.length; i++) MAP_CURSORS[i] = 1;
                }();
            }
            return targetPropValueWasApplied;
        };
        function resolveInnerMapMode(currentMode, valueIsDefined, isTargetPropMatched) {
            let innerMode = currentMode;
            return !valueIsDefined && (isTargetPropMatched ? 2 & currentMode : 1 & currentMode) ? (innerMode |= 2, 
            innerMode &= -5) : (innerMode |= 4, innerMode &= -3), innerMode;
        }
        function isValueAllowedToBeApplied(mode, isTargetPropMatched) {
            let doApplyValue = 0 != (1 & mode);
            return doApplyValue ? 4 & mode && isTargetPropMatched && (doApplyValue = !1) : 2 & mode && (doApplyValue = isTargetPropMatched), 
            doApplyValue;
        }
        const MAP_CURSORS = [];
        function refreshContentQueries(tView, lView) {
            const contentQueries = tView.contentQueries;
            if (null !== contentQueries) for (let i = 0; i < contentQueries.length; i += 2) {
                const queryStartIdx = contentQueries[i], directiveDefIdx = contentQueries[i + 1];
                if (-1 !== directiveDefIdx) {
                    const directiveDef = tView.data[directiveDefIdx];
                    setCurrentQueryIndex(queryStartIdx), directiveDef.contentQueries(2, lView[directiveDefIdx], directiveDefIdx);
                }
            }
        }
        function elementCreate(name, renderer, namespace) {
            return isProceduralRenderer(renderer) ? renderer.createElement(name, namespace) : null === namespace ? renderer.createElement(name) : renderer.createElementNS(namespace, name);
        }
        function createLView(parentLView, tView, context, flags, host, tHostNode, rendererFactory, renderer, sanitizer, injector) {
            const lView = tView.blueprint.slice();
            return lView[HOST] = host, lView[FLAGS] = 140 | flags, resetPreOrderHookFlags(lView), 
            lView[PARENT] = lView[DECLARATION_VIEW] = parentLView, lView[CONTEXT] = context, 
            lView[RENDERER_FACTORY] = rendererFactory || parentLView && parentLView[RENDERER_FACTORY], 
            lView[RENDERER] = renderer || parentLView && parentLView[RENDERER], lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] || null, 
            lView[INJECTOR$1] = injector || parentLView && parentLView[INJECTOR$1] || null, 
            lView[T_HOST] = tHostNode, lView;
        }
        function getOrCreateTNode(tView, tHostNode, index, type, name, attrs) {
            const adjustedIndex = index + HEADER_OFFSET, tNode = tView.data[adjustedIndex] || function(tView, tHostNode, adjustedIndex, type, name, attrs) {
                const previousOrParentTNode = getPreviousOrParentTNode(), isParent = getIsParent(), parent = isParent ? previousOrParentTNode : previousOrParentTNode && previousOrParentTNode.parent, tNode = tView.data[adjustedIndex] = createTNode(0, parent && parent !== tHostNode ? parent : null, type, adjustedIndex, name, attrs);
                return null === tView.firstChild && (tView.firstChild = tNode), previousOrParentTNode && (!isParent || null != previousOrParentTNode.child || null === tNode.parent && 2 !== previousOrParentTNode.type ? isParent || (previousOrParentTNode.next = tNode) : previousOrParentTNode.child = tNode), 
                tNode;
            }(tView, tHostNode, adjustedIndex, type, name, attrs);
            return setPreviousOrParentTNode(tNode, !0), tNode;
        }
        function renderView(lView, tView, context) {
            enterView(lView, lView[T_HOST]);
            try {
                const viewQuery = tView.viewQuery;
                null !== viewQuery && executeViewQueryFn(1, viewQuery, context);
                const templateFn = tView.template;
                null !== templateFn && executeTemplate(lView, templateFn, 1, context), tView.firstCreatePass && (tView.firstCreatePass = !1), 
                tView.staticContentQueries && refreshContentQueries(tView, lView), tView.staticViewQueries && executeViewQueryFn(2, tView.viewQuery, context);
                const components = tView.components;
                null !== components && function(hostLView, components) {
                    for (let i = 0; i < components.length; i++) renderComponent(hostLView, components[i]);
                }(lView, components);
            } finally {
                lView[FLAGS] &= -5, leaveView();
            }
        }
        function refreshView(lView, tView, templateFn, context) {
            enterView(lView, lView[T_HOST]);
            const flags = lView[FLAGS];
            try {
                resetPreOrderHookFlags(lView), setBindingIndex(tView.bindingStartIndex), null !== templateFn && executeTemplate(lView, templateFn, 2, context);
                const checkNoChangesMode = getCheckNoChangesMode(), hooksInitPhaseCompleted = 3 == (3 & flags);
                if (!checkNoChangesMode) if (hooksInitPhaseCompleted) {
                    const preOrderCheckHooks = tView.preOrderCheckHooks;
                    null !== preOrderCheckHooks && executeCheckHooks(lView, preOrderCheckHooks, null);
                } else {
                    const preOrderHooks = tView.preOrderHooks;
                    null !== preOrderHooks && executeInitAndCheckHooks(lView, preOrderHooks, 0, null), 
                    incrementInitPhaseFlags(lView, 0);
                }
                if (function(lView) {
                    let viewOrContainer = lView[CHILD_HEAD];
                    for (;null !== viewOrContainer; ) {
                        if (isLContainer(viewOrContainer) && -1 === viewOrContainer[ACTIVE_INDEX]) {
                            for (let i = CONTAINER_HEADER_OFFSET; i < viewOrContainer.length; i++) {
                                const embeddedLView = viewOrContainer[i], embeddedTView = embeddedLView[TVIEW];
                                refreshView(embeddedLView, embeddedTView, embeddedTView.template, embeddedLView[CONTEXT]);
                            }
                            const movedViews = viewOrContainer[MOVED_VIEWS];
                            if (null !== movedViews) {
                                const declaredComponentLView = findComponentView(lView);
                                for (let i = 0; i < movedViews.length; i++) {
                                    const movedLView = movedViews[i];
                                    let parentLView = movedLView[PARENT];
                                    for (;isLContainer(parentLView); ) parentLView = parentLView[PARENT];
                                    const insertedComponentLView = findComponentView(parentLView);
                                    if (16 != (16 & insertedComponentLView[FLAGS]) && insertedComponentLView !== declaredComponentLView) {
                                        const movedTView = movedLView[TVIEW];
                                        refreshView(movedLView, movedTView, movedTView.template, movedLView[CONTEXT]);
                                    }
                                }
                            }
                        }
                        viewOrContainer = viewOrContainer[NEXT];
                    }
                }(lView), null !== tView.contentQueries && refreshContentQueries(tView, lView), 
                !checkNoChangesMode) if (hooksInitPhaseCompleted) {
                    const contentCheckHooks = tView.contentCheckHooks;
                    null !== contentCheckHooks && executeCheckHooks(lView, contentCheckHooks);
                } else {
                    const contentHooks = tView.contentHooks;
                    null !== contentHooks && executeInitAndCheckHooks(lView, contentHooks, 1), incrementInitPhaseFlags(lView, 1);
                }
                !function(tView, lView) {
                    const selectedIndex = getSelectedIndex();
                    try {
                        if (null !== tView.expandoInstructions) {
                            let bindingRootIndex = setBindingIndex(tView.expandoStartIndex);
                            setBindingRoot(bindingRootIndex);
                            let currentDirectiveIndex = -1, currentElementIndex = -1;
                            for (let i = 0; i < tView.expandoInstructions.length; i++) {
                                const instruction = tView.expandoInstructions[i];
                                if ("number" == typeof instruction) {
                                    if (instruction <= 0) {
                                        setActiveHostElement(currentElementIndex = -instruction);
                                        const providerCount = tView.expandoInstructions[++i];
                                        currentDirectiveIndex = bindingRootIndex += INJECTOR_BLOOM_PARENT_SIZE + providerCount;
                                    } else bindingRootIndex += instruction;
                                    setBindingRoot(bindingRootIndex);
                                } else null !== instruction && (incrementActiveDirectiveId(), setBindingIndex(bindingRootIndex), 
                                instruction(2, unwrapRNode(lView[currentDirectiveIndex]), currentElementIndex)), 
                                currentDirectiveIndex++;
                            }
                        }
                    } finally {
                        setActiveHostElement(selectedIndex);
                    }
                }(tView, lView);
                const components = tView.components;
                null !== components && function(hostLView, components) {
                    for (let i = 0; i < components.length; i++) refreshComponent(hostLView, components[i]);
                }(lView, components);
                const viewQuery = tView.viewQuery;
                if (null !== viewQuery && executeViewQueryFn(2, viewQuery, context), !checkNoChangesMode) if (hooksInitPhaseCompleted) {
                    const viewCheckHooks = tView.viewCheckHooks;
                    null !== viewCheckHooks && executeCheckHooks(lView, viewCheckHooks);
                } else {
                    const viewHooks = tView.viewHooks;
                    null !== viewHooks && executeInitAndCheckHooks(lView, viewHooks, 2), incrementInitPhaseFlags(lView, 2);
                }
            } finally {
                !0 === tView.firstUpdatePass && (tView.firstUpdatePass = !1), lView[FLAGS] &= -73, 
                hasActiveElementFlag(1) && executeElementExitFn(), leaveView();
            }
        }
        function renderComponentOrTemplate(hostView, templateFn, context) {
            const rendererFactory = hostView[RENDERER_FACTORY], normalExecutionPath = !getCheckNoChangesMode(), creationModeIsActive = isCreationMode(hostView);
            try {
                normalExecutionPath && !creationModeIsActive && rendererFactory.begin && rendererFactory.begin();
                const tView = hostView[TVIEW];
                creationModeIsActive && renderView(hostView, tView, context), refreshView(hostView, tView, templateFn, context);
            } finally {
                normalExecutionPath && !creationModeIsActive && rendererFactory.end && rendererFactory.end();
            }
        }
        function executeTemplate(lView, templateFn, rf, context) {
            const prevSelectedIndex = getSelectedIndex();
            try {
                setActiveHostElement(null), 2 & rf && lView.length > HEADER_OFFSET && selectIndexInternal(lView, 0, getCheckNoChangesMode()), 
                templateFn(rf, context);
            } finally {
                hasActiveElementFlag(1) && executeElementExitFn(), setSelectedIndex(prevSelectedIndex);
            }
        }
        function executeContentQueries(tView, tNode, lView) {
            if (isContentQueryHost(tNode)) {
                const end = tNode.directiveEnd;
                for (let directiveIndex = tNode.directiveStart; directiveIndex < end; directiveIndex++) {
                    const def = tView.data[directiveIndex];
                    def.contentQueries && def.contentQueries(1, lView[directiveIndex], directiveIndex);
                }
            }
        }
        function createDirectivesInstances(tView, lView, tNode) {
            getBindingsEnabled() && (function(tView, lView, tNode, native) {
                const start = tNode.directiveStart, end = tNode.directiveEnd;
                tView.firstCreatePass || getOrCreateNodeInjectorForNode(tNode, lView), attachPatchData(native, lView);
                const initialInputs = tNode.initialInputs;
                for (let i = start; i < end; i++) {
                    const def = tView.data[i], isComponent = isComponentDef(def);
                    isComponent && addComponentLogic(lView, tNode, def);
                    const directive = getNodeInjectable(tView.data, lView, i, tNode);
                    attachPatchData(directive, lView), null !== initialInputs && setInputsFromAttrs(0, i - start, directive, def, 0, initialInputs), 
                    isComponent && (getComponentLViewByIndex(tNode.index, lView)[CONTEXT] = directive);
                }
            }(tView, lView, tNode, getNativeByTNode(tNode, lView)), 128 == (128 & tNode.flags) && function(tView, viewData, tNode) {
                const start = tNode.directiveStart, end = tNode.directiveEnd, expando = tView.expandoInstructions, firstCreatePass = tView.firstCreatePass, elementIndex = tNode.index - HEADER_OFFSET;
                try {
                    setActiveHostElement(elementIndex);
                    for (let i = start; i < end; i++) {
                        const def = tView.data[i], directive = viewData[i];
                        def.hostBindings ? (incrementActiveDirectiveId(), invokeHostBindingsInCreationMode(def, expando, directive, tNode, firstCreatePass)) : firstCreatePass && expando.push(null);
                    }
                } finally {
                    setActiveHostElement(null);
                }
            }(tView, lView, tNode));
        }
        function saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {
            const localNames = tNode.localNames;
            if (localNames) {
                let localIndex = tNode.index + 1;
                for (let i = 0; i < localNames.length; i += 2) {
                    const index = localNames[i + 1], value = -1 === index ? localRefExtractor(tNode, viewData) : viewData[index];
                    viewData[localIndex++] = value;
                }
            }
        }
        function getOrCreateTComponentView(def) {
            return def.tView || (def.tView = createTView(0, -1, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts));
        }
        function createTView(type, viewIndex, templateFn, decls, vars, directives, pipes, viewQuery, schemas, consts) {
            const bindingStartIndex = HEADER_OFFSET + decls, initialViewLength = bindingStartIndex + vars, blueprint = function(bindingStartIndex, initialViewLength) {
                const blueprint = [];
                for (let i = 0; i < initialViewLength; i++) blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);
                return (blueprint);
            }(bindingStartIndex, initialViewLength);
            return blueprint[TVIEW] = {
                id: viewIndex,
                blueprint: blueprint,
                template: templateFn,
                queries: null,
                viewQuery: viewQuery,
                node: null,
                data: blueprint.slice().fill(null, bindingStartIndex),
                bindingStartIndex: bindingStartIndex,
                expandoStartIndex: initialViewLength,
                expandoInstructions: null,
                firstCreatePass: !0,
                firstUpdatePass: !0,
                staticViewQueries: !1,
                staticContentQueries: !1,
                preOrderHooks: null,
                preOrderCheckHooks: null,
                contentHooks: null,
                contentCheckHooks: null,
                viewHooks: null,
                viewCheckHooks: null,
                destroyHooks: null,
                cleanup: null,
                contentQueries: null,
                components: null,
                directiveRegistry: "function" == typeof directives ? directives() : directives,
                pipeRegistry: "function" == typeof pipes ? pipes() : pipes,
                firstChild: null,
                schemas: schemas,
                consts: consts
            };
        }
        function createTNode(tView, tParent, type, adjustedIndex, tagName, attrs) {
            return {
                type: type,
                index: adjustedIndex,
                injectorIndex: tParent ? tParent.injectorIndex : -1,
                directiveStart: -1,
                directiveEnd: -1,
                propertyBindings: null,
                flags: 0,
                providerIndexes: 0,
                tagName: tagName,
                attrs: attrs,
                localNames: null,
                initialInputs: void 0,
                inputs: void 0,
                outputs: void 0,
                tViews: null,
                next: null,
                projectionNext: null,
                child: null,
                parent: tParent,
                projection: null,
                styles: null,
                classes: null
            };
        }
        function generatePropertyAliases(inputAliasMap, directiveDefIdx, propStore) {
            for (let publicName in inputAliasMap) if (inputAliasMap.hasOwnProperty(publicName)) {
                const internalName = inputAliasMap[publicName];
                (propStore = null === propStore ? {} : propStore).hasOwnProperty(publicName) ? propStore[publicName].push(directiveDefIdx, publicName, internalName) : propStore[publicName] = [ directiveDefIdx, publicName, internalName ];
            }
            return propStore;
        }
        function elementPropertyInternal(lView, index, propName, value, sanitizer, nativeOnly, loadRendererFn) {
            const element = getNativeByIndex(index, lView), tNode = getTNode(index, lView);
            let dataValue, inputData = tNode.inputs;
            if (!nativeOnly && null != inputData && (dataValue = inputData[propName])) setInputsForProperty(lView, dataValue, value), 
            isComponentHost(tNode) && function(lView, viewIndex) {
                const childComponentLView = getComponentLViewByIndex(viewIndex, lView);
                16 & childComponentLView[FLAGS] || (childComponentLView[FLAGS] |= 64);
            }(lView, index + HEADER_OFFSET); else if (3 === tNode.type) {
                propName = "class" === (name = propName) ? "className" : "for" === name ? "htmlFor" : "formaction" === name ? "formAction" : "innerHtml" === name ? "innerHTML" : "readonly" === name ? "readOnly" : "tabindex" === name ? "tabIndex" : name;
                const renderer = loadRendererFn ? loadRendererFn(tNode, lView) : lView[RENDERER];
                value = null != sanitizer ? sanitizer(value, tNode.tagName || "", propName) : value, 
                isProceduralRenderer(renderer) ? renderer.setProperty(element, propName, value) : isAnimationProp(propName) || (element.setProperty ? element.setProperty(propName, value) : element[propName] = value);
            }
            var name;
        }
        function resolveDirectives(tView, lView, tNode, localRefs) {
            if (!getBindingsEnabled()) return !1;
            const directives = function(tView, viewData, tNode) {
                const registry = tView.directiveRegistry;
                let matches = null;
                if (registry) for (let i = 0; i < registry.length; i++) {
                    const def = registry[i];
                    isNodeMatchingSelectorList(tNode, def.selectors, !1) && (matches || (matches = []), 
                    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, viewData), tView, def.type), 
                    isComponentDef(def) ? (2 & tNode.flags && throwMultipleComponentError(tNode), markAsComponentHost(tView, tNode), 
                    matches.unshift(def)) : matches.push(def));
                }
                return matches;
            }(tView, lView, tNode), exportsMap = null === localRefs ? null : {
                "": -1
            };
            let hasDirectives = !1;
            if (null !== directives) {
                hasDirectives = !0, initNodeFlags(tNode, tView.data.length, directives.length);
                for (let i = 0; i < directives.length; i++) {
                    const def = directives[i];
                    def.providersResolver && def.providersResolver(def);
                }
                generateExpandoInstructionBlock(tView, tNode, directives.length);
                const initialPreOrderHooksLength = tView.preOrderHooks && tView.preOrderHooks.length || 0, initialPreOrderCheckHooksLength = tView.preOrderCheckHooks && tView.preOrderCheckHooks.length || 0, nodeIndex = tNode.index - HEADER_OFFSET;
                for (let i = 0; i < directives.length; i++) {
                    const def = directives[i], directiveDefIdx = tView.data.length;
                    baseResolveDirective(tView, lView, def), saveNameToExportMap(tView.data.length - 1, def, exportsMap), 
                    null !== def.contentQueries && (tNode.flags |= 8), null !== def.hostBindings && (tNode.flags |= 128), 
                    registerPreOrderHooks(directiveDefIdx, def, tView, nodeIndex, initialPreOrderHooksLength, initialPreOrderCheckHooksLength);
                }
                !function(tView, tNode) {
                    const end = tNode.directiveEnd, defs = tView.data, tNodeAttrs = tNode.attrs, inputsFromAttrs = [];
                    let inputsStore = null, outputsStore = null;
                    for (let i = tNode.directiveStart; i < end; i++) {
                        const directiveDef = defs[i], directiveInputs = directiveDef.inputs;
                        inputsFromAttrs.push(null !== tNodeAttrs ? generateInitialInputs(directiveInputs, tNodeAttrs) : null), 
                        inputsStore = generatePropertyAliases(directiveInputs, i, inputsStore), outputsStore = generatePropertyAliases(directiveDef.outputs, i, outputsStore);
                    }
                    null !== inputsStore && ((inputsStore.hasOwnProperty("class") || inputsStore.hasOwnProperty("className")) && (tNode.flags |= 16), 
                    inputsStore.hasOwnProperty("style") && (tNode.flags |= 32)), tNode.initialInputs = inputsFromAttrs, 
                    tNode.inputs = inputsStore, tNode.outputs = outputsStore;
                }(tView, tNode);
            }
            return exportsMap && function(tNode, localRefs, exportsMap) {
                if (localRefs) {
                    const localNames = tNode.localNames = [];
                    for (let i = 0; i < localRefs.length; i += 2) {
                        const index = exportsMap[localRefs[i + 1]];
                        if (null == index) throw new Error(`Export of name '${localRefs[i + 1]}' not found!`);
                        localNames.push(localRefs[i], index);
                    }
                }
            }(tNode, localRefs, exportsMap), hasDirectives;
        }
        function invokeHostBindingsInCreationMode(def, expando, directive, tNode, firstCreatePass) {
            const previousExpandoLength = expando.length;
            setCurrentDirectiveDef(def), def.hostBindings(1, directive, tNode.index - HEADER_OFFSET), 
            setCurrentDirectiveDef(null), previousExpandoLength === expando.length && firstCreatePass && expando.push(def.hostBindings);
        }
        function generateExpandoInstructionBlock(tView, tNode, directiveCount) {
            const elementIndex = -(tNode.index - HEADER_OFFSET), providerCount = tView.data.length - (65535 & tNode.providerIndexes);
            (tView.expandoInstructions || (tView.expandoInstructions = [])).push(elementIndex, providerCount, directiveCount);
        }
        function markAsComponentHost(tView, hostTNode) {
            hostTNode.flags |= 2, (tView.components || (tView.components = [])).push(hostTNode.index);
        }
        function saveNameToExportMap(index, def, exportsMap) {
            if (exportsMap) {
                if (def.exportAs) for (let i = 0; i < def.exportAs.length; i++) exportsMap[def.exportAs[i]] = index;
                def.template && (exportsMap[""] = index);
            }
        }
        function initNodeFlags(tNode, index, numberOfDirectives) {
            tNode.flags |= 1, tNode.directiveStart = index, tNode.directiveEnd = index + numberOfDirectives, 
            tNode.providerIndexes = index;
        }
        function baseResolveDirective(tView, viewData, def) {
            tView.data.push(def);
            const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type)), nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), null);
            tView.blueprint.push(nodeInjectorFactory), viewData.push(nodeInjectorFactory);
        }
        function addComponentLogic(lView, hostTNode, def) {
            const native = getNativeByTNode(hostTNode, lView), tView = getOrCreateTComponentView(def), rendererFactory = lView[RENDERER_FACTORY], componentView = addToViewTree(lView, createLView(lView, tView, null, def.onPush ? 64 : 16, native, hostTNode, rendererFactory, rendererFactory.createRenderer(native, def)));
            lView[hostTNode.index] = componentView;
        }
        function setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {
            const initialInputs = initialInputData[directiveIndex];
            if (null !== initialInputs) {
                const setInput = def.setInput;
                for (let i = 0; i < initialInputs.length; ) {
                    const publicName = initialInputs[i++], privateName = initialInputs[i++], value = initialInputs[i++];
                    null !== setInput ? def.setInput(instance, value, publicName, privateName) : instance[privateName] = value;
                }
            }
        }
        function generateInitialInputs(inputs, attrs) {
            let inputsToStore = null, i = 0;
            for (;i < attrs.length; ) {
                const attrName = attrs[i];
                if (0 !== attrName) if (5 !== attrName) {
                    if ("number" == typeof attrName) break;
                    inputs.hasOwnProperty(attrName) && (null === inputsToStore && (inputsToStore = []), 
                    inputsToStore.push(attrName, inputs[attrName], attrs[i + 1])), i += 2;
                } else i += 2; else i += 4;
            }
            return inputsToStore;
        }
        function createLContainer(hostNative, currentView, native, tNode) {
            return new Array(hostNative, !0, -1, currentView, null, null, tNode, native, null);
        }
        function refreshComponent(hostLView, componentHostIdx) {
            const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
            if (128 == (128 & componentView[FLAGS]) && 80 & componentView[FLAGS]) {
                const tView = componentView[TVIEW];
                refreshView(componentView, tView, tView.template, componentView[CONTEXT]);
            }
        }
        function renderComponent(hostLView, componentHostIdx) {
            const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
            !function(componentView) {
                const componentTView = componentView[TVIEW];
                for (let i = componentView.length; i < componentTView.blueprint.length; i++) componentView.push(componentTView.blueprint[i]);
            }(componentView), renderView(componentView, componentView[TVIEW], componentView[CONTEXT]);
        }
        function addToViewTree(lView, lViewOrLContainer) {
            return lView[CHILD_HEAD] ? lView[CHILD_TAIL][NEXT] = lViewOrLContainer : lView[CHILD_HEAD] = lViewOrLContainer, 
            lView[CHILD_TAIL] = lViewOrLContainer, lViewOrLContainer;
        }
        function markViewDirty(lView) {
            for (;lView; ) {
                lView[FLAGS] |= 64;
                const parent = getLViewParent(lView);
                if (isRootView(lView) && !parent) return lView;
                lView = parent;
            }
            return null;
        }
        function detectChangesInternal(view, context) {
            const rendererFactory = view[RENDERER_FACTORY];
            rendererFactory.begin && rendererFactory.begin();
            try {
                const tView = view[TVIEW];
                refreshView(view, tView, tView.template, context);
            } catch (error) {
                throw handleError(view, error), error;
            } finally {
                rendererFactory.end && rendererFactory.end();
            }
        }
        function detectChangesInRootView(lView) {
            !function(rootContext) {
                for (let i = 0; i < rootContext.components.length; i++) {
                    const rootComponent = rootContext.components[i], lView = readPatchedLView(rootComponent);
                    renderComponentOrTemplate(lView, lView[TVIEW].template, rootComponent);
                }
            }(lView[CONTEXT]);
        }
        function executeViewQueryFn(flags, viewQueryFn, component) {
            setCurrentQueryIndex(0), viewQueryFn(flags, component);
        }
        const CLEAN_PROMISE = (() => Promise.resolve(null))();
        function getCleanup(view) {
            return view[CLEANUP] || (view[CLEANUP] = []);
        }
        function getTViewCleanup(view) {
            return view[TVIEW].cleanup || (view[TVIEW].cleanup = []);
        }
        function loadComponentRenderer(tNode, lView) {
            return lView[tNode.index][RENDERER];
        }
        function handleError(lView, error) {
            const injector = lView[INJECTOR$1], errorHandler = injector ? injector.get(ErrorHandler, null) : null;
            errorHandler && errorHandler.handleError(error);
        }
        function setInputsForProperty(lView, inputs, value) {
            const tView = lView[TVIEW];
            for (let i = 0; i < inputs.length; ) {
                const index = inputs[i++], publicName = inputs[i++], privateName = inputs[i++], instance = lView[index], def = tView.data[index];
                def.setInput ? def.setInput(instance, value, publicName, privateName) : instance[privateName] = value;
            }
        }
        function textBindingInternal(lView, index, value) {
            const element = getNativeByIndex(index, lView), renderer = lView[RENDERER];
            isProceduralRenderer(renderer) ? renderer.setValue(element, value) : element.textContent = value;
        }
        function renderInitialStyling(renderer, native, tNode, append) {
            null !== tNode.classes && (append ? renderStylingMap(renderer, native, tNode.classes, !0) : writeStylingValueDirectly(renderer, native, getInitialStylingValue(tNode.classes), !0, null)), 
            null !== tNode.styles && (append ? renderStylingMap(renderer, native, tNode.styles, !1) : writeStylingValueDirectly(renderer, native, getInitialStylingValue(tNode.styles), !1, null));
        }
        function getLContainer(tNode, embeddedView) {
            const container = embeddedView[PARENT];
            return -1 === tNode.index ? isLContainer(container) ? container : null : container;
        }
        function getContainerRenderParent(tViewNode, view) {
            const container = getLContainer(tViewNode, view);
            return container ? nativeParentNode(view[RENDERER], container[NATIVE]) : null;
        }
        function applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {
            if (null != lNodeToHandle) {
                let lContainer, isComponent = !1;
                isLContainer(lNodeToHandle) ? lContainer = lNodeToHandle : isLView(lNodeToHandle) && (isComponent = !0, 
                lNodeToHandle = lNodeToHandle[HOST]);
                const rNode = unwrapRNode(lNodeToHandle);
                0 === action && null !== parent ? null == beforeNode ? nativeAppendChild(renderer, parent, rNode) : nativeInsertBefore(renderer, parent, rNode, beforeNode || null) : 1 === action && null !== parent ? nativeInsertBefore(renderer, parent, rNode, beforeNode || null) : 2 === action ? function(renderer, rNode, isHostElement) {
                    const nativeParent = nativeParentNode(renderer, rNode);
                    nativeParent && function(renderer, parent, child, isHostElement) {
                        isProceduralRenderer(renderer) ? renderer.removeChild(parent, child, isHostElement) : parent.removeChild(child);
                    }(renderer, nativeParent, rNode, isHostElement);
                }(renderer, rNode, isComponent) : 3 === action && renderer.destroyNode(rNode), null != lContainer && function(renderer, action, lContainer, renderParent, beforeNode) {
                    const anchor = lContainer[NATIVE];
                    anchor !== unwrapRNode(lContainer) && applyToElementOrContainer(action, renderer, renderParent, anchor, beforeNode);
                    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) applyView(renderer, action, lContainer[i], renderParent, anchor);
                }(renderer, action, lContainer, parent, beforeNode);
            }
        }
        function addRemoveViewFromContainer(lView, insertMode, beforeNode) {
            const renderParent = getContainerRenderParent(lView[TVIEW].node, lView);
            renderParent && applyView(lView[RENDERER], insertMode ? 1 : 2, lView, renderParent, beforeNode);
        }
        function detachMovedView(declarationContainer, lView) {
            const movedViews = declarationContainer[MOVED_VIEWS], declaredViewIndex = movedViews.indexOf(lView);
            movedViews.splice(declaredViewIndex, 1);
        }
        function detachView(lContainer, removeIndex) {
            if (lContainer.length <= CONTAINER_HEADER_OFFSET) return;
            const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex, viewToDetach = lContainer[indexInContainer];
            if (viewToDetach) {
                const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];
                null !== declarationLContainer && declarationLContainer !== lContainer && detachMovedView(declarationLContainer, viewToDetach), 
                removeIndex > 0 && (lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT]);
                const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);
                addRemoveViewFromContainer(viewToDetach, !1, null);
                const lQueries = removedLView[QUERIES];
                null !== lQueries && lQueries.detachView(removedLView[TVIEW]), viewToDetach[PARENT] = null, 
                viewToDetach[NEXT] = null, viewToDetach[FLAGS] &= -129;
            }
            return viewToDetach;
        }
        function destroyLView(lView) {
            if (!(256 & lView[FLAGS])) {
                const renderer = lView[RENDERER];
                isProceduralRenderer(renderer) && renderer.destroyNode && applyView(renderer, 3, lView, null, null), 
                function(rootView) {
                    let lViewOrLContainer = rootView[CHILD_HEAD];
                    if (!lViewOrLContainer) return cleanUpView(rootView);
                    for (;lViewOrLContainer; ) {
                        let next = null;
                        if (isLView(lViewOrLContainer)) next = lViewOrLContainer[CHILD_HEAD]; else {
                            const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];
                            firstView && (next = firstView);
                        }
                        if (!next) {
                            for (;lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView; ) cleanUpView(lViewOrLContainer), 
                            lViewOrLContainer = getParentState(lViewOrLContainer, rootView);
                            cleanUpView(lViewOrLContainer || rootView), next = lViewOrLContainer && lViewOrLContainer[NEXT];
                        }
                        lViewOrLContainer = next;
                    }
                }(lView);
            }
        }
        function getParentState(lViewOrLContainer, rootView) {
            let tNode;
            return isLView(lViewOrLContainer) && (tNode = lViewOrLContainer[T_HOST]) && 2 === tNode.type ? getLContainer(tNode, lViewOrLContainer) : lViewOrLContainer[PARENT] === rootView ? null : lViewOrLContainer[PARENT];
        }
        function cleanUpView(view) {
            if (isLView(view) && !(256 & view[FLAGS])) {
                view[FLAGS] &= -129, view[FLAGS] |= 256, function(view) {
                    const tView = view[TVIEW];
                    let destroyHooks;
                    if (null != tView && null != (destroyHooks = tView.destroyHooks)) for (let i = 0; i < destroyHooks.length; i += 2) {
                        const context = view[destroyHooks[i]];
                        context instanceof NodeInjectorFactory || destroyHooks[i + 1].call(context);
                    }
                }(view), function(lView) {
                    const tCleanup = lView[TVIEW].cleanup;
                    if (null !== tCleanup) {
                        const lCleanup = lView[CLEANUP];
                        for (let i = 0; i < tCleanup.length - 1; i += 2) if ("string" == typeof tCleanup[i]) {
                            const idxOrTargetGetter = tCleanup[i + 1], target = "function" == typeof idxOrTargetGetter ? idxOrTargetGetter(lView) : unwrapRNode(lView[idxOrTargetGetter]), listener = lCleanup[tCleanup[i + 2]], useCaptureOrSubIdx = tCleanup[i + 3];
                            "boolean" == typeof useCaptureOrSubIdx ? target.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx) : useCaptureOrSubIdx >= 0 ? lCleanup[useCaptureOrSubIdx]() : lCleanup[-useCaptureOrSubIdx].unsubscribe(), 
                            i += 2;
                        } else tCleanup[i].call(lCleanup[tCleanup[i + 1]]);
                        lView[CLEANUP] = null;
                    }
                }(view);
                const hostTNode = view[T_HOST];
                hostTNode && 3 === hostTNode.type && isProceduralRenderer(view[RENDERER]) && view[RENDERER].destroy();
                const declarationContainer = view[DECLARATION_LCONTAINER];
                if (null !== declarationContainer && isLContainer(view[PARENT])) {
                    declarationContainer !== view[PARENT] && detachMovedView(declarationContainer, view);
                    const lQueries = view[QUERIES];
                    null !== lQueries && lQueries.detachView(view[TVIEW]);
                }
            }
        }
        function getRenderParent(tNode, currentView) {
            if (isRootView(currentView)) return nativeParentNode(currentView[RENDERER], getNativeByTNode(tNode, currentView));
            let parentTNode = tNode.parent;
            for (;null != parentTNode && (4 === parentTNode.type || 5 === parentTNode.type); ) parentTNode = (tNode = parentTNode).parent;
            if (null == parentTNode) {
                const hostTNode = currentView[T_HOST];
                return 2 === hostTNode.type ? getContainerRenderParent(hostTNode, currentView) : currentView[HOST];
            }
            if (tNode && 5 === tNode.type && 4 & tNode.flags) return getNativeByTNode(tNode, currentView).parentNode;
            if (2 & parentTNode.flags) {
                const tData = currentView[TVIEW].data, encapsulation = tData[tData[parentTNode.index].directiveStart].encapsulation;
                if (encapsulation !== ViewEncapsulation$1.ShadowDom && encapsulation !== ViewEncapsulation$1.Native) return null;
            }
            return (getNativeByTNode(parentTNode, currentView));
        }
        function nativeInsertBefore(renderer, parent, child, beforeNode) {
            isProceduralRenderer(renderer) ? renderer.insertBefore(parent, child, beforeNode) : parent.insertBefore(child, beforeNode, !0);
        }
        function nativeAppendChild(renderer, parent, child) {
            isProceduralRenderer(renderer) ? renderer.appendChild(parent, child) : parent.appendChild(child);
        }
        function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode) {
            null !== beforeNode ? nativeInsertBefore(renderer, parent, child, beforeNode) : nativeAppendChild(renderer, parent, child);
        }
        function nativeParentNode(renderer, node) {
            return isProceduralRenderer(renderer) ? renderer.parentNode(node) : node.parentNode;
        }
        function getNativeAnchorNode(parentTNode, lView) {
            if (2 === parentTNode.type) {
                const lContainer = getLContainer(parentTNode, lView);
                return null === lContainer ? null : getBeforeNodeForView(lContainer.indexOf(lView, CONTAINER_HEADER_OFFSET) - CONTAINER_HEADER_OFFSET, lContainer);
            }
            return 4 === parentTNode.type || 5 === parentTNode.type ? getNativeByTNode(parentTNode, lView) : null;
        }
        function appendChild(childEl, childTNode, currentView) {
            const renderParent = getRenderParent(childTNode, currentView);
            if (null != renderParent) {
                const renderer = currentView[RENDERER], anchorNode = getNativeAnchorNode(childTNode.parent || currentView[T_HOST], currentView);
                if (Array.isArray(childEl)) for (let i = 0; i < childEl.length; i++) nativeAppendOrInsertBefore(renderer, renderParent, childEl[i], anchorNode); else nativeAppendOrInsertBefore(renderer, renderParent, childEl, anchorNode);
            }
        }
        function getBeforeNodeForView(viewIndexInContainer, lContainer) {
            const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;
            if (nextViewIndex < lContainer.length) {
                const lView = lContainer[nextViewIndex], firstTNodeOfView = lView[TVIEW].firstChild;
                if (null !== firstTNodeOfView) return function getFirstNativeNode(lView, tNode) {
                    if (null !== tNode) {
                        const tNodeType = tNode.type;
                        if (3 === tNodeType) return getNativeByTNode(tNode, lView);
                        if (0 === tNodeType) return getBeforeNodeForView(-1, lView[tNode.index]);
                        if (4 === tNodeType || 5 === tNodeType) {
                            const elIcuContainerChild = tNode.child;
                            return null !== elIcuContainerChild ? getFirstNativeNode(lView, elIcuContainerChild) : getNativeByTNode(tNode, lView);
                        }
                        {
                            const componentView = findComponentView(lView), componentHost = componentView[T_HOST], parentView = getLViewParent(componentView), firstProjectedTNode = componentHost.projection[tNode.projection];
                            return null != firstProjectedTNode ? getFirstNativeNode(parentView, firstProjectedTNode) : getFirstNativeNode(lView, tNode.next);
                        }
                    }
                    return null;
                }(lView, firstTNodeOfView);
            }
            return lContainer[NATIVE];
        }
        function applyNodes(renderer, action, tNode, lView, renderParent, beforeNode, isProjection) {
            for (;null != tNode; ) {
                const rawSlotValue = lView[tNode.index], tNodeType = tNode.type;
                isProjection && 0 === action && (rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView), 
                tNode.flags |= 4), 64 != (64 & tNode.flags) && (4 === tNodeType || 5 === tNodeType ? (applyNodes(renderer, action, tNode.child, lView, renderParent, beforeNode, !1), 
                applyToElementOrContainer(action, renderer, renderParent, rawSlotValue, beforeNode)) : 1 === tNodeType ? applyProjectionRecursive(renderer, action, lView, tNode, renderParent, beforeNode) : applyToElementOrContainer(action, renderer, renderParent, rawSlotValue, beforeNode)), 
                tNode = isProjection ? tNode.projectionNext : tNode.next;
            }
        }
        function applyView(renderer, action, lView, renderParent, beforeNode) {
            applyNodes(renderer, action, lView[TVIEW].node.child, lView, renderParent, beforeNode, !1);
        }
        function applyProjectionRecursive(renderer, action, lView, tProjectionNode, renderParent, beforeNode) {
            const componentLView = findComponentView(lView), nodeToProjectOrRNodes = componentLView[T_HOST].projection[tProjectionNode.projection];
            if (Array.isArray(nodeToProjectOrRNodes)) for (let i = 0; i < nodeToProjectOrRNodes.length; i++) applyToElementOrContainer(action, renderer, renderParent, nodeToProjectOrRNodes[i], beforeNode); else applyNodes(renderer, action, nodeToProjectOrRNodes, componentLView[PARENT], renderParent, beforeNode, !0);
        }
        class ViewRef {
            constructor(_lView, _cdRefInjectingView) {
                this._lView = _lView, this._cdRefInjectingView = _cdRefInjectingView, this._appRef = null, 
                this._viewContainerRef = null, this._tViewNode = null;
            }
            get rootNodes() {
                return null == this._lView[HOST] ? function collectNativeNodes(lView, tNode, result, isProjection = !1) {
                    for (;null !== tNode; ) {
                        const lNode = lView[tNode.index];
                        if (null !== lNode && result.push(unwrapRNode(lNode)), isLContainer(lNode)) for (let i = CONTAINER_HEADER_OFFSET; i < lNode.length; i++) {
                            const lViewInAContainer = lNode[i], lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;
                            null !== lViewFirstChildTNode && collectNativeNodes(lViewInAContainer, lViewFirstChildTNode, result);
                        }
                        const tNodeType = tNode.type;
                        if (4 === tNodeType || 5 === tNodeType) collectNativeNodes(lView, tNode.child, result); else if (1 === tNodeType) {
                            const componentView = findComponentView(lView), componentHost = componentView[T_HOST], parentView = getLViewParent(componentView);
                            let firstProjectedNode = componentHost.projection[tNode.projection];
                            null !== firstProjectedNode && null !== parentView && collectNativeNodes(parentView, firstProjectedNode, result, !0);
                        }
                        tNode = isProjection ? tNode.projectionNext : tNode.next;
                    }
                    return result;
                }(this._lView, this._lView[T_HOST].child, []) : [];
            }
            get context() {
                return this._lView[CONTEXT];
            }
            get destroyed() {
                return 256 == (256 & this._lView[FLAGS]);
            }
            destroy() {
                if (this._appRef) this._appRef.detachView(this); else if (this._viewContainerRef) {
                    const index = this._viewContainerRef.indexOf(this);
                    index > -1 && this._viewContainerRef.detach(index), this._viewContainerRef = null;
                }
                destroyLView(this._lView);
            }
            onDestroy(callback) {
                var view, cleanupFn;
                cleanupFn = callback, getCleanup(view = this._lView).push(cleanupFn), view[TVIEW].firstCreatePass && getTViewCleanup(view).push(view[CLEANUP].length - 1, null);
            }
            markForCheck() {
                markViewDirty(this._cdRefInjectingView || this._lView);
            }
            detach() {
                this._lView[FLAGS] &= -129;
            }
            reattach() {
                this._lView[FLAGS] |= 128;
            }
            detectChanges() {
                detectChangesInternal(this._lView, this.context);
            }
            checkNoChanges() {
                !function(view, context) {
                    setCheckNoChangesMode(!0);
                    try {
                        detectChangesInternal(view, context);
                    } finally {
                        setCheckNoChangesMode(!1);
                    }
                }(this._lView, this.context);
            }
            attachToViewContainerRef(vcRef) {
                if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!");
                this._viewContainerRef = vcRef;
            }
            detachFromAppRef() {
                var lView;
                this._appRef = null, applyView((lView = this._lView)[RENDERER], 2, lView, null, null);
            }
            attachToAppRef(appRef) {
                if (this._viewContainerRef) throw new Error("This view is already attached to a ViewContainer!");
                this._appRef = appRef;
            }
        }
        class RootViewRef extends ViewRef {
            constructor(_view) {
                super(_view), this._view = _view;
            }
            detectChanges() {
                detectChangesInRootView(this._view);
            }
            checkNoChanges() {
                !function(lView) {
                    setCheckNoChangesMode(!0);
                    try {
                        detectChangesInRootView(lView);
                    } finally {
                        setCheckNoChangesMode(!1);
                    }
                }(this._view);
            }
            get context() {
                return null;
            }
        }
        let R3ElementRef, R3TemplateRef, R3ViewContainerRef;
        function createElementRef(ElementRefToken, tNode, view) {
            return R3ElementRef || (R3ElementRef = class extends ElementRefToken {}), new R3ElementRef(getNativeByTNode(tNode, view));
        }
        function createTemplateRef(TemplateRefToken, ElementRefToken, hostTNode, hostView) {
            return R3TemplateRef || (R3TemplateRef = class extends TemplateRefToken {
                constructor(_declarationView, _declarationTContainer, elementRef) {
                    super(), this._declarationView = _declarationView, this._declarationTContainer = _declarationTContainer, 
                    this.elementRef = elementRef;
                }
                createEmbeddedView(context) {
                    const embeddedTView = this._declarationTContainer.tViews, lView = createLView(this._declarationView, embeddedTView, context, 16, null, embeddedTView.node);
                    lView[DECLARATION_LCONTAINER] = this._declarationView[this._declarationTContainer.index];
                    const declarationViewLQueries = this._declarationView[QUERIES];
                    null !== declarationViewLQueries && (lView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView)), 
                    renderView(lView, embeddedTView, context);
                    const viewRef = new ViewRef(lView);
                    return viewRef._tViewNode = lView[T_HOST], viewRef;
                }
            }), 0 === hostTNode.type ? new R3TemplateRef(hostView, hostTNode, createElementRef(ElementRefToken, hostTNode, hostView)) : null;
        }
        function createContainerRef(ViewContainerRefToken, ElementRefToken, hostTNode, hostView) {
            let lContainer;
            R3ViewContainerRef || (R3ViewContainerRef = class extends ViewContainerRefToken {
                constructor(_lContainer, _hostTNode, _hostView) {
                    super(), this._lContainer = _lContainer, this._hostTNode = _hostTNode, this._hostView = _hostView;
                }
                get element() {
                    return createElementRef(ElementRefToken, this._hostTNode, this._hostView);
                }
                get injector() {
                    return new NodeInjector(this._hostTNode, this._hostView);
                }
                get parentInjector() {
                    const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostView), parentView = getParentInjectorView(parentLocation, this._hostView), parentTNode = function(location, startView, startTNode) {
                        if (startTNode.parent && -1 !== startTNode.parent.injectorIndex) {
                            const injectorIndex = startTNode.parent.injectorIndex;
                            let parentTNode = startTNode.parent;
                            for (;null != parentTNode.parent && injectorIndex == parentTNode.injectorIndex; ) parentTNode = parentTNode.parent;
                            return parentTNode;
                        }
                        let viewOffset = getParentInjectorViewOffset(location), parentView = startView, parentTNode = startView[T_HOST];
                        for (;viewOffset > 1; ) parentTNode = (parentView = parentView[DECLARATION_VIEW])[T_HOST], 
                        viewOffset--;
                        return parentTNode;
                    }(parentLocation, this._hostView, this._hostTNode);
                    return hasParentInjector(parentLocation) && null != parentTNode ? new NodeInjector(parentTNode, parentView) : new NodeInjector(null, this._hostView);
                }
                clear() {
                    for (;this.length > 0; ) this.remove(this.length - 1);
                }
                get(index) {
                    return null !== this._lContainer[VIEW_REFS] && this._lContainer[VIEW_REFS][index] || null;
                }
                get length() {
                    return this._lContainer.length - CONTAINER_HEADER_OFFSET;
                }
                createEmbeddedView(templateRef, context, index) {
                    const viewRef = templateRef.createEmbeddedView(context || {});
                    return this.insert(viewRef, index), viewRef;
                }
                createComponent(componentFactory, index, injector, projectableNodes, ngModuleRef) {
                    const contextInjector = injector || this.parentInjector;
                    if (!ngModuleRef && null == componentFactory.ngModule && contextInjector) {
                        const result = contextInjector.get(NgModuleRef, null);
                        result && (ngModuleRef = result);
                    }
                    const componentRef = componentFactory.create(contextInjector, projectableNodes, void 0, ngModuleRef);
                    return this.insert(componentRef.hostView, index), componentRef;
                }
                insert(viewRef, index) {
                    if (viewRef.destroyed) throw new Error("Cannot insert a destroyed View in a ViewContainer!");
                    this.allocateContainerIfNeeded();
                    const lView = viewRef._lView, adjustedIdx = this._adjustIndex(index);
                    return isLContainer(lView[PARENT]) ? this.move(viewRef, adjustedIdx) : (function(lView, lContainer, index) {
                        const indexInContainer = CONTAINER_HEADER_OFFSET + index, containerLength = lContainer.length;
                        index > 0 && (lContainer[indexInContainer - 1][NEXT] = lView), index < containerLength - CONTAINER_HEADER_OFFSET ? (lView[NEXT] = lContainer[indexInContainer], 
                        addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView)) : (lContainer.push(lView), 
                        lView[NEXT] = null), lView[PARENT] = lContainer;
                        const declarationLContainer = lView[DECLARATION_LCONTAINER];
                        null !== declarationLContainer && lContainer !== declarationLContainer && function(declarationContainer, lView) {
                            const movedViews = declarationContainer[MOVED_VIEWS];
                            null === movedViews ? declarationContainer[MOVED_VIEWS] = [ lView ] : movedViews.push(lView);
                        }(declarationLContainer, lView);
                        const lQueries = lView[QUERIES];
                        null !== lQueries && lQueries.insertView(lView[TVIEW]), lView[FLAGS] |= 128;
                    }(lView, this._lContainer, adjustedIdx), addRemoveViewFromContainer(lView, !0, getBeforeNodeForView(adjustedIdx, this._lContainer)), 
                    viewRef.attachToViewContainerRef(this), addToArray(this._lContainer[VIEW_REFS], adjustedIdx, viewRef), 
                    viewRef);
                }
                move(viewRef, newIndex) {
                    if (viewRef.destroyed) throw new Error("Cannot move a destroyed View in a ViewContainer!");
                    const index = this.indexOf(viewRef);
                    return -1 !== index && this.detach(index), this.insert(viewRef, newIndex), viewRef;
                }
                indexOf(viewRef) {
                    return null !== this._lContainer[VIEW_REFS] ? this._lContainer[VIEW_REFS].indexOf(viewRef) : 0;
                }
                remove(index) {
                    this.allocateContainerIfNeeded();
                    const adjustedIdx = this._adjustIndex(index, -1);
                    (function(lContainer, removeIndex) {
                        const detachedView = detachView(lContainer, removeIndex);
                        detachedView && destroyLView(detachedView);
                    })(this._lContainer, adjustedIdx), removeFromArray(this._lContainer[VIEW_REFS], adjustedIdx);
                }
                detach(index) {
                    this.allocateContainerIfNeeded();
                    const adjustedIdx = this._adjustIndex(index, -1), view = detachView(this._lContainer, adjustedIdx);
                    return view && null != removeFromArray(this._lContainer[VIEW_REFS], adjustedIdx) ? new ViewRef(view) : null;
                }
                _adjustIndex(index, shift = 0) {
                    return null == index ? this.length + shift : index;
                }
                allocateContainerIfNeeded() {
                    null === this._lContainer[VIEW_REFS] && (this._lContainer[VIEW_REFS] = []);
                }
            });
            const slotValue = hostView[hostTNode.index];
            if (isLContainer(slotValue)) (lContainer = slotValue)[ACTIVE_INDEX] = -1; else {
                let commentNode;
                if (commentNode = 4 === hostTNode.type ? unwrapRNode(slotValue) : hostView[RENDERER].createComment(""), 
                isRootView(hostView)) {
                    const renderer = hostView[RENDERER], hostNative = getNativeByTNode(hostTNode, hostView);
                    nativeInsertBefore(renderer, nativeParentNode(renderer, hostNative), commentNode, function(renderer, node) {
                        return isProceduralRenderer(renderer) ? renderer.nextSibling(node) : node.nextSibling;
                    }(renderer, hostNative));
                } else appendChild(commentNode, hostTNode, hostView);
                hostView[hostTNode.index] = lContainer = createLContainer(slotValue, hostView, commentNode, hostTNode), 
                addToViewTree(hostView, lContainer);
            }
            return new R3ViewContainerRef(lContainer, hostTNode, hostView);
        }
        let ChangeDetectorRef = (() => {
            class ChangeDetectorRef {}
            return ChangeDetectorRef.__NG_ELEMENT_ID__ = () => SWITCH_CHANGE_DETECTOR_REF_FACTORY(), 
            ChangeDetectorRef;
        })();
        const SWITCH_CHANGE_DETECTOR_REF_FACTORY = function(isPipe = !1) {
            return function(tNode, lView, isPipe) {
                if (!isPipe && isComponentHost(tNode)) {
                    const componentView = getComponentLViewByIndex(tNode.index, lView);
                    return new ViewRef(componentView, componentView);
                }
                if (3 === tNode.type || 0 === tNode.type || 4 === tNode.type) {
                    const hostComponentView = findComponentView(lView);
                    return new ViewRef(hostComponentView, lView);
                }
                return (null);
            }(getPreviousOrParentTNode(), getLView(), isPipe);
        }, INJECTOR_SCOPE = new InjectionToken("Set Injector scope."), NOT_YET = {}, CIRCULAR = {}, EMPTY_ARRAY$2 = [];
        let NULL_INJECTOR = void 0;
        function getNullInjector() {
            return void 0 === NULL_INJECTOR && (NULL_INJECTOR = new NullInjector), NULL_INJECTOR;
        }
        function createInjector(defType, parent = null, additionalProviders = null, name) {
            return parent = parent || getNullInjector(), new R3Injector(defType, additionalProviders, parent, name);
        }
        class R3Injector {
            constructor(def, additionalProviders, parent, source = null) {
                this.parent = parent, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, 
                this._destroyed = !1;
                const dedupStack = [];
                additionalProviders && deepForEach(additionalProviders, provider => this.processProvider(provider, def, additionalProviders)), 
                deepForEach([ def ], injectorDef => this.processInjectorType(injectorDef, [], dedupStack)), 
                this.records.set(INJECTOR, makeRecord(void 0, this));
                const record = this.records.get(INJECTOR_SCOPE);
                this.scope = null != record ? record.value : null, this.injectorDefTypes.forEach(defType => this.get(defType)), 
                this.source = source || ("object" == typeof def ? null : stringify(def));
            }
            get destroyed() {
                return this._destroyed;
            }
            destroy() {
                this.assertNotDestroyed(), this._destroyed = !0;
                try {
                    this.onDestroy.forEach(service => service.ngOnDestroy());
                } finally {
                    this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear();
                }
            }
            get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {
                this.assertNotDestroyed();
                const previousInjector = setCurrentInjector(this);
                try {
                    if (!(flags & InjectFlags.SkipSelf)) {
                        let record = this.records.get(token);
                        if (void 0 === record) {
                            const def = ("function" == typeof (value = token) || "object" == typeof value && value instanceof InjectionToken) && getInjectableDef(token);
                            record = def && this.injectableDefInScope(def) ? makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET) : null, 
                            this.records.set(token, record);
                        }
                        if (null != record) return this.hydrate(token, record);
                    }
                    return (flags & InjectFlags.Self ? getNullInjector() : this.parent).get(token, notFoundValue = flags & InjectFlags.Optional && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue);
                } catch (e) {
                    if ("NullInjectorError" === e.name) {
                        if ((e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || []).unshift(stringify(token)), 
                        previousInjector) throw e;
                        return function(e, token, injectorErrorName, source) {
                            const tokenPath = e[NG_TEMP_TOKEN_PATH];
                            throw token[SOURCE] && tokenPath.unshift(token[SOURCE]), e.message = function(text, obj, injectorErrorName, source = null) {
                                text = text && "\n" === text.charAt(0) && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;
                                let context = stringify(obj);
                                if (Array.isArray(obj)) context = obj.map(stringify).join(" -> "); else if ("object" == typeof obj) {
                                    let parts = [];
                                    for (let key in obj) if (obj.hasOwnProperty(key)) {
                                        let value = obj[key];
                                        parts.push(key + ":" + ("string" == typeof value ? JSON.stringify(value) : stringify(value)));
                                    }
                                    context = `{${parts.join(", ")}}`;
                                }
                                return `${injectorErrorName}${source ? "(" + source + ")" : ""}[${context}]: ${text.replace(NEW_LINE, "\n  ")}`;
                            }("\n" + e.message, tokenPath, injectorErrorName, source), e[NG_TOKEN_PATH] = tokenPath, 
                            e[NG_TEMP_TOKEN_PATH] = null, e;
                        }(e, token, "R3InjectorError", this.source);
                    }
                    throw e;
                } finally {
                    setCurrentInjector(previousInjector);
                }
                var value;
            }
            toString() {
                const tokens = [];
                return this.records.forEach((v, token) => tokens.push(stringify(token))), `R3Injector[${tokens.join(", ")}]`;
            }
            assertNotDestroyed() {
                if (this._destroyed) throw new Error("Injector has already been destroyed.");
            }
            processInjectorType(defOrWrappedDef, parents, dedupStack) {
                if (!(defOrWrappedDef = resolveForwardRef(defOrWrappedDef))) return !1;
                let def = getInjectorDef(defOrWrappedDef);
                const ngModule = null == def && defOrWrappedDef.ngModule || void 0, defType = void 0 === ngModule ? defOrWrappedDef : ngModule, isDuplicate = -1 !== dedupStack.indexOf(defType);
                if (void 0 !== ngModule && (def = getInjectorDef(ngModule)), null == def) return !1;
                if (this.injectorDefTypes.add(defType), this.records.set(defType, makeRecord(def.factory, NOT_YET)), 
                null != def.imports && !isDuplicate) {
                    let importTypesWithProviders;
                    dedupStack.push(defType);
                    try {
                        deepForEach(def.imports, imported => {
                            this.processInjectorType(imported, parents, dedupStack) && (void 0 === importTypesWithProviders && (importTypesWithProviders = []), 
                            importTypesWithProviders.push(imported));
                        });
                    } finally {}
                    if (void 0 !== importTypesWithProviders) for (let i = 0; i < importTypesWithProviders.length; i++) {
                        const {ngModule: ngModule, providers: providers} = importTypesWithProviders[i];
                        deepForEach(providers, provider => this.processProvider(provider, ngModule, providers || EMPTY_ARRAY$2));
                    }
                }
                const defProviders = def.providers;
                if (null != defProviders && !isDuplicate) {
                    const injectorType = defOrWrappedDef;
                    deepForEach(defProviders, provider => this.processProvider(provider, injectorType, defProviders));
                }
                return void 0 !== ngModule && void 0 !== defOrWrappedDef.providers;
            }
            processProvider(provider, ngModuleType, providers) {
                let token = isTypeProvider(provider = resolveForwardRef(provider)) ? provider : resolveForwardRef(provider && provider.provide);
                const record = function(provider, ngModuleType, providers) {
                    return isValueProvider(provider) ? makeRecord(void 0, provider.useValue) : makeRecord(providerToFactory(provider, ngModuleType, providers), NOT_YET);
                }(provider, ngModuleType, providers);
                if (isTypeProvider(provider) || !0 !== provider.multi) {
                    const existing = this.records.get(token);
                    existing && void 0 !== existing.multi && throwMixedMultiProviderError();
                } else {
                    let multiRecord = this.records.get(token);
                    multiRecord ? void 0 === multiRecord.multi && throwMixedMultiProviderError() : ((multiRecord = makeRecord(void 0, NOT_YET, !0)).factory = () => injectArgs(multiRecord.multi), 
                    this.records.set(token, multiRecord)), token = provider, multiRecord.multi.push(provider);
                }
                this.records.set(token, record);
            }
            hydrate(token, record) {
                var value;
                return record.value === CIRCULAR ? function(token) {
                    throw new Error(`Cannot instantiate cyclic dependency! ${token}`);
                }(stringify(token)) : record.value === NOT_YET && (record.value = CIRCULAR, record.value = record.factory()), 
                "object" == typeof record.value && record.value && null !== (value = record.value) && "object" == typeof value && "function" == typeof value.ngOnDestroy && this.onDestroy.add(record.value), 
                record.value;
            }
            injectableDefInScope(def) {
                return !!def.providedIn && ("string" == typeof def.providedIn ? "any" === def.providedIn || def.providedIn === this.scope : this.injectorDefTypes.has(def.providedIn));
            }
        }
        function injectableDefOrInjectorDefFactory(token) {
            const injectableDef = getInjectableDef(token), factory = null !== injectableDef ? injectableDef.factory : getFactoryDef(token);
            if (null !== factory) return factory;
            const injectorDef = getInjectorDef(token);
            if (null !== injectorDef) return injectorDef.factory;
            if (token instanceof InjectionToken) throw new Error(`Token ${stringify(token)} is missing a ɵprov definition.`);
            if (token instanceof Function) return function(token) {
                const paramLength = token.length;
                if (paramLength > 0) {
                    const args = newArray(paramLength, "?");
                    throw new Error(`Can't resolve all parameters for ${stringify(token)}: (${args.join(", ")}).`);
                }
                const inheritedInjectableDef = function(type) {
                    const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF]);
                    return def ? (console.warn(`DEPRECATED: DI is instantiating a token "${type.name}" that inherits its @Injectable decorator but does not provide one itself.\n` + `This will become an error in v10. Please add @Injectable() to the "${type.name}" class.`), 
                    def) : null;
                }(token);
                return null !== inheritedInjectableDef ? () => inheritedInjectableDef.factory(token) : () => new token;
            }(token);
            throw new Error("unreachable");
        }
        function providerToFactory(provider, ngModuleType, providers) {
            let factory = void 0;
            if (isTypeProvider(provider)) return injectableDefOrInjectorDefFactory(resolveForwardRef(provider));
            if (isValueProvider(provider)) factory = () => resolveForwardRef(provider.useValue); else if ((value = provider) && value.useExisting) factory = () => ɵɵinject(resolveForwardRef(provider.useExisting)); else if (function(value) {
                return !(!value || !value.useFactory);
            }(provider)) factory = () => provider.useFactory(...injectArgs(provider.deps || [])); else {
                const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
                if (classRef || function(ngModuleType, providers, provider) {
                    let ngModuleDetail = "";
                    throw ngModuleType && providers && (ngModuleDetail = ` - only instances of Provider and Type are allowed, got: [${providers.map(v => v == provider ? "?" + provider + "?" : "...").join(", ")}]`), 
                    new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}'` + ngModuleDetail);
                }(ngModuleType, providers, provider), !function(value) {
                    return !!value.deps;
                }(provider)) return injectableDefOrInjectorDefFactory(classRef);
                factory = () => new classRef(...injectArgs(provider.deps));
            }
            var value;
            return factory;
        }
        function makeRecord(factory, value, multi = !1) {
            return {
                factory: factory,
                value: value,
                multi: multi ? [] : void 0
            };
        }
        function isValueProvider(value) {
            return null !== value && "object" == typeof value && USE_VALUE in value;
        }
        function isTypeProvider(value) {
            return "function" == typeof value;
        }
        const INJECTOR_IMPL = function(providers, parent, name) {
            return createInjector({
                name: name
            }, parent, providers, name);
        };
        let Injector = (() => {
            class Injector {
                static create(options, parent) {
                    return Array.isArray(options) ? INJECTOR_IMPL(options, parent, "") : INJECTOR_IMPL(options.providers, options.parent, options.name || "");
                }
            }
            return Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND, Injector.NULL = new NullInjector, 
            Injector.ɵprov = ɵɵdefineInjectable({
                token: Injector,
                providedIn: "any",
                factory: () => ɵɵinject(INJECTOR)
            }), Injector.__NG_ELEMENT_ID__ = -1, Injector;
        })();
        const ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken("AnalyzeForEntryComponents");
        let componentResourceResolutionQueue = new Map;
        const componentDefPendingResolution = new Set;
        function unwrapResponse(response) {
            return "string" == typeof response ? response : response.text();
        }
        function ɵɵallocHostVars(count) {
            const lView = getLView(), tView = lView[TVIEW];
            tView.firstCreatePass && (function(tView, def, hostVars) {
                const expando = tView.expandoInstructions, length = expando.length;
                length >= 2 && expando[length - 2] === def.hostBindings ? expando[length - 1] = expando[length - 1] + hostVars : expando.push(def.hostBindings, hostVars);
            }(tView, instructionState.lFrame.currentDirectiveDef, count), function(tView, lView, totalHostVars) {
                for (let i = 0; i < totalHostVars; i++) lView.push(NO_CHANGE), tView.blueprint.push(NO_CHANGE), 
                tView.data.push(null);
            }(tView, lView, count));
        }
        let _symbolIterator = null;
        function getSymbolIterator() {
            if (!_symbolIterator) {
                const Symbol = _global.Symbol;
                if (Symbol && Symbol.iterator) _symbolIterator = Symbol.iterator; else {
                    const keys = Object.getOwnPropertyNames(Map.prototype);
                    for (let i = 0; i < keys.length; ++i) {
                        const key = keys[i];
                        "entries" !== key && "size" !== key && Map.prototype[key] === Map.prototype.entries && (_symbolIterator = key);
                    }
                }
            }
            return _symbolIterator;
        }
        function looseIdentical(a, b) {
            return a === b || "number" == typeof a && "number" == typeof b && isNaN(a) && isNaN(b);
        }
        class WrappedValue {
            constructor(value) {
                this.wrapped = value;
            }
            static wrap(value) {
                return new WrappedValue(value);
            }
            static unwrap(value) {
                return WrappedValue.isWrapped(value) ? value.wrapped : value;
            }
            static isWrapped(value) {
                return value instanceof WrappedValue;
            }
        }
        function isListLikeIterable$1(obj) {
            return !!isJsObject$1(obj) && (Array.isArray(obj) || !(obj instanceof Map) && getSymbolIterator() in obj);
        }
        function isJsObject$1(o) {
            return null !== o && ("function" == typeof o || "object" == typeof o);
        }
        function updateBinding(lView, bindingIndex, value) {
            return lView[bindingIndex] = value;
        }
        function getBinding(lView, bindingIndex) {
            return lView[bindingIndex];
        }
        function bindingUpdated(lView, bindingIndex, value) {
            return !Object.is(lView[bindingIndex], value) && (lView[bindingIndex] = value, !0);
        }
        function bindingUpdated2(lView, bindingIndex, exp1, exp2) {
            const different = bindingUpdated(lView, bindingIndex, exp1);
            return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
        }
        function ɵɵattribute(name, value, sanitizer, namespace) {
            const lView = getLView();
            return bindingUpdated(lView, nextBindingIndex(), value) && function(index, name, value, lView, sanitizer, namespace) {
                const element = getNativeByIndex(index, lView), renderer = lView[RENDERER];
                if (null == value) isProceduralRenderer(renderer) ? renderer.removeAttribute(element, name, namespace) : element.removeAttribute(name); else {
                    const tNode = getTNode(index, lView), strValue = null == sanitizer ? renderStringify(value) : sanitizer(value, tNode.tagName || "", name);
                    isProceduralRenderer(renderer) ? renderer.setAttribute(element, name, strValue, namespace) : namespace ? element.setAttributeNS(namespace, name, strValue) : element.setAttribute(name, strValue);
                }
            }(getSelectedIndex(), name, value, lView, sanitizer, namespace), ɵɵattribute;
        }
        function interpolation1(lView, prefix, v0, suffix) {
            return bindingUpdated(lView, nextBindingIndex(), v0) ? prefix + renderStringify(v0) + suffix : NO_CHANGE;
        }
        function ɵɵtemplate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
            const lView = getLView(), tView = lView[TVIEW], tViewConsts = tView.consts, tContainerNode = function(lView, nodeIndex, tagName, attrs) {
                const adjustedIndex = nodeIndex + HEADER_OFFSET, comment = lView[adjustedIndex] = lView[RENDERER].createComment(""), tNode = getOrCreateTNode(lView[TVIEW], lView[T_HOST], nodeIndex, 0, tagName, attrs), lContainer = lView[adjustedIndex] = createLContainer(comment, lView, comment, tNode);
                return appendChild(comment, tNode, lView), attachPatchData(comment, lView), addToViewTree(lView, lContainer), 
                tNode;
            }(lView, index, tagName || null, getConstant(tViewConsts, attrsIndex)), localRefs = getConstant(tViewConsts, localRefsIndex);
            if (tView.firstCreatePass) {
                resolveDirectives(tView, lView, tContainerNode, localRefs), registerPostOrderHooks(tView, tContainerNode);
                const embeddedTView = tContainerNode.tViews = createTView(0, -1, templateFn, decls, vars, tView.directiveRegistry, tView.pipeRegistry, null, tView.schemas, tViewConsts), embeddedTViewNode = createTNode(0, null, 2, -1, null, null);
                embeddedTViewNode.injectorIndex = tContainerNode.injectorIndex, embeddedTView.node = embeddedTViewNode, 
                null !== tView.queries && (tView.queries.template(tView, tContainerNode), embeddedTView.queries = tView.queries.embeddedTView(tContainerNode));
            }
            isDirectiveHost(tContainerNode) && createDirectivesInstances(tView, lView, tContainerNode), 
            null != localRefs && saveResolvedLocalsInData(lView, tContainerNode, localRefExtractor), 
            setIsNotParent();
        }
        function ɵɵreference(index) {
            return load(instructionState.lFrame.contextLView, index);
        }
        function ɵɵdirectiveInject(token, flags = InjectFlags.Default) {
            token = resolveForwardRef(token);
            const lView = getLView();
            return null == lView ? ɵɵinject(token, flags) : getOrCreateInjectable(getPreviousOrParentTNode(), lView, token, flags);
        }
        function ɵɵinjectAttribute(attrNameToInject) {
            return function(tNode, attrNameToInject) {
                if ("class" === attrNameToInject) return getInitialStylingValue(tNode.classes);
                if ("style" === attrNameToInject) return getInitialStylingValue(tNode.styles);
                const attrs = tNode.attrs;
                if (attrs) {
                    const attrsLength = attrs.length;
                    let i = 0;
                    for (;i < attrsLength; ) {
                        const value = attrs[i];
                        if (isNameOnlyAttributeMarker(value)) break;
                        if (0 === value) i += 2; else if ("number" == typeof value) for (i++; i < attrsLength && "string" == typeof attrs[i]; ) i++; else {
                            if (value === attrNameToInject) return attrs[i + 1];
                            i += 2;
                        }
                    }
                }
                return null;
            }(getPreviousOrParentTNode(), attrNameToInject);
        }
        function ɵɵinvalidFactory() {
            throw new Error("invalid");
        }
        function ɵɵstyleSanitizer(sanitizer) {
            setCurrentStyleSanitizer(sanitizer);
        }
        function ɵɵstyleProp(prop, value, suffix) {
            !function(elementIndex, prop, value, suffix) {
                const bindingIndex = nextBindingIndex(), lView = getLView(), tNode = getTNode(elementIndex, lView), firstUpdatePass = lView[TVIEW].firstUpdatePass;
                firstUpdatePass && (patchConfig(tNode, 32768), patchHostStylingFlag(tNode, isHostStyling(), !1)), 
                stylingProp(tNode, firstUpdatePass, lView, bindingIndex, prop, function(value, suffix) {
                    if (value === NO_CHANGE) return value;
                    let resolvedValue = null;
                    return null !== value && (resolvedValue = suffix ? renderStringify(value) + suffix : value), 
                    resolvedValue;
                }(value, suffix), !1);
            }(getSelectedIndex(), prop, value, suffix);
        }
        function ɵɵclassProp(className, value) {
            const bindingIndex = nextBindingIndex(), lView = getLView(), tNode = getTNode(getSelectedIndex(), lView), firstUpdatePass = lView[TVIEW].firstUpdatePass;
            firstUpdatePass && (patchConfig(tNode, 1024), patchHostStylingFlag(tNode, isHostStyling(), !0)), 
            stylingProp(tNode, firstUpdatePass, lView, bindingIndex, className, value, !0);
        }
        function stylingProp(tNode, firstUpdatePass, lView, bindingIndex, prop, value, isClassBased) {
            let updated = !1;
            const native = getNativeByTNode(tNode, lView), context = isClassBased ? getClassesContext(tNode) : getStylesContext(tNode), sanitizer = isClassBased ? null : getCurrentStyleSanitizer();
            if (allowDirectStyling(tNode, isClassBased, firstUpdatePass)) {
                const sanitizerToUse = isClassBased ? null : sanitizer;
                updated = function(renderer, context, tNode, element, data, bindingIndex, prop, value, isClassBased, sanitizer) {
                    let applied = !1;
                    if (hasValueChanged(data[bindingIndex], value)) {
                        setValue(data, bindingIndex, value);
                        const applyFn = isClassBased ? setClass : setStyle, mapBindingsFlag = isClassBased ? 512 : 16384;
                        if (!(applied = applyStylingValue(renderer, element, prop, value, applyFn, bindingIndex, sanitizer)) && hasConfig(tNode, mapBindingsFlag)) {
                            const state = getStylingState(element, TEMPLATE_DIRECTIVE_INDEX), map = isClassBased ? state.lastDirectClassMap : state.lastDirectStyleMap;
                            applied = !!map && findAndApplyMapValue(renderer, element, applyFn, map, prop, bindingIndex, sanitizer);
                        }
                        if (!applied && hasConfig(tNode, 256)) {
                            const map = getStylingMapArray(context);
                            applied = !!map && findAndApplyMapValue(renderer, element, applyFn, map, prop, bindingIndex);
                        }
                        applied || applyFn(renderer, element, prop, null, bindingIndex);
                    }
                    return applied;
                }(getRenderer(tNode, lView), context, tNode, native, lView, bindingIndex, prop, value, isClassBased, sanitizerToUse), 
                sanitizerToUse && setElementExitFn(stylingApply);
            } else {
                const directiveIndex = getActiveDirectiveId();
                updated = isClassBased ? updateClassViaContext(context, tNode, lView, native, directiveIndex, prop, bindingIndex, value, !1, firstUpdatePass) : updateStyleViaContext(context, tNode, lView, native, directiveIndex, prop, bindingIndex, value, sanitizer, !1, firstUpdatePass), 
                setElementExitFn(stylingApply);
            }
            return updated;
        }
        function ɵɵstyleMap(styles) {
            const index = getSelectedIndex(), lView = getLView(), tNode = getTNode(index, lView), firstUpdatePass = lView[TVIEW].firstUpdatePass, context = getStylesContext(tNode), hasDirectiveInput = hasStyleInput(tNode), bindingIndex = incrementBindingIndex(2);
            !isHostStyling() && hasDirectiveInput && styles !== NO_CHANGE && (updateDirectiveInputValue(context, lView, tNode, bindingIndex, styles, !1, firstUpdatePass), 
            styles = NO_CHANGE), firstUpdatePass && (patchConfig(tNode, 16384), patchHostStylingFlag(tNode, isHostStyling(), !1)), 
            stylingMap(context, tNode, firstUpdatePass, lView, bindingIndex, styles, !1, hasDirectiveInput);
        }
        function ɵɵclassMap(classes) {
            classMapInternal(getSelectedIndex(), classes);
        }
        function classMapInternal(elementIndex, classes) {
            const lView = getLView(), tNode = getTNode(elementIndex, lView), firstUpdatePass = lView[TVIEW].firstUpdatePass, context = getClassesContext(tNode), hasDirectiveInput = hasClassInput(tNode), bindingIndex = incrementBindingIndex(2);
            !isHostStyling() && hasDirectiveInput && classes !== NO_CHANGE && (updateDirectiveInputValue(context, lView, tNode, bindingIndex, classes, !0, firstUpdatePass), 
            classes = NO_CHANGE), firstUpdatePass && (patchConfig(tNode, 512), patchHostStylingFlag(tNode, isHostStyling(), !0)), 
            stylingMap(context, tNode, firstUpdatePass, lView, bindingIndex, classes, !0, hasDirectiveInput);
        }
        function stylingMap(context, tNode, firstUpdatePass, lView, bindingIndex, value, isClassBased, hasDirectiveInput) {
            const directiveIndex = getActiveDirectiveId(), native = getNativeByTNode(tNode, lView), oldValue = getValue(lView, bindingIndex), sanitizer = getCurrentStyleSanitizer(), valueHasChanged = hasValueChanged(oldValue, value);
            if (allowDirectStyling(tNode, isClassBased, firstUpdatePass)) {
                const sanitizerToUse = isClassBased ? null : sanitizer;
                (function(renderer, context, tNode, element, data, bindingIndex, value, isClassBased, sanitizer, forceUpdate, bindingValueContainsInitial) {
                    const oldValue = getValue(data, bindingIndex);
                    if (forceUpdate || hasValueChanged(oldValue, value)) {
                        const hasInitial = hasConfig(tNode, 256), initialValue = hasInitial && !bindingValueContainsInitial ? getInitialStylingValue(context) : null;
                        setValue(data, bindingIndex, value);
                        const cachedValueIndex = bindingIndex + 1;
                        let cachedValue = getValue(data, cachedValueIndex);
                        cachedValue === NO_CHANGE && (cachedValue = initialValue), cachedValue = "string" != typeof cachedValue ? "" : cachedValue;
                        let writeToAttrDirectly = !hasConfig(tNode, isClassBased ? 1024 : 32768);
                        if (writeToAttrDirectly && function(element, cachedValue, isClassBased) {
                            return "undefined" === _global.Node || cachedValue === VALUE_IS_EXTERNALLY_MODIFIED || ((isClassBased ? element.className : element.style && element.style.cssText) || "") !== (cachedValue || "");
                        }(element, cachedValue, isClassBased) && (writeToAttrDirectly = !1, oldValue !== VALUE_IS_EXTERNALLY_MODIFIED && (function(renderer, element, values, isClassBased) {
                            let arr;
                            var value;
                            value = values, arr = Array.isArray(value) && "string" == typeof value[1] ? values : normalizeIntoStylingMap(null, values, !isClassBased);
                            const applyFn = isClassBased ? setClass : setStyle;
                            for (let i = 1; i < arr.length; i += 2) getMapValue(arr, i) && applyFn(renderer, element, getMapProp(arr, i), !1);
                        }(renderer, element, oldValue, isClassBased), setValue(data, cachedValueIndex, VALUE_IS_EXTERNALLY_MODIFIED))), 
                        writeToAttrDirectly) setValue(data, cachedValueIndex, writeStylingValueDirectly(renderer, element, value, isClassBased, hasInitial && !bindingValueContainsInitial ? getInitialStylingValue(context) : null) || null); else {
                            const applyFn = isClassBased ? setClass : setStyle, map = normalizeIntoStylingMap(oldValue, value, !isClassBased), initialStyles = hasInitial ? getStylingMapArray(context) : null;
                            for (let i = 1; i < map.length; i += 2) {
                                const prop = getMapProp(map, i);
                                let applied = applyStylingValue(renderer, element, prop, getMapValue(map, i), applyFn, bindingIndex, sanitizer);
                                !applied && initialStyles && (applied = findAndApplyMapValue(renderer, element, applyFn, initialStyles, prop, bindingIndex, sanitizer)), 
                                applied || applyFn(renderer, element, prop, null, bindingIndex);
                            }
                            const state = getStylingState(element, TEMPLATE_DIRECTIVE_INDEX);
                            isClassBased ? state.lastDirectClassMap = map : state.lastDirectStyleMap = map;
                        }
                    }
                })(getRenderer(tNode, lView), context, tNode, native, lView, bindingIndex, value, isClassBased, sanitizerToUse, valueHasChanged, hasDirectiveInput), 
                sanitizerToUse && setElementExitFn(stylingApply);
            } else {
                const stylingMapArr = value === NO_CHANGE ? NO_CHANGE : normalizeIntoStylingMap(oldValue, value, !isClassBased);
                _activeStylingMapApplyFn = syncStylingMap, isClassBased ? updateClassViaContext(context, tNode, lView, native, directiveIndex, null, bindingIndex, stylingMapArr, valueHasChanged, firstUpdatePass) : updateStyleViaContext(context, tNode, lView, native, directiveIndex, null, bindingIndex, stylingMapArr, sanitizer, valueHasChanged, firstUpdatePass), 
                setElementExitFn(stylingApply);
            }
        }
        function updateDirectiveInputValue(context, lView, tNode, bindingIndex, newValue, isClassBased, firstUpdatePass) {
            if (hasValueChanged(getValue(lView, bindingIndex), newValue)) {
                if (isStylingValueDefined(newValue) || !firstUpdatePass) {
                    const inputName = isClassBased ? selectClassBasedInputName(tNode.inputs) : "style";
                    setInputsForProperty(lView, tNode.inputs[inputName], function(initialValue, bindingValue, isClassBased) {
                        let value = bindingValue;
                        var classes;
                        return initialValue.length && (value = isClassBased ? concatString(initialValue, ((classes = bindingValue) && "string" != typeof classes && (classes = Object.keys(classes).join(" ")), 
                        classes || "")) : concatString(initialValue, forceStylesAsString(bindingValue, !0), ";")), 
                        value;
                    }(getInitialStylingValue(context), newValue, isClassBased)), setElementExitFn(stylingApply);
                }
                setValue(lView, bindingIndex, newValue);
            }
        }
        function stylingApply() {
            const lView = getLView(), tView = lView[TVIEW], tNode = getTNode(getSelectedIndex(), lView), native = getNativeByTNode(tNode, lView), directiveIndex = getActiveDirectiveId(), renderer = getRenderer(tNode, lView), sanitizer = getCurrentStyleSanitizer();
            (function(renderer, data, tNode, classesContext, stylesContext, element, directiveIndex, styleSanitizer, firstUpdatePass) {
                const state = getStylingState(element, directiveIndex), hostBindingsMode = isHostStylingActive(state.sourceIndex);
                stylesContext && (firstUpdatePass && syncContextInitialStyling(stylesContext, tNode, !1), 
                0 !== state.stylesBitMask && applyStylingViaContext(stylesContext, tNode, renderer, element, data, state.stylesBitMask, setStyle, styleSanitizer, hostBindingsMode, !1)), 
                classesContext && (firstUpdatePass && syncContextInitialStyling(classesContext, tNode, !0), 
                0 !== state.classesBitMask && applyStylingViaContext(classesContext, tNode, renderer, element, data, state.classesBitMask, setClass, null, hostBindingsMode, !0)), 
                _state.element = null;
            })(renderer, lView, tNode, isStylingContext(tNode.classes) ? tNode.classes : null, isStylingContext(tNode.styles) ? tNode.styles : null, native, directiveIndex, sanitizer, tView.firstUpdatePass), 
            setCurrentStyleSanitizer(null);
        }
        function getRenderer(tNode, lView) {
            return 3 === tNode.type ? lView[RENDERER] : null;
        }
        function registerInitialStylingOnTNode(tNode, attrs, startIndex) {
            let hasAdditionalInitialStyling = !1, styles = getStylingMapArray(tNode.styles), classes = getStylingMapArray(tNode.classes), mode = -1;
            for (let i = startIndex; i < attrs.length; i++) {
                const attr = attrs[i];
                if ("number" == typeof attr) mode = attr; else if (1 == mode) addItemToStylingMap(classes = classes || allocStylingMapArray(null), attr, !0), 
                hasAdditionalInitialStyling = !0; else if (2 == mode) {
                    const value = attrs[++i];
                    addItemToStylingMap(styles = styles || allocStylingMapArray(null), attr, value), 
                    hasAdditionalInitialStyling = !0;
                }
            }
            return classes && classes.length > 1 && (tNode.classes || (tNode.classes = classes), 
            updateRawValueOnContext(tNode.classes, stylingMapToString(classes, !0))), styles && styles.length > 1 && (tNode.styles || (tNode.styles = styles), 
            updateRawValueOnContext(tNode.styles, stylingMapToString(styles, !1))), hasAdditionalInitialStyling && (tNode.flags |= 256), 
            hasAdditionalInitialStyling;
        }
        function updateRawValueOnContext(context, value) {
            getStylingMapArray(context)[0] = value;
        }
        function getStylesContext(tNode) {
            return getContext(tNode, !1);
        }
        function getClassesContext(tNode) {
            return getContext(tNode, !0);
        }
        function getContext(tNode, isClassBased) {
            let context = isClassBased ? tNode.classes : tNode.styles;
            var initialStyling;
            return isStylingContext(context) || (isDirectiveHost(tNode), initialStyling = (initialStyling = context) || allocStylingMapArray(null), 
            context = [ DEFAULT_TOTAL_SOURCES, initialStyling ], isClassBased ? tNode.classes = context : tNode.styles = context), 
            context;
        }
        function isHostStyling() {
            return isHostStylingActive(getActiveDirectiveId());
        }
        function patchHostStylingFlag(tNode, hostBindingsMode, isClassBased) {
            patchConfig(tNode, hostBindingsMode ? isClassBased ? 4096 : 131072 : isClassBased ? 2048 : 65536);
        }
        function ɵɵelementStart(index, name, attrsIndex, localRefsIndex) {
            const lView = getLView(), tView = lView[TVIEW], tViewConsts = tView.consts, attrs = getConstant(tViewConsts, attrsIndex), localRefs = getConstant(tViewConsts, localRefsIndex), renderer = lView[RENDERER], native = lView[index + HEADER_OFFSET] = elementCreate(name, renderer, instructionState.lFrame.currentNamespace), tNode = getOrCreateTNode(tView, lView[T_HOST], index, 3, name, attrs);
            if (null != attrs) {
                const lastAttrIndex = setUpAttributes(renderer, native, attrs);
                tView.firstCreatePass && registerInitialStylingOnTNode(tNode, attrs, lastAttrIndex);
            }
            256 == (256 & tNode.flags) && renderInitialStyling(renderer, native, tNode, !1), 
            appendChild(native, tNode, lView), 0 === instructionState.lFrame.elementDepthCount && attachPatchData(native, lView), 
            instructionState.lFrame.elementDepthCount++, tView.firstCreatePass && (resolveDirectives(tView, lView, tNode, localRefs), 
            null !== tView.queries && tView.queries.elementStart(tView, tNode)), isDirectiveHost(tNode) && (createDirectivesInstances(tView, lView, tNode), 
            executeContentQueries(tView, tNode, lView)), null != localRefs && saveResolvedLocalsInData(lView, tNode);
        }
        function ɵɵelementEnd() {
            let previousOrParentTNode = getPreviousOrParentTNode();
            getIsParent() ? setIsNotParent() : setPreviousOrParentTNode(previousOrParentTNode = previousOrParentTNode.parent, !1);
            const tNode = previousOrParentTNode, lView = getLView(), tView = lView[TVIEW];
            if (instructionState.lFrame.elementDepthCount--, tView.firstCreatePass && (registerPostOrderHooks(tView, previousOrParentTNode), 
            isContentQueryHost(previousOrParentTNode) && tView.queries.elementEnd(previousOrParentTNode)), 
            hasClassInput(tNode)) {
                const inputName = selectClassBasedInputName(tNode.inputs);
                setDirectiveStylingInput(tNode.classes, lView, tNode.inputs[inputName]);
            }
            hasStyleInput(tNode) && setDirectiveStylingInput(tNode.styles, lView, tNode.inputs.style);
        }
        function ɵɵelement(index, name, attrsIndex, localRefsIndex) {
            ɵɵelementStart(index, name, attrsIndex, localRefsIndex), ɵɵelementEnd();
        }
        function ɵɵelementHostAttrs(attrs) {
            const hostElementIndex = getSelectedIndex(), lView = getLView(), tView = lView[TVIEW], tNode = getTNode(hostElementIndex, lView);
            if (3 === tNode.type) {
                const native = getNativeByTNode(tNode, lView), lastAttrIndex = setUpAttributes(lView[RENDERER], native, attrs);
                tView.firstCreatePass && registerInitialStylingOnTNode(tNode, attrs, lastAttrIndex) && renderInitialStyling(lView[RENDERER], native, tNode, !0);
            }
        }
        function setDirectiveStylingInput(context, lView, stylingInputs) {
            setInputsForProperty(lView, stylingInputs, context && getInitialStylingValue(context) || null);
        }
        function ɵɵelementContainerStart(index, attrsIndex, localRefsIndex) {
            const lView = getLView(), tView = lView[TVIEW], renderer = lView[RENDERER], tViewConsts = tView.consts, attrs = getConstant(tViewConsts, attrsIndex), localRefs = getConstant(tViewConsts, localRefsIndex), native = lView[index + HEADER_OFFSET] = renderer.createComment(""), tNode = getOrCreateTNode(tView, lView[T_HOST], index, 4, "ng-container", attrs);
            attrs && tView.firstCreatePass && registerInitialStylingOnTNode(tNode, attrs, 0), 
            appendChild(native, tNode, lView), attachPatchData(native, lView), tView.firstCreatePass && (resolveDirectives(tView, lView, tNode, localRefs), 
            tView.queries && tView.queries.elementStart(tView, tNode)), isDirectiveHost(tNode) && (createDirectivesInstances(tView, lView, tNode), 
            executeContentQueries(tView, tNode, lView)), null != localRefs && saveResolvedLocalsInData(lView, tNode);
        }
        function ɵɵelementContainerEnd() {
            let previousOrParentTNode = getPreviousOrParentTNode();
            const tView = getLView()[TVIEW];
            getIsParent() ? setIsNotParent() : setPreviousOrParentTNode(previousOrParentTNode = previousOrParentTNode.parent, !1), 
            tView.firstCreatePass && (registerPostOrderHooks(tView, previousOrParentTNode), 
            isContentQueryHost(previousOrParentTNode) && tView.queries.elementEnd(previousOrParentTNode));
        }
        function ɵɵgetCurrentView() {
            return getLView();
        }
        function isPromise(obj) {
            return !!obj && "function" == typeof obj.then;
        }
        function isObservable(obj) {
            return !!obj && "function" == typeof obj.subscribe;
        }
        function ɵɵlistener(eventName, listenerFn, useCapture = !1, eventTargetResolver) {
            const lView = getLView(), tNode = getPreviousOrParentTNode();
            listenerInternal(lView, lView[RENDERER], tNode, eventName, listenerFn, useCapture, eventTargetResolver);
        }
        function ɵɵcomponentHostSyntheticListener(eventName, listenerFn, useCapture = !1, eventTargetResolver) {
            const lView = getLView(), tNode = getPreviousOrParentTNode();
            listenerInternal(lView, loadComponentRenderer(tNode, lView), tNode, eventName, listenerFn, useCapture, eventTargetResolver);
        }
        function listenerInternal(lView, renderer, tNode, eventName, listenerFn, useCapture = !1, eventTargetResolver) {
            const tView = lView[TVIEW], isTNodeDirectiveHost = isDirectiveHost(tNode), tCleanup = tView.firstCreatePass && (tView.cleanup || (tView.cleanup = []));
            let processOutputs = !0;
            if (3 === tNode.type) {
                const native = getNativeByTNode(tNode, lView), resolved = eventTargetResolver ? eventTargetResolver(native) : EMPTY_OBJ, target = resolved.target || native, lCleanup = getCleanup(lView), lCleanupIndex = lCleanup.length, idxOrTargetGetter = eventTargetResolver ? _lView => eventTargetResolver(unwrapRNode(_lView[tNode.index])).target : tNode.index;
                if (isProceduralRenderer(renderer)) {
                    let existingListener = null;
                    if (!eventTargetResolver && isTNodeDirectiveHost && (existingListener = function(lView, eventName, tNodeIdx) {
                        const tCleanup = lView[TVIEW].cleanup;
                        if (null != tCleanup) for (let i = 0; i < tCleanup.length - 1; i += 2) {
                            const cleanupEventName = tCleanup[i];
                            if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {
                                const lCleanup = lView[CLEANUP], listenerIdxInLCleanup = tCleanup[i + 2];
                                return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;
                            }
                            "string" == typeof cleanupEventName && (i += 2);
                        }
                        return null;
                    }(lView, eventName, tNode.index)), null !== existingListener) (existingListener.__ngLastListenerFn__ || existingListener).__ngNextListenerFn__ = listenerFn, 
                    existingListener.__ngLastListenerFn__ = listenerFn, processOutputs = !1; else {
                        listenerFn = wrapListener(tNode, lView, listenerFn, !1);
                        const cleanupFn = renderer.listen(resolved.name || target, eventName, listenerFn);
                        lCleanup.push(listenerFn, cleanupFn), tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);
                    }
                } else listenerFn = wrapListener(tNode, lView, listenerFn, !0), target.addEventListener(eventName, listenerFn, useCapture), 
                lCleanup.push(listenerFn), tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, useCapture);
            }
            const outputs = tNode.outputs;
            let props;
            if (processOutputs && null != outputs && (props = outputs[eventName])) {
                const propsLength = props.length;
                if (propsLength) {
                    const lCleanup = getCleanup(lView);
                    for (let i = 0; i < propsLength; i += 3) {
                        const subscription = lView[props[i]][props[i + 2]].subscribe(listenerFn), idx = lCleanup.length;
                        lCleanup.push(listenerFn, subscription), tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));
                    }
                }
            }
        }
        function executeListenerWithErrorHandling(lView, tNode, listenerFn, e) {
            try {
                return !1 !== listenerFn(e);
            } catch (error) {
                return handleError(lView, error), !1;
            }
        }
        function wrapListener(tNode, lView, listenerFn, wrapWithPreventDefault) {
            return function wrapListenerIn_markDirtyAndPreventDefault(e) {
                if (e === Function) return listenerFn;
                const startView = 2 & tNode.flags ? getComponentLViewByIndex(tNode.index, lView) : lView;
                0 == (32 & lView[FLAGS]) && markViewDirty(startView);
                let result = executeListenerWithErrorHandling(lView, 0, listenerFn, e), nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;
                for (;nextListenerFn; ) result = executeListenerWithErrorHandling(lView, 0, nextListenerFn, e) && result, 
                nextListenerFn = nextListenerFn.__ngNextListenerFn__;
                return wrapWithPreventDefault && !1 === result && (e.preventDefault(), e.returnValue = !1), 
                result;
            };
        }
        function ɵɵnextContext(level = 1) {
            return function(level = 1) {
                return instructionState.lFrame.contextLView = function(nestingLevel, currentView) {
                    for (;nestingLevel > 0; ) currentView = currentView[DECLARATION_VIEW], nestingLevel--;
                    return currentView;
                }(level, instructionState.lFrame.contextLView), instructionState.lFrame.contextLView[CONTEXT];
            }(level);
        }
        function matchingProjectionSlotIndex(tNode, projectionSlots) {
            let wildcardNgContentIndex = null;
            const ngProjectAsAttrVal = function(tNode) {
                const nodeAttrs = tNode.attrs;
                if (null != nodeAttrs) {
                    const ngProjectAsAttrIdx = nodeAttrs.indexOf(5);
                    if (0 == (1 & ngProjectAsAttrIdx)) return nodeAttrs[ngProjectAsAttrIdx + 1];
                }
                return null;
            }(tNode);
            for (let i = 0; i < projectionSlots.length; i++) {
                const slotValue = projectionSlots[i];
                if ("*" !== slotValue) {
                    if (null === ngProjectAsAttrVal ? isNodeMatchingSelectorList(tNode, slotValue, !0) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) return i;
                } else wildcardNgContentIndex = i;
            }
            return wildcardNgContentIndex;
        }
        function ɵɵprojectionDef(projectionSlots) {
            const componentNode = findComponentView(getLView())[T_HOST];
            if (!componentNode.projection) {
                const projectionHeads = componentNode.projection = newArray(projectionSlots ? projectionSlots.length : 1, null), tails = projectionHeads.slice();
                let componentChild = componentNode.child;
                for (;null !== componentChild; ) {
                    const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;
                    null !== slotIndex && (tails[slotIndex] ? tails[slotIndex].projectionNext = componentChild : projectionHeads[slotIndex] = componentChild, 
                    tails[slotIndex] = componentChild), componentChild = componentChild.next;
                }
            }
        }
        let delayProjection = !1;
        function ɵɵprojection(nodeIndex, selectorIndex = 0, attrs) {
            const lView = getLView(), tProjectionNode = getOrCreateTNode(lView[TVIEW], lView[T_HOST], nodeIndex, 1, null, attrs || null);
            null === tProjectionNode.projection && (tProjectionNode.projection = selectorIndex), 
            setIsNotParent(), delayProjection || function(lView, tProjectionNode) {
                applyProjectionRecursive(lView[RENDERER], 0, lView, tProjectionNode, getRenderParent(tProjectionNode, lView), getNativeAnchorNode(tProjectionNode.parent || lView[T_HOST], lView));
            }(lView, tProjectionNode);
        }
        function ɵɵproperty(propName, value, sanitizer) {
            const lView = getLView();
            return bindingUpdated(lView, nextBindingIndex(), value) && elementPropertyInternal(lView, getSelectedIndex(), propName, value, sanitizer), 
            ɵɵproperty;
        }
        function ɵɵpropertyInterpolate(propName, v0, sanitizer) {
            return ɵɵpropertyInterpolate1(propName, "", v0, "", sanitizer), ɵɵpropertyInterpolate;
        }
        function ɵɵpropertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {
            const lView = getLView(), interpolatedValue = interpolation1(lView, prefix, v0, suffix);
            return interpolatedValue !== NO_CHANGE && elementPropertyInternal(lView, getSelectedIndex(), propName, interpolatedValue, sanitizer), 
            ɵɵpropertyInterpolate1;
        }
        function ɵɵtext(index, value = "") {
            const lView = getLView(), textNative = lView[index + HEADER_OFFSET] = function(value, renderer) {
                return isProceduralRenderer(renderer) ? renderer.createText(value) : renderer.createTextNode(value);
            }(value, lView[RENDERER]), tNode = getOrCreateTNode(lView[TVIEW], lView[T_HOST], index, 3, null, null);
            setIsNotParent(), appendChild(textNative, tNode, lView);
        }
        function ɵɵtextInterpolate(v0) {
            return ɵɵtextInterpolate1("", v0, ""), ɵɵtextInterpolate;
        }
        function ɵɵtextInterpolate1(prefix, v0, suffix) {
            const lView = getLView(), interpolated = interpolation1(lView, prefix, v0, suffix);
            return interpolated !== NO_CHANGE && textBindingInternal(lView, getSelectedIndex(), interpolated), 
            ɵɵtextInterpolate1;
        }
        function ɵɵtextInterpolate2(prefix, v0, i0, v1, suffix) {
            const lView = getLView(), interpolated = function(lView, prefix, v0, i0, v1, suffix) {
                const different = bindingUpdated2(lView, getBindingIndex(), v0, v1);
                return incrementBindingIndex(2), different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;
            }(lView, prefix, v0, i0, v1, suffix);
            return interpolated !== NO_CHANGE && textBindingInternal(lView, getSelectedIndex(), interpolated), 
            ɵɵtextInterpolate2;
        }
        function ɵɵclassMapInterpolate1(prefix, v0, suffix) {
            const interpolatedValue = interpolation1(getLView(), prefix, v0, suffix);
            classMapInternal(getSelectedIndex(), interpolatedValue);
        }
        function ɵɵhostProperty(propName, value, sanitizer) {
            const lView = getLView();
            return bindingUpdated(lView, nextBindingIndex(), value) && elementPropertyInternal(lView, getSelectedIndex(), propName, value, sanitizer, !0), 
            ɵɵhostProperty;
        }
        function ɵɵupdateSyntheticHostBinding(propName, value, sanitizer) {
            const lView = getLView();
            return bindingUpdated(lView, nextBindingIndex(), value) && elementPropertyInternal(lView, getSelectedIndex(), propName, value, sanitizer, !0, loadComponentRenderer), 
            ɵɵupdateSyntheticHostBinding;
        }
        function getComponent(element) {
            if (!(element instanceof Node)) throw new Error("Expecting instance of DOM Node");
            const context = loadLContext(element, !1);
            return null === context ? null : (void 0 === context.component && (context.component = function(nodeIndex, lView) {
                const tNode = lView[TVIEW].data[nodeIndex];
                return 2 & tNode.flags ? lView[tNode.directiveStart] : null;
            }(context.nodeIndex, context.lView)), context.component);
        }
        function loadLContext(target, throwOnNotFound = !0) {
            const context = function(target) {
                let mpValue = readPatchedData(target);
                if (mpValue) {
                    if (Array.isArray(mpValue)) {
                        const lView = mpValue;
                        let nodeIndex, component = void 0, directives = void 0;
                        if ((instance = target) && instance.constructor && instance.constructor.ɵcmp) {
                            if (-1 == (nodeIndex = function(lView, componentInstance) {
                                const componentIndices = lView[TVIEW].components;
                                if (componentIndices) for (let i = 0; i < componentIndices.length; i++) {
                                    const elementComponentIndex = componentIndices[i];
                                    if (getComponentLViewByIndex(elementComponentIndex, lView)[CONTEXT] === componentInstance) return elementComponentIndex;
                                } else if (getComponentLViewByIndex(HEADER_OFFSET, lView)[CONTEXT] === componentInstance) return HEADER_OFFSET;
                                return -1;
                            }(lView, target))) throw new Error("The provided component was not found in the application");
                            component = target;
                        } else if (function(instance) {
                            return instance && instance.constructor && instance.constructor.ɵdir;
                        }(target)) {
                            if (-1 == (nodeIndex = function(lView, directiveInstance) {
                                let tNode = lView[TVIEW].firstChild;
                                for (;tNode; ) {
                                    const directiveIndexEnd = tNode.directiveEnd;
                                    for (let i = tNode.directiveStart; i < directiveIndexEnd; i++) if (lView[i] === directiveInstance) return tNode.index;
                                    tNode = traverseNextElement(tNode);
                                }
                                return -1;
                            }(lView, target))) throw new Error("The provided directive was not found in the application");
                            directives = function(nodeIndex, lView, includeComponents) {
                                const tNode = lView[TVIEW].data[nodeIndex];
                                let directiveStartIndex = tNode.directiveStart;
                                return 0 == directiveStartIndex ? EMPTY_ARRAY : (2 & tNode.flags && directiveStartIndex++, 
                                lView.slice(directiveStartIndex, tNode.directiveEnd));
                            }(nodeIndex, lView);
                        } else if (-1 == (nodeIndex = findViaNativeElement(lView, target))) return null;
                        const native = unwrapRNode(lView[nodeIndex]), existingCtx = readPatchedData(native), context = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);
                        if (component && void 0 === context.component && (context.component = component, 
                        attachPatchData(context.component, context)), directives && void 0 === context.directives) {
                            context.directives = directives;
                            for (let i = 0; i < directives.length; i++) attachPatchData(directives[i], context);
                        }
                        attachPatchData(context.native, context), mpValue = context;
                    }
                } else {
                    const rElement = target;
                    let parent = rElement;
                    for (;parent = parent.parentNode; ) {
                        const parentContext = readPatchedData(parent);
                        if (parentContext) {
                            let lView;
                            if (!(lView = Array.isArray(parentContext) ? parentContext : parentContext.lView)) return null;
                            const index = findViaNativeElement(lView, rElement);
                            if (index >= 0) {
                                const native = unwrapRNode(lView[index]), context = createLContext(lView, index, native);
                                attachPatchData(native, context), mpValue = context;
                                break;
                            }
                        }
                    }
                }
                var instance;
                return (mpValue || null);
            }(target);
            if (!context && throwOnNotFound) throw new Error("Invalid ng target");
            return context;
        }
        function isBrowserEvents(listener) {
            return "boolean" == typeof listener.useCapture;
        }
        function sortListeners(a, b) {
            return a.name == b.name ? 0 : a.name < b.name ? -1 : 1;
        }
        function LifecycleHooksFeature(component, def) {
            const rootTView = readPatchedLView(component)[TVIEW], dirIndex = rootTView.data.length - 1;
            registerPreOrderHooks(dirIndex, def, rootTView, -1, -1, -1), registerPostOrderHooks(rootTView, {
                directiveStart: dirIndex,
                directiveEnd: dirIndex + 1
            });
        }
        function ɵɵInheritDefinitionFeature(definition) {
            let superType = Object.getPrototypeOf(definition.type.prototype).constructor;
            for (;superType; ) {
                let superDef = void 0;
                if (isComponentDef(definition)) superDef = superType.ɵcmp || superType.ɵdir; else {
                    if (superType.ɵcmp) throw new Error("Directives cannot inherit Components");
                    superDef = superType.ɵdir;
                }
                if (superDef) {
                    const writeableDef = definition;
                    writeableDef.inputs = maybeUnwrapEmpty(definition.inputs), writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs), 
                    writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);
                    const superHostBindings = superDef.hostBindings;
                    superHostBindings && inheritHostBindings(definition, superHostBindings);
                    const superViewQuery = superDef.viewQuery, superContentQueries = superDef.contentQueries;
                    superViewQuery && inheritViewQuery(definition, superViewQuery), superContentQueries && inheritContentQueries(definition, superContentQueries), 
                    fillProperties(definition.inputs, superDef.inputs), fillProperties(definition.declaredInputs, superDef.declaredInputs), 
                    fillProperties(definition.outputs, superDef.outputs), definition.afterContentChecked = definition.afterContentChecked || superDef.afterContentChecked, 
                    definition.afterContentInit = definition.afterContentInit || superDef.afterContentInit, 
                    definition.afterViewChecked = definition.afterViewChecked || superDef.afterViewChecked, 
                    definition.afterViewInit = definition.afterViewInit || superDef.afterViewInit, definition.doCheck = definition.doCheck || superDef.doCheck, 
                    definition.onDestroy = definition.onDestroy || superDef.onDestroy, definition.onInit = definition.onInit || superDef.onInit;
                    const features = superDef.features;
                    if (features) for (let i = 0; i < features.length; i++) {
                        const feature = features[i];
                        feature && feature.ngInherit && feature(definition);
                    }
                }
                superType = Object.getPrototypeOf(superType);
            }
        }
        function maybeUnwrapEmpty(value) {
            return value === EMPTY_OBJ ? {} : value === EMPTY_ARRAY ? [] : value;
        }
        function inheritViewQuery(definition, superViewQuery) {
            const prevViewQuery = definition.viewQuery;
            definition.viewQuery = prevViewQuery ? (rf, ctx) => {
                superViewQuery(rf, ctx), prevViewQuery(rf, ctx);
            } : superViewQuery;
        }
        function inheritContentQueries(definition, superContentQueries) {
            const prevContentQueries = definition.contentQueries;
            definition.contentQueries = prevContentQueries ? (rf, ctx, directiveIndex) => {
                superContentQueries(rf, ctx, directiveIndex), prevContentQueries(rf, ctx, directiveIndex);
            } : superContentQueries;
        }
        function inheritHostBindings(definition, superHostBindings) {
            const prevHostBindings = definition.hostBindings;
            superHostBindings !== prevHostBindings && (definition.hostBindings = prevHostBindings ? (rf, ctx, elementIndex) => {
                superHostBindings(rf, ctx, elementIndex), prevHostBindings(rf, ctx, elementIndex);
            } : superHostBindings);
        }
        class SimpleChange {
            constructor(previousValue, currentValue, firstChange) {
                this.previousValue = previousValue, this.currentValue = currentValue, this.firstChange = firstChange;
            }
            isFirstChange() {
                return this.firstChange;
            }
        }
        function ɵɵNgOnChangesFeature() {
            return NgOnChangesFeatureImpl.ngInherit = !0, NgOnChangesFeatureImpl;
        }
        function NgOnChangesFeatureImpl(definition) {
            definition.type.prototype.ngOnChanges && (definition.setInput = ngOnChangesSetInput, 
            definition.onChanges = function() {
                const simpleChangesStore = getSimpleChangesStore(this), current = simpleChangesStore && simpleChangesStore.current;
                if (current) {
                    const previous = simpleChangesStore.previous;
                    if (previous === EMPTY_OBJ) simpleChangesStore.previous = current; else for (let key in current) previous[key] = current[key];
                    simpleChangesStore.current = null, this.ngOnChanges(current);
                }
            });
        }
        function ngOnChangesSetInput(instance, value, publicName, privateName) {
            const simpleChangesStore = getSimpleChangesStore(instance) || function(instance, store) {
                return instance[SIMPLE_CHANGES_STORE] = store;
            }(instance, {
                previous: EMPTY_OBJ,
                current: null
            }), current = simpleChangesStore.current || (simpleChangesStore.current = {}), previous = simpleChangesStore.previous, declaredName = this.declaredInputs[publicName], previousChange = previous[declaredName];
            current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ), 
            instance[privateName] = value;
        }
        const SIMPLE_CHANGES_STORE = "__ngSimpleChanges__";
        function getSimpleChangesStore(instance) {
            return instance[SIMPLE_CHANGES_STORE] || null;
        }
        function resolveProvider$1(provider, tInjectables, lInjectablesBlueprint, isComponent, isViewProvider) {
            if (provider = resolveForwardRef(provider), Array.isArray(provider)) for (let i = 0; i < provider.length; i++) resolveProvider$1(provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider); else {
                const lView = getLView(), tView = lView[TVIEW];
                let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide), providerFactory = providerToFactory(provider);
                const tNode = getPreviousOrParentTNode(), beginIndex = 65535 & tNode.providerIndexes, endIndex = tNode.directiveStart, cptViewProvidersCount = tNode.providerIndexes >> 16;
                if (provider.useClass || isTypeProvider(provider)) {
                    const ngOnDestroy = (provider.useClass || provider).prototype.ngOnDestroy;
                    ngOnDestroy && (tView.destroyHooks || (tView.destroyHooks = [])).push(tInjectables.length, ngOnDestroy);
                }
                if (isTypeProvider(provider) || !provider.multi) {
                    const factory = new NodeInjectorFactory(providerFactory, isViewProvider, ɵɵdirectiveInject), existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);
                    -1 == existingFactoryIndex ? (diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token), 
                    tInjectables.push(token), tNode.directiveStart++, tNode.directiveEnd++, isViewProvider && (tNode.providerIndexes += 65536), 
                    lInjectablesBlueprint.push(factory), lView.push(factory)) : (lInjectablesBlueprint[existingFactoryIndex] = factory, 
                    lView[existingFactoryIndex] = factory);
                } else {
                    const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex), existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount), doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex], doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];
                    if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {
                        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
                        const factory = function(factoryFn, index, isViewProvider, isComponent, f) {
                            const factory = new NodeInjectorFactory(factoryFn, isViewProvider, ɵɵdirectiveInject);
                            return factory.multi = [], factory.index = index, factory.componentProviders = 0, 
                            multiFactoryAdd(factory, f, isComponent && !isViewProvider), factory;
                        }(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory);
                        !isViewProvider && doesViewProvidersFactoryExist && (lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory), 
                        tInjectables.push(token), tNode.directiveStart++, tNode.directiveEnd++, isViewProvider && (tNode.providerIndexes += 65536), 
                        lInjectablesBlueprint.push(factory), lView.push(factory);
                    } else multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent);
                    !isViewProvider && isComponent && doesViewProvidersFactoryExist && lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;
                }
            }
        }
        function multiFactoryAdd(multiFactory, factory, isComponentProvider) {
            multiFactory.multi.push(factory), isComponentProvider && multiFactory.componentProviders++;
        }
        function indexOf(item, arr, begin, end) {
            for (let i = begin; i < end; i++) if (arr[i] === item) return i;
            return -1;
        }
        function multiProvidersFactoryResolver(_, tData, lData, tNode) {
            return multiResolve(this.multi, []);
        }
        function multiViewProvidersFactoryResolver(_, tData, lData, tNode) {
            const factories = this.multi;
            let result;
            if (this.providerFactory) {
                const componentCount = this.providerFactory.componentProviders, multiProviders = getNodeInjectable(tData, lData, this.providerFactory.index, tNode);
                multiResolve(factories, result = multiProviders.slice(0, componentCount));
                for (let i = componentCount; i < multiProviders.length; i++) result.push(multiProviders[i]);
            } else multiResolve(factories, result = []);
            return result;
        }
        function multiResolve(factories, result) {
            for (let i = 0; i < factories.length; i++) result.push((0, factories[i])());
            return result;
        }
        function ɵɵProvidersFeature(providers, viewProviders = []) {
            return definition => {
                definition.providersResolver = (def, processProvidersFn) => (function(def, providers, viewProviders) {
                    const tView = getLView()[TVIEW];
                    if (tView.firstCreatePass) {
                        const isComponent = isComponentDef(def);
                        resolveProvider$1(viewProviders, tView.data, tView.blueprint, isComponent, !0), 
                        resolveProvider$1(providers, tView.data, tView.blueprint, isComponent, !1);
                    }
                })(def, processProvidersFn ? processProvidersFn(providers) : providers, viewProviders);
            };
        }
        class ComponentRef {}
        class ComponentFactory {}
        const ERROR_COMPONENT = "ngComponent";
        class _NullComponentFactoryResolver {
            resolveComponentFactory(component) {
                throw function(component) {
                    const error = Error(`No component factory found for ${stringify(component)}. Did you add it to @NgModule.entryComponents?`);
                    return error[ERROR_COMPONENT] = component, error;
                }(component);
            }
        }
        let ComponentFactoryResolver = (() => {
            class ComponentFactoryResolver {}
            return ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver, ComponentFactoryResolver;
        })(), ElementRef = (() => {
            class ElementRef {
                constructor(nativeElement) {
                    this.nativeElement = nativeElement;
                }
            }
            return ElementRef.__NG_ELEMENT_ID__ = () => SWITCH_ELEMENT_REF_FACTORY(ElementRef), 
            ElementRef;
        })();
        const SWITCH_ELEMENT_REF_FACTORY = function(ElementRefToken) {
            return createElementRef(ElementRefToken, getPreviousOrParentTNode(), getLView());
        };
        class RendererFactory2 {}
        const RendererStyleFlags2 = function() {
            var RendererStyleFlags2 = {
                Important: 1,
                DashCase: 2
            };
            return RendererStyleFlags2[RendererStyleFlags2.Important] = "Important", RendererStyleFlags2[RendererStyleFlags2.DashCase] = "DashCase", 
            RendererStyleFlags2;
        }();
        let Renderer2 = (() => {
            class Renderer2 {}
            return Renderer2.__NG_ELEMENT_ID__ = () => SWITCH_RENDERER2_FACTORY(), Renderer2;
        })();
        const SWITCH_RENDERER2_FACTORY = function() {
            const lView = getLView(), nodeAtIndex = getComponentLViewByIndex(getPreviousOrParentTNode().index, lView);
            return function(view) {
                const renderer = view[RENDERER];
                if (isProceduralRenderer(renderer)) return renderer;
                throw new Error("Cannot inject Renderer2 when the application uses Renderer3!");
            }(isLView(nodeAtIndex) ? nodeAtIndex : lView);
        };
        let Sanitizer = (() => {
            class Sanitizer {}
            return Sanitizer.ɵprov = ɵɵdefineInjectable({
                token: Sanitizer,
                providedIn: "root",
                factory: () => null
            }), Sanitizer;
        })();
        class Version {
            constructor(full) {
                this.full = full, this.major = full.split(".")[0], this.minor = full.split(".")[1], 
                this.patch = full.split(".").slice(2).join(".");
            }
        }
        const VERSION = new Version("9.0.0-rc.2");
        class DefaultIterableDifferFactory {
            constructor() {}
            supports(obj) {
                return isListLikeIterable$1(obj);
            }
            create(trackByFn) {
                return new DefaultIterableDiffer(trackByFn);
            }
        }
        const trackByIdentity = (index, item) => item;
        class DefaultIterableDiffer {
            constructor(trackByFn) {
                this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, 
                this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, 
                this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, 
                this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = trackByFn || trackByIdentity;
            }
            forEachItem(fn) {
                let record;
                for (record = this._itHead; null !== record; record = record._next) fn(record);
            }
            forEachOperation(fn) {
                let nextIt = this._itHead, nextRemove = this._removalsHead, addRemoveOffset = 0, moveOffsets = null;
                for (;nextIt || nextRemove; ) {
                    const record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove, adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets), currentIndex = record.currentIndex;
                    if (record === nextRemove) addRemoveOffset--, nextRemove = nextRemove._nextRemoved; else if (nextIt = nextIt._next, 
                    null == record.previousIndex) addRemoveOffset++; else {
                        moveOffsets || (moveOffsets = []);
                        const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset, localCurrentIndex = currentIndex - addRemoveOffset;
                        if (localMovePreviousIndex != localCurrentIndex) {
                            for (let i = 0; i < localMovePreviousIndex; i++) {
                                const offset = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0, index = offset + i;
                                localCurrentIndex <= index && index < localMovePreviousIndex && (moveOffsets[i] = offset + 1);
                            }
                            moveOffsets[record.previousIndex] = localCurrentIndex - localMovePreviousIndex;
                        }
                    }
                    adjPreviousIndex !== currentIndex && fn(record, adjPreviousIndex, currentIndex);
                }
            }
            forEachPreviousItem(fn) {
                let record;
                for (record = this._previousItHead; null !== record; record = record._nextPrevious) fn(record);
            }
            forEachAddedItem(fn) {
                let record;
                for (record = this._additionsHead; null !== record; record = record._nextAdded) fn(record);
            }
            forEachMovedItem(fn) {
                let record;
                for (record = this._movesHead; null !== record; record = record._nextMoved) fn(record);
            }
            forEachRemovedItem(fn) {
                let record;
                for (record = this._removalsHead; null !== record; record = record._nextRemoved) fn(record);
            }
            forEachIdentityChange(fn) {
                let record;
                for (record = this._identityChangesHead; null !== record; record = record._nextIdentityChange) fn(record);
            }
            diff(collection) {
                if (null == collection && (collection = []), !isListLikeIterable$1(collection)) throw new Error(`Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`);
                return this.check(collection) ? this : null;
            }
            onDestroy() {}
            check(collection) {
                this._reset();
                let index, item, itemTrackBy, record = this._itHead, mayBeDirty = !1;
                if (Array.isArray(collection)) {
                    this.length = collection.length;
                    for (let index = 0; index < this.length; index++) itemTrackBy = this._trackByFn(index, item = collection[index]), 
                    null !== record && looseIdentical(record.trackById, itemTrackBy) ? (mayBeDirty && (record = this._verifyReinsertion(record, item, itemTrackBy, index)), 
                    looseIdentical(record.item, item) || this._addIdentityChange(record, item)) : (record = this._mismatch(record, item, itemTrackBy, index), 
                    mayBeDirty = !0), record = record._next;
                } else index = 0, function(obj, fn) {
                    if (Array.isArray(obj)) for (let i = 0; i < obj.length; i++) fn(obj[i]); else {
                        const iterator = obj[getSymbolIterator()]();
                        let item;
                        for (;!(item = iterator.next()).done; ) fn(item.value);
                    }
                }(collection, item => {
                    itemTrackBy = this._trackByFn(index, item), null !== record && looseIdentical(record.trackById, itemTrackBy) ? (mayBeDirty && (record = this._verifyReinsertion(record, item, itemTrackBy, index)), 
                    looseIdentical(record.item, item) || this._addIdentityChange(record, item)) : (record = this._mismatch(record, item, itemTrackBy, index), 
                    mayBeDirty = !0), record = record._next, index++;
                }), this.length = index;
                return this._truncate(record), this.collection = collection, this.isDirty;
            }
            get isDirty() {
                return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead;
            }
            _reset() {
                if (this.isDirty) {
                    let record, nextRecord;
                    for (record = this._previousItHead = this._itHead; null !== record; record = record._next) record._nextPrevious = record._next;
                    for (record = this._additionsHead; null !== record; record = record._nextAdded) record.previousIndex = record.currentIndex;
                    for (this._additionsHead = this._additionsTail = null, record = this._movesHead; null !== record; record = nextRecord) record.previousIndex = record.currentIndex, 
                    nextRecord = record._nextMoved;
                    this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, 
                    this._identityChangesHead = this._identityChangesTail = null;
                }
            }
            _mismatch(record, item, itemTrackBy, index) {
                let previousRecord;
                return null === record ? previousRecord = this._itTail : (previousRecord = record._prev, 
                this._remove(record)), null !== (record = null === this._linkedRecords ? null : this._linkedRecords.get(itemTrackBy, index)) ? (looseIdentical(record.item, item) || this._addIdentityChange(record, item), 
                this._moveAfter(record, previousRecord, index)) : null !== (record = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(itemTrackBy, null)) ? (looseIdentical(record.item, item) || this._addIdentityChange(record, item), 
                this._reinsertAfter(record, previousRecord, index)) : record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index), 
                record;
            }
            _verifyReinsertion(record, item, itemTrackBy, index) {
                let reinsertRecord = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(itemTrackBy, null);
                return null !== reinsertRecord ? record = this._reinsertAfter(reinsertRecord, record._prev, index) : record.currentIndex != index && (record.currentIndex = index, 
                this._addToMoves(record, index)), record;
            }
            _truncate(record) {
                for (;null !== record; ) {
                    const nextRecord = record._next;
                    this._addToRemovals(this._unlink(record)), record = nextRecord;
                }
                null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), 
                null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), 
                null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null);
            }
            _reinsertAfter(record, prevRecord, index) {
                null !== this._unlinkedRecords && this._unlinkedRecords.remove(record);
                const prev = record._prevRemoved, next = record._nextRemoved;
                return null === prev ? this._removalsHead = next : prev._nextRemoved = next, null === next ? this._removalsTail = prev : next._prevRemoved = prev, 
                this._insertAfter(record, prevRecord, index), this._addToMoves(record, index), record;
            }
            _moveAfter(record, prevRecord, index) {
                return this._unlink(record), this._insertAfter(record, prevRecord, index), this._addToMoves(record, index), 
                record;
            }
            _addAfter(record, prevRecord, index) {
                return this._insertAfter(record, prevRecord, index), this._additionsTail = null === this._additionsTail ? this._additionsHead = record : this._additionsTail._nextAdded = record, 
                record;
            }
            _insertAfter(record, prevRecord, index) {
                const next = null === prevRecord ? this._itHead : prevRecord._next;
                return record._next = next, record._prev = prevRecord, null === next ? this._itTail = record : next._prev = record, 
                null === prevRecord ? this._itHead = record : prevRecord._next = record, null === this._linkedRecords && (this._linkedRecords = new _DuplicateMap), 
                this._linkedRecords.put(record), record.currentIndex = index, record;
            }
            _remove(record) {
                return this._addToRemovals(this._unlink(record));
            }
            _unlink(record) {
                null !== this._linkedRecords && this._linkedRecords.remove(record);
                const prev = record._prev, next = record._next;
                return null === prev ? this._itHead = next : prev._next = next, null === next ? this._itTail = prev : next._prev = prev, 
                record;
            }
            _addToMoves(record, toIndex) {
                return record.previousIndex === toIndex ? record : (this._movesTail = null === this._movesTail ? this._movesHead = record : this._movesTail._nextMoved = record, 
                record);
            }
            _addToRemovals(record) {
                return null === this._unlinkedRecords && (this._unlinkedRecords = new _DuplicateMap), 
                this._unlinkedRecords.put(record), record.currentIndex = null, record._nextRemoved = null, 
                null === this._removalsTail ? (this._removalsTail = this._removalsHead = record, 
                record._prevRemoved = null) : (record._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = record), 
                record;
            }
            _addIdentityChange(record, item) {
                return record.item = item, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = record : this._identityChangesTail._nextIdentityChange = record, 
                record;
            }
        }
        class IterableChangeRecord_ {
            constructor(item, trackById) {
                this.item = item, this.trackById = trackById, this.currentIndex = null, this.previousIndex = null, 
                this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, 
                this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, 
                this._nextMoved = null, this._nextIdentityChange = null;
            }
        }
        class _DuplicateItemRecordList {
            constructor() {
                this._head = null, this._tail = null;
            }
            add(record) {
                null === this._head ? (this._head = this._tail = record, record._nextDup = null, 
                record._prevDup = null) : (this._tail._nextDup = record, record._prevDup = this._tail, 
                record._nextDup = null, this._tail = record);
            }
            get(trackById, atOrAfterIndex) {
                let record;
                for (record = this._head; null !== record; record = record._nextDup) if ((null === atOrAfterIndex || atOrAfterIndex <= record.currentIndex) && looseIdentical(record.trackById, trackById)) return record;
                return null;
            }
            remove(record) {
                const prev = record._prevDup, next = record._nextDup;
                return null === prev ? this._head = next : prev._nextDup = next, null === next ? this._tail = prev : next._prevDup = prev, 
                null === this._head;
            }
        }
        class _DuplicateMap {
            constructor() {
                this.map = new Map;
            }
            put(record) {
                const key = record.trackById;
                let duplicates = this.map.get(key);
                duplicates || (duplicates = new _DuplicateItemRecordList, this.map.set(key, duplicates)), 
                duplicates.add(record);
            }
            get(trackById, atOrAfterIndex) {
                const recordList = this.map.get(trackById);
                return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
            }
            remove(record) {
                const key = record.trackById;
                return this.map.get(key).remove(record) && this.map.delete(key), record;
            }
            get isEmpty() {
                return 0 === this.map.size;
            }
            clear() {
                this.map.clear();
            }
        }
        function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
            const previousIndex = item.previousIndex;
            if (null === previousIndex) return previousIndex;
            let moveOffset = 0;
            return moveOffsets && previousIndex < moveOffsets.length && (moveOffset = moveOffsets[previousIndex]), 
            previousIndex + addRemoveOffset + moveOffset;
        }
        class DefaultKeyValueDifferFactory {
            constructor() {}
            supports(obj) {
                return obj instanceof Map || isJsObject$1(obj);
            }
            create() {
                return new DefaultKeyValueDiffer;
            }
        }
        class DefaultKeyValueDiffer {
            constructor() {
                this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, 
                this._changesHead = null, this._changesTail = null, this._additionsHead = null, 
                this._additionsTail = null, this._removalsHead = null, this._removalsTail = null;
            }
            get isDirty() {
                return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead;
            }
            forEachItem(fn) {
                let record;
                for (record = this._mapHead; null !== record; record = record._next) fn(record);
            }
            forEachPreviousItem(fn) {
                let record;
                for (record = this._previousMapHead; null !== record; record = record._nextPrevious) fn(record);
            }
            forEachChangedItem(fn) {
                let record;
                for (record = this._changesHead; null !== record; record = record._nextChanged) fn(record);
            }
            forEachAddedItem(fn) {
                let record;
                for (record = this._additionsHead; null !== record; record = record._nextAdded) fn(record);
            }
            forEachRemovedItem(fn) {
                let record;
                for (record = this._removalsHead; null !== record; record = record._nextRemoved) fn(record);
            }
            diff(map) {
                if (map) {
                    if (!(map instanceof Map || isJsObject$1(map))) throw new Error(`Error trying to diff '${stringify(map)}'. Only maps and objects are allowed`);
                } else map = new Map;
                return this.check(map) ? this : null;
            }
            onDestroy() {}
            check(map) {
                this._reset();
                let insertBefore = this._mapHead;
                if (this._appendAfter = null, this._forEach(map, (value, key) => {
                    if (insertBefore && insertBefore.key === key) this._maybeAddToChanges(insertBefore, value), 
                    this._appendAfter = insertBefore, insertBefore = insertBefore._next; else {
                        const record = this._getOrCreateRecordForKey(key, value);
                        insertBefore = this._insertBeforeOrAppend(insertBefore, record);
                    }
                }), insertBefore) {
                    insertBefore._prev && (insertBefore._prev._next = null), this._removalsHead = insertBefore;
                    for (let record = insertBefore; null !== record; record = record._nextRemoved) record === this._mapHead && (this._mapHead = null), 
                    this._records.delete(record.key), record._nextRemoved = record._next, record.previousValue = record.currentValue, 
                    record.currentValue = null, record._prev = null, record._next = null;
                }
                return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), 
                this.isDirty;
            }
            _insertBeforeOrAppend(before, record) {
                if (before) {
                    const prev = before._prev;
                    return record._next = before, record._prev = prev, before._prev = record, prev && (prev._next = record), 
                    before === this._mapHead && (this._mapHead = record), this._appendAfter = before, 
                    before;
                }
                return this._appendAfter ? (this._appendAfter._next = record, record._prev = this._appendAfter) : this._mapHead = record, 
                this._appendAfter = record, null;
            }
            _getOrCreateRecordForKey(key, value) {
                if (this._records.has(key)) {
                    const record = this._records.get(key);
                    this._maybeAddToChanges(record, value);
                    const prev = record._prev, next = record._next;
                    return prev && (prev._next = next), next && (next._prev = prev), record._next = null, 
                    record._prev = null, record;
                }
                const record = new KeyValueChangeRecord_(key);
                return this._records.set(key, record), record.currentValue = value, this._addToAdditions(record), 
                record;
            }
            _reset() {
                if (this.isDirty) {
                    let record;
                    for (this._previousMapHead = this._mapHead, record = this._previousMapHead; null !== record; record = record._next) record._nextPrevious = record._next;
                    for (record = this._changesHead; null !== record; record = record._nextChanged) record.previousValue = record.currentValue;
                    for (record = this._additionsHead; null != record; record = record._nextAdded) record.previousValue = record.currentValue;
                    this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, 
                    this._removalsHead = null;
                }
            }
            _maybeAddToChanges(record, newValue) {
                looseIdentical(newValue, record.currentValue) || (record.previousValue = record.currentValue, 
                record.currentValue = newValue, this._addToChanges(record));
            }
            _addToAdditions(record) {
                null === this._additionsHead ? this._additionsHead = this._additionsTail = record : (this._additionsTail._nextAdded = record, 
                this._additionsTail = record);
            }
            _addToChanges(record) {
                null === this._changesHead ? this._changesHead = this._changesTail = record : (this._changesTail._nextChanged = record, 
                this._changesTail = record);
            }
            _forEach(obj, fn) {
                obj instanceof Map ? obj.forEach(fn) : Object.keys(obj).forEach(k => fn(obj[k], k));
            }
        }
        class KeyValueChangeRecord_ {
            constructor(key) {
                this.key = key, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, 
                this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, 
                this._nextChanged = null;
            }
        }
        let IterableDiffers = (() => {
            class IterableDiffers {
                constructor(factories) {
                    this.factories = factories;
                }
                static create(factories, parent) {
                    if (null != parent) {
                        const copied = parent.factories.slice();
                        factories = factories.concat(copied);
                    }
                    return new IterableDiffers(factories);
                }
                static extend(factories) {
                    return {
                        provide: IterableDiffers,
                        useFactory: parent => {
                            if (!parent) throw new Error("Cannot extend IterableDiffers without a parent injector");
                            return IterableDiffers.create(factories, parent);
                        },
                        deps: [ [ IterableDiffers, new SkipSelf, new Optional ] ]
                    };
                }
                find(iterable) {
                    const factory = this.factories.find(f => f.supports(iterable));
                    if (null != factory) return factory;
                    throw new Error(`Cannot find a differ supporting object '${iterable}' of type '${type = iterable, 
                    type.name || typeof type}'`);
                    var type;
                }
            }
            return IterableDiffers.ɵprov = ɵɵdefineInjectable({
                token: IterableDiffers,
                providedIn: "root",
                factory: () => new IterableDiffers([ new DefaultIterableDifferFactory ])
            }), IterableDiffers;
        })(), KeyValueDiffers = (() => {
            class KeyValueDiffers {
                constructor(factories) {
                    this.factories = factories;
                }
                static create(factories, parent) {
                    if (parent) {
                        const copied = parent.factories.slice();
                        factories = factories.concat(copied);
                    }
                    return new KeyValueDiffers(factories);
                }
                static extend(factories) {
                    return {
                        provide: KeyValueDiffers,
                        useFactory: parent => {
                            if (!parent) throw new Error("Cannot extend KeyValueDiffers without a parent injector");
                            return KeyValueDiffers.create(factories, parent);
                        },
                        deps: [ [ KeyValueDiffers, new SkipSelf, new Optional ] ]
                    };
                }
                find(kv) {
                    const factory = this.factories.find(f => f.supports(kv));
                    if (factory) return factory;
                    throw new Error(`Cannot find a differ supporting object '${kv}'`);
                }
            }
            return KeyValueDiffers.ɵprov = ɵɵdefineInjectable({
                token: KeyValueDiffers,
                providedIn: "root",
                factory: () => new KeyValueDiffers([ new DefaultKeyValueDifferFactory ])
            }), KeyValueDiffers;
        })();
        const keyValDiff = [ new DefaultKeyValueDifferFactory ], defaultIterableDiffers = new IterableDiffers([ new DefaultIterableDifferFactory ]), defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
        let TemplateRef = (() => {
            class TemplateRef {}
            return TemplateRef.__NG_ELEMENT_ID__ = () => SWITCH_TEMPLATE_REF_FACTORY(TemplateRef, ElementRef), 
            TemplateRef;
        })();
        const SWITCH_TEMPLATE_REF_FACTORY = function(TemplateRefToken, ElementRefToken) {
            return createTemplateRef(TemplateRefToken, ElementRefToken, getPreviousOrParentTNode(), getLView());
        };
        let ViewContainerRef = (() => {
            class ViewContainerRef {}
            return ViewContainerRef.__NG_ELEMENT_ID__ = () => SWITCH_VIEW_CONTAINER_REF_FACTORY(ViewContainerRef, ElementRef), 
            ViewContainerRef;
        })();
        const SWITCH_VIEW_CONTAINER_REF_FACTORY = function(ViewContainerRefToken, ElementRefToken) {
            return createContainerRef(ViewContainerRefToken, ElementRefToken, getPreviousOrParentTNode(), getLView());
        }, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
        function toRefArray(map) {
            const array = [];
            for (let nonMinified in map) map.hasOwnProperty(nonMinified) && array.push({
                propName: map[nonMinified],
                templateName: nonMinified
            });
            return array;
        }
        const SCHEDULER = new InjectionToken("SCHEDULER_TOKEN", {
            providedIn: "root",
            factory: () => defaultScheduler
        });
        class ComponentFactory$1 extends ComponentFactory {
            constructor(componentDef, ngModule) {
                super(), this.componentDef = componentDef, this.ngModule = ngModule, this.componentType = componentDef.type, 
                this.selector = componentDef.selectors[0][0] || "div", this.ngContentSelectors = componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [], 
                this.isBoundToModule = !!ngModule;
            }
            get inputs() {
                return toRefArray(this.componentDef.inputs);
            }
            get outputs() {
                return toRefArray(this.componentDef.outputs);
            }
            create(injector, projectableNodes, rootSelectorOrNode, ngModule) {
                const rootViewInjector = (ngModule = ngModule || this.ngModule) ? function(rootViewInjector, moduleInjector) {
                    return {
                        get: (token, notFoundValue, flags) => {
                            const value = rootViewInjector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);
                            return value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ? value : moduleInjector.get(token, notFoundValue, flags);
                        }
                    };
                }(injector, ngModule.injector) : injector, rendererFactory = rootViewInjector.get(RendererFactory2, domRendererFactory3), sanitizer = rootViewInjector.get(Sanitizer, null), hostRNode = rootSelectorOrNode ? function(rendererFactory, elementOrSelector, encapsulation) {
                    const renderer = rendererFactory.createRenderer(null, null);
                    if (isProceduralRenderer(renderer)) return renderer.selectRootElement(elementOrSelector, encapsulation === ViewEncapsulation$1.ShadowDom);
                    let rElement = "string" == typeof elementOrSelector ? renderer.querySelector(elementOrSelector) : elementOrSelector;
                    return rElement.textContent = "", rElement;
                }(rendererFactory, rootSelectorOrNode, this.componentDef.encapsulation) : elementCreate(this.selector, rendererFactory.createRenderer(null, this.componentDef), null), rootFlags = this.componentDef.onPush ? 576 : 528, isIsolated = "string" == typeof rootSelectorOrNode && /^#root-ng-internal-isolated-\d+/.test(rootSelectorOrNode), rootContext = {
                    components: [],
                    scheduler: defaultScheduler,
                    clean: CLEAN_PROMISE,
                    playerHandler: null,
                    flags: 0
                }, renderer = rendererFactory.createRenderer(hostRNode, this.componentDef);
                rootSelectorOrNode && hostRNode && (isProceduralRenderer(renderer) ? renderer.setAttribute(hostRNode, "ng-version", VERSION.full) : hostRNode.setAttribute("ng-version", VERSION.full));
                const rootTView = createTView(0, -1, null, 1, 0, null, null, null, null, null), rootLView = createLView(null, rootTView, rootContext, rootFlags, null, null, rendererFactory, renderer, sanitizer, rootViewInjector);
                let component, tElementNode;
                enterView(rootLView, null);
                try {
                    const componentView = function(rNode, def, rootView, rendererFactory, renderer, sanitizer) {
                        const tView = rootView[TVIEW];
                        rootView[0 + HEADER_OFFSET] = rNode;
                        const tNode = getOrCreateTNode(tView, null, 0, 3, null, null), componentView = createLView(rootView, getOrCreateTComponentView(def), null, def.onPush ? 64 : 16, rootView[HEADER_OFFSET], tNode, rendererFactory, renderer, void 0);
                        return tView.firstCreatePass && (diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), tView, def.type), 
                        markAsComponentHost(tView, tNode), initNodeFlags(tNode, rootView.length, 1)), addToViewTree(rootView, componentView), 
                        rootView[HEADER_OFFSET] = componentView;
                    }(hostRNode, this.componentDef, rootLView, rendererFactory, renderer);
                    tElementNode = getTNode(0, rootLView), projectableNodes && (tElementNode.projection = projectableNodes.map(nodesforSlot => Array.from(nodesforSlot))), 
                    component = function(componentView, componentDef, rootView, rootContext, hostFeatures) {
                        const tView = rootView[TVIEW], component = function(tView, lView, def) {
                            const rootTNode = getPreviousOrParentTNode();
                            tView.firstCreatePass && (def.providersResolver && def.providersResolver(def), generateExpandoInstructionBlock(tView, rootTNode, 1), 
                            baseResolveDirective(tView, lView, def));
                            const directive = getNodeInjectable(tView.data, lView, lView.length - 1, rootTNode);
                            attachPatchData(directive, lView);
                            const native = getNativeByTNode(rootTNode, lView);
                            return native && attachPatchData(native, lView), directive;
                        }(tView, rootView, componentDef);
                        rootContext.components.push(component), componentView[CONTEXT] = component, hostFeatures && hostFeatures.forEach(feature => feature(component, componentDef)), 
                        componentDef.contentQueries && componentDef.contentQueries(1, component, rootView.length - 1);
                        const rootTNode = getPreviousOrParentTNode();
                        return tView.firstCreatePass && componentDef.hostBindings && (setActiveHostElement(rootTNode.index - HEADER_OFFSET), 
                        incrementActiveDirectiveId(), invokeHostBindingsInCreationMode(componentDef, tView.expandoInstructions, component, rootTNode, tView.firstCreatePass), 
                        setActiveHostElement(null)), component;
                    }(componentView, this.componentDef, rootLView, rootContext, [ LifecycleHooksFeature ]), 
                    renderView(rootLView, rootTView, null);
                } finally {
                    leaveView();
                }
                const componentRef = new ComponentRef$1(this.componentType, component, createElementRef(ElementRef, tElementNode, rootLView), rootLView, tElementNode);
                return rootSelectorOrNode && !isIsolated || (componentRef.hostView._tViewNode.child = tElementNode), 
                componentRef;
            }
        }
        class ComponentRef$1 extends ComponentRef {
            constructor(componentType, instance, location, _rootLView, _tNode) {
                super(), this.location = location, this._rootLView = _rootLView, this._tNode = _tNode, 
                this.destroyCbs = [], this.instance = instance, this.hostView = this.changeDetectorRef = new RootViewRef(_rootLView), 
                this.hostView._tViewNode = function(tView, tParentNode, index, lView) {
                    let tNode = tView.node;
                    return null == tNode && (tView.node = tNode = createTNode(0, null, 2, -1, null, null)), 
                    lView[T_HOST] = tNode;
                }(_rootLView[TVIEW], 0, 0, _rootLView), this.componentType = componentType;
            }
            get injector() {
                return new NodeInjector(this._tNode, this._rootLView);
            }
            destroy() {
                this.destroyCbs && (this.destroyCbs.forEach(fn => fn()), this.destroyCbs = null, 
                !this.hostView.destroyed && this.hostView.destroy());
            }
            onDestroy(callback) {
                this.destroyCbs && this.destroyCbs.push(callback);
            }
        }
        const u = void 0;
        var localeEn = [ "en", [ [ "a", "p" ], [ "AM", "PM" ], u ], [ [ "AM", "PM" ], u, u ], [ [ "S", "M", "T", "W", "T", "F", "S" ], [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ] ], u, [ [ "J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D" ], [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ] ], u, [ [ "B", "A" ], [ "BC", "AD" ], [ "Before Christ", "Anno Domini" ] ], 0, [ 6, 0 ], [ "M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y" ], [ "h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz" ], [ "{1}, {0}", u, "{1} 'at' {0}", u ], [ ".", ",", ";", "%", "+", "-", "E", "×", "‰", "∞", "NaN", ":" ], [ "#,##0.###", "#,##0%", "¤#,##0.00", "#E0" ], "$", "US Dollar", {}, function(n) {
            let i = Math.floor(Math.abs(n)), v = n.toString().replace(/^[^.]*\.?/, "").length;
            return 1 === i && 0 === v ? 1 : 5;
        } ];
        let LOCALE_DATA = {};
        function registerLocaleData(data, localeId, extraData) {
            "string" != typeof localeId && (extraData = localeId, localeId = data[LocaleDataIndex.LocaleId]), 
            localeId = localeId.toLowerCase().replace(/_/g, "-"), LOCALE_DATA[localeId] = data, 
            extraData && (LOCALE_DATA[localeId][LocaleDataIndex.ExtraData] = extraData);
        }
        function findLocaleData(locale) {
            const normalizedLocale = function(locale) {
                return locale.toLowerCase().replace(/_/g, "-");
            }(locale);
            let match = getLocaleData(normalizedLocale);
            if (match) return match;
            const parentLocale = normalizedLocale.split("-")[0];
            if (match = getLocaleData(parentLocale)) return match;
            if ("en" === parentLocale) return localeEn;
            throw new Error(`Missing locale data for the locale "${locale}".`);
        }
        function getLocalePluralCase(locale) {
            return findLocaleData(locale)[LocaleDataIndex.PluralCase];
        }
        function getLocaleData(normalizedLocale) {
            return normalizedLocale in LOCALE_DATA || (LOCALE_DATA[normalizedLocale] = _global.ng && _global.ng.common && _global.ng.common.locales && _global.ng.common.locales[normalizedLocale]), 
            LOCALE_DATA[normalizedLocale];
        }
        const LocaleDataIndex = function() {
            var LocaleDataIndex = {
                LocaleId: 0,
                DayPeriodsFormat: 1,
                DayPeriodsStandalone: 2,
                DaysFormat: 3,
                DaysStandalone: 4,
                MonthsFormat: 5,
                MonthsStandalone: 6,
                Eras: 7,
                FirstDayOfWeek: 8,
                WeekendRange: 9,
                DateFormat: 10,
                TimeFormat: 11,
                DateTimeFormat: 12,
                NumberSymbols: 13,
                NumberFormats: 14,
                CurrencySymbol: 15,
                CurrencyName: 16,
                Currencies: 17,
                PluralCase: 18,
                ExtraData: 19
            };
            return LocaleDataIndex[LocaleDataIndex.LocaleId] = "LocaleId", LocaleDataIndex[LocaleDataIndex.DayPeriodsFormat] = "DayPeriodsFormat", 
            LocaleDataIndex[LocaleDataIndex.DayPeriodsStandalone] = "DayPeriodsStandalone", 
            LocaleDataIndex[LocaleDataIndex.DaysFormat] = "DaysFormat", LocaleDataIndex[LocaleDataIndex.DaysStandalone] = "DaysStandalone", 
            LocaleDataIndex[LocaleDataIndex.MonthsFormat] = "MonthsFormat", LocaleDataIndex[LocaleDataIndex.MonthsStandalone] = "MonthsStandalone", 
            LocaleDataIndex[LocaleDataIndex.Eras] = "Eras", LocaleDataIndex[LocaleDataIndex.FirstDayOfWeek] = "FirstDayOfWeek", 
            LocaleDataIndex[LocaleDataIndex.WeekendRange] = "WeekendRange", LocaleDataIndex[LocaleDataIndex.DateFormat] = "DateFormat", 
            LocaleDataIndex[LocaleDataIndex.TimeFormat] = "TimeFormat", LocaleDataIndex[LocaleDataIndex.DateTimeFormat] = "DateTimeFormat", 
            LocaleDataIndex[LocaleDataIndex.NumberSymbols] = "NumberSymbols", LocaleDataIndex[LocaleDataIndex.NumberFormats] = "NumberFormats", 
            LocaleDataIndex[LocaleDataIndex.CurrencySymbol] = "CurrencySymbol", LocaleDataIndex[LocaleDataIndex.CurrencyName] = "CurrencyName", 
            LocaleDataIndex[LocaleDataIndex.Currencies] = "Currencies", LocaleDataIndex[LocaleDataIndex.PluralCase] = "PluralCase", 
            LocaleDataIndex[LocaleDataIndex.ExtraData] = "ExtraData", LocaleDataIndex;
        }(), DEFAULT_LOCALE_ID = "en-US";
        let LOCALE_ID = DEFAULT_LOCALE_ID;
        function setLocaleId(localeId) {
            var msg;
            msg = "Expected localeId to be defined", null == localeId && function(msg) {
                throw new Error(`ASSERTION ERROR: ${msg}`);
            }(msg), "string" == typeof localeId && (LOCALE_ID = localeId.toLowerCase().replace(/_/g, "-"));
        }
        const modules = new Map, COMPONENT_FACTORY_RESOLVER = {
            provide: ComponentFactoryResolver,
            useClass: class extends ComponentFactoryResolver {
                constructor(ngModule) {
                    super(), this.ngModule = ngModule;
                }
                resolveComponentFactory(component) {
                    const componentDef = getComponentDef(component);
                    return new ComponentFactory$1(componentDef, this.ngModule);
                }
            },
            deps: [ NgModuleRef ]
        };
        class NgModuleRef$1 extends NgModuleRef {
            constructor(ngModuleType, _parent) {
                super(), this._parent = _parent, this._bootstrapComponents = [], this.injector = this, 
                this.destroyCbs = [];
                const ngModuleDef = getNgModuleDef(ngModuleType), ngLocaleIdDef = ngModuleType[NG_LOC_ID_DEF] || null;
                ngLocaleIdDef && setLocaleId(ngLocaleIdDef), this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap), 
                this._r3Injector = createInjector(ngModuleType, _parent, [ {
                    provide: NgModuleRef,
                    useValue: this
                }, COMPONENT_FACTORY_RESOLVER ], stringify(ngModuleType)), this.instance = this.get(ngModuleType);
            }
            get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, injectFlags = InjectFlags.Default) {
                return token === Injector || token === NgModuleRef || token === INJECTOR ? this : this._r3Injector.get(token, notFoundValue, injectFlags);
            }
            get componentFactoryResolver() {
                return this.get(ComponentFactoryResolver);
            }
            destroy() {
                const injector = this._r3Injector;
                !injector.destroyed && injector.destroy(), this.destroyCbs.forEach(fn => fn()), 
                this.destroyCbs = null;
            }
            onDestroy(callback) {
                this.destroyCbs.push(callback);
            }
        }
        class NgModuleFactory$1 extends NgModuleFactory {
            constructor(moduleType) {
                super(), this.moduleType = moduleType, null !== getNgModuleDef(moduleType) && function registerNgModuleType(ngModuleType) {
                    if (null !== ngModuleType.ɵmod.id) {
                        const id = ngModuleType.ɵmod.id;
                        (function(id, type, incoming) {
                            if (type && type !== incoming) throw new Error(`Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);
                        })(id, modules.get(id), ngModuleType), modules.set(id, ngModuleType);
                    }
                    let imports = ngModuleType.ɵmod.imports;
                    imports instanceof Function && (imports = imports()), imports && imports.forEach(i => registerNgModuleType(i));
                }(moduleType);
            }
            create(parentInjector) {
                return new NgModuleRef$1(this.moduleType, parentInjector);
            }
        }
        function ɵɵpureFunction1(slotOffset, pureFn, exp, thisArg) {
            const lView = getLView(), bindingIndex = getBindingRoot() + slotOffset;
            return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getBinding(lView, bindingIndex + 1);
        }
        function ɵɵpureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {
            const bindingIndex = getBindingRoot() + slotOffset, lView = getLView();
            return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getBinding(lView, bindingIndex + 2);
        }
        function ɵɵpipe(index, pipeName) {
            const tView = getLView()[TVIEW];
            let pipeDef;
            const adjustedIndex = index + HEADER_OFFSET;
            tView.firstCreatePass ? (pipeDef = function(name, registry) {
                if (registry) for (let i = registry.length - 1; i >= 0; i--) {
                    const pipeDef = registry[i];
                    if (name === pipeDef.name) return pipeDef;
                }
                throw new Error(`The pipe '${name}' could not be found!`);
            }(pipeName, tView.pipeRegistry), tView.data[adjustedIndex] = pipeDef, pipeDef.onDestroy && (tView.destroyHooks || (tView.destroyHooks = [])).push(adjustedIndex, pipeDef.onDestroy)) : pipeDef = tView.data[adjustedIndex];
            const pipeInstance = (pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type)))();
            return function(index, value) {
                const lView = getLView(), tView = lView[TVIEW], adjustedIndex = index + HEADER_OFFSET;
                adjustedIndex >= tView.data.length && (tView.data[adjustedIndex] = null, tView.blueprint[adjustedIndex] = null), 
                lView[adjustedIndex] = value;
            }(index, pipeInstance), pipeInstance;
        }
        function ɵɵpipeBind1(index, slotOffset, v1) {
            const lView = getLView(), pipeInstance = load(lView, index);
            return function(lView, newValue) {
                return WrappedValue.isWrapped(newValue) && (newValue = WrappedValue.unwrap(newValue), 
                lView[getBindingIndex()] = NO_CHANGE), newValue;
            }(lView, function(lView, index) {
                return lView[TVIEW].data[index + HEADER_OFFSET].pure;
            }(lView, index) ? ɵɵpureFunction1(slotOffset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1));
        }
        class EventEmitter extends rxjs__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(isAsync = !1) {
                super(), this.__isAsync = isAsync;
            }
            emit(value) {
                super.next(value);
            }
            subscribe(generatorOrNext, error, complete) {
                let schedulerFn, errorFn = err => null, completeFn = () => null;
                generatorOrNext && "object" == typeof generatorOrNext ? (schedulerFn = this.__isAsync ? value => {
                    setTimeout(() => generatorOrNext.next(value));
                } : value => {
                    generatorOrNext.next(value);
                }, generatorOrNext.error && (errorFn = this.__isAsync ? err => {
                    setTimeout(() => generatorOrNext.error(err));
                } : err => {
                    generatorOrNext.error(err);
                }), generatorOrNext.complete && (completeFn = this.__isAsync ? () => {
                    setTimeout(() => generatorOrNext.complete());
                } : () => {
                    generatorOrNext.complete();
                })) : (schedulerFn = this.__isAsync ? value => {
                    setTimeout(() => generatorOrNext(value));
                } : value => {
                    generatorOrNext(value);
                }, error && (errorFn = this.__isAsync ? err => {
                    setTimeout(() => error(err));
                } : err => {
                    error(err);
                }), complete && (completeFn = this.__isAsync ? () => {
                    setTimeout(() => complete());
                } : () => {
                    complete();
                }));
                const sink = super.subscribe(schedulerFn, errorFn, completeFn);
                return generatorOrNext instanceof rxjs__WEBPACK_IMPORTED_MODULE_1__.a && generatorOrNext.add(sink), 
                sink;
            }
        }
        function symbolIterator() {
            return this._results[getSymbolIterator()]();
        }
        class QueryList {
            constructor() {
                this.dirty = !0, this._results = [], this.changes = new EventEmitter, this.length = 0;
                const symbol = getSymbolIterator(), proto = QueryList.prototype;
                proto[symbol] || (proto[symbol] = symbolIterator);
            }
            map(fn) {
                return this._results.map(fn);
            }
            filter(fn) {
                return this._results.filter(fn);
            }
            find(fn) {
                return this._results.find(fn);
            }
            reduce(fn, init) {
                return this._results.reduce(fn, init);
            }
            forEach(fn) {
                this._results.forEach(fn);
            }
            some(fn) {
                return this._results.some(fn);
            }
            toArray() {
                return this._results.slice();
            }
            toString() {
                return this._results.toString();
            }
            reset(resultsTree) {
                this._results = function flatten(list, dst) {
                    void 0 === dst && (dst = list);
                    for (let i = 0; i < list.length; i++) {
                        let item = list[i];
                        Array.isArray(item) ? (dst === list && (dst = list.slice(0, i)), flatten(item, dst)) : dst !== list && dst.push(item);
                    }
                    return dst;
                }(resultsTree), this.dirty = !1, this.length = this._results.length, this.last = this._results[this.length - 1], 
                this.first = this._results[0];
            }
            notifyOnChanges() {
                this.changes.emit(this);
            }
            setDirty() {
                this.dirty = !0;
            }
            destroy() {
                this.changes.complete(), this.changes.unsubscribe();
            }
        }
        class LQuery_ {
            constructor(queryList) {
                this.queryList = queryList, this.matches = null;
            }
            clone() {
                return new LQuery_(this.queryList);
            }
            setDirty() {
                this.queryList.setDirty();
            }
        }
        class LQueries_ {
            constructor(queries = []) {
                this.queries = queries;
            }
            createEmbeddedView(tView) {
                const tQueries = tView.queries;
                if (null !== tQueries) {
                    const noOfInheritedQueries = null !== tView.contentQueries ? tView.contentQueries[0] : tQueries.length, viewLQueries = [];
                    for (let i = 0; i < noOfInheritedQueries; i++) {
                        const tQuery = tQueries.getByIndex(i);
                        viewLQueries.push(this.queries[tQuery.indexInDeclarationView].clone());
                    }
                    return new LQueries_(viewLQueries);
                }
                return null;
            }
            insertView(tView) {
                this.dirtyQueriesWithMatches(tView);
            }
            detachView(tView) {
                this.dirtyQueriesWithMatches(tView);
            }
            dirtyQueriesWithMatches(tView) {
                for (let i = 0; i < this.queries.length; i++) null !== getTQuery(tView, i).matches && this.queries[i].setDirty();
            }
        }
        class TQueryMetadata_ {
            constructor(predicate, descendants, isStatic, read = null) {
                this.predicate = predicate, this.descendants = descendants, this.isStatic = isStatic, 
                this.read = read;
            }
        }
        class TQueries_ {
            constructor(queries = []) {
                this.queries = queries;
            }
            elementStart(tView, tNode) {
                for (let i = 0; i < this.queries.length; i++) this.queries[i].elementStart(tView, tNode);
            }
            elementEnd(tNode) {
                for (let i = 0; i < this.queries.length; i++) this.queries[i].elementEnd(tNode);
            }
            embeddedTView(tNode) {
                let queriesForTemplateRef = null;
                for (let i = 0; i < this.length; i++) {
                    const childQueryIndex = null !== queriesForTemplateRef ? queriesForTemplateRef.length : 0, tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);
                    tqueryClone && (tqueryClone.indexInDeclarationView = i, null !== queriesForTemplateRef ? queriesForTemplateRef.push(tqueryClone) : queriesForTemplateRef = [ tqueryClone ]);
                }
                return null !== queriesForTemplateRef ? new TQueries_(queriesForTemplateRef) : null;
            }
            template(tView, tNode) {
                for (let i = 0; i < this.queries.length; i++) this.queries[i].template(tView, tNode);
            }
            getByIndex(index) {
                return this.queries[index];
            }
            get length() {
                return this.queries.length;
            }
            track(tquery) {
                this.queries.push(tquery);
            }
        }
        class TQuery_ {
            constructor(metadata, nodeIndex = -1) {
                this.metadata = metadata, this.matches = null, this.indexInDeclarationView = -1, 
                this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = nodeIndex;
            }
            elementStart(tView, tNode) {
                this.isApplyingToNode(tNode) && this.matchTNode(tView, tNode);
            }
            elementEnd(tNode) {
                this._declarationNodeIndex === tNode.index && (this._appliesToNextNode = !1);
            }
            template(tView, tNode) {
                this.elementStart(tView, tNode);
            }
            embeddedTView(tNode, childQueryIndex) {
                return this.isApplyingToNode(tNode) ? (this.crossesNgTemplate = !0, this.addMatch(-tNode.index, childQueryIndex), 
                new TQuery_(this.metadata)) : null;
            }
            isApplyingToNode(tNode) {
                return this._appliesToNextNode && !1 === this.metadata.descendants ? this._declarationNodeIndex === (tNode.parent ? tNode.parent.index : -1) : this._appliesToNextNode;
            }
            matchTNode(tView, tNode) {
                if (Array.isArray(this.metadata.predicate)) {
                    const localNames = this.metadata.predicate;
                    for (let i = 0; i < localNames.length; i++) this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, localNames[i]));
                } else {
                    const typePredicate = this.metadata.predicate;
                    typePredicate === TemplateRef ? 0 === tNode.type && this.matchTNodeWithReadOption(tView, tNode, -1) : this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, typePredicate, !1, !1));
                }
            }
            matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {
                if (null !== nodeMatchIdx) {
                    const read = this.metadata.read;
                    if (null !== read) if (read === ElementRef || read === ViewContainerRef || read === TemplateRef && 0 === tNode.type) this.addMatch(tNode.index, -2); else {
                        const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, !1, !1);
                        null !== directiveOrProviderIdx && this.addMatch(tNode.index, directiveOrProviderIdx);
                    } else this.addMatch(tNode.index, nodeMatchIdx);
                }
            }
            addMatch(tNodeIdx, matchIdx) {
                null === this.matches ? this.matches = [ tNodeIdx, matchIdx ] : this.matches.push(tNodeIdx, matchIdx);
            }
        }
        function getIdxOfMatchingSelector(tNode, selector) {
            const localNames = tNode.localNames;
            if (null !== localNames) for (let i = 0; i < localNames.length; i += 2) if (localNames[i] === selector) return localNames[i + 1];
            return null;
        }
        function createResultForNode(lView, tNode, matchingIdx, read) {
            return -1 === matchingIdx ? function(tNode, currentView) {
                return 3 === tNode.type || 4 === tNode.type ? createElementRef(ElementRef, tNode, currentView) : 0 === tNode.type ? createTemplateRef(TemplateRef, ElementRef, tNode, currentView) : null;
            }(tNode, lView) : -2 === matchingIdx ? function(lView, tNode, read) {
                return read === ElementRef ? createElementRef(ElementRef, tNode, lView) : read === TemplateRef ? createTemplateRef(TemplateRef, ElementRef, tNode, lView) : read === ViewContainerRef ? createContainerRef(ViewContainerRef, ElementRef, tNode, lView) : void 0;
            }(lView, tNode, read) : getNodeInjectable(lView[TVIEW].data, lView, matchingIdx, tNode);
        }
        function materializeViewResults(lView, tQuery, queryIndex) {
            const lQuery = lView[QUERIES].queries[queryIndex];
            if (null === lQuery.matches) {
                const tViewData = lView[TVIEW].data, tQueryMatches = tQuery.matches, result = [];
                for (let i = 0; i < tQueryMatches.length; i += 2) {
                    const matchedNodeIdx = tQueryMatches[i];
                    result.push(matchedNodeIdx < 0 ? null : createResultForNode(lView, tViewData[matchedNodeIdx], tQueryMatches[i + 1], tQuery.metadata.read));
                }
                lQuery.matches = result;
            }
            return lQuery.matches;
        }
        function ɵɵqueryRefresh(queryList) {
            const lView = getLView(), queryIndex = getCurrentQueryIndex();
            setCurrentQueryIndex(queryIndex + 1);
            const tQuery = getTQuery(lView[TVIEW], queryIndex);
            if (queryList.dirty && isCreationMode(lView) === tQuery.metadata.isStatic) {
                if (null === tQuery.matches) queryList.reset([]); else {
                    const result = tQuery.crossesNgTemplate ? function collectQueryResults(lView, queryIndex, result) {
                        const tQuery = lView[TVIEW].queries.getByIndex(queryIndex), tQueryMatches = tQuery.matches;
                        if (null !== tQueryMatches) {
                            const lViewResults = materializeViewResults(lView, tQuery, queryIndex);
                            for (let i = 0; i < tQueryMatches.length; i += 2) {
                                const tNodeIdx = tQueryMatches[i];
                                if (tNodeIdx > 0) result.push(lViewResults[i / 2]); else {
                                    const childQueryIndex = tQueryMatches[i + 1], declarationLContainer = lView[-tNodeIdx];
                                    for (let i = CONTAINER_HEADER_OFFSET; i < declarationLContainer.length; i++) {
                                        const embeddedLView = declarationLContainer[i];
                                        embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT] && collectQueryResults(embeddedLView, childQueryIndex, result);
                                    }
                                    if (null !== declarationLContainer[MOVED_VIEWS]) {
                                        const embeddedLViews = declarationLContainer[MOVED_VIEWS];
                                        for (let i = 0; i < embeddedLViews.length; i++) collectQueryResults(embeddedLViews[i], childQueryIndex, result);
                                    }
                                }
                            }
                        }
                        return result;
                    }(lView, queryIndex, []) : materializeViewResults(lView, tQuery, queryIndex);
                    queryList.reset(result), queryList.notifyOnChanges();
                }
                return !0;
            }
            return !1;
        }
        function ɵɵstaticViewQuery(predicate, descend, read) {
            viewQueryInternal(getLView(), predicate, descend, read, !0);
        }
        function ɵɵviewQuery(predicate, descend, read) {
            viewQueryInternal(getLView(), predicate, descend, read, !1);
        }
        function viewQueryInternal(lView, predicate, descend, read, isStatic) {
            const tView = lView[TVIEW];
            tView.firstCreatePass && (createTQuery(tView, new TQueryMetadata_(predicate, descend, isStatic, read), -1), 
            isStatic && (tView.staticViewQueries = !0)), createLQuery(lView);
        }
        function ɵɵcontentQuery(directiveIndex, predicate, descend, read) {
            contentQueryInternal(getLView(), predicate, descend, read, !1, getPreviousOrParentTNode(), directiveIndex);
        }
        function ɵɵstaticContentQuery(directiveIndex, predicate, descend, read) {
            contentQueryInternal(getLView(), predicate, descend, read, !0, getPreviousOrParentTNode(), directiveIndex);
        }
        function contentQueryInternal(lView, predicate, descend, read, isStatic, tNode, directiveIndex) {
            const tView = lView[TVIEW];
            tView.firstCreatePass && (createTQuery(tView, new TQueryMetadata_(predicate, descend, isStatic, read), tNode.index), 
            function(tView, directiveIndex) {
                const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);
                directiveIndex !== (tView.contentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1) && tViewContentQueries.push(tView.queries.length - 1, directiveIndex);
            }(tView, directiveIndex), isStatic && (tView.staticContentQueries = !0)), createLQuery(lView);
        }
        function ɵɵloadQuery() {
            return lView = getLView(), queryIndex = getCurrentQueryIndex(), lView[QUERIES].queries[queryIndex].queryList;
            var lView, queryIndex;
        }
        function createLQuery(lView) {
            const queryList = new QueryList;
            !function(lView, context, cleanupFn) {
                const lCleanup = getCleanup(lView);
                lCleanup.push(context), lView[TVIEW].firstCreatePass && getTViewCleanup(lView).push(cleanupFn, lCleanup.length - 1);
            }(lView, queryList, queryList.destroy), null === lView[QUERIES] && (lView[QUERIES] = new LQueries_), 
            lView[QUERIES].queries.push(new LQuery_(queryList));
        }
        function createTQuery(tView, metadata, nodeIndex) {
            null === tView.queries && (tView.queries = new TQueries_), tView.queries.track(new TQuery_(metadata, nodeIndex));
        }
        function getTQuery(tView, index) {
            return tView.queries.getByIndex(index);
        }
        function ɵɵtemplateRefExtractor(tNode, currentView) {
            return createTemplateRef(TemplateRef, ElementRef, tNode, currentView);
        }
        const APP_INITIALIZER = new InjectionToken("Application Initializer");
        let ApplicationInitStatus = (() => {
            class ApplicationInitStatus {
                constructor(appInits) {
                    this.appInits = appInits, this.initialized = !1, this.done = !1, this.donePromise = new Promise((res, rej) => {
                        this.resolve = res, this.reject = rej;
                    });
                }
                runInitializers() {
                    if (this.initialized) return;
                    const asyncInitPromises = [], complete = () => {
                        this.done = !0, this.resolve();
                    };
                    if (this.appInits) for (let i = 0; i < this.appInits.length; i++) {
                        const initResult = this.appInits[i]();
                        isPromise(initResult) && asyncInitPromises.push(initResult);
                    }
                    Promise.all(asyncInitPromises).then(() => {
                        complete();
                    }).catch(e => {
                        this.reject(e);
                    }), 0 === asyncInitPromises.length && complete(), this.initialized = !0;
                }
            }
            return ApplicationInitStatus.ɵfac = function(t) {
                return new (t || ApplicationInitStatus)(ɵɵinject(APP_INITIALIZER, 8));
            }, ApplicationInitStatus.ɵprov = ɵɵdefineInjectable({
                token: ApplicationInitStatus,
                factory: function(t) {
                    return ApplicationInitStatus.ɵfac(t);
                },
                providedIn: null
            }), ApplicationInitStatus;
        })();
        const APP_ID = new InjectionToken("AppId"), APP_ID_RANDOM_PROVIDER = {
            provide: APP_ID,
            useFactory: function() {
                return `${_randomChar()}${_randomChar()}${_randomChar()}`;
            },
            deps: []
        };
        function _randomChar() {
            return String.fromCharCode(97 + Math.floor(25 * Math.random()));
        }
        const PLATFORM_INITIALIZER = new InjectionToken("Platform Initializer"), PLATFORM_ID = new InjectionToken("Platform ID"), APP_BOOTSTRAP_LISTENER = new InjectionToken("appBootstrapListener");
        let Console = (() => {
            class Console {
                log(message) {
                    console.log(message);
                }
                warn(message) {
                    console.warn(message);
                }
            }
            return Console.ɵfac = function(t) {
                return new (t || Console);
            }, Console.ɵprov = ɵɵdefineInjectable({
                token: Console,
                factory: function(t) {
                    return Console.ɵfac(t);
                },
                providedIn: null
            }), Console;
        })();
        const LOCALE_ID$1 = new InjectionToken("LocaleId"), ivyEnabled = !0;
        class ModuleWithComponentFactories {
            constructor(ngModuleFactory, componentFactories) {
                this.ngModuleFactory = ngModuleFactory, this.componentFactories = componentFactories;
            }
        }
        const Compiler_compileModuleSync__POST_R3__ = function(moduleType) {
            return new NgModuleFactory$1(moduleType);
        }, Compiler_compileModuleSync = Compiler_compileModuleSync__POST_R3__, Compiler_compileModuleAsync = function(moduleType) {
            return Promise.resolve(Compiler_compileModuleSync__POST_R3__(moduleType));
        }, Compiler_compileModuleAndAllComponentsSync__POST_R3__ = function(moduleType) {
            const ngModuleFactory = Compiler_compileModuleSync__POST_R3__(moduleType), componentFactories = maybeUnwrapFn(getNgModuleDef(moduleType).declarations).reduce((factories, declaration) => {
                const componentDef = getComponentDef(declaration);
                return componentDef && factories.push(new ComponentFactory$1(componentDef)), factories;
            }, []);
            return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
        }, Compiler_compileModuleAndAllComponentsSync = Compiler_compileModuleAndAllComponentsSync__POST_R3__, Compiler_compileModuleAndAllComponentsAsync = function(moduleType) {
            return Promise.resolve(Compiler_compileModuleAndAllComponentsSync__POST_R3__(moduleType));
        };
        let Compiler = (() => {
            class Compiler {
                constructor() {
                    this.compileModuleSync = Compiler_compileModuleSync, this.compileModuleAsync = Compiler_compileModuleAsync, 
                    this.compileModuleAndAllComponentsSync = Compiler_compileModuleAndAllComponentsSync, 
                    this.compileModuleAndAllComponentsAsync = Compiler_compileModuleAndAllComponentsAsync;
                }
                clearCache() {}
                clearCacheFor(type) {}
                getModuleId(moduleType) {}
            }
            return Compiler.ɵfac = function(t) {
                return new (t || Compiler);
            }, Compiler.ɵprov = ɵɵdefineInjectable({
                token: Compiler,
                factory: function(t) {
                    return Compiler.ɵfac(t);
                },
                providedIn: null
            }), Compiler;
        })();
        const COMPILER_OPTIONS = new InjectionToken("compilerOptions");
        let trace, events;
        function detectWTF() {
            const wtf = _global.wtf;
            return !(!wtf || !(trace = wtf.trace) || (events = trace.events, 0));
        }
        const wtfEnabled = detectWTF();
        function noopScope(arg0, arg1) {
            return null;
        }
        const wtfCreateScope = wtfEnabled ? function(signature, flags = null) {
            return events.createScope(signature, flags);
        } : (signature, flags) => noopScope, wtfLeave = wtfEnabled ? function(scope, returnValue) {
            return trace.leaveScope(scope, returnValue), returnValue;
        } : (s, r) => r, promise = (() => Promise.resolve(0))();
        function scheduleMicroTask(fn) {
            "undefined" == typeof Zone ? promise.then(() => {
                fn && fn.apply(null, null);
            }) : Zone.current.scheduleMicroTask("scheduleMicrotask", fn);
        }
        class NgZone {
            constructor({enableLongStackTrace: enableLongStackTrace = !1, shouldCoalesceEventChangeDetection: shouldCoalesceEventChangeDetection = !1}) {
                if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, 
                this.onUnstable = new EventEmitter(!1), this.onMicrotaskEmpty = new EventEmitter(!1), 
                this.onStable = new EventEmitter(!1), this.onError = new EventEmitter(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js");
                Zone.assertZonePatched(), this._nesting = 0, this._outer = this._inner = Zone.current, 
                Zone.wtfZoneSpec && (this._inner = this._inner.fork(Zone.wtfZoneSpec)), Zone.TaskTrackingZoneSpec && (this._inner = this._inner.fork(new Zone.TaskTrackingZoneSpec)), 
                enableLongStackTrace && Zone.longStackTraceZoneSpec && (this._inner = this._inner.fork(Zone.longStackTraceZoneSpec)), 
                this.shouldCoalesceEventChangeDetection = shouldCoalesceEventChangeDetection, this.lastRequestAnimationFrameId = -1, 
                this.nativeRequestAnimationFrame = function() {
                    let nativeRequestAnimationFrame = _global.requestAnimationFrame, nativeCancelAnimationFrame = _global.cancelAnimationFrame;
                    if ("undefined" != typeof Zone && nativeRequestAnimationFrame && nativeCancelAnimationFrame) {
                        const unpatchedRequestAnimationFrame = nativeRequestAnimationFrame[Zone.__symbol__("OriginalDelegate")];
                        unpatchedRequestAnimationFrame && (nativeRequestAnimationFrame = unpatchedRequestAnimationFrame);
                        const unpatchedCancelAnimationFrame = nativeCancelAnimationFrame[Zone.__symbol__("OriginalDelegate")];
                        unpatchedCancelAnimationFrame && (nativeCancelAnimationFrame = unpatchedCancelAnimationFrame);
                    }
                    return {
                        nativeRequestAnimationFrame: nativeRequestAnimationFrame,
                        nativeCancelAnimationFrame: nativeCancelAnimationFrame
                    };
                }().nativeRequestAnimationFrame, function(zone) {
                    const maybeDelayChangeDetection = !!zone.shouldCoalesceEventChangeDetection && zone.nativeRequestAnimationFrame && (() => {
                        !function(zone) {
                            -1 === zone.lastRequestAnimationFrameId && (zone.lastRequestAnimationFrameId = zone.nativeRequestAnimationFrame.call(_global, () => {
                                zone.lastRequestAnimationFrameId = -1, updateMicroTaskStatus(zone), checkStable(zone);
                            }), updateMicroTaskStatus(zone));
                        }(zone);
                    });
                    zone._inner = zone._inner.fork({
                        name: "angular",
                        properties: {
                            isAngularZone: !0,
                            maybeDelayChangeDetection: maybeDelayChangeDetection
                        },
                        onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
                            try {
                                return onEnter(zone), delegate.invokeTask(target, task, applyThis, applyArgs);
                            } finally {
                                maybeDelayChangeDetection && "eventTask" === task.type && maybeDelayChangeDetection(), 
                                onLeave(zone);
                            }
                        },
                        onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
                            try {
                                return onEnter(zone), delegate.invoke(target, callback, applyThis, applyArgs, source);
                            } finally {
                                onLeave(zone);
                            }
                        },
                        onHasTask: (delegate, current, target, hasTaskState) => {
                            delegate.hasTask(target, hasTaskState), current === target && ("microTask" == hasTaskState.change ? (zone._hasPendingMicrotasks = hasTaskState.microTask, 
                            updateMicroTaskStatus(zone), checkStable(zone)) : "macroTask" == hasTaskState.change && (zone.hasPendingMacrotasks = hasTaskState.macroTask));
                        },
                        onHandleError: (delegate, current, target, error) => (delegate.handleError(target, error), 
                        zone.runOutsideAngular(() => zone.onError.emit(error)), !1)
                    });
                }(this);
            }
            static isInAngularZone() {
                return !0 === Zone.current.get("isAngularZone");
            }
            static assertInAngularZone() {
                if (!NgZone.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!");
            }
            static assertNotInAngularZone() {
                if (NgZone.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!");
            }
            run(fn, applyThis, applyArgs) {
                return this._inner.run(fn, applyThis, applyArgs);
            }
            runTask(fn, applyThis, applyArgs, name) {
                const zone = this._inner, task = zone.scheduleEventTask("NgZoneEvent: " + name, fn, EMPTY_PAYLOAD, noop$1, noop$1);
                try {
                    return zone.runTask(task, applyThis, applyArgs);
                } finally {
                    zone.cancelTask(task);
                }
            }
            runGuarded(fn, applyThis, applyArgs) {
                return this._inner.runGuarded(fn, applyThis, applyArgs);
            }
            runOutsideAngular(fn) {
                return this._outer.run(fn);
            }
        }
        function noop$1() {}
        const EMPTY_PAYLOAD = {};
        function checkStable(zone) {
            if (0 == zone._nesting && !zone.hasPendingMicrotasks && !zone.isStable) try {
                zone._nesting++, zone.onMicrotaskEmpty.emit(null);
            } finally {
                if (zone._nesting--, !zone.hasPendingMicrotasks) try {
                    zone.runOutsideAngular(() => zone.onStable.emit(null));
                } finally {
                    zone.isStable = !0;
                }
            }
        }
        function updateMicroTaskStatus(zone) {
            zone.hasPendingMicrotasks = !!(zone._hasPendingMicrotasks || zone.shouldCoalesceEventChangeDetection && -1 !== zone.lastRequestAnimationFrameId);
        }
        function onEnter(zone) {
            zone._nesting++, zone.isStable && (zone.isStable = !1, zone.onUnstable.emit(null));
        }
        function onLeave(zone) {
            zone._nesting--, checkStable(zone);
        }
        class NoopNgZone {
            constructor() {
                this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, 
                this.onUnstable = new EventEmitter, this.onMicrotaskEmpty = new EventEmitter, this.onStable = new EventEmitter, 
                this.onError = new EventEmitter;
            }
            run(fn, applyThis, applyArgs) {
                return fn.apply(applyThis, applyArgs);
            }
            runGuarded(fn, applyThis, applyArgs) {
                return fn.apply(applyThis, applyArgs);
            }
            runOutsideAngular(fn) {
                return fn();
            }
            runTask(fn, applyThis, applyArgs, name) {
                return fn.apply(applyThis, applyArgs);
            }
        }
        let Testability = (() => {
            class Testability {
                constructor(_ngZone) {
                    this._ngZone = _ngZone, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, 
                    this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), 
                    _ngZone.run(() => {
                        this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone");
                    });
                }
                _watchAngularEvents() {
                    this._ngZone.onUnstable.subscribe({
                        next: () => {
                            this._didWork = !0, this._isZoneStable = !1;
                        }
                    }), this._ngZone.runOutsideAngular(() => {
                        this._ngZone.onStable.subscribe({
                            next: () => {
                                NgZone.assertNotInAngularZone(), scheduleMicroTask(() => {
                                    this._isZoneStable = !0, this._runCallbacksIfReady();
                                });
                            }
                        });
                    });
                }
                increasePendingRequestCount() {
                    return this._pendingCount += 1, this._didWork = !0, this._pendingCount;
                }
                decreasePendingRequestCount() {
                    if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero");
                    return this._runCallbacksIfReady(), this._pendingCount;
                }
                isStable() {
                    return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks;
                }
                _runCallbacksIfReady() {
                    if (this.isStable()) scheduleMicroTask(() => {
                        for (;0 !== this._callbacks.length; ) {
                            let cb = this._callbacks.pop();
                            clearTimeout(cb.timeoutId), cb.doneCb(this._didWork);
                        }
                        this._didWork = !1;
                    }); else {
                        let pending = this.getPendingTasks();
                        this._callbacks = this._callbacks.filter(cb => !cb.updateCb || !cb.updateCb(pending) || (clearTimeout(cb.timeoutId), 
                        !1)), this._didWork = !0;
                    }
                }
                getPendingTasks() {
                    return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(t => ({
                        source: t.source,
                        creationLocation: t.creationLocation,
                        data: t.data
                    })) : [];
                }
                addCallback(cb, timeout, updateCb) {
                    let timeoutId = -1;
                    timeout && timeout > 0 && (timeoutId = setTimeout(() => {
                        this._callbacks = this._callbacks.filter(cb => cb.timeoutId !== timeoutId), cb(this._didWork, this.getPendingTasks());
                    }, timeout)), this._callbacks.push({
                        doneCb: cb,
                        timeoutId: timeoutId,
                        updateCb: updateCb
                    });
                }
                whenStable(doneCb, timeout, updateCb) {
                    if (updateCb && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');
                    this.addCallback(doneCb, timeout, updateCb), this._runCallbacksIfReady();
                }
                getPendingRequestCount() {
                    return this._pendingCount;
                }
                findProviders(using, provider, exactMatch) {
                    return [];
                }
            }
            return Testability.ɵfac = function(t) {
                return new (t || Testability)(ɵɵinject(NgZone));
            }, Testability.ɵprov = ɵɵdefineInjectable({
                token: Testability,
                factory: function(t) {
                    return Testability.ɵfac(t);
                },
                providedIn: null
            }), Testability;
        })(), TestabilityRegistry = (() => {
            class TestabilityRegistry {
                constructor() {
                    this._applications = new Map, _testabilityGetter.addToWindow(this);
                }
                registerApplication(token, testability) {
                    this._applications.set(token, testability);
                }
                unregisterApplication(token) {
                    this._applications.delete(token);
                }
                unregisterAllApplications() {
                    this._applications.clear();
                }
                getTestability(elem) {
                    return this._applications.get(elem) || null;
                }
                getAllTestabilities() {
                    return Array.from(this._applications.values());
                }
                getAllRootElements() {
                    return Array.from(this._applications.keys());
                }
                findTestabilityInTree(elem, findInAncestors = !0) {
                    return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
                }
            }
            return TestabilityRegistry.ɵfac = function(t) {
                return new (t || TestabilityRegistry);
            }, TestabilityRegistry.ɵprov = ɵɵdefineInjectable({
                token: TestabilityRegistry,
                factory: function(t) {
                    return TestabilityRegistry.ɵfac(t);
                },
                providedIn: null
            }), TestabilityRegistry;
        })();
        class _NoopGetTestability {
            addToWindow(registry) {}
            findTestabilityInTree(registry, elem, findInAncestors) {
                return null;
            }
        }
        function setTestabilityGetter(getter) {
            _testabilityGetter = getter;
        }
        let _platform, _testabilityGetter = new _NoopGetTestability, compileNgModuleFactory = function(injector, options, moduleType) {
            const moduleFactory = new NgModuleFactory$1(moduleType);
            if (0 === componentResourceResolutionQueue.size) return Promise.resolve(moduleFactory);
            const compilerProviders = function(parts) {
                const result = [];
                return parts.forEach(part => part && result.push(...part)), result;
            }(injector.get(COMPILER_OPTIONS, []).concat(options).map(o => o.providers));
            if (0 === compilerProviders.length) return Promise.resolve(moduleFactory);
            const compiler = function() {
                const globalNg = _global.ng;
                if (!globalNg || !globalNg.ɵcompilerFacade) throw new Error("Angular JIT compilation failed: '@angular/compiler' not loaded!\n  - JIT compilation is discouraged for production use-cases! Consider AOT mode instead.\n  - Did you bootstrap using '@angular/platform-browser-dynamic' or '@angular/platform-server'?\n  - Alternatively provide the compiler with 'import \"@angular/compiler\";' before bootstrapping.");
                return globalNg.ɵcompilerFacade;
            }(), resourceLoader = Injector.create({
                providers: compilerProviders
            }).get(compiler.ResourceLoader);
            return function(resourceResolver) {
                const componentResolved = [], urlMap = new Map;
                function cachedResourceResolve(url) {
                    let promise = urlMap.get(url);
                    if (!promise) {
                        const resp = resourceResolver(url);
                        urlMap.set(url, promise = resp.then(unwrapResponse));
                    }
                    return promise;
                }
                return componentResourceResolutionQueue.forEach((component, type) => {
                    const promises = [];
                    component.templateUrl && promises.push(cachedResourceResolve(component.templateUrl).then(template => {
                        component.template = template;
                    }));
                    const styleUrls = component.styleUrls, styles = component.styles || (component.styles = []), styleOffset = component.styles.length;
                    styleUrls && styleUrls.forEach((styleUrl, index) => {
                        styles.push(""), promises.push(cachedResourceResolve(styleUrl).then(style => {
                            styles[styleOffset + index] = style, styleUrls.splice(styleUrls.indexOf(styleUrl), 1), 
                            0 == styleUrls.length && (component.styleUrls = void 0);
                        }));
                    });
                    const fullyResolved = Promise.all(promises).then(() => (function(type) {
                        componentDefPendingResolution.delete(type);
                    })(type));
                    componentResolved.push(fullyResolved);
                }), componentResourceResolutionQueue = new Map, Promise.all(componentResolved).then(() => void 0);
            }(url => Promise.resolve(resourceLoader.get(url))).then(() => moduleFactory);
        }, publishDefaultGlobalUtils$1 = function() {}, isBoundToModule = function(cf) {
            return cf.isBoundToModule;
        };
        const ALLOW_MULTIPLE_PLATFORMS = new InjectionToken("AllowMultipleToken");
        class NgProbeToken {
            constructor(name, token) {
                this.name = name, this.token = token;
            }
        }
        function createPlatformFactory(parentPlatformFactory, name, providers = []) {
            const desc = `Platform: ${name}`, marker = new InjectionToken(desc);
            return (extraProviders = []) => {
                let platform = getPlatform();
                if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, !1)) if (parentPlatformFactory) parentPlatformFactory(providers.concat(extraProviders).concat({
                    provide: marker,
                    useValue: !0
                })); else {
                    const injectedProviders = providers.concat(extraProviders).concat({
                        provide: marker,
                        useValue: !0
                    }, {
                        provide: INJECTOR_SCOPE,
                        useValue: "platform"
                    });
                    !function(injector) {
                        if (_platform && !_platform.destroyed && !_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one.");
                        publishDefaultGlobalUtils$1(), _platform = injector.get(PlatformRef);
                        const inits = injector.get(PLATFORM_INITIALIZER, null);
                        inits && inits.forEach(init => init());
                    }(Injector.create({
                        providers: injectedProviders,
                        name: desc
                    }));
                }
                return function(requiredToken) {
                    const platform = getPlatform();
                    if (!platform) throw new Error("No platform exists!");
                    if (!platform.injector.get(requiredToken, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first.");
                    return platform;
                }(marker);
            };
        }
        function getPlatform() {
            return _platform && !_platform.destroyed ? _platform : null;
        }
        let PlatformRef = (() => {
            class PlatformRef {
                constructor(_injector) {
                    this._injector = _injector, this._modules = [], this._destroyListeners = [], this._destroyed = !1;
                }
                bootstrapModuleFactory(moduleFactory, options) {
                    const ngZone = (ngZoneEventCoalescing = options && options.ngZoneEventCoalescing || !1, 
                    "noop" === (ngZoneOption = options ? options.ngZone : void 0) ? new NoopNgZone : ("zone.js" === ngZoneOption ? void 0 : ngZoneOption) || new NgZone({
                        enableLongStackTrace: isDevMode(),
                        shouldCoalesceEventChangeDetection: ngZoneEventCoalescing
                    })), providers = [ {
                        provide: NgZone,
                        useValue: ngZone
                    } ];
                    var ngZoneOption, ngZoneEventCoalescing;
                    return ngZone.run(() => {
                        const ngZoneInjector = Injector.create({
                            providers: providers,
                            parent: this.injector,
                            name: moduleFactory.moduleType.name
                        }), moduleRef = moduleFactory.create(ngZoneInjector), exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
                        if (!exceptionHandler) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");
                        return ivyEnabled && setLocaleId(moduleRef.injector.get(LOCALE_ID$1, DEFAULT_LOCALE_ID) || DEFAULT_LOCALE_ID), 
                        moduleRef.onDestroy(() => remove(this._modules, moduleRef)), ngZone.runOutsideAngular(() => ngZone.onError.subscribe({
                            next: error => {
                                exceptionHandler.handleError(error);
                            }
                        })), function(errorHandler, ngZone, callback) {
                            try {
                                const result = callback();
                                return isPromise(result) ? result.catch(e => {
                                    throw ngZone.runOutsideAngular(() => errorHandler.handleError(e)), e;
                                }) : result;
                            } catch (e) {
                                throw ngZone.runOutsideAngular(() => errorHandler.handleError(e)), e;
                            }
                        }(exceptionHandler, ngZone, () => {
                            const initStatus = moduleRef.injector.get(ApplicationInitStatus);
                            return initStatus.runInitializers(), initStatus.donePromise.then(() => (this._moduleDoBootstrap(moduleRef), 
                            moduleRef));
                        });
                    });
                }
                bootstrapModule(moduleType, compilerOptions = []) {
                    const options = optionsReducer({}, compilerOptions);
                    return compileNgModuleFactory(this.injector, options, moduleType).then(moduleFactory => this.bootstrapModuleFactory(moduleFactory, options));
                }
                _moduleDoBootstrap(moduleRef) {
                    const appRef = moduleRef.injector.get(ApplicationRef);
                    if (moduleRef._bootstrapComponents.length > 0) moduleRef._bootstrapComponents.forEach(f => appRef.bootstrap(f)); else {
                        if (!moduleRef.instance.ngDoBootstrap) throw new Error(`The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. ` + "Please define one of these.");
                        moduleRef.instance.ngDoBootstrap(appRef);
                    }
                    this._modules.push(moduleRef);
                }
                onDestroy(callback) {
                    this._destroyListeners.push(callback);
                }
                get injector() {
                    return this._injector;
                }
                destroy() {
                    if (this._destroyed) throw new Error("The platform has already been destroyed!");
                    this._modules.slice().forEach(module => module.destroy()), this._destroyListeners.forEach(listener => listener()), 
                    this._destroyed = !0;
                }
                get destroyed() {
                    return this._destroyed;
                }
            }
            return PlatformRef.ɵfac = function(t) {
                return new (t || PlatformRef)(ɵɵinject(Injector));
            }, PlatformRef.ɵprov = ɵɵdefineInjectable({
                token: PlatformRef,
                factory: function(t) {
                    return PlatformRef.ɵfac(t);
                },
                providedIn: null
            }), PlatformRef;
        })();
        function optionsReducer(dst, objs) {
            return Array.isArray(objs) ? objs.reduce(optionsReducer, dst) : Object.assign(Object.assign({}, dst), objs);
        }
        let ApplicationRef = (() => {
            class ApplicationRef {
                constructor(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus) {
                    this._zone = _zone, this._console = _console, this._injector = _injector, this._exceptionHandler = _exceptionHandler, 
                    this._componentFactoryResolver = _componentFactoryResolver, this._initStatus = _initStatus, 
                    this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._enforceNoNewChanges = !1, 
                    this._stable = !0, this.componentTypes = [], this.components = [], this._enforceNoNewChanges = isDevMode(), 
                    this._zone.onMicrotaskEmpty.subscribe({
                        next: () => {
                            this._zone.run(() => {
                                this.tick();
                            });
                        }
                    });
                    const isCurrentlyStable = new rxjs__WEBPACK_IMPORTED_MODULE_2__.a(observer => {
                        this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, 
                        this._zone.runOutsideAngular(() => {
                            observer.next(this._stable), observer.complete();
                        });
                    }), isStable = new rxjs__WEBPACK_IMPORTED_MODULE_2__.a(observer => {
                        let stableSub;
                        this._zone.runOutsideAngular(() => {
                            stableSub = this._zone.onStable.subscribe(() => {
                                NgZone.assertNotInAngularZone(), scheduleMicroTask(() => {
                                    this._stable || this._zone.hasPendingMacrotasks || this._zone.hasPendingMicrotasks || (this._stable = !0, 
                                    observer.next(!0));
                                });
                            });
                        });
                        const unstableSub = this._zone.onUnstable.subscribe(() => {
                            NgZone.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => {
                                observer.next(!1);
                            }));
                        });
                        return (() => {
                            stableSub.unsubscribe(), unstableSub.unsubscribe();
                        });
                    });
                    this.isStable = Object(rxjs__WEBPACK_IMPORTED_MODULE_3__.a)(isCurrentlyStable, isStable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)()));
                }
                bootstrap(componentOrFactory, rootSelectorOrNode) {
                    if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");
                    let componentFactory;
                    componentFactory = componentOrFactory instanceof ComponentFactory ? componentOrFactory : this._componentFactoryResolver.resolveComponentFactory(componentOrFactory), 
                    this.componentTypes.push(componentFactory.componentType);
                    const ngModule = isBoundToModule(componentFactory) ? void 0 : this._injector.get(NgModuleRef), compRef = componentFactory.create(Injector.NULL, [], rootSelectorOrNode || componentFactory.selector, ngModule);
                    compRef.onDestroy(() => {
                        this._unloadComponent(compRef);
                    });
                    const testability = compRef.injector.get(Testability, null);
                    return testability && compRef.injector.get(TestabilityRegistry).registerApplication(compRef.location.nativeElement, testability), 
                    this._loadComponent(compRef), isDevMode() && this._console.log("Angular is running in the development mode. Call enableProdMode() to enable the production mode."), 
                    compRef;
                }
                tick() {
                    if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively");
                    const scope = ApplicationRef._tickScope();
                    try {
                        this._runningTick = !0;
                        for (let view of this._views) view.detectChanges();
                        if (this._enforceNoNewChanges) for (let view of this._views) view.checkNoChanges();
                    } catch (e) {
                        this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(e));
                    } finally {
                        this._runningTick = !1, wtfLeave(scope);
                    }
                }
                attachView(viewRef) {
                    const view = viewRef;
                    this._views.push(view), view.attachToAppRef(this);
                }
                detachView(viewRef) {
                    const view = viewRef;
                    remove(this._views, view), view.detachFromAppRef();
                }
                _loadComponent(componentRef) {
                    this.attachView(componentRef.hostView), this.tick(), this.components.push(componentRef), 
                    this._injector.get(APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners).forEach(listener => listener(componentRef));
                }
                _unloadComponent(componentRef) {
                    this.detachView(componentRef.hostView), remove(this.components, componentRef);
                }
                ngOnDestroy() {
                    this._views.slice().forEach(view => view.destroy());
                }
                get viewCount() {
                    return this._views.length;
                }
            }
            return ApplicationRef.ɵfac = function(t) {
                return new (t || ApplicationRef)(ɵɵinject(NgZone), ɵɵinject(Console), ɵɵinject(Injector), ɵɵinject(ErrorHandler), ɵɵinject(ComponentFactoryResolver), ɵɵinject(ApplicationInitStatus));
            }, ApplicationRef.ɵprov = ɵɵdefineInjectable({
                token: ApplicationRef,
                factory: function(t) {
                    return ApplicationRef.ɵfac(t);
                },
                providedIn: null
            }), ApplicationRef._tickScope = wtfCreateScope("ApplicationRef#tick()"), ApplicationRef;
        })();
        function remove(list, el) {
            const index = list.indexOf(el);
            index > -1 && list.splice(index, 1);
        }
        class NgModuleFactoryLoader {}
        const _SEPARATOR = "#", FACTORY_CLASS_SUFFIX = "NgFactory";
        class SystemJsNgModuleLoaderConfig {}
        const DEFAULT_CONFIG = {
            factoryPathPrefix: "",
            factoryPathSuffix: ".ngfactory"
        };
        let SystemJsNgModuleLoader = (() => {
            class SystemJsNgModuleLoader {
                constructor(_compiler, config) {
                    this._compiler = _compiler, this._config = config || DEFAULT_CONFIG;
                }
                load(path) {
                    return !ivyEnabled && this._compiler instanceof Compiler ? this.loadFactory(path) : this.loadAndCompile(path);
                }
                loadAndCompile(path) {
                    let [module, exportName] = path.split(_SEPARATOR);
                    return void 0 === exportName && (exportName = "default"), __webpack_require__("zn8P")(module).then(module => module[exportName]).then(type => checkNotEmpty(type, module, exportName)).then(type => this._compiler.compileModuleAsync(type));
                }
                loadFactory(path) {
                    let [module, exportName] = path.split(_SEPARATOR), factoryClassSuffix = FACTORY_CLASS_SUFFIX;
                    return void 0 === exportName && (exportName = "default", factoryClassSuffix = ""), 
                    __webpack_require__("zn8P")(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix).then(module => module[exportName + factoryClassSuffix]).then(factory => checkNotEmpty(factory, module, exportName));
                }
            }
            return SystemJsNgModuleLoader.ɵfac = function(t) {
                return new (t || SystemJsNgModuleLoader)(ɵɵinject(Compiler), ɵɵinject(SystemJsNgModuleLoaderConfig, 8));
            }, SystemJsNgModuleLoader.ɵprov = ɵɵdefineInjectable({
                token: SystemJsNgModuleLoader,
                factory: function(t) {
                    return SystemJsNgModuleLoader.ɵfac(t);
                },
                providedIn: null
            }), SystemJsNgModuleLoader;
        })();
        function checkNotEmpty(value, modulePath, exportName) {
            if (!value) throw new Error(`Cannot find '${exportName}' in '${modulePath}'`);
            return value;
        }
        class DebugNode__POST_R3__ {
            constructor(nativeNode) {
                this.nativeNode = nativeNode;
            }
            get parent() {
                const parent = this.nativeNode.parentNode;
                return parent ? new DebugElement__POST_R3__(parent) : null;
            }
            get injector() {
                return function(target) {
                    const context = loadLContext(target, !1);
                    return null === context ? Injector.NULL : new NodeInjector(context.lView[TVIEW].data[context.nodeIndex], context.lView);
                }(this.nativeNode);
            }
            get componentInstance() {
                const nativeElement = this.nativeNode;
                return nativeElement && (getComponent(nativeElement) || function(element) {
                    const context = loadLContext(element, !1);
                    if (null === context) return null;
                    let parent, lView = context.lView;
                    for (;null === lView[HOST] && (parent = getLViewParent(lView)); ) lView = parent;
                    return 512 & lView[FLAGS] ? null : lView[CONTEXT];
                }(nativeElement));
            }
            get context() {
                return getComponent(this.nativeNode) || function(element) {
                    if (!(element instanceof Node)) throw new Error("Expecting instance of DOM Node");
                    const context = loadLContext(element, !1);
                    return null === context ? null : context.lView[CONTEXT];
                }(this.nativeNode);
            }
            get listeners() {
                return function(element) {
                    if (!(element instanceof Node)) throw new Error("Expecting instance of DOM Node");
                    const lContext = loadLContext(element, !1);
                    if (null === lContext) return [];
                    const lView = lContext.lView, lCleanup = lView[CLEANUP], tCleanup = lView[TVIEW].cleanup, listeners = [];
                    if (tCleanup && lCleanup) for (let i = 0; i < tCleanup.length; ) {
                        const firstParam = tCleanup[i++], secondParam = tCleanup[i++];
                        if ("string" == typeof firstParam) {
                            const name = firstParam, listenerElement = unwrapRNode(lView[secondParam]), callback = lCleanup[tCleanup[i++]], useCaptureOrIndx = tCleanup[i++], useCapture = "boolean" == typeof useCaptureOrIndx ? useCaptureOrIndx : !(useCaptureOrIndx >= 0) && null;
                            element == listenerElement && listeners.push({
                                element: element,
                                name: name,
                                callback: callback,
                                useCapture: useCapture
                            });
                        }
                    }
                    return listeners.sort(sortListeners), listeners;
                }(this.nativeNode).filter(isBrowserEvents);
            }
            get references() {
                return function(target) {
                    const context = loadLContext(target, !1);
                    return null === context ? {} : (void 0 === context.localRefs && (context.localRefs = function(lView, nodeIndex) {
                        const tNode = lView[TVIEW].data[nodeIndex];
                        if (tNode && tNode.localNames) {
                            const result = {};
                            let localIndex = tNode.index + 1;
                            for (let i = 0; i < tNode.localNames.length; i += 2) result[tNode.localNames[i]] = lView[localIndex], 
                            localIndex++;
                            return result;
                        }
                        return null;
                    }(context.lView, context.nodeIndex)), context.localRefs || {});
                }(this.nativeNode);
            }
            get providerTokens() {
                return function(element) {
                    const context = loadLContext(element, !1);
                    if (null === context) return [];
                    const tView = context.lView[TVIEW], tNode = tView.data[context.nodeIndex], providerTokens = [], endIndex = tNode.directiveEnd;
                    for (let i = 65535 & tNode.providerIndexes; i < endIndex; i++) {
                        let value = tView.data[i];
                        void 0 !== (obj = value).type && void 0 !== obj.template && void 0 !== obj.declaredInputs && (value = value.type), 
                        providerTokens.push(value);
                    }
                    var obj;
                    return providerTokens;
                }(this.nativeNode);
            }
        }
        class DebugElement__POST_R3__ extends DebugNode__POST_R3__ {
            constructor(nativeNode) {
                super(nativeNode);
            }
            get nativeElement() {
                return this.nativeNode.nodeType == Node.ELEMENT_NODE ? this.nativeNode : null;
            }
            get name() {
                try {
                    const context = loadLContext(this.nativeNode);
                    return context.lView[TVIEW].data[context.nodeIndex].tagName;
                } catch (e) {
                    return this.nativeNode.nodeName;
                }
            }
            get properties() {
                const context = loadLContext(this.nativeNode, !1);
                if (null == context) return {};
                const lView = context.lView, tData = lView[TVIEW].data, properties = function(tNode, lView, tData) {
                    const properties = {};
                    let bindingIndexes = tNode.propertyBindings;
                    if (null !== bindingIndexes) for (let i = 0; i < bindingIndexes.length; i++) {
                        const bindingIndex = bindingIndexes[i], metadataParts = tData[bindingIndex].split(INTERPOLATION_DELIMITER), propertyName = metadataParts[0];
                        if (metadataParts.length > 1) {
                            let value = metadataParts[1];
                            for (let j = 1; j < metadataParts.length - 1; j++) value += renderStringify(lView[bindingIndex + j - 1]) + metadataParts[j + 1];
                            properties[propertyName] = value;
                        } else properties[propertyName] = lView[bindingIndex];
                    }
                    return properties;
                }(tData[context.nodeIndex], lView, tData), className = function(debugElement) {
                    const classes = debugElement.classes;
                    let output = "";
                    for (const className of Object.keys(classes)) classes[className] && (output = output ? output + ` ${className}` : className);
                    return output;
                }(this);
                return className && (properties.className = properties.className ? properties.className + ` ${className}` : className), 
                properties;
            }
            get attributes() {
                const attributes = {}, element = this.nativeElement;
                if (!element) return attributes;
                const context = loadLContext(element, !1);
                if (null == context) return {};
                const tNodeAttrs = context.lView[TVIEW].data[context.nodeIndex].attrs, lowercaseTNodeAttrs = [];
                if (tNodeAttrs) {
                    let i = 0;
                    for (;i < tNodeAttrs.length; ) {
                        const attrName = tNodeAttrs[i];
                        if ("string" != typeof attrName) break;
                        attributes[attrName] = tNodeAttrs[i + 1], lowercaseTNodeAttrs.push(attrName.toLowerCase()), 
                        i += 2;
                    }
                }
                const eAttrs = element.attributes;
                for (let i = 0; i < eAttrs.length; i++) {
                    const attr = eAttrs[i];
                    -1 === lowercaseTNodeAttrs.indexOf(attr.name) && (attributes[attr.name] = attr.value);
                }
                return attributes;
            }
            get styles() {
                return this.nativeElement && this.nativeElement.style ? this.nativeElement.style : {};
            }
            get classes() {
                if (!this._classesProxy) {
                    const element = this.nativeElement;
                    this._classesProxy = function(handler) {
                        const g = _global;
                        if (!g.Proxy) throw new Error("Proxy is not supported in this browser");
                        return new g.Proxy({}, handler);
                    }({
                        get: (target, prop) => !!element && element.classList.contains(prop),
                        set: (target, prop, value) => !!element && element.classList.toggle(prop, !!value),
                        ownKeys: () => element ? Array.from(element.classList).sort() : [],
                        getOwnPropertyDescriptor: k => ({
                            enumerable: !0,
                            configurable: !0
                        })
                    });
                }
                return this._classesProxy;
            }
            get childNodes() {
                const childNodes = this.nativeNode.childNodes, children = [];
                for (let i = 0; i < childNodes.length; i++) children.push(getDebugNode__POST_R3__(childNodes[i]));
                return children;
            }
            get children() {
                const nativeElement = this.nativeElement;
                if (!nativeElement) return [];
                const childNodes = nativeElement.children, children = [];
                for (let i = 0; i < childNodes.length; i++) children.push(getDebugNode__POST_R3__(childNodes[i]));
                return children;
            }
            query(predicate) {
                return this.queryAll(predicate)[0] || null;
            }
            queryAll(predicate) {
                const matches = [];
                return _queryAllR3(this, predicate, matches, !0), matches;
            }
            queryAllNodes(predicate) {
                const matches = [];
                return _queryAllR3(this, predicate, matches, !1), matches;
            }
            triggerEventHandler(eventName, eventObj) {
                const node = this.nativeNode, invokedListeners = [];
                this.listeners.forEach(listener => {
                    if (listener.name === eventName) {
                        const callback = listener.callback;
                        callback(eventObj), invokedListeners.push(callback);
                    }
                }), "function" == typeof node.eventListeners && node.eventListeners(eventName).forEach(listener => {
                    const unwrappedListener = listener(Function);
                    return -1 === invokedListeners.indexOf(unwrappedListener) && unwrappedListener(eventObj);
                });
            }
        }
        function _queryAllR3(parentElement, predicate, matches, elementsOnly) {
            const context = loadLContext(parentElement.nativeNode);
            _queryNodeChildrenR3(context.lView[TVIEW].data[context.nodeIndex], context.lView, predicate, matches, elementsOnly, parentElement.nativeNode);
        }
        function _queryNodeChildrenR3(tNode, lView, predicate, matches, elementsOnly, rootNativeNode) {
            const nativeNode = getNativeByTNodeOrNull(tNode, lView);
            if (3 === tNode.type || 4 === tNode.type) {
                if (_addQueryMatchR3(nativeNode, predicate, matches, elementsOnly, rootNativeNode), 
                isComponentHost(tNode)) {
                    const componentView = getComponentLViewByIndex(tNode.index, lView);
                    componentView && componentView[TVIEW].firstChild && _queryNodeChildrenR3(componentView[TVIEW].firstChild, componentView, predicate, matches, elementsOnly, rootNativeNode);
                } else tNode.child && _queryNodeChildrenR3(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode), 
                nativeNode && function _queryNativeNodeDescendants(parentNode, predicate, matches, elementsOnly) {
                    const nodes = parentNode.childNodes, length = nodes.length;
                    for (let i = 0; i < length; i++) {
                        const node = nodes[i], debugNode = getDebugNode$1(node);
                        debugNode && (elementsOnly && debugNode instanceof DebugElement__POST_R3__ && predicate(debugNode) && -1 === matches.indexOf(debugNode) ? matches.push(debugNode) : !elementsOnly && predicate(debugNode) && -1 === matches.indexOf(debugNode) && matches.push(debugNode), 
                        _queryNativeNodeDescendants(node, predicate, matches, elementsOnly));
                    }
                }(nativeNode, predicate, matches, elementsOnly);
                const nodeOrContainer = lView[tNode.index];
                isLContainer(nodeOrContainer) && _queryNodeChildrenInContainerR3(nodeOrContainer, predicate, matches, elementsOnly, rootNativeNode);
            } else if (0 === tNode.type) {
                const lContainer = lView[tNode.index];
                _addQueryMatchR3(lContainer[NATIVE], predicate, matches, elementsOnly, rootNativeNode), 
                _queryNodeChildrenInContainerR3(lContainer, predicate, matches, elementsOnly, rootNativeNode);
            } else if (1 === tNode.type) {
                const componentView = findComponentView(lView), head = componentView[T_HOST].projection[tNode.projection];
                if (Array.isArray(head)) for (let nativeNode of head) _addQueryMatchR3(nativeNode, predicate, matches, elementsOnly, rootNativeNode); else if (head) {
                    const nextLView = componentView[PARENT];
                    _queryNodeChildrenR3(nextLView[TVIEW].data[head.index], nextLView, predicate, matches, elementsOnly, rootNativeNode);
                }
            } else tNode.child && _queryNodeChildrenR3(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
            if (rootNativeNode !== nativeNode) {
                const nextTNode = 4 & tNode.flags ? tNode.projectionNext : tNode.next;
                nextTNode && _queryNodeChildrenR3(nextTNode, lView, predicate, matches, elementsOnly, rootNativeNode);
            }
        }
        function _queryNodeChildrenInContainerR3(lContainer, predicate, matches, elementsOnly, rootNativeNode) {
            for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
                const childView = lContainer[i];
                _queryNodeChildrenR3(childView[TVIEW].node, childView, predicate, matches, elementsOnly, rootNativeNode);
            }
        }
        function _addQueryMatchR3(nativeNode, predicate, matches, elementsOnly, rootNativeNode) {
            if (rootNativeNode !== nativeNode) {
                const debugNode = getDebugNode$1(nativeNode);
                if (!debugNode) return;
                elementsOnly && debugNode instanceof DebugElement__POST_R3__ && predicate(debugNode) && -1 === matches.indexOf(debugNode) ? matches.push(debugNode) : !elementsOnly && predicate(debugNode) && -1 === matches.indexOf(debugNode) && matches.push(debugNode);
            }
        }
        const NG_DEBUG_PROPERTY = "__ng_debug__";
        function getDebugNode__POST_R3__(nativeNode) {
            return nativeNode instanceof Node ? (nativeNode.hasOwnProperty(NG_DEBUG_PROPERTY) || (nativeNode[NG_DEBUG_PROPERTY] = nativeNode.nodeType == Node.ELEMENT_NODE ? new DebugElement__POST_R3__(nativeNode) : new DebugNode__POST_R3__(nativeNode)), 
            nativeNode[NG_DEBUG_PROPERTY]) : null;
        }
        const getDebugNode$1 = getDebugNode__POST_R3__, platformCore = createPlatformFactory(null, "core", [ {
            provide: PLATFORM_ID,
            useValue: "unknown"
        }, {
            provide: PlatformRef,
            deps: [ Injector ]
        }, {
            provide: TestabilityRegistry,
            deps: []
        }, {
            provide: Console,
            deps: []
        } ]), APPLICATION_MODULE_PROVIDERS = [ {
            provide: ApplicationRef,
            useClass: ApplicationRef,
            deps: [ NgZone, Console, Injector, ErrorHandler, ComponentFactoryResolver, ApplicationInitStatus ]
        }, {
            provide: SCHEDULER,
            deps: [ NgZone ],
            useFactory: function(ngZone) {
                let queue = [];
                return ngZone.onStable.subscribe(() => {
                    for (;queue.length; ) queue.pop()();
                }), function(fn) {
                    queue.push(fn);
                };
            }
        }, {
            provide: ApplicationInitStatus,
            useClass: ApplicationInitStatus,
            deps: [ [ new Optional, APP_INITIALIZER ] ]
        }, {
            provide: Compiler,
            useClass: Compiler,
            deps: []
        }, APP_ID_RANDOM_PROVIDER, {
            provide: IterableDiffers,
            useFactory: function() {
                return defaultIterableDiffers;
            },
            deps: []
        }, {
            provide: KeyValueDiffers,
            useFactory: function() {
                return defaultKeyValueDiffers;
            },
            deps: []
        }, {
            provide: LOCALE_ID$1,
            useFactory: function(locale) {
                return locale = locale || ivyEnabled && "undefined" != typeof $localize && $localize.locale || DEFAULT_LOCALE_ID, 
                ivyEnabled && setLocaleId(locale), locale;
            },
            deps: [ [ new Inject(LOCALE_ID$1), new Optional, new SkipSelf ] ]
        } ];
        let ApplicationModule = (() => {
            class ApplicationModule {
                constructor(appRef) {}
            }
            return ApplicationModule.ɵmod = ɵɵdefineNgModule({
                type: ApplicationModule
            }), ApplicationModule.ɵinj = ɵɵdefineInjector({
                factory: function(t) {
                    return new (t || ApplicationModule)(ɵɵinject(ApplicationRef));
                },
                providers: APPLICATION_MODULE_PROVIDERS
            }), ApplicationModule;
        })();
    