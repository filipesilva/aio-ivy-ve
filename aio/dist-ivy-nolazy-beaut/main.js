(window.webpackJsonp = window.webpackJsonp || []).push([ [ 2 ], {
    "+1zh": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var common = __webpack_require__("ofXK"), icon = __webpack_require__("NFeN"), Subject = __webpack_require__("XNiG"), combineLatest = __webpack_require__("itXk"), asap = __webpack_require__("7Hc7"), takeUntil = __webpack_require__("1G5W"), Observable = __webpack_require__("HDdC"), isNumeric = __webpack_require__("Y7HM");
        class SubscribeOnObservable_SubscribeOnObservable extends Observable.a {
            constructor(source, delayTime = 0, scheduler = asap.a) {
                super(), this.source = source, this.delayTime = delayTime, this.scheduler = scheduler, 
                (!Object(isNumeric.a)(delayTime) || delayTime < 0) && (this.delayTime = 0), scheduler && "function" == typeof scheduler.schedule || (this.scheduler = asap.a);
            }
            static create(source, delay = 0, scheduler = asap.a) {
                return new SubscribeOnObservable_SubscribeOnObservable(source, delay, scheduler);
            }
            static dispatch(arg) {
                const {source: source, subscriber: subscriber} = arg;
                return this.add(source.subscribe(subscriber));
            }
            _subscribe(subscriber) {
                return this.scheduler.schedule(SubscribeOnObservable_SubscribeOnObservable.dispatch, this.delayTime, {
                    source: this.source,
                    subscriber: subscriber
                });
            }
        }
        function subscribeOn(scheduler, delay = 0) {
            return function(source) {
                return source.lift(new subscribeOn_SubscribeOnOperator(scheduler, delay));
            };
        }
        class subscribeOn_SubscribeOnOperator {
            constructor(scheduler, delay) {
                this.scheduler = scheduler, this.delay = delay;
            }
            call(subscriber, source) {
                return new SubscribeOnObservable_SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
            }
        }
        var startWith = __webpack_require__("JX91"), core = __webpack_require__("fXoL"), scroll_service = __webpack_require__("Faly"), toc_service = __webpack_require__("TNhP");
        const _c0 = [ "tocItem" ];
        function TocComponent_div_0_div_1_Template(rf, ctx) {
            1 & rf && (core.Vb(0, "div", 7), core.Ec(1, " Contents "), core.Tb());
        }
        function TocComponent_div_0_button_2_Template(rf, ctx) {
            if (1 & rf) {
                const _r95 = core.Wb();
                core.Vb(0, "button", 8), core.cc("click", (function($event) {
                    return core.uc(_r95), core.gc(2).toggle(!1);
                })), core.Ec(1, " Contents "), core.Qb(2, "mat-icon", 9), core.Tb();
            }
            if (2 & rf) {
                const ctx_r91 = core.gc(2);
                core.Cb("aria-pressed", !ctx_r91.isCollapsed), core.Ab(2), core.Fb("collapsed", ctx_r91.isCollapsed);
            }
        }
        function TocComponent_div_0_ng_container_4_li_1_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "li", 11, 12), core.Qb(2, "a", 13), core.Tb()), 2 & rf) {
                const ctx_r100 = core.gc(), toc_r96 = ctx_r100.$implicit, i_r97 = ctx_r100.index, ctx_r98 = core.gc(2);
                core.Db(toc_r96.level), core.Fb("secondary", "EmbeddedExpandable" === ctx_r98.type && i_r97 >= ctx_r98.primaryMax), 
                core.Fb("active", i_r97 === ctx_r98.activeIndex), core.mc("title", toc_r96.title), 
                core.Ab(2), core.lc("href", toc_r96.href, core.wc)("innerHTML", toc_r96.content, core.vc);
            }
        }
        function TocComponent_div_0_ng_container_4_Template(rf, ctx) {
            if (1 & rf && (core.Sb(0), core.Cc(1, TocComponent_div_0_ng_container_4_li_1_Template, 3, 8, "li", 10), 
            core.Rb()), 2 & rf) {
                const toc_r96 = ctx.$implicit, ctx_r92 = core.gc(2);
                core.Ab(1), core.lc("ngIf", "Floating" === ctx_r92.type || "h1" !== toc_r96.level);
            }
        }
        function TocComponent_div_0_button_5_Template(rf, ctx) {
            if (1 & rf) {
                const _r102 = core.Wb();
                core.Vb(0, "button", 14), core.cc("click", (function($event) {
                    return core.uc(_r102), core.gc(2).toggle();
                })), core.Tb();
            }
            if (2 & rf) {
                const ctx_r93 = core.gc(2);
                core.Fb("collapsed", ctx_r93.isCollapsed), core.Cb("aria-pressed", !ctx_r93.isCollapsed);
            }
        }
        function TocComponent_div_0_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "div", 1), core.Cc(1, TocComponent_div_0_div_1_Template, 2, 0, "div", 2), 
            core.Cc(2, TocComponent_div_0_button_2_Template, 3, 2, "button", 3), core.Vb(3, "ul", 4), 
            core.Cc(4, TocComponent_div_0_ng_container_4_Template, 2, 1, "ng-container", 5), 
            core.Tb(), core.Cc(5, TocComponent_div_0_button_5_Template, 1, 2, "button", 6), 
            core.Tb()), 2 & rf) {
                const ctx_r89 = core.gc();
                core.Fb("collapsed", ctx_r89.isCollapsed), core.Ab(1), core.lc("ngIf", "EmbeddedSimple" === ctx_r89.type), 
                core.Ab(1), core.lc("ngIf", "EmbeddedExpandable" === ctx_r89.type), core.Ab(1), 
                core.Fb("embedded", "Floating" !== ctx_r89.type), core.Ab(1), core.lc("ngForOf", ctx_r89.tocList), 
                core.Ab(1), core.lc("ngIf", "EmbeddedExpandable" === ctx_r89.type);
            }
        }
        let toc_component_TocComponent = (() => {
            class TocComponent {
                constructor(scrollService, elementRef, tocService) {
                    this.scrollService = scrollService, this.tocService = tocService, this.activeIndex = null, 
                    this.type = "None", this.isCollapsed = !0, this.isEmbedded = !1, this.onDestroy = new Subject.a, 
                    this.primaryMax = 4, this.isEmbedded = -1 !== elementRef.nativeElement.className.indexOf("embedded");
                }
                ngOnInit() {
                    this.tocService.tocList.pipe(Object(takeUntil.a)(this.onDestroy)).subscribe(tocList => {
                        this.tocList = tocList;
                        const itemCount = function(array, fn) {
                            return array.reduce((result, item) => (item => "h1" !== item.level)(item) ? result + 1 : result, 0);
                        }(this.tocList);
                        this.type = itemCount > 0 ? this.isEmbedded ? itemCount > this.primaryMax ? "EmbeddedExpandable" : "EmbeddedSimple" : "Floating" : "None";
                    });
                }
                ngAfterViewInit() {
                    this.isEmbedded || Object(combineLatest.a)([ this.tocService.activeItemIndex.pipe(subscribeOn(asap.a)), this.items.changes.pipe(Object(startWith.a)(this.items)) ]).pipe(Object(takeUntil.a)(this.onDestroy)).subscribe(([index, items]) => {
                        if (this.activeIndex = index, null === index || index >= items.length) return;
                        const e = items.toArray()[index].nativeElement, p = e.offsetParent, eRect = e.getBoundingClientRect(), pRect = p.getBoundingClientRect();
                        eRect.top >= pRect.top && eRect.bottom <= pRect.bottom || (p.scrollTop += eRect.top - pRect.top - p.clientHeight / 2);
                    });
                }
                ngOnDestroy() {
                    this.onDestroy.next();
                }
                toggle(canScroll = !0) {
                    this.isCollapsed = !this.isCollapsed, canScroll && this.isCollapsed && this.toTop();
                }
                toTop() {
                    this.scrollService.scrollToTop();
                }
            }
            return TocComponent.ɵfac = function(t) {
                return new (t || TocComponent)(core.Pb(scroll_service.a), core.Pb(core.k), core.Pb(toc_service.a));
            }, TocComponent.ɵcmp = core.Jb({
                type: TocComponent,
                selectors: [ [ "aio-toc" ] ],
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && core.Jc(_c0, !0), 2 & rf && core.qc(_t = core.dc()) && (ctx.items = _t);
                },
                decls: 1,
                vars: 1,
                consts: [ [ "class", "toc-inner no-print", 3, "collapsed", 4, "ngIf" ], [ 1, "toc-inner", "no-print" ], [ "class", "toc-heading embedded", 4, "ngIf" ], [ "type", "button", "class", "toc-heading embedded secondary", "title", "Expand/collapse contents", "aria-label", "Expand/collapse contents", 3, "click", 4, "ngIf" ], [ 1, "toc-list" ], [ 4, "ngFor", "ngForOf" ], [ "type", "button", "class", "toc-more-items embedded material-icons", "title", "Expand/collapse contents", "aria-label", "Expand/collapse contents", 3, "collapsed", "click", 4, "ngIf" ], [ 1, "toc-heading", "embedded" ], [ "type", "button", "title", "Expand/collapse contents", "aria-label", "Expand/collapse contents", 1, "toc-heading", "embedded", "secondary", 3, "click" ], [ "svgIcon", "keyboard_arrow_right", 1, "rotating-icon" ], [ 3, "title", "class", "secondary", "active", 4, "ngIf" ], [ 3, "title" ], [ "tocItem", "" ], [ 3, "href", "innerHTML" ], [ "type", "button", "title", "Expand/collapse contents", "aria-label", "Expand/collapse contents", 1, "toc-more-items", "embedded", "material-icons", 3, "click" ] ],
                template: function(rf, ctx) {
                    1 & rf && core.Cc(0, TocComponent_div_0_Template, 6, 6, "div", 0), 2 & rf && core.lc("ngIf", "None" !== ctx.type);
                },
                directives: [ common.k, common.j, icon.a ],
                encapsulation: 2
            }), TocComponent;
        })();
        __webpack_require__.d(__webpack_exports__, "TocModule", (function() {
            return toc_module_TocModule;
        }));
        let toc_module_TocModule = (() => {
            class TocModule {
                constructor() {
                    this.customElementComponent = toc_component_TocComponent;
                }
            }
            return TocModule.ɵmod = core.Nb({
                type: TocModule
            }), TocModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || TocModule);
                },
                imports: [ [ common.c, icon.b ] ]
            }), TocModule;
        })();
    },
    "+rOU": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "d", (function() {
            return ComponentPortal;
        })), __webpack_require__.d(__webpack_exports__, "i", (function() {
            return TemplatePortal;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return BasePortalOutlet;
        })), __webpack_require__.d(__webpack_exports__, "e", (function() {
            return DomPortalOutlet;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return CdkPortal;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return CdkPortalOutlet;
        })), __webpack_require__.d(__webpack_exports__, "f", (function() {
            return PortalHostDirective;
        })), __webpack_require__.d(__webpack_exports__, "h", (function() {
            return PortalModule;
        })), __webpack_require__.d(__webpack_exports__, "g", (function() {
            return PortalInjector;
        }));
        var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("fXoL");
        function throwPortalAlreadyAttachedError() {
            throw Error("Host already has a portal attached");
        }
        class Portal {
            attach(host) {
                return null == host && function() {
                    throw Error("Attempting to attach a portal to a null PortalOutlet");
                }(), host.hasAttached() && throwPortalAlreadyAttachedError(), this._attachedHost = host, 
                host.attach(this);
            }
            detach() {
                let host = this._attachedHost;
                null == host ? function() {
                    throw Error("Attempting to detach a portal that is not attached to a host");
                }() : (this._attachedHost = null, host.detach());
            }
            get isAttached() {
                return null != this._attachedHost;
            }
            setAttachedHost(host) {
                this._attachedHost = host;
            }
        }
        class ComponentPortal extends Portal {
            constructor(component, viewContainerRef, injector, componentFactoryResolver) {
                super(), this.component = component, this.viewContainerRef = viewContainerRef, this.injector = injector, 
                this.componentFactoryResolver = componentFactoryResolver;
            }
        }
        class TemplatePortal extends Portal {
            constructor(template, viewContainerRef, context) {
                super(), this.templateRef = template, this.viewContainerRef = viewContainerRef, 
                this.context = context;
            }
            get origin() {
                return this.templateRef.elementRef;
            }
            attach(host, context = this.context) {
                return this.context = context, super.attach(host);
            }
            detach() {
                return this.context = void 0, super.detach();
            }
        }
        class BasePortalOutlet {
            constructor() {
                this._isDisposed = !1;
            }
            hasAttached() {
                return !!this._attachedPortal;
            }
            attach(portal) {
                return portal || function() {
                    throw Error("Must provide a portal to attach");
                }(), this.hasAttached() && throwPortalAlreadyAttachedError(), this._isDisposed && function() {
                    throw Error("This PortalOutlet has already been disposed");
                }(), portal instanceof ComponentPortal ? (this._attachedPortal = portal, this.attachComponentPortal(portal)) : portal instanceof TemplatePortal ? (this._attachedPortal = portal, 
                this.attachTemplatePortal(portal)) : void function() {
                    throw Error("Attempting to attach an unknown Portal type. BasePortalOutlet accepts either a ComponentPortal or a TemplatePortal.");
                }();
            }
            detach() {
                this._attachedPortal && (this._attachedPortal.setAttachedHost(null), this._attachedPortal = null), 
                this._invokeDisposeFn();
            }
            dispose() {
                this.hasAttached() && this.detach(), this._invokeDisposeFn(), this._isDisposed = !0;
            }
            setDisposeFn(fn) {
                this._disposeFn = fn;
            }
            _invokeDisposeFn() {
                this._disposeFn && (this._disposeFn(), this._disposeFn = null);
            }
        }
        class DomPortalOutlet extends BasePortalOutlet {
            constructor(outletElement, _componentFactoryResolver, _appRef, _defaultInjector) {
                super(), this.outletElement = outletElement, this._componentFactoryResolver = _componentFactoryResolver, 
                this._appRef = _appRef, this._defaultInjector = _defaultInjector;
            }
            attachComponentPortal(portal) {
                const componentFactory = (portal.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(portal.component);
                let componentRef;
                return portal.viewContainerRef ? (componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector), 
                this.setDisposeFn(() => componentRef.destroy())) : (componentRef = componentFactory.create(portal.injector || this._defaultInjector), 
                this._appRef.attachView(componentRef.hostView), this.setDisposeFn(() => {
                    this._appRef.detachView(componentRef.hostView), componentRef.destroy();
                })), this.outletElement.appendChild(this._getComponentRootNode(componentRef)), componentRef;
            }
            attachTemplatePortal(portal) {
                let viewContainer = portal.viewContainerRef, viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);
                return viewRef.detectChanges(), viewRef.rootNodes.forEach(rootNode => this.outletElement.appendChild(rootNode)), 
                this.setDisposeFn(() => {
                    let index = viewContainer.indexOf(viewRef);
                    -1 !== index && viewContainer.remove(index);
                }), viewRef;
            }
            dispose() {
                super.dispose(), null != this.outletElement.parentNode && this.outletElement.parentNode.removeChild(this.outletElement);
            }
            _getComponentRootNode(componentRef) {
                return componentRef.hostView.rootNodes[0];
            }
        }
        let CdkPortal = (() => {
            class CdkPortal extends TemplatePortal {
                constructor(templateRef, viewContainerRef) {
                    super(templateRef, viewContainerRef);
                }
            }
            return CdkPortal.ɵfac = function(t) {
                return new (t || CdkPortal)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.L), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.O));
            }, CdkPortal.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Kb({
                type: CdkPortal,
                selectors: [ [ "", "cdkPortal", "" ] ],
                exportAs: [ "cdkPortal" ],
                features: [ _angular_core__WEBPACK_IMPORTED_MODULE_0__.xb ]
            }), CdkPortal;
        })(), CdkPortalOutlet = (() => {
            class CdkPortalOutlet extends BasePortalOutlet {
                constructor(_componentFactoryResolver, _viewContainerRef) {
                    super(), this._componentFactoryResolver = _componentFactoryResolver, this._viewContainerRef = _viewContainerRef, 
                    this._isInitialized = !1, this.attached = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.m;
                }
                get portal() {
                    return this._attachedPortal;
                }
                set portal(portal) {
                    (!this.hasAttached() || portal || this._isInitialized) && (this.hasAttached() && super.detach(), 
                    portal && super.attach(portal), this._attachedPortal = portal);
                }
                get attachedRef() {
                    return this._attachedRef;
                }
                ngOnInit() {
                    this._isInitialized = !0;
                }
                ngOnDestroy() {
                    super.dispose(), this._attachedPortal = null, this._attachedRef = null;
                }
                attachComponentPortal(portal) {
                    portal.setAttachedHost(this);
                    const viewContainerRef = null != portal.viewContainerRef ? portal.viewContainerRef : this._viewContainerRef, componentFactory = (portal.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(portal.component), ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector);
                    return super.setDisposeFn(() => ref.destroy()), this._attachedPortal = portal, this._attachedRef = ref, 
                    this.attached.emit(ref), ref;
                }
                attachTemplatePortal(portal) {
                    portal.setAttachedHost(this);
                    const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);
                    return super.setDisposeFn(() => this._viewContainerRef.clear()), this._attachedPortal = portal, 
                    this._attachedRef = viewRef, this.attached.emit(viewRef), viewRef;
                }
            }
            return CdkPortalOutlet.ɵfac = function(t) {
                return new (t || CdkPortalOutlet)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.j), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.O));
            }, CdkPortalOutlet.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Kb({
                type: CdkPortalOutlet,
                selectors: [ [ "", "cdkPortalOutlet", "" ] ],
                inputs: {
                    portal: [ "cdkPortalOutlet", "portal" ]
                },
                outputs: {
                    attached: "attached"
                },
                exportAs: [ "cdkPortalOutlet" ],
                features: [ _angular_core__WEBPACK_IMPORTED_MODULE_0__.xb ]
            }), CdkPortalOutlet;
        })(), PortalHostDirective = (() => {
            class PortalHostDirective extends CdkPortalOutlet {}
            return PortalHostDirective.ɵfac = function(t) {
                return ɵPortalHostDirective_BaseFactory(t || PortalHostDirective);
            }, PortalHostDirective.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Kb({
                type: PortalHostDirective,
                selectors: [ [ "", "cdkPortalHost", "" ], [ "", "portalHost", "" ] ],
                inputs: {
                    portal: [ "cdkPortalHost", "portal" ]
                },
                exportAs: [ "cdkPortalHost" ],
                features: [ _angular_core__WEBPACK_IMPORTED_MODULE_0__.zb([ {
                    provide: CdkPortalOutlet,
                    useExisting: PortalHostDirective
                } ]), _angular_core__WEBPACK_IMPORTED_MODULE_0__.xb ]
            }), PortalHostDirective;
        })();
        const ɵPortalHostDirective_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Xb(PortalHostDirective);
        let PortalModule = (() => {
            class PortalModule {}
            return PortalModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Nb({
                type: PortalModule
            }), PortalModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Mb({
                factory: function(t) {
                    return new (t || PortalModule);
                }
            }), PortalModule;
        })();
        class PortalInjector {
            constructor(_parentInjector, _customTokens) {
                this._parentInjector = _parentInjector, this._customTokens = _customTokens;
            }
            get(token, notFoundValue) {
                const value = this._customTokens.get(token);
                return void 0 !== value ? value : this._parentInjector.get(token, notFoundValue);
            }
        }
    },
    "/ck9": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return CopierService;
        }));
        class CopierService {
            createFake(text) {
                const docElem = document.documentElement, isRTL = "rtl" === docElem.getAttribute("dir");
                this.fakeElem = document.createElement("textarea"), this.fakeElem.style.fontSize = "12pt", 
                this.fakeElem.style.border = "0", this.fakeElem.style.padding = "0", this.fakeElem.style.margin = "0", 
                this.fakeElem.style.position = "absolute", this.fakeElem.style[isRTL ? "right" : "left"] = "-9999px";
                const yPosition = window.pageYOffset || docElem.scrollTop;
                this.fakeElem.style.top = yPosition + "px", this.fakeElem.setAttribute("readonly", ""), 
                this.fakeElem.value = text, document.body.appendChild(this.fakeElem), this.fakeElem.select(), 
                this.fakeElem.setSelectionRange(0, this.fakeElem.value.length);
            }
            removeFake() {
                this.fakeElem && (document.body.removeChild(this.fakeElem), this.fakeElem = null);
            }
            copyText(text) {
                try {
                    return this.createFake(text), document.execCommand("copy");
                } catch (err) {
                    return !1;
                } finally {
                    this.removeFake();
                }
            }
        }
    },
    "/lUL": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return LocationService;
        }));
        var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("jtHE"), rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("lJxs"), rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("vkgz"), _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("fXoL"), app_shared_ga_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("4MUX"), _angular_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("ofXK"), _scroll_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("Faly"), app_sw_updates_sw_updates_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("iL+y");
        let LocationService = (() => {
            class LocationService {
                constructor(gaService, location, scrollService, platformLocation, swUpdates) {
                    this.gaService = gaService, this.location = location, this.scrollService = scrollService, 
                    this.platformLocation = platformLocation, this.urlParser = document.createElement("a"), 
                    this.urlSubject = new rxjs__WEBPACK_IMPORTED_MODULE_0__.a(1), this.swUpdateActivated = !1, 
                    this.currentUrl = this.urlSubject.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.a)(url => this.stripSlashes(url))), 
                    this.currentPath = this.currentUrl.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.a)(url => (url.match(/[^?#]*/) || [])[0]), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(path => this.gaService.locationChanged(path))), 
                    this.urlSubject.next(location.path(!0)), this.location.subscribe(state => this.urlSubject.next(state.url || "")), 
                    swUpdates.updateActivated.subscribe(() => this.swUpdateActivated = !0);
                }
                go(url) {
                    url && (url = this.stripSlashes(url), /^http/.test(url) ? this.goExternal(url) : this.swUpdateActivated ? (this.scrollService.removeStoredScrollInfo(), 
                    this.goExternal(url)) : (this.location.go(url), this.urlSubject.next(url)));
                }
                goExternal(url) {
                    window.location.assign(url);
                }
                replace(url) {
                    window.location.replace(url);
                }
                stripSlashes(url) {
                    return url.replace(/^\/+/, "").replace(/\/+(\?|#|$)/, "$1");
                }
                search() {
                    const search = {}, path = this.location.path(), q = path.indexOf("?");
                    if (q > -1) try {
                        path.substr(q + 1).split("&").forEach(p => {
                            const pair = p.split("=");
                            pair[0] && (search[decodeURIComponent(pair[0])] = pair[1] && decodeURIComponent(pair[1]));
                        });
                    } catch (e) {}
                    return search;
                }
                setSearch(label, params) {
                    const search = Object.keys(params).reduce((acc, key) => {
                        const value = params[key];
                        return void 0 === value ? acc : acc += (acc ? "&" : "?") + `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
                    }, "");
                    this.platformLocation.replaceState({}, label, this.platformLocation.pathname + search);
                }
                handleAnchorClick(anchor, button = 0, ctrlKey = !1, metaKey = !1) {
                    if (0 !== button || ctrlKey || metaKey) return !0;
                    const anchorTarget = anchor.target;
                    if (anchorTarget && "_self" !== anchorTarget) return !0;
                    if (null != anchor.getAttribute("download")) return !0;
                    const {pathname: pathname, search: search, hash: hash} = anchor, relativeUrl = pathname + search + hash;
                    return this.urlParser.href = relativeUrl, anchor.href !== this.urlParser.href || !/\/[^/.]*$/.test(pathname) || (this.go(relativeUrl), 
                    !1);
                }
            }
            return LocationService.ɵfac = function(t) {
                return new (t || LocationService)(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Zb(app_shared_ga_service__WEBPACK_IMPORTED_MODULE_4__.a), _angular_core__WEBPACK_IMPORTED_MODULE_3__.Zb(_angular_common__WEBPACK_IMPORTED_MODULE_5__.g), _angular_core__WEBPACK_IMPORTED_MODULE_3__.Zb(_scroll_service__WEBPACK_IMPORTED_MODULE_6__.a), _angular_core__WEBPACK_IMPORTED_MODULE_3__.Zb(_angular_common__WEBPACK_IMPORTED_MODULE_5__.q), _angular_core__WEBPACK_IMPORTED_MODULE_3__.Zb(app_sw_updates_sw_updates_service__WEBPACK_IMPORTED_MODULE_7__.a));
            }, LocationService.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_3__.Lb({
                token: LocationService,
                factory: function(t) {
                    return LocationService.ɵfac(t);
                },
                providedIn: null
            }), LocationService;
        })();
    },
    "/uUt": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return distinctUntilChanged;
        }));
        var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7o/Q");
        function distinctUntilChanged(compare, keySelector) {
            return source => source.lift(new DistinctUntilChangedOperator(compare, keySelector));
        }
        class DistinctUntilChangedOperator {
            constructor(compare, keySelector) {
                this.compare = compare, this.keySelector = keySelector;
            }
            call(subscriber, source) {
                return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
            }
        }
        class DistinctUntilChangedSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(destination, compare, keySelector) {
                super(destination), this.keySelector = keySelector, this.hasKey = !1, "function" == typeof compare && (this.compare = compare);
            }
            compare(x, y) {
                return x === y;
            }
            _next(value) {
                let key;
                try {
                    const {keySelector: keySelector} = this;
                    key = keySelector ? keySelector(value) : value;
                } catch (err) {
                    return this.destination.error(err);
                }
                let result = !1;
                if (this.hasKey) try {
                    const {compare: compare} = this;
                    result = compare(this.key, key);
                } catch (err) {
                    return this.destination.error(err);
                } else this.hasKey = !0;
                result || (this.key = key, this.destination.next(value));
            }
        }
    },
    0: function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__("zUnb");
    },
    "05l1": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return publishReplay;
        }));
        var _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("jtHE"), _multicast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("oB13");
        function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
            selectorOrScheduler && "function" != typeof selectorOrScheduler && (scheduler = selectorOrScheduler);
            const selector = "function" == typeof selectorOrScheduler ? selectorOrScheduler : void 0, subject = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__.a(bufferSize, windowTime, scheduler);
            return source => Object(_multicast__WEBPACK_IMPORTED_MODULE_1__.a)(() => subject, selector)(source);
        }
    },
    "0EUg": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return concatAll;
        }));
        var _mergeAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("bHdf");
        function concatAll() {
            return Object(_mergeAll__WEBPACK_IMPORTED_MODULE_0__.a)(1);
        }
    },
    "1G5W": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return takeUntil;
        }));
        var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("l7GE"), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("ZUHj");
        function takeUntil(notifier) {
            return source => source.lift(new TakeUntilOperator(notifier));
        }
        class TakeUntilOperator {
            constructor(notifier) {
                this.notifier = notifier;
            }
            call(subscriber, source) {
                const takeUntilSubscriber = new TakeUntilSubscriber(subscriber), notifierSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__.a)(takeUntilSubscriber, this.notifier);
                return notifierSubscription && !takeUntilSubscriber.seenValue ? (takeUntilSubscriber.add(notifierSubscription), 
                source.subscribe(takeUntilSubscriber)) : takeUntilSubscriber;
            }
        }
        class TakeUntilSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(destination) {
                super(destination), this.seenValue = !1;
            }
            notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.seenValue = !0, this.complete();
            }
            notifyComplete() {}
        }
    },
    "2QA8": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return rxSubscriber;
        }));
        const rxSubscriber = (() => "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random())();
    },
    "2fFW": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return config;
        }));
        let _enable_super_gross_mode_that_will_cause_bad_things = !1;
        const config = {
            Promise: void 0,
            set useDeprecatedSynchronousErrorHandling(value) {
                if (value) {
                    const error = new Error;
                    console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error.stack);
                } else _enable_super_gross_mode_that_will_cause_bad_things && console.log("RxJS: Back to a better error behavior. Thank you. <3");
                _enable_super_gross_mode_that_will_cause_bad_things = value;
            },
            get useDeprecatedSynchronousErrorHandling() {
                return _enable_super_gross_mode_that_will_cause_bad_things;
            }
        };
    },
    "3N8a": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        var Subscription = __webpack_require__("quSY");
        class Action_Action extends Subscription.a {
            constructor(scheduler, work) {
                super();
            }
            schedule(state, delay = 0) {
                return this;
            }
        }
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AsyncAction_AsyncAction;
        }));
        class AsyncAction_AsyncAction extends Action_Action {
            constructor(scheduler, work) {
                super(scheduler, work), this.scheduler = scheduler, this.work = work, this.pending = !1;
            }
            schedule(state, delay = 0) {
                if (this.closed) return this;
                this.state = state;
                const id = this.id, scheduler = this.scheduler;
                return null != id && (this.id = this.recycleAsyncId(scheduler, id, delay)), this.pending = !0, 
                this.delay = delay, this.id = this.id || this.requestAsyncId(scheduler, this.id, delay), 
                this;
            }
            requestAsyncId(scheduler, id, delay = 0) {
                return setInterval(scheduler.flush.bind(scheduler, this), delay);
            }
            recycleAsyncId(scheduler, id, delay = 0) {
                if (null !== delay && this.delay === delay && !1 === this.pending) return id;
                clearInterval(id);
            }
            execute(state, delay) {
                if (this.closed) return new Error("executing a cancelled action");
                this.pending = !1;
                const error = this._execute(state, delay);
                if (error) return error;
                !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
            }
            _execute(state, delay) {
                let errored = !1, errorValue = void 0;
                try {
                    this.work(state);
                } catch (e) {
                    errored = !0, errorValue = !!e && e || new Error(e);
                }
                if (errored) return this.unsubscribe(), errorValue;
            }
            _unsubscribe() {
                const id = this.id, scheduler = this.scheduler, actions = scheduler.actions, index = actions.indexOf(this);
                this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== index && actions.splice(index, 1), 
                null != id && (this.id = this.recycleAsyncId(scheduler, id, null)), this.delay = null;
            }
        }
    },
    "3UWI": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        var scheduler_async = __webpack_require__("D0XW"), OuterSubscriber = __webpack_require__("l7GE"), subscribeToResult = __webpack_require__("ZUHj");
        class AuditOperator {
            constructor(durationSelector) {
                this.durationSelector = durationSelector;
            }
            call(subscriber, source) {
                return source.subscribe(new audit_AuditSubscriber(subscriber, this.durationSelector));
            }
        }
        class audit_AuditSubscriber extends OuterSubscriber.a {
            constructor(destination, durationSelector) {
                super(destination), this.durationSelector = durationSelector, this.hasValue = !1;
            }
            _next(value) {
                if (this.value = value, this.hasValue = !0, !this.throttled) {
                    let duration;
                    try {
                        const {durationSelector: durationSelector} = this;
                        duration = durationSelector(value);
                    } catch (err) {
                        return this.destination.error(err);
                    }
                    const innerSubscription = Object(subscribeToResult.a)(this, duration);
                    !innerSubscription || innerSubscription.closed ? this.clearThrottle() : this.add(this.throttled = innerSubscription);
                }
            }
            clearThrottle() {
                const {value: value, hasValue: hasValue, throttled: throttled} = this;
                throttled && (this.remove(throttled), this.throttled = null, throttled.unsubscribe()), 
                hasValue && (this.value = null, this.hasValue = !1, this.destination.next(value));
            }
            notifyNext(outerValue, innerValue, outerIndex, innerIndex) {
                this.clearThrottle();
            }
            notifyComplete() {
                this.clearThrottle();
            }
        }
        var timer = __webpack_require__("PqYM");
        function auditTime(duration, scheduler = scheduler_async.a) {
            return durationSelector = () => Object(timer.a)(duration, scheduler), function(source) {
                return source.lift(new AuditOperator(durationSelector));
            };
            var durationSelector;
        }
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return auditTime;
        }));
    },
    "4I5i": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return ArgumentOutOfRangeError;
        }));
        const ArgumentOutOfRangeError = (() => {
            function ArgumentOutOfRangeErrorImpl() {
                return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", 
                this;
            }
            return ArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype), ArgumentOutOfRangeErrorImpl;
        })();
    },
    "4MUX": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return GaService;
        }));
        var _environments_environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("AytR"), app_shared_window__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("GvZq"), _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("fXoL");
        let GaService = (() => {
            class GaService {
                constructor(window) {
                    this.window = window, this.ga("create", _environments_environment__WEBPACK_IMPORTED_MODULE_0__.a.gaId, "auto");
                }
                locationChanged(url) {
                    this.sendPage(url);
                }
                sendPage(url) {
                    url !== this.previousUrl && (this.previousUrl = url, this.ga("set", "page", "/" + url), 
                    this.ga("send", "pageview"));
                }
                sendEvent(source, action, label, value) {
                    this.ga("send", "event", source, action, label, value);
                }
                ga(...args) {
                    const gaFn = this.window.ga;
                    gaFn && gaFn(...args);
                }
            }
            return GaService.ɵfac = function(t) {
                return new (t || GaService)(_angular_core__WEBPACK_IMPORTED_MODULE_2__.Zb(app_shared_window__WEBPACK_IMPORTED_MODULE_1__.a));
            }, GaService.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_2__.Lb({
                token: GaService,
                factory: function(t) {
                    return GaService.ɵfac(t);
                },
                providedIn: null
            }), GaService;
        })();
    },
    "5+tZ": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return mergeMap;
        }));
        var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ZUHj"), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("l7GE"), _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("51Dv"), _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("lJxs"), _observable_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("Cfvw");
        function mergeMap(project, resultSelector, concurrent = Number.POSITIVE_INFINITY) {
            return "function" == typeof resultSelector ? source => source.pipe(mergeMap((a, i) => Object(_observable_from__WEBPACK_IMPORTED_MODULE_4__.a)(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_3__.a)((b, ii) => resultSelector(a, b, i, ii))), concurrent)) : ("number" == typeof resultSelector && (concurrent = resultSelector), 
            source => source.lift(new MergeMapOperator(project, concurrent)));
        }
        class MergeMapOperator {
            constructor(project, concurrent = Number.POSITIVE_INFINITY) {
                this.project = project, this.concurrent = concurrent;
            }
            call(observer, source) {
                return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
            }
        }
        class MergeMapSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__.a {
            constructor(destination, project, concurrent = Number.POSITIVE_INFINITY) {
                super(destination), this.project = project, this.concurrent = concurrent, this.hasCompleted = !1, 
                this.buffer = [], this.active = 0, this.index = 0;
            }
            _next(value) {
                this.active < this.concurrent ? this._tryNext(value) : this.buffer.push(value);
            }
            _tryNext(value) {
                let result;
                const index = this.index++;
                try {
                    result = this.project(value, index);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.active++, this._innerSub(result, value, index);
            }
            _innerSub(ish, value, index) {
                const innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__.a(this, void 0, void 0);
                this.destination.add(innerSubscriber), Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_0__.a)(this, ish, value, index, innerSubscriber);
            }
            _complete() {
                this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), 
                this.unsubscribe();
            }
            notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }
            notifyComplete(innerSub) {
                const buffer = this.buffer;
                this.remove(innerSub), this.active--, buffer.length > 0 ? this._next(buffer.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete();
            }
        }
    },
    "51Dv": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return InnerSubscriber;
        }));
        var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7o/Q");
        class InnerSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(parent, outerValue, outerIndex) {
                super(), this.parent = parent, this.outerValue = outerValue, this.outerIndex = outerIndex, 
                this.index = 0;
            }
            _next(value) {
                this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
            }
            _error(error) {
                this.parent.notifyError(error, this), this.unsubscribe();
            }
            _complete() {
                this.parent.notifyComplete(this), this.unsubscribe();
            }
        }
    },
    "5UAH": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var common = __webpack_require__("ofXK"), http = __webpack_require__("tk/3"), shared_module = __webpack_require__("PCNd"), catchError = __webpack_require__("JIr8"), map = __webpack_require__("lJxs"), document_service = __webpack_require__("jn67"), core = __webpack_require__("fXoL"), logger_service = __webpack_require__("vHPH");
        function AnnouncementBarComponent_div_0_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "div", 1), core.Vb(1, "div", 2), core.Qb(2, "img", 3), 
            core.Qb(3, "p", 4), core.Vb(4, "a", 5), core.Ec(5, "Learn More"), core.Tb(), core.Tb(), 
            core.Tb()), 2 & rf) {
                const ctx_r52 = core.gc();
                core.Ab(2), core.lc("src", ctx_r52.announcement.imageUrl, core.wc), core.Ab(1), 
                core.lc("innerHTML", ctx_r52.announcement.message, core.vc), core.Ab(1), core.lc("href", ctx_r52.announcement.linkUrl, core.wc);
            }
        }
        const announcementsPath = document_service.a + "announcements.json";
        let announcement_bar_component_AnnouncementBarComponent = (() => {
            class AnnouncementBarComponent {
                constructor(http, logger) {
                    this.http = http, this.logger = logger;
                }
                ngOnInit() {
                    this.http.get(announcementsPath).pipe(Object(catchError.a)(error => (this.logger.error(new Error(`${announcementsPath} request failed: ${error.message}`)), 
                    [])), Object(map.a)(announcements => this.findCurrentAnnouncement(announcements)), Object(catchError.a)(error => (this.logger.error(new Error(`${announcementsPath} contains invalid data: ${error.message}`)), 
                    []))).subscribe(announcement => this.announcement = announcement);
                }
                findCurrentAnnouncement(announcements) {
                    return announcements.filter(announcement => new Date(announcement.startDate).valueOf() < Date.now()).filter(announcement => new Date(announcement.endDate).valueOf() > Date.now())[0];
                }
            }
            return AnnouncementBarComponent.ɵfac = function(t) {
                return new (t || AnnouncementBarComponent)(core.Pb(http.a), core.Pb(logger_service.a));
            }, AnnouncementBarComponent.ɵcmp = core.Jb({
                type: AnnouncementBarComponent,
                selectors: [ [ "aio-announcement-bar" ] ],
                decls: 1,
                vars: 1,
                consts: [ [ "class", "homepage-container", 4, "ngIf" ], [ 1, "homepage-container" ], [ 1, "announcement-bar" ], [ "alt", "", 3, "src" ], [ 3, "innerHTML" ], [ 1, "button", 3, "href" ] ],
                template: function(rf, ctx) {
                    1 & rf && core.Cc(0, AnnouncementBarComponent_div_0_Template, 6, 3, "div", 0), 2 & rf && core.lc("ngIf", ctx.announcement);
                },
                directives: [ common.k ],
                encapsulation: 2
            }), AnnouncementBarComponent;
        })();
        __webpack_require__.d(__webpack_exports__, "AnnouncementBarModule", (function() {
            return announcement_bar_module_AnnouncementBarModule;
        }));
        let announcement_bar_module_AnnouncementBarModule = (() => {
            class AnnouncementBarModule {
                constructor() {
                    this.customElementComponent = announcement_bar_component_AnnouncementBarComponent;
                }
            }
            return AnnouncementBarModule.ɵmod = core.Nb({
                type: AnnouncementBarModule
            }), AnnouncementBarModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || AnnouncementBarModule);
                },
                imports: [ [ common.c, shared_module.a, http.b ] ]
            }), AnnouncementBarModule;
        })();
    },
    "5yfJ": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return NEVER;
        }));
        var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("HDdC"), _util_noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("KqfI");
        const NEVER = new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(_util_noop__WEBPACK_IMPORTED_MODULE_1__.a);
    },
    "6CTB": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return CodeComponent;
        }));
        var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("fXoL"), rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("vkgz"), _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("dNgK"), _pretty_printer_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("vVVL"), app_shared_copier_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("/ck9"), app_shared_logger_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("vHPH"), _angular_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("ofXK");
        const _c0 = [ "codeContainer" ];
        function CodeComponent_button_2_Template(rf, ctx) {
            if (1 & rf) {
                const _r106 = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Wb();
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(0, "button", 3), _angular_core__WEBPACK_IMPORTED_MODULE_0__.cc("click", (function($event) {
                    return _angular_core__WEBPACK_IMPORTED_MODULE_0__.uc(_r106), _angular_core__WEBPACK_IMPORTED_MODULE_0__.gc().doCopy();
                })), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ec(1, "\n        "), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(2, "span", 4), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ec(3, "content_copy"), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb(), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ec(4, "\n      "), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb();
            }
            if (2 & rf) {
                const ctx_r103 = _angular_core__WEBPACK_IMPORTED_MODULE_0__.gc();
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Cb("aria-label", ctx_r103.ariaLabel);
            }
        }
        let CodeComponent = (() => {
            class CodeComponent {
                constructor(snackbar, pretty, copier, logger) {
                    this.snackbar = snackbar, this.pretty = pretty, this.copier = copier, this.logger = logger, 
                    this.ariaLabel = "", this.codeFormatted = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.m;
                }
                set code(code) {
                    this._code = code, this._code && this._code.trim() ? this.formatDisplayedCode() : this.showMissingCodeMessage();
                }
                get code() {
                    return this._code;
                }
                set header(header) {
                    this._header = header, this.ariaLabel = this.header ? `Copy code snippet from ${this.header}` : "";
                }
                get header() {
                    return this._header;
                }
                ngOnChanges() {
                    this.code && this.formatDisplayedCode();
                }
                formatDisplayedCode() {
                    const leftAlignedCode = function(text) {
                        let indent = Number.MAX_VALUE;
                        const lines = text.split("\n");
                        return lines.forEach(line => {
                            const lineIndent = line.search(/\S/);
                            -1 !== lineIndent && (indent = Math.min(lineIndent, indent));
                        }), lines.map(line => line.substr(indent)).join("\n").trim();
                    }(this.code);
                    this.setCodeHtml(leftAlignedCode), this.codeText = this.getCodeText(), this.pretty.formatCode(leftAlignedCode, this.language, this.getLinenums()).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.a)(() => this.codeFormatted.emit())).subscribe(c => this.setCodeHtml(c), () => {});
                }
                showMissingCodeMessage() {
                    const src = this.path ? this.path + (this.region ? "#" + this.region : "") : "";
                    this.setCodeHtml(`<p class="code-missing">The code sample is missing${src ? ` for\n${src}` : "."}</p>`);
                }
                setCodeHtml(formattedCode) {
                    this.codeContainer.nativeElement.innerHTML = formattedCode;
                }
                getCodeText() {
                    return this.codeContainer.nativeElement.textContent;
                }
                doCopy() {
                    const code = this.codeText;
                    this.copier.copyText(code) ? (this.logger.log("Copied code to clipboard:", code), 
                    this.snackbar.open("Code Copied", "", {
                        duration: 800
                    })) : (this.logger.error(new Error(`ERROR copying code to clipboard: "${code}"`)), 
                    this.snackbar.open("Copy failed. Please try again!", "", {
                        duration: 800
                    }));
                }
                getLinenums() {
                    const linenums = "boolean" == typeof this.linenums ? this.linenums : "true" === this.linenums || "false" !== this.linenums && ("string" == typeof this.linenums ? parseInt(this.linenums, 10) : this.linenums);
                    return null != linenums && !isNaN(linenums) && linenums;
                }
            }
            return CodeComponent.ɵfac = function(t) {
                return new (t || CodeComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(_angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_2__.a), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(_pretty_printer_service__WEBPACK_IMPORTED_MODULE_3__.a), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(app_shared_copier_service__WEBPACK_IMPORTED_MODULE_4__.a), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(app_shared_logger_service__WEBPACK_IMPORTED_MODULE_5__.a));
            }, CodeComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Jb({
                type: CodeComponent,
                selectors: [ [ "aio-code" ] ],
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && _angular_core__WEBPACK_IMPORTED_MODULE_0__.yc(_c0, !0), 2 & rf && _angular_core__WEBPACK_IMPORTED_MODULE_0__.qc(_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__.dc()) && (ctx.codeContainer = _t.first);
                },
                inputs: {
                    hideCopy: "hideCopy",
                    language: "language",
                    linenums: "linenums",
                    path: "path",
                    region: "region",
                    header: "header"
                },
                outputs: {
                    codeFormatted: "codeFormatted"
                },
                features: [ _angular_core__WEBPACK_IMPORTED_MODULE_0__.yb() ],
                decls: 7,
                vars: 4,
                consts: [ [ "class", "material-icons copy-button no-print", "title", "Copy code snippet", 3, "click", 4, "ngIf" ], [ 1, "animated", "fadeIn" ], [ "codeContainer", "" ], [ "title", "Copy code snippet", 1, "material-icons", "copy-button", "no-print", 3, "click" ], [ "aria-hidden", "true" ] ],
                template: function(rf, ctx) {
                    1 & rf && (_angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(0, "pre"), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ec(1, "      "), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.Cc(2, CodeComponent_button_2_Template, 5, 1, "button", 0), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ec(3, "\n      "), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Qb(4, "code", 1, 2), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ec(6, "\n    "), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb()), 
                    2 & rf && (_angular_core__WEBPACK_IMPORTED_MODULE_0__.Eb("prettyprint lang-", ctx.language, ""), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(2), _angular_core__WEBPACK_IMPORTED_MODULE_0__.lc("ngIf", !ctx.hideCopy));
                },
                directives: [ _angular_common__WEBPACK_IMPORTED_MODULE_6__.k ],
                encapsulation: 2
            }), CodeComponent;
        })();
    },
    "6U+v": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var common = __webpack_require__("ofXK"), core = __webpack_require__("fXoL"), map = __webpack_require__("lJxs"), publishLast = __webpack_require__("qZ0a"), document_service = __webpack_require__("jn67"), http = __webpack_require__("tk/3");
        const resourcesPath = document_service.a + "resources.json";
        let resource_service_ResourceService = (() => {
            class ResourceService {
                constructor(http) {
                    this.http = http, this.categories = this.getCategories();
                }
                getCategories() {
                    const categories = this.http.get(resourcesPath).pipe(Object(map.a)(data => (function(categoryJson) {
                        return Object.keys(categoryJson).map(catKey => {
                            const cat = categoryJson[catKey];
                            return {
                                id: makeId(catKey),
                                title: catKey,
                                order: cat.order,
                                subCategories: mkSubCategories(cat.subCategories, catKey)
                            };
                        }).sort(compareCats);
                    })(data)), Object(publishLast.a)());
                    return categories.connect(), categories;
                }
            }
            return ResourceService.ɵfac = function(t) {
                return new (t || ResourceService)(core.Zb(http.a));
            }, ResourceService.ɵprov = core.Lb({
                token: ResourceService,
                factory: function(t) {
                    return ResourceService.ɵfac(t);
                },
                providedIn: null
            }), ResourceService;
        })();
        function mkSubCategories(subCategoryJson, catKey) {
            return Object.keys(subCategoryJson).map(subKey => {
                const sub = subCategoryJson[subKey];
                return {
                    id: makeId(subKey),
                    title: subKey,
                    order: sub.order,
                    resources: mkResources(sub.resources, subKey, catKey)
                };
            }).sort(compareCats);
        }
        function mkResources(resourceJson, subKey, catKey) {
            return Object.keys(resourceJson).map(resKey => {
                const res = resourceJson[resKey];
                return res.category = catKey, res.subCategory = subKey, res.id = makeId(resKey), 
                res;
            }).sort(compareTitles);
        }
        function compareCats(l, r) {
            return l.order === r.order ? compareTitles(l, r) : l.order > r.order ? 1 : -1;
        }
        function compareTitles(l, r) {
            return l.title.toUpperCase() > r.title.toUpperCase() ? 1 : -1;
        }
        function makeId(title) {
            return title.toLowerCase().replace(/\s+/g, "-");
        }
        function ResourceListComponent_div_2_div_6_div_4_div_1_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "div", 10), core.Vb(1, "a", 11), core.Vb(2, "div"), core.Vb(3, "h4"), 
            core.Ec(4), core.Tb(), core.Vb(5, "p", 12), core.Ec(6), core.Tb(), core.Tb(), core.Tb(), 
            core.Tb()), 2 & rf) {
                const resource_r86 = core.gc().$implicit;
                core.Ab(1), core.lc("href", resource_r86.url, core.wc), core.Ab(3), core.Fc(resource_r86.title), 
                core.Ab(2), core.Fc(resource_r86.desc || "No Description");
            }
        }
        function ResourceListComponent_div_2_div_6_div_4_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "div"), core.Cc(1, ResourceListComponent_div_2_div_6_div_4_div_1_Template, 7, 3, "div", 9), 
            core.Tb()), 2 & rf) {
                const resource_r86 = ctx.$implicit;
                core.Ab(1), core.lc("ngIf", resource_r86.rev);
            }
        }
        function ResourceListComponent_div_2_div_6_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "div"), core.Qb(1, "a", 5), core.Vb(2, "h3", 8), core.Ec(3), 
            core.Tb(), core.Cc(4, ResourceListComponent_div_2_div_6_div_4_Template, 2, 1, "div", 7), 
            core.Tb()), 2 & rf) {
                const subCategory_r84 = ctx.$implicit;
                core.Ab(1), core.mc("id", subCategory_r84.id), core.Ab(2), core.Fc(subCategory_r84.title), 
                core.Ab(1), core.lc("ngForOf", subCategory_r84.resources);
            }
        }
        function ResourceListComponent_div_2_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "div", 3), core.Vb(1, "header", 4), core.Qb(2, "a", 5), 
            core.Vb(3, "h2"), core.Ec(4), core.Tb(), core.Tb(), core.Vb(5, "div", 6), core.Cc(6, ResourceListComponent_div_2_div_6_Template, 5, 3, "div", 7), 
            core.Tb(), core.Tb()), 2 & rf) {
                const category_r82 = ctx.$implicit;
                core.Ab(2), core.mc("id", category_r82.id), core.Ab(2), core.Fc(category_r82.title), 
                core.Ab(2), core.lc("ngForOf", category_r82.subCategories);
            }
        }
        let resource_list_component_ResourceListComponent = (() => {
            class ResourceListComponent {
                constructor(location, resourceService) {
                    this.resourceService = resourceService, this.scrollPos = 0, this.location = location.pathname.replace(/^\/+/, "");
                }
                href(cat) {
                    return this.location + "#" + cat.id;
                }
                ngOnInit() {
                    this.resourceService.categories.subscribe(cats => this.categories = cats);
                }
                onScroll(target) {
                    this.scrollPos = target && (target.scrollTop || target.body.scrollTop) || 0;
                }
            }
            return ResourceListComponent.ɵfac = function(t) {
                return new (t || ResourceListComponent)(core.Pb(common.q), core.Pb(resource_service_ResourceService));
            }, ResourceListComponent.ɵcmp = core.Jb({
                type: ResourceListComponent,
                selectors: [ [ "aio-resource-list" ] ],
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && core.cc("scroll", (function($event) {
                        return ctx.onScroll($event.target);
                    }), !1, core.tc);
                },
                decls: 3,
                vars: 1,
                consts: [ [ 1, "resources-container" ], [ 1, "l-flex--column" ], [ "class", "showcase", 4, "ngFor", "ngForOf" ], [ 1, "showcase" ], [ 1, "c-resource-header" ], [ 1, "h-anchor-offset", 3, "id" ], [ 1, "shadow-1" ], [ 4, "ngFor", "ngForOf" ], [ 1, "subcategory-title" ], [ "class", "c-resource", 4, "ngIf" ], [ 1, "c-resource" ], [ "target", "_blank", 1, "l-flex--column", "resource-row-link", 3, "href" ], [ 1, "resource-description" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.Vb(0, "div", 0), core.Vb(1, "div", 1), core.Cc(2, ResourceListComponent_div_2_Template, 7, 3, "div", 2), 
                    core.Tb(), core.Tb()), 2 & rf && (core.Ab(2), core.lc("ngForOf", ctx.categories));
                },
                directives: [ common.j, common.k ],
                encapsulation: 2
            }), ResourceListComponent;
        })();
        __webpack_require__.d(__webpack_exports__, "ResourceListModule", (function() {
            return resource_list_module_ResourceListModule;
        }));
        let resource_list_module_ResourceListModule = (() => {
            class ResourceListModule {
                constructor() {
                    this.customElementComponent = resource_list_component_ResourceListComponent;
                }
            }
            return ResourceListModule.ɵmod = core.Nb({
                type: ResourceListModule
            }), ResourceListModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || ResourceListModule);
                },
                providers: [ resource_service_ResourceService ],
                imports: [ [ common.c ] ]
            }), ResourceListModule;
        })();
    },
    "7Hc7": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        let nextHandle = 1;
        const tasksByHandle = {}, Immediate = {
            setImmediate(cb) {
                const handle = nextHandle++;
                return tasksByHandle[handle] = cb, Promise.resolve().then(() => (function(handle) {
                    const cb = tasksByHandle[handle];
                    cb && cb();
                })(handle)), handle;
            },
            clearImmediate(handle) {
                delete tasksByHandle[handle];
            }
        };
        var AsyncAction = __webpack_require__("3N8a");
        class AsapAction_AsapAction extends AsyncAction.a {
            constructor(scheduler, work) {
                super(scheduler, work), this.scheduler = scheduler, this.work = work;
            }
            requestAsyncId(scheduler, id, delay = 0) {
                return null !== delay && delay > 0 ? super.requestAsyncId(scheduler, id, delay) : (scheduler.actions.push(this), 
                scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null))));
            }
            recycleAsyncId(scheduler, id, delay = 0) {
                if (null !== delay && delay > 0 || null === delay && this.delay > 0) return super.recycleAsyncId(scheduler, id, delay);
                0 === scheduler.actions.length && (Immediate.clearImmediate(id), scheduler.scheduled = void 0);
            }
        }
        var AsyncScheduler = __webpack_require__("IjjT");
        class AsapScheduler_AsapScheduler extends AsyncScheduler.a {
            flush(action) {
                this.active = !0, this.scheduled = void 0;
                const {actions: actions} = this;
                let error, index = -1, count = actions.length;
                action = action || actions.shift();
                do {
                    if (error = action.execute(action.state, action.delay)) break;
                } while (++index < count && (action = actions.shift()));
                if (this.active = !1, error) {
                    for (;++index < count && (action = actions.shift()); ) action.unsubscribe();
                    throw error;
                }
            }
        }
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return asap;
        }));
        const asap = new AsapScheduler_AsapScheduler(AsapAction_AsapAction);
    },
    "7o/Q": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Subscriber;
        }));
        var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("n6bG"), _Observer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("gRHU"), _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("quSY"), _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("2QA8"), _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("2fFW"), _util_hostReportError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("NJ4a");
        class Subscriber extends _Subscription__WEBPACK_IMPORTED_MODULE_2__.a {
            constructor(destinationOrNext, error, complete) {
                switch (super(), this.syncErrorValue = null, this.syncErrorThrown = !1, this.syncErrorThrowable = !1, 
                this.isStopped = !1, arguments.length) {
                  case 0:
                    this.destination = _Observer__WEBPACK_IMPORTED_MODULE_1__.a;
                    break;

                  case 1:
                    if (!destinationOrNext) {
                        this.destination = _Observer__WEBPACK_IMPORTED_MODULE_1__.a;
                        break;
                    }
                    if ("object" == typeof destinationOrNext) {
                        destinationOrNext instanceof Subscriber ? (this.syncErrorThrowable = destinationOrNext.syncErrorThrowable, 
                        this.destination = destinationOrNext, destinationOrNext.add(this)) : (this.syncErrorThrowable = !0, 
                        this.destination = new SafeSubscriber(this, destinationOrNext));
                        break;
                    }

                  default:
                    this.syncErrorThrowable = !0, this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                }
            }
            [_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_3__.a]() {
                return this;
            }
            static create(next, error, complete) {
                const subscriber = new Subscriber(next, error, complete);
                return subscriber.syncErrorThrowable = !1, subscriber;
            }
            next(value) {
                this.isStopped || this._next(value);
            }
            error(err) {
                this.isStopped || (this.isStopped = !0, this._error(err));
            }
            complete() {
                this.isStopped || (this.isStopped = !0, this._complete());
            }
            unsubscribe() {
                this.closed || (this.isStopped = !0, super.unsubscribe());
            }
            _next(value) {
                this.destination.next(value);
            }
            _error(err) {
                this.destination.error(err), this.unsubscribe();
            }
            _complete() {
                this.destination.complete(), this.unsubscribe();
            }
            _unsubscribeAndRecycle() {
                const {_parentOrParents: _parentOrParents} = this;
                return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, 
                this._parentOrParents = _parentOrParents, this;
            }
        }
        class SafeSubscriber extends Subscriber {
            constructor(_parentSubscriber, observerOrNext, error, complete) {
                let next;
                super(), this._parentSubscriber = _parentSubscriber;
                let context = this;
                Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.a)(observerOrNext) ? next = observerOrNext : observerOrNext && (next = observerOrNext.next, 
                error = observerOrNext.error, complete = observerOrNext.complete, observerOrNext !== _Observer__WEBPACK_IMPORTED_MODULE_1__.a && (context = Object.create(observerOrNext), 
                Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.a)(context.unsubscribe) && this.add(context.unsubscribe.bind(context)), 
                context.unsubscribe = this.unsubscribe.bind(this))), this._context = context, this._next = next, 
                this._error = error, this._complete = complete;
            }
            next(value) {
                if (!this.isStopped && this._next) {
                    const {_parentSubscriber: _parentSubscriber} = this;
                    _config__WEBPACK_IMPORTED_MODULE_4__.a.useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? this.__tryOrSetError(_parentSubscriber, this._next, value) && this.unsubscribe() : this.__tryOrUnsub(this._next, value);
                }
            }
            error(err) {
                if (!this.isStopped) {
                    const {_parentSubscriber: _parentSubscriber} = this, {useDeprecatedSynchronousErrorHandling: useDeprecatedSynchronousErrorHandling} = _config__WEBPACK_IMPORTED_MODULE_4__.a;
                    if (this._error) useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? (this.__tryOrSetError(_parentSubscriber, this._error, err), 
                    this.unsubscribe()) : (this.__tryOrUnsub(this._error, err), this.unsubscribe()); else if (_parentSubscriber.syncErrorThrowable) useDeprecatedSynchronousErrorHandling ? (_parentSubscriber.syncErrorValue = err, 
                    _parentSubscriber.syncErrorThrown = !0) : Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_5__.a)(err), 
                    this.unsubscribe(); else {
                        if (this.unsubscribe(), useDeprecatedSynchronousErrorHandling) throw err;
                        Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_5__.a)(err);
                    }
                }
            }
            complete() {
                if (!this.isStopped) {
                    const {_parentSubscriber: _parentSubscriber} = this;
                    if (this._complete) {
                        const wrappedComplete = () => this._complete.call(this._context);
                        _config__WEBPACK_IMPORTED_MODULE_4__.a.useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? (this.__tryOrSetError(_parentSubscriber, wrappedComplete), 
                        this.unsubscribe()) : (this.__tryOrUnsub(wrappedComplete), this.unsubscribe());
                    } else this.unsubscribe();
                }
            }
            __tryOrUnsub(fn, value) {
                try {
                    fn.call(this._context, value);
                } catch (err) {
                    if (this.unsubscribe(), _config__WEBPACK_IMPORTED_MODULE_4__.a.useDeprecatedSynchronousErrorHandling) throw err;
                    Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_5__.a)(err);
                }
            }
            __tryOrSetError(parent, fn, value) {
                if (!_config__WEBPACK_IMPORTED_MODULE_4__.a.useDeprecatedSynchronousErrorHandling) throw new Error("bad call");
                try {
                    fn.call(this._context, value);
                } catch (err) {
                    return _config__WEBPACK_IMPORTED_MODULE_4__.a.useDeprecatedSynchronousErrorHandling ? (parent.syncErrorValue = err, 
                    parent.syncErrorThrown = !0, !0) : (Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_5__.a)(err), 
                    !0);
                }
                return !1;
            }
            _unsubscribe() {
                const {_parentSubscriber: _parentSubscriber} = this;
                this._context = null, this._parentSubscriber = null, _parentSubscriber.unsubscribe();
            }
        }
    },
    "8LU1": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "b", (function() {
            return coerceBooleanProperty;
        })), __webpack_require__.d(__webpack_exports__, "e", (function() {
            return coerceNumberProperty;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return coerceArray;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return coerceCssPixelValue;
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return coerceElement;
        }));
        var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("fXoL");
        function coerceBooleanProperty(value) {
            return null != value && "false" !== `${value}`;
        }
        function coerceNumberProperty(value, fallbackValue = 0) {
            return function(value) {
                return !isNaN(parseFloat(value)) && !isNaN(Number(value));
            }(value) ? Number(value) : fallbackValue;
        }
        function coerceArray(value) {
            return Array.isArray(value) ? value : [ value ];
        }
        function coerceCssPixelValue(value) {
            return null == value ? "" : "string" == typeof value ? value : `${value}px`;
        }
        function coerceElement(elementOrRef) {
            return elementOrRef instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.k ? elementOrRef.nativeElement : elementOrRef;
        }
    },
    "9ppp": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return ObjectUnsubscribedError;
        }));
        const ObjectUnsubscribedError = (() => {
            function ObjectUnsubscribedErrorImpl() {
                return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", 
                this;
            }
            return ObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype), ObjectUnsubscribedErrorImpl;
        })();
    },
    Afo1: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var common = __webpack_require__("ofXK"), shared_module = __webpack_require__("PCNd"), switchMap = __webpack_require__("eIep"), core = __webpack_require__("fXoL"), location_service = __webpack_require__("/lUL"), search_service = __webpack_require__("to4i"), search_results_component = __webpack_require__("LwjS");
        let file_not_found_search_component_FileNotFoundSearchComponent = (() => {
            class FileNotFoundSearchComponent {
                constructor(location, search) {
                    this.location = location, this.search = search;
                }
                ngOnInit() {
                    this.searchResults = this.location.currentPath.pipe(Object(switchMap.a)(path => {
                        const query = path.split(/\W+/).join(" ");
                        return this.search.search(query);
                    }));
                }
            }
            return FileNotFoundSearchComponent.ɵfac = function(t) {
                return new (t || FileNotFoundSearchComponent)(core.Pb(location_service.a), core.Pb(search_service.a));
            }, FileNotFoundSearchComponent.ɵcmp = core.Jb({
                type: FileNotFoundSearchComponent,
                selectors: [ [ "aio-file-not-found-search" ] ],
                decls: 4,
                vars: 3,
                consts: [ [ 1, "embedded", 3, "searchResults" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.Vb(0, "p"), core.Ec(1, "Let's see if any of these search results help..."), 
                    core.Tb(), core.Qb(2, "aio-search-results", 0), core.hc(3, "async")), 2 & rf && (core.Ab(2), 
                    core.lc("searchResults", core.ic(3, 1, ctx.searchResults)));
                },
                directives: [ search_results_component.a ],
                pipes: [ common.b ],
                encapsulation: 2
            }), FileNotFoundSearchComponent;
        })();
        __webpack_require__.d(__webpack_exports__, "FileNotFoundSearchModule", (function() {
            return file_not_found_search_module_FileNotFoundSearchModule;
        }));
        let file_not_found_search_module_FileNotFoundSearchModule = (() => {
            class FileNotFoundSearchModule {
                constructor() {
                    this.customElementComponent = file_not_found_search_component_FileNotFoundSearchComponent;
                }
            }
            return FileNotFoundSearchModule.ɵmod = core.Nb({
                type: FileNotFoundSearchModule
            }), FileNotFoundSearchModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || FileNotFoundSearchModule);
                },
                imports: [ [ common.c, shared_module.a ] ]
            }), FileNotFoundSearchModule;
        })();
    },
    AytR: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return environment;
        }));
        const environment = {
            gaId: "UA-8594346-15",
            production: !0,
            mode: "stable"
        };
    },
    Cfvw: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        var Observable = __webpack_require__("HDdC"), subscribeTo = __webpack_require__("SeVD"), Subscription = __webpack_require__("quSY"), symbol_observable = __webpack_require__("kJWO"), scheduleArray = __webpack_require__("jZKg"), symbol_iterator = __webpack_require__("Lhse"), isPromise = __webpack_require__("c2HN"), isArrayLike = __webpack_require__("I55L");
        function from(input, scheduler) {
            return scheduler ? function(input, scheduler) {
                if (null != input) {
                    if (function(input) {
                        return input && "function" == typeof input[symbol_observable.a];
                    }(input)) return function(input, scheduler) {
                        return new Observable.a(subscriber => {
                            const sub = new Subscription.a;
                            return sub.add(scheduler.schedule(() => {
                                const observable = input[symbol_observable.a]();
                                sub.add(observable.subscribe({
                                    next(value) {
                                        sub.add(scheduler.schedule(() => subscriber.next(value)));
                                    },
                                    error(err) {
                                        sub.add(scheduler.schedule(() => subscriber.error(err)));
                                    },
                                    complete() {
                                        sub.add(scheduler.schedule(() => subscriber.complete()));
                                    }
                                }));
                            })), sub;
                        });
                    }(input, scheduler);
                    if (Object(isPromise.a)(input)) return function(input, scheduler) {
                        return new Observable.a(subscriber => {
                            const sub = new Subscription.a;
                            return sub.add(scheduler.schedule(() => input.then(value => {
                                sub.add(scheduler.schedule(() => {
                                    subscriber.next(value), sub.add(scheduler.schedule(() => subscriber.complete()));
                                }));
                            }, err => {
                                sub.add(scheduler.schedule(() => subscriber.error(err)));
                            }))), sub;
                        });
                    }(input, scheduler);
                    if (Object(isArrayLike.a)(input)) return Object(scheduleArray.a)(input, scheduler);
                    if (function(input) {
                        return input && "function" == typeof input[symbol_iterator.a];
                    }(input) || "string" == typeof input) return function(input, scheduler) {
                        if (!input) throw new Error("Iterable cannot be null");
                        return new Observable.a(subscriber => {
                            const sub = new Subscription.a;
                            let iterator;
                            return sub.add(() => {
                                iterator && "function" == typeof iterator.return && iterator.return();
                            }), sub.add(scheduler.schedule(() => {
                                iterator = input[symbol_iterator.a](), sub.add(scheduler.schedule((function() {
                                    if (subscriber.closed) return;
                                    let value, done;
                                    try {
                                        const result = iterator.next();
                                        value = result.value, done = result.done;
                                    } catch (err) {
                                        return void subscriber.error(err);
                                    }
                                    done ? subscriber.complete() : (subscriber.next(value), this.schedule());
                                })));
                            })), sub;
                        });
                    }(input, scheduler);
                }
                throw new TypeError((null !== input && typeof input || input) + " is not observable");
            }(input, scheduler) : input instanceof Observable.a ? input : new Observable.a(Object(subscribeTo.a)(input));
        }
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return from;
        }));
    },
    D0XW: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return async;
        }));
        var _AsyncAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("3N8a");
        const async = new (__webpack_require__("IjjT").a)(_AsyncAction__WEBPACK_IMPORTED_MODULE_0__.a);
    },
    DH7j: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return isArray;
        }));
        const isArray = (() => Array.isArray || (x => x && "number" == typeof x.length))();
    },
    DzVX: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var common = __webpack_require__("ofXK"), code_component = __webpack_require__("6CTB"), core = __webpack_require__("fXoL");
        const _c0 = [ "content" ];
        function CodeExampleComponent_header_3_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "header"), core.Ec(1), core.Tb()), 2 & rf) {
                const ctx_r108 = core.gc();
                core.Ab(1), core.Fc(ctx_r108.header);
            }
        }
        const _c1 = [ "*" ];
        let code_example_component_CodeExampleComponent = (() => {
            class CodeExampleComponent {
                constructor() {
                    this._path = "", this.isAvoid = !1;
                }
                set header(header) {
                    this._header = header, this.classes = {
                        "headed-code": !!this.header,
                        "simple-code": !this.header
                    };
                }
                get header() {
                    return this._header;
                }
                set path(path) {
                    this._path = path, this.isAvoid = -1 !== this.path.indexOf(".avoid.");
                }
                get path() {
                    return this._path;
                }
                set hidecopy(hidecopy) {
                    this._hidecopy = null != hidecopy && "false" !== `${hidecopy}`;
                }
                get hidecopy() {
                    return this._hidecopy;
                }
                set hyphenatedHideCopy(hidecopy) {
                    this.hidecopy = hidecopy;
                }
                set capitalizedHideCopy(hidecopy) {
                    this.hidecopy = hidecopy;
                }
                ngAfterViewInit() {
                    this.aioCode.code = this.content.nativeElement.innerHTML;
                }
            }
            return CodeExampleComponent.ɵfac = function(t) {
                return new (t || CodeExampleComponent);
            }, CodeExampleComponent.ɵcmp = core.Jb({
                type: CodeExampleComponent,
                selectors: [ [ "code-example" ] ],
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && (core.yc(_c0, !0), core.yc(code_component.a, !0)), 2 & rf && (core.qc(_t = core.dc()) && (ctx.content = _t.first), 
                    core.qc(_t = core.dc()) && (ctx.aioCode = _t.first));
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && core.Bb(1), 2 & rf && core.Fb("avoidFile", ctx.isAvoid);
                },
                inputs: {
                    language: "language",
                    linenums: "linenums",
                    region: "region",
                    header: "header",
                    path: "path",
                    hidecopy: "hidecopy",
                    hyphenatedHideCopy: [ "hide-copy", "hyphenatedHideCopy" ],
                    capitalizedHideCopy: [ "hideCopy", "capitalizedHideCopy" ]
                },
                ngContentSelectors: _c1,
                decls: 5,
                vars: 8,
                consts: [ [ 2, "display", "none" ], [ "content", "" ], [ 4, "ngIf" ], [ 3, "ngClass", "language", "linenums", "path", "region", "hideCopy", "header" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.kc(), core.Vb(0, "div", 0, 1), core.jc(2), core.Tb(), core.Cc(3, CodeExampleComponent_header_3_Template, 2, 1, "header", 2), 
                    core.Qb(4, "aio-code", 3)), 2 & rf && (core.Ab(3), core.lc("ngIf", ctx.header), 
                    core.Ab(1), core.lc("ngClass", ctx.classes)("language", ctx.language)("linenums", ctx.linenums)("path", ctx.path)("region", ctx.region)("hideCopy", ctx.hidecopy)("header", ctx.header));
                },
                directives: [ common.k, code_component.a, common.i ],
                encapsulation: 2
            }), CodeExampleComponent;
        })();
        var code_module = __webpack_require__("V90o");
        __webpack_require__.d(__webpack_exports__, "CodeExampleModule", (function() {
            return code_example_module_CodeExampleModule;
        }));
        let code_example_module_CodeExampleModule = (() => {
            class CodeExampleModule {
                constructor() {
                    this.customElementComponent = code_example_component_CodeExampleComponent;
                }
            }
            return CodeExampleModule.ɵmod = core.Nb({
                type: CodeExampleModule
            }), CodeExampleModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || CodeExampleModule);
                },
                imports: [ [ common.c, code_module.a ] ]
            }), CodeExampleModule;
        })();
    },
    EY2u: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return EMPTY;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return empty;
        }));
        var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("HDdC");
        const EMPTY = new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(subscriber => subscriber.complete());
        function empty(scheduler) {
            return scheduler ? function(scheduler) {
                return new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(subscriber => scheduler.schedule(() => subscriber.complete()));
            }(scheduler) : EMPTY;
        }
    },
    FKr1: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        var core = __webpack_require__("fXoL"), bidi = __webpack_require__("cH1L");
        const VERSION = new core.N("9.0.0-next.0");
        var coercion = __webpack_require__("8LU1"), fesm2015_platform = (__webpack_require__("XNiG"), 
        __webpack_require__("HDdC"), __webpack_require__("nLfN")), a11y = (__webpack_require__("jhN1"), 
        __webpack_require__("JX91"), __webpack_require__("ofXK"), __webpack_require__("u47x")), animations = __webpack_require__("R1ws");
        __webpack_require__("FtGj"), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return core_MatCommonModule;
        })), __webpack_require__.d(__webpack_exports__, "h", (function() {
            return mixinDisabled;
        })), __webpack_require__.d(__webpack_exports__, "f", (function() {
            return mixinColor;
        })), __webpack_require__.d(__webpack_exports__, "g", (function() {
            return mixinDisableRipple;
        })), __webpack_require__.d(__webpack_exports__, "i", (function() {
            return mixinTabIndex;
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return core_MatRippleModule;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MAT_RIPPLE_GLOBAL_OPTIONS;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return core_MatRipple;
        })), __webpack_require__.d(__webpack_exports__, "e", (function() {
            return core_RippleRenderer;
        }));
        const _c1 = [ 1, "mat-ripple" ], VERSION$1 = new core.N("9.0.0-next.0"), MATERIAL_SANITY_CHECKS = new core.p("mat-sanity-checks", {
            providedIn: "root",
            factory: function() {
                return !0;
            }
        });
        let SUPPORTS_INTL_API, core_MatCommonModule = (() => {
            class MatCommonModule {
                constructor(sanityChecks) {
                    this._hasDoneGlobalChecks = !1, this._document = "object" == typeof document && document ? document : null, 
                    this._window = "object" == typeof window && window ? window : null, this._sanityChecks = sanityChecks, 
                    this._hasDoneGlobalChecks || (this._checkDoctypeIsDefined(), this._checkThemeIsPresent(), 
                    this._checkCdkVersionMatch(), this._hasDoneGlobalChecks = !0);
                }
                _checksAreEnabled() {
                    return Object(core.W)() && !this._isTestEnv();
                }
                _isTestEnv() {
                    const window = this._window;
                    return window && (window.__karma__ || window.jasmine);
                }
                _checkDoctypeIsDefined() {
                    this._checksAreEnabled() && (!0 === this._sanityChecks || this._sanityChecks.doctype) && this._document && !this._document.doctype && console.warn("Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.");
                }
                _checkThemeIsPresent() {
                    if (!(this._checksAreEnabled() && !1 !== this._sanityChecks && this._sanityChecks.theme && this._document && this._document.body && "function" == typeof getComputedStyle)) return;
                    const testElement = this._document.createElement("div");
                    testElement.classList.add("mat-theme-loaded-marker"), this._document.body.appendChild(testElement);
                    const computedStyle = getComputedStyle(testElement);
                    computedStyle && "none" !== computedStyle.display && console.warn("Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming"), 
                    this._document.body.removeChild(testElement);
                }
                _checkCdkVersionMatch() {
                    this._checksAreEnabled() && (!0 === this._sanityChecks || this._sanityChecks.version) && VERSION$1.full !== VERSION.full && console.warn("The Angular Material version (" + VERSION$1.full + ") does not match the Angular CDK version (" + VERSION.full + ").\nPlease ensure the versions of these two packages exactly match.");
                }
            }
            return MatCommonModule.ɵmod = core.Nb({
                type: MatCommonModule
            }), MatCommonModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || MatCommonModule)(core.Zb(MATERIAL_SANITY_CHECKS, 8));
                },
                imports: [ [ bidi.a ], bidi.a ]
            }), MatCommonModule;
        })();
        function mixinDisabled(base) {
            return class extends base {
                constructor(...args) {
                    super(...args), this._disabled = !1;
                }
                get disabled() {
                    return this._disabled;
                }
                set disabled(value) {
                    this._disabled = Object(coercion.b)(value);
                }
            };
        }
        function mixinColor(base, defaultColor) {
            return class extends base {
                get color() {
                    return this._color;
                }
                set color(value) {
                    const colorPalette = value || defaultColor;
                    colorPalette !== this._color && (this._color && this._elementRef.nativeElement.classList.remove(`mat-${this._color}`), 
                    colorPalette && this._elementRef.nativeElement.classList.add(`mat-${colorPalette}`), 
                    this._color = colorPalette);
                }
                constructor(...args) {
                    super(...args), this.color = defaultColor;
                }
            };
        }
        function mixinDisableRipple(base) {
            return class extends base {
                constructor(...args) {
                    super(...args), this._disableRipple = !1;
                }
                get disableRipple() {
                    return this._disableRipple;
                }
                set disableRipple(value) {
                    this._disableRipple = Object(coercion.b)(value);
                }
            };
        }
        function mixinTabIndex(base, defaultTabIndex = 0) {
            return class extends base {
                constructor(...args) {
                    super(...args), this._tabIndex = defaultTabIndex;
                }
                get tabIndex() {
                    return this.disabled ? -1 : this._tabIndex;
                }
                set tabIndex(value) {
                    this._tabIndex = null != value ? value : defaultTabIndex;
                }
            };
        }
        try {
            SUPPORTS_INTL_API = "undefined" != typeof Intl;
        } catch (_a) {
            SUPPORTS_INTL_API = !1;
        }
        const RippleState = function() {
            var RippleState = {
                FADING_IN: 0,
                VISIBLE: 1,
                FADING_OUT: 2,
                HIDDEN: 3
            };
            return RippleState[RippleState.FADING_IN] = "FADING_IN", RippleState[RippleState.VISIBLE] = "VISIBLE", 
            RippleState[RippleState.FADING_OUT] = "FADING_OUT", RippleState[RippleState.HIDDEN] = "HIDDEN", 
            RippleState;
        }();
        class RippleRef {
            constructor(_renderer, element, config) {
                this._renderer = _renderer, this.element = element, this.config = config, this.state = RippleState.HIDDEN;
            }
            fadeOut() {
                this._renderer.fadeOutRipple(this);
            }
        }
        const defaultRippleAnimationConfig = {
            enterDuration: 450,
            exitDuration: 400
        }, ignoreMouseEventsTimeout = 800, passiveEventOptions = Object(fesm2015_platform.e)({
            passive: !0
        });
        class core_RippleRenderer {
            constructor(_target, _ngZone, elementOrElementRef, platform) {
                this._target = _target, this._ngZone = _ngZone, this._isPointerDown = !1, this._triggerEvents = new Map, 
                this._activeRipples = new Set, this._onMousedown = event => {
                    const isFakeMousedown = Object(a11y.g)(event), isSyntheticEvent = this._lastTouchStartEvent && Date.now() < this._lastTouchStartEvent + ignoreMouseEventsTimeout;
                    this._target.rippleDisabled || isFakeMousedown || isSyntheticEvent || (this._isPointerDown = !0, 
                    this.fadeInRipple(event.clientX, event.clientY, this._target.rippleConfig));
                }, this._onTouchStart = event => {
                    if (!this._target.rippleDisabled) {
                        this._lastTouchStartEvent = Date.now(), this._isPointerDown = !0;
                        const touches = event.changedTouches;
                        for (let i = 0; i < touches.length; i++) this.fadeInRipple(touches[i].clientX, touches[i].clientY, this._target.rippleConfig);
                    }
                }, this._onPointerUp = () => {
                    this._isPointerDown && (this._isPointerDown = !1, this._activeRipples.forEach(ripple => {
                        !ripple.config.persistent && (ripple.state === RippleState.VISIBLE || ripple.config.terminateOnPointerUp && ripple.state === RippleState.FADING_IN) && ripple.fadeOut();
                    }));
                }, platform.isBrowser && (this._containerElement = Object(coercion.d)(elementOrElementRef), 
                this._triggerEvents.set("mousedown", this._onMousedown).set("mouseup", this._onPointerUp).set("mouseleave", this._onPointerUp).set("touchstart", this._onTouchStart).set("touchend", this._onPointerUp).set("touchcancel", this._onPointerUp));
            }
            fadeInRipple(x, y, config = {}) {
                const containerRect = this._containerRect = this._containerRect || this._containerElement.getBoundingClientRect(), animationConfig = Object.assign({}, defaultRippleAnimationConfig, config.animation);
                config.centered && (x = containerRect.left + containerRect.width / 2, y = containerRect.top + containerRect.height / 2);
                const radius = config.radius || function(x, y, rect) {
                    const distX = Math.max(Math.abs(x - rect.left), Math.abs(x - rect.right)), distY = Math.max(Math.abs(y - rect.top), Math.abs(y - rect.bottom));
                    return Math.sqrt(distX * distX + distY * distY);
                }(x, y, containerRect), offsetX = x - containerRect.left, offsetY = y - containerRect.top, duration = animationConfig.enterDuration, ripple = document.createElement("div");
                ripple.classList.add("mat-ripple-element"), ripple.style.left = `${offsetX - radius}px`, 
                ripple.style.top = `${offsetY - radius}px`, ripple.style.height = `${2 * radius}px`, 
                ripple.style.width = `${2 * radius}px`, ripple.style.backgroundColor = config.color || null, 
                ripple.style.transitionDuration = `${duration}ms`, this._containerElement.appendChild(ripple), 
                window.getComputedStyle(ripple).getPropertyValue("opacity"), ripple.style.transform = "scale(1)";
                const rippleRef = new RippleRef(this, ripple, config);
                return rippleRef.state = RippleState.FADING_IN, this._activeRipples.add(rippleRef), 
                config.persistent || (this._mostRecentTransientRipple = rippleRef), this._runTimeoutOutsideZone(() => {
                    const isMostRecentTransientRipple = rippleRef === this._mostRecentTransientRipple;
                    rippleRef.state = RippleState.VISIBLE, config.persistent || isMostRecentTransientRipple && this._isPointerDown || rippleRef.fadeOut();
                }, duration), rippleRef;
            }
            fadeOutRipple(rippleRef) {
                const wasActive = this._activeRipples.delete(rippleRef);
                if (rippleRef === this._mostRecentTransientRipple && (this._mostRecentTransientRipple = null), 
                this._activeRipples.size || (this._containerRect = null), !wasActive) return;
                const rippleEl = rippleRef.element, animationConfig = Object.assign({}, defaultRippleAnimationConfig, rippleRef.config.animation);
                rippleEl.style.transitionDuration = `${animationConfig.exitDuration}ms`, rippleEl.style.opacity = "0", 
                rippleRef.state = RippleState.FADING_OUT, this._runTimeoutOutsideZone(() => {
                    rippleRef.state = RippleState.HIDDEN, rippleEl.parentNode.removeChild(rippleEl);
                }, animationConfig.exitDuration);
            }
            fadeOutAll() {
                this._activeRipples.forEach(ripple => ripple.fadeOut());
            }
            setupTriggerEvents(elementOrElementRef) {
                const element = Object(coercion.d)(elementOrElementRef);
                element && element !== this._triggerElement && (this._removeTriggerEvents(), this._ngZone.runOutsideAngular(() => {
                    this._triggerEvents.forEach((fn, type) => {
                        element.addEventListener(type, fn, passiveEventOptions);
                    });
                }), this._triggerElement = element);
            }
            _runTimeoutOutsideZone(fn, delay = 0) {
                this._ngZone.runOutsideAngular(() => setTimeout(fn, delay));
            }
            _removeTriggerEvents() {
                this._triggerElement && this._triggerEvents.forEach((fn, type) => {
                    this._triggerElement.removeEventListener(type, fn, passiveEventOptions);
                });
            }
        }
        const MAT_RIPPLE_GLOBAL_OPTIONS = new core.p("mat-ripple-global-options");
        let core_MatRipple = (() => {
            class MatRipple {
                constructor(_elementRef, ngZone, platform, globalOptions, animationMode) {
                    this._elementRef = _elementRef, this.radius = 0, this._disabled = !1, this._isInitialized = !1, 
                    this._globalOptions = globalOptions || {}, this._rippleRenderer = new core_RippleRenderer(this, ngZone, _elementRef, platform), 
                    "NoopAnimations" === animationMode && (this._globalOptions.animation = {
                        enterDuration: 0,
                        exitDuration: 0
                    });
                }
                get disabled() {
                    return this._disabled;
                }
                set disabled(value) {
                    this._disabled = value, this._setupTriggerEventsIfEnabled();
                }
                get trigger() {
                    return this._trigger || this._elementRef.nativeElement;
                }
                set trigger(trigger) {
                    this._trigger = trigger, this._setupTriggerEventsIfEnabled();
                }
                ngOnInit() {
                    this._isInitialized = !0, this._setupTriggerEventsIfEnabled();
                }
                ngOnDestroy() {
                    this._rippleRenderer._removeTriggerEvents();
                }
                fadeOutAll() {
                    this._rippleRenderer.fadeOutAll();
                }
                get rippleConfig() {
                    return {
                        centered: this.centered,
                        radius: this.radius,
                        color: this.color,
                        animation: Object.assign({}, this._globalOptions.animation, this.animation),
                        terminateOnPointerUp: this._globalOptions.terminateOnPointerUp
                    };
                }
                get rippleDisabled() {
                    return this.disabled || !!this._globalOptions.disabled;
                }
                _setupTriggerEventsIfEnabled() {
                    !this.disabled && this._isInitialized && this._rippleRenderer.setupTriggerEvents(this.trigger);
                }
                launch(configOrX, y = 0, config) {
                    return "number" == typeof configOrX ? this._rippleRenderer.fadeInRipple(configOrX, y, Object.assign({}, this.rippleConfig, config)) : this._rippleRenderer.fadeInRipple(0, 0, Object.assign({}, this.rippleConfig, configOrX));
                }
            }
            return MatRipple.ɵfac = function(t) {
                return new (t || MatRipple)(core.Pb(core.k), core.Pb(core.y), core.Pb(fesm2015_platform.a), core.Pb(MAT_RIPPLE_GLOBAL_OPTIONS, 8), core.Pb(animations.a, 8));
            }, MatRipple.ɵdir = core.Kb({
                type: MatRipple,
                selectors: [ [ "", "mat-ripple", "" ], [ "", "matRipple", "" ] ],
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (core.Bb(1), core.Ub(_c1)), 2 & rf && core.Fb("mat-ripple-unbounded", ctx.unbounded);
                },
                inputs: {
                    radius: [ "matRippleRadius", "radius" ],
                    disabled: [ "matRippleDisabled", "disabled" ],
                    trigger: [ "matRippleTrigger", "trigger" ],
                    color: [ "matRippleColor", "color" ],
                    unbounded: [ "matRippleUnbounded", "unbounded" ],
                    centered: [ "matRippleCentered", "centered" ],
                    animation: [ "matRippleAnimation", "animation" ]
                },
                exportAs: [ "matRipple" ]
            }), MatRipple;
        })(), core_MatRippleModule = (() => {
            class MatRippleModule {}
            return MatRippleModule.ɵmod = core.Nb({
                type: MatRippleModule
            }), MatRippleModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || MatRippleModule);
                },
                imports: [ [ core_MatCommonModule, fesm2015_platform.b ], core_MatCommonModule ]
            }), MatRippleModule;
        })();
    },
    Faly: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return ScrollService;
        }));
        var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ofXK"), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("XNiG"), rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("xgIS"), rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("1G5W"), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("Kj3r"), _angular_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("fXoL");
        const topMargin = 16;
        let ScrollService = (() => {
            class ScrollService {
                constructor(document, platformLocation, viewportScroller, location) {
                    this.document = document, this.platformLocation = platformLocation, this.viewportScroller = viewportScroller, 
                    this.location = location, this.onDestroy = new rxjs__WEBPACK_IMPORTED_MODULE_1__.a, 
                    this.poppedStateScrollPosition = null, this.supportManualScrollRestoration = !!window && "scrollTo" in window && "scrollX" in window && "scrollY" in window && !!history && "scrollRestoration" in history, 
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_2__.a)(window, "resize").pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(this.onDestroy)).subscribe(() => this._topOffset = null), 
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_2__.a)(window, "scroll").pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)(250), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(this.onDestroy)).subscribe(() => this.updateScrollPositionInHistory()), 
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_2__.a)(window, "beforeunload").pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(this.onDestroy)).subscribe(() => this.updateScrollLocationHref()), 
                    this.supportManualScrollRestoration && (history.scrollRestoration = "manual", this.location.subscribe(event => {
                        "hashchange" === event.type ? this.scrollToPosition() : (this.removeStoredScrollInfo(), 
                        this.poppedStateScrollPosition = event.state ? event.state.scrollPosition : null);
                    })), window.location.href !== this.getStoredScrollLocationHref() && this.removeStoredScrollInfo();
                }
                get topOffset() {
                    if (!this._topOffset) {
                        const toolbar = this.document.querySelector(".app-toolbar");
                        this._topOffset = (toolbar && toolbar.clientHeight || 0) + topMargin;
                    }
                    return this._topOffset;
                }
                get topOfPageElement() {
                    return this._topOfPageElement || (this._topOfPageElement = this.document.getElementById("top-of-page") || this.document.body), 
                    this._topOfPageElement;
                }
                ngOnDestroy() {
                    this.onDestroy.next();
                }
                scroll() {
                    const hash = this.getCurrentHash(), element = hash ? this.document.getElementById(hash) : this.topOfPageElement;
                    this.scrollToElement(element);
                }
                isLocationWithHash() {
                    return !!this.getCurrentHash();
                }
                scrollAfterRender(delay) {
                    const storedScrollPosition = this.getStoredScrollPosition();
                    storedScrollPosition ? this.viewportScroller.scrollToPosition(storedScrollPosition) : this.needToFixScrollPosition() ? this.scrollToPosition() : this.isLocationWithHash() ? setTimeout(() => this.scroll(), delay) : this.scrollToTop();
                }
                scrollToElement(element) {
                    element && (element.scrollIntoView(), window && window.scrollBy && (window.scrollBy(0, element.getBoundingClientRect().top - this.topOffset), 
                    window.pageYOffset < 20 && window.scrollBy(0, -window.pageYOffset)));
                }
                scrollToTop() {
                    this.scrollToElement(this.topOfPageElement);
                }
                scrollToPosition() {
                    this.poppedStateScrollPosition && (this.viewportScroller.scrollToPosition(this.poppedStateScrollPosition), 
                    this.poppedStateScrollPosition = null);
                }
                updateScrollLocationHref() {
                    window.sessionStorage.setItem("scrollLocationHref", window.location.href);
                }
                updateScrollPositionInHistory() {
                    if (this.supportManualScrollRestoration) {
                        const currentScrollPosition = this.viewportScroller.getScrollPosition();
                        this.location.replaceState(this.location.path(!0), void 0, {
                            scrollPosition: currentScrollPosition
                        }), window.sessionStorage.setItem("scrollPosition", currentScrollPosition.join(","));
                    }
                }
                getStoredScrollLocationHref() {
                    return window.sessionStorage.getItem("scrollLocationHref") || null;
                }
                getStoredScrollPosition() {
                    const position = window.sessionStorage.getItem("scrollPosition");
                    if (!position) return null;
                    const [x, y] = position.split(",");
                    return [ +x, +y ];
                }
                removeStoredScrollInfo() {
                    window.sessionStorage.removeItem("scrollLocationHref"), window.sessionStorage.removeItem("scrollPosition");
                }
                needToFixScrollPosition() {
                    return this.supportManualScrollRestoration && !!this.poppedStateScrollPosition;
                }
                getCurrentHash() {
                    return decodeURIComponent(this.platformLocation.hash.replace(/^#/, ""));
                }
            }
            return ScrollService.ɵfac = function(t) {
                return new (t || ScrollService)(_angular_core__WEBPACK_IMPORTED_MODULE_5__.Zb(_angular_common__WEBPACK_IMPORTED_MODULE_0__.d), _angular_core__WEBPACK_IMPORTED_MODULE_5__.Zb(_angular_common__WEBPACK_IMPORTED_MODULE_0__.q), _angular_core__WEBPACK_IMPORTED_MODULE_5__.Zb(_angular_common__WEBPACK_IMPORTED_MODULE_0__.r), _angular_core__WEBPACK_IMPORTED_MODULE_5__.Zb(_angular_common__WEBPACK_IMPORTED_MODULE_0__.g));
            }, ScrollService.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_5__.Lb({
                token: ScrollService,
                factory: function(t) {
                    return ScrollService.ɵfac(t);
                },
                providedIn: null
            }), ScrollService;
        })();
    },
    FiGy: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return ScrollSpyService;
        }));
        var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ofXK"), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("jtHE"), rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("XNiG"), rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("xgIS"), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("3UWI"), rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("1G5W"), rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("/uUt"), _angular_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("fXoL"), app_shared_scroll_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("Faly");
        class ScrollSpiedElement {
            constructor(element, index) {
                this.element = element, this.index = index, this.top = 0;
            }
            calculateTop(scrollTop, topOffset) {
                this.top = scrollTop + this.element.getBoundingClientRect().top - topOffset;
            }
        }
        class ScrollSpiedElementGroup {
            constructor(elements) {
                this.activeScrollItem = new rxjs__WEBPACK_IMPORTED_MODULE_1__.a(1), this.spiedElements = elements.map((elem, i) => new ScrollSpiedElement(elem, i));
            }
            calibrate(scrollTop, topOffset) {
                this.spiedElements.forEach(spiedElem => spiedElem.calculateTop(scrollTop, topOffset)), 
                this.spiedElements.sort((a, b) => b.top - a.top);
            }
            onScroll(scrollTop, maxScrollTop) {
                let activeItem;
                scrollTop + 1 >= maxScrollTop ? activeItem = this.spiedElements[0] : this.spiedElements.some(spiedElem => spiedElem.top <= scrollTop && (activeItem = spiedElem, 
                !0)), this.activeScrollItem.next(activeItem || null);
            }
        }
        let ScrollSpyService = (() => {
            class ScrollSpyService {
                constructor(doc, scrollService) {
                    this.doc = doc, this.scrollService = scrollService, this.spiedElementGroups = [], 
                    this.onStopListening = new rxjs__WEBPACK_IMPORTED_MODULE_2__.a, this.resizeEvents = Object(rxjs__WEBPACK_IMPORTED_MODULE_3__.a)(window, "resize").pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)(300), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)(this.onStopListening)), 
                    this.scrollEvents = Object(rxjs__WEBPACK_IMPORTED_MODULE_3__.a)(window, "scroll").pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)(10), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)(this.onStopListening));
                }
                spyOn(elements) {
                    this.spiedElementGroups.length || (this.resizeEvents.subscribe(() => this.onResize()), 
                    this.scrollEvents.subscribe(() => this.onScroll()), this.onResize());
                    const scrollTop = this.getScrollTop(), topOffset = this.getTopOffset(), maxScrollTop = this.lastMaxScrollTop, spiedGroup = new ScrollSpiedElementGroup(elements);
                    return spiedGroup.calibrate(scrollTop, topOffset), spiedGroup.onScroll(scrollTop, maxScrollTop), 
                    this.spiedElementGroups.push(spiedGroup), {
                        active: spiedGroup.activeScrollItem.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.a)()),
                        unspy: () => this.unspy(spiedGroup)
                    };
                }
                getContentHeight() {
                    return this.doc.body.scrollHeight || Number.MAX_SAFE_INTEGER;
                }
                getScrollTop() {
                    return window && window.pageYOffset || 0;
                }
                getTopOffset() {
                    return this.scrollService.topOffset + 50;
                }
                getViewportHeight() {
                    return this.doc.body.clientHeight || 0;
                }
                onResize() {
                    const contentHeight = this.getContentHeight(), viewportHeight = this.getViewportHeight(), scrollTop = this.getScrollTop(), topOffset = this.getTopOffset();
                    this.lastContentHeight = contentHeight, this.lastMaxScrollTop = contentHeight - viewportHeight, 
                    this.spiedElementGroups.forEach(group => group.calibrate(scrollTop, topOffset));
                }
                onScroll() {
                    this.lastContentHeight !== this.getContentHeight() && this.onResize();
                    const scrollTop = this.getScrollTop(), maxScrollTop = this.lastMaxScrollTop;
                    this.spiedElementGroups.forEach(group => group.onScroll(scrollTop, maxScrollTop));
                }
                unspy(spiedGroup) {
                    spiedGroup.activeScrollItem.complete(), this.spiedElementGroups = this.spiedElementGroups.filter(group => group !== spiedGroup), 
                    this.spiedElementGroups.length || this.onStopListening.next();
                }
            }
            return ScrollSpyService.ɵfac = function(t) {
                return new (t || ScrollSpyService)(_angular_core__WEBPACK_IMPORTED_MODULE_7__.Zb(_angular_common__WEBPACK_IMPORTED_MODULE_0__.d), _angular_core__WEBPACK_IMPORTED_MODULE_7__.Zb(app_shared_scroll_service__WEBPACK_IMPORTED_MODULE_8__.a));
            }, ScrollSpyService.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_7__.Lb({
                token: ScrollSpyService,
                factory: function(t) {
                    return ScrollSpyService.ɵfac(t);
                },
                providedIn: null
            }), ScrollSpyService;
        })();
    },
    FtGj: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "k", (function() {
            return TAB;
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return ENTER;
        })), __webpack_require__.d(__webpack_exports__, "e", (function() {
            return ESCAPE;
        })), __webpack_require__.d(__webpack_exports__, "j", (function() {
            return SPACE;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return END;
        })), __webpack_require__.d(__webpack_exports__, "f", (function() {
            return HOME;
        })), __webpack_require__.d(__webpack_exports__, "g", (function() {
            return LEFT_ARROW;
        })), __webpack_require__.d(__webpack_exports__, "l", (function() {
            return UP_ARROW;
        })), __webpack_require__.d(__webpack_exports__, "i", (function() {
            return RIGHT_ARROW;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return DOWN_ARROW;
        })), __webpack_require__.d(__webpack_exports__, "n", (function() {
            return ZERO;
        })), __webpack_require__.d(__webpack_exports__, "h", (function() {
            return NINE;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return A;
        })), __webpack_require__.d(__webpack_exports__, "m", (function() {
            return Z;
        })), __webpack_require__.d(__webpack_exports__, "o", (function() {
            return hasModifierKey;
        }));
        const TAB = 9, ENTER = 13, ESCAPE = 27, SPACE = 32, END = 35, HOME = 36, LEFT_ARROW = 37, UP_ARROW = 38, RIGHT_ARROW = 39, DOWN_ARROW = 40, ZERO = 48, NINE = 57, A = 65, Z = 90;
        function hasModifierKey(event, ...modifiers) {
            return modifiers.length ? modifiers.some(modifier => event[modifier]) : event.altKey || event.shiftKey || event.ctrlKey || event.metaKey;
        }
    },
    GU7r: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "b", (function() {
            return ContentObserver;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return CdkObserveContent;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return ObserversModule;
        }));
        var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("8LU1"), _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("fXoL"), rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("HDdC"), rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("XNiG"), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("Kj3r");
        let MutationObserverFactory = (() => {
            class MutationObserverFactory {
                create(callback) {
                    return "undefined" == typeof MutationObserver ? null : new MutationObserver(callback);
                }
            }
            return MutationObserverFactory.ɵfac = function(t) {
                return new (t || MutationObserverFactory);
            }, MutationObserverFactory.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb({
                token: MutationObserverFactory,
                factory: function(t) {
                    return MutationObserverFactory.ɵfac(t);
                },
                providedIn: "root"
            }), MutationObserverFactory.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb)({
                factory: function() {
                    return new MutationObserverFactory;
                },
                token: MutationObserverFactory,
                providedIn: "root"
            }), MutationObserverFactory;
        })(), ContentObserver = (() => {
            class ContentObserver {
                constructor(_mutationObserverFactory) {
                    this._mutationObserverFactory = _mutationObserverFactory, this._observedElements = new Map;
                }
                ngOnDestroy() {
                    this._observedElements.forEach((_, element) => this._cleanupObserver(element));
                }
                observe(elementOrRef) {
                    const element = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__.d)(elementOrRef);
                    return new rxjs__WEBPACK_IMPORTED_MODULE_2__.a(observer => {
                        const subscription = this._observeElement(element).subscribe(observer);
                        return () => {
                            subscription.unsubscribe(), this._unobserveElement(element);
                        };
                    });
                }
                _observeElement(element) {
                    if (this._observedElements.has(element)) this._observedElements.get(element).count++; else {
                        const stream = new rxjs__WEBPACK_IMPORTED_MODULE_3__.a, observer = this._mutationObserverFactory.create(mutations => stream.next(mutations));
                        observer && observer.observe(element, {
                            characterData: !0,
                            childList: !0,
                            subtree: !0
                        }), this._observedElements.set(element, {
                            observer: observer,
                            stream: stream,
                            count: 1
                        });
                    }
                    return (this._observedElements.get(element).stream);
                }
                _unobserveElement(element) {
                    this._observedElements.has(element) && (this._observedElements.get(element).count--, 
                    this._observedElements.get(element).count || this._cleanupObserver(element));
                }
                _cleanupObserver(element) {
                    if (this._observedElements.has(element)) {
                        const {observer: observer, stream: stream} = this._observedElements.get(element);
                        observer && observer.disconnect(), stream.complete(), this._observedElements.delete(element);
                    }
                }
            }
            return ContentObserver.ɵfac = function(t) {
                return new (t || ContentObserver)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(MutationObserverFactory));
            }, ContentObserver.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb({
                token: ContentObserver,
                factory: function(t) {
                    return ContentObserver.ɵfac(t);
                },
                providedIn: "root"
            }), ContentObserver.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb)({
                factory: function() {
                    return new ContentObserver(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb)(MutationObserverFactory));
                },
                token: ContentObserver,
                providedIn: "root"
            }), ContentObserver;
        })(), CdkObserveContent = (() => {
            class CdkObserveContent {
                constructor(_contentObserver, _elementRef, _ngZone) {
                    this._contentObserver = _contentObserver, this._elementRef = _elementRef, this._ngZone = _ngZone, 
                    this.event = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.m, this._disabled = !1, 
                    this._currentSubscription = null;
                }
                get disabled() {
                    return this._disabled;
                }
                set disabled(value) {
                    this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__.b)(value), 
                    this._disabled ? this._unsubscribe() : this._subscribe();
                }
                get debounce() {
                    return this._debounce;
                }
                set debounce(value) {
                    this._debounce = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__.e)(value), 
                    this._subscribe();
                }
                ngAfterContentInit() {
                    this._currentSubscription || this.disabled || this._subscribe();
                }
                ngOnDestroy() {
                    this._unsubscribe();
                }
                _subscribe() {
                    this._unsubscribe();
                    const stream = this._contentObserver.observe(this._elementRef);
                    this._ngZone.runOutsideAngular(() => {
                        this._currentSubscription = (this.debounce ? stream.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)(this.debounce)) : stream).subscribe(this.event);
                    });
                }
                _unsubscribe() {
                    this._currentSubscription && this._currentSubscription.unsubscribe();
                }
            }
            return CdkObserveContent.ɵfac = function(t) {
                return new (t || CdkObserveContent)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Pb(ContentObserver), _angular_core__WEBPACK_IMPORTED_MODULE_1__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_1__.k), _angular_core__WEBPACK_IMPORTED_MODULE_1__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_1__.y));
            }, CdkObserveContent.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Kb({
                type: CdkObserveContent,
                selectors: [ [ "", "cdkObserveContent", "" ] ],
                inputs: {
                    disabled: [ "cdkObserveContentDisabled", "disabled" ],
                    debounce: "debounce"
                },
                outputs: {
                    event: "cdkObserveContent"
                },
                exportAs: [ "cdkObserveContent" ]
            }), CdkObserveContent;
        })(), ObserversModule = (() => {
            class ObserversModule {}
            return ObserversModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Nb({
                type: ObserversModule
            }), ObserversModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Mb({
                factory: function(t) {
                    return new (t || ObserversModule);
                },
                providers: [ MutationObserverFactory ]
            }), ObserversModule;
        })();
    },
    GvZq: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return WindowToken;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return windowProvider;
        }));
        const WindowToken = new (__webpack_require__("fXoL").p)("Window");
        function windowProvider() {
            return window;
        }
    },
    GyhO: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return concat;
        }));
        var _of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("LRne"), _operators_concatAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("0EUg");
        function concat(...observables) {
            return Object(_operators_concatAll__WEBPACK_IMPORTED_MODULE_1__.a)()(Object(_of__WEBPACK_IMPORTED_MODULE_0__.a)(...observables));
        }
    },
    HDdC: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        var Subscriber = __webpack_require__("7o/Q"), rxSubscriber = __webpack_require__("2QA8"), Observer = __webpack_require__("gRHU"), observable = __webpack_require__("kJWO"), pipe = __webpack_require__("mCNh"), config = __webpack_require__("2fFW");
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Observable_Observable;
        }));
        let Observable_Observable = (() => {
            class Observable {
                constructor(subscribe) {
                    this._isScalar = !1, subscribe && (this._subscribe = subscribe);
                }
                lift(operator) {
                    const observable = new Observable;
                    return observable.source = this, observable.operator = operator, observable;
                }
                subscribe(observerOrNext, error, complete) {
                    const {operator: operator} = this, sink = function(nextOrObserver, error, complete) {
                        if (nextOrObserver) {
                            if (nextOrObserver instanceof Subscriber.a) return nextOrObserver;
                            if (nextOrObserver[rxSubscriber.a]) return nextOrObserver[rxSubscriber.a]();
                        }
                        return nextOrObserver || error || complete ? new Subscriber.a(nextOrObserver, error, complete) : new Subscriber.a(Observer.a);
                    }(observerOrNext, error, complete);
                    if (sink.add(operator ? operator.call(sink, this.source) : this.source || config.a.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink)), 
                    config.a.useDeprecatedSynchronousErrorHandling && sink.syncErrorThrowable && (sink.syncErrorThrowable = !1, 
                    sink.syncErrorThrown)) throw sink.syncErrorValue;
                    return sink;
                }
                _trySubscribe(sink) {
                    try {
                        return this._subscribe(sink);
                    } catch (err) {
                        config.a.useDeprecatedSynchronousErrorHandling && (sink.syncErrorThrown = !0, sink.syncErrorValue = err), 
                        function(observer) {
                            for (;observer; ) {
                                const {closed: closed, destination: destination, isStopped: isStopped} = observer;
                                if (closed || isStopped) return !1;
                                observer = destination && destination instanceof Subscriber.a ? destination : null;
                            }
                            return !0;
                        }(sink) ? sink.error(err) : console.warn(err);
                    }
                }
                forEach(next, promiseCtor) {
                    return new (promiseCtor = getPromiseCtor(promiseCtor))((resolve, reject) => {
                        let subscription;
                        subscription = this.subscribe(value => {
                            try {
                                next(value);
                            } catch (err) {
                                reject(err), subscription && subscription.unsubscribe();
                            }
                        }, reject, resolve);
                    });
                }
                _subscribe(subscriber) {
                    const {source: source} = this;
                    return source && source.subscribe(subscriber);
                }
                [observable.a]() {
                    return this;
                }
                pipe(...operations) {
                    return 0 === operations.length ? this : Object(pipe.b)(operations)(this);
                }
                toPromise(promiseCtor) {
                    return new (promiseCtor = getPromiseCtor(promiseCtor))((resolve, reject) => {
                        let value;
                        this.subscribe(x => value = x, err => reject(err), () => resolve(value));
                    });
                }
            }
            return Observable.create = subscribe => new Observable(subscribe), Observable;
        })();
        function getPromiseCtor(promiseCtor) {
            if (promiseCtor || (promiseCtor = config.a.Promise || Promise), !promiseCtor) throw new Error("no Promise impl found");
            return promiseCtor;
        }
    },
    I55L: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return isArrayLike;
        }));
        const isArrayLike = x => x && "number" == typeof x.length && "function" != typeof x;
    },
    IjjT: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        let Scheduler = (() => {
            class Scheduler {
                constructor(SchedulerAction, now = Scheduler.now) {
                    this.SchedulerAction = SchedulerAction, this.now = now;
                }
                schedule(work, delay = 0, state) {
                    return new this.SchedulerAction(this, work).schedule(state, delay);
                }
            }
            return Scheduler.now = () => Date.now(), Scheduler;
        })();
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AsyncScheduler_AsyncScheduler;
        }));
        class AsyncScheduler_AsyncScheduler extends Scheduler {
            constructor(SchedulerAction, now = Scheduler.now) {
                super(SchedulerAction, () => AsyncScheduler_AsyncScheduler.delegate && AsyncScheduler_AsyncScheduler.delegate !== this ? AsyncScheduler_AsyncScheduler.delegate.now() : now()), 
                this.actions = [], this.active = !1, this.scheduled = void 0;
            }
            schedule(work, delay = 0, state) {
                return AsyncScheduler_AsyncScheduler.delegate && AsyncScheduler_AsyncScheduler.delegate !== this ? AsyncScheduler_AsyncScheduler.delegate.schedule(work, delay, state) : super.schedule(work, delay, state);
            }
            flush(action) {
                const {actions: actions} = this;
                if (this.active) return void actions.push(action);
                let error;
                this.active = !0;
                do {
                    if (error = action.execute(action.state, action.delay)) break;
                } while (action = actions.shift());
                if (this.active = !1, error) {
                    for (;action = actions.shift(); ) action.unsubscribe();
                    throw error;
                }
            }
        }
    },
    IzEk: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return take;
        }));
        var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7o/Q"), _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("4I5i"), _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("EY2u");
        function take(count) {
            return source => 0 === count ? Object(_observable_empty__WEBPACK_IMPORTED_MODULE_2__.b)() : source.lift(new TakeOperator(count));
        }
        class TakeOperator {
            constructor(total) {
                if (this.total = total, this.total < 0) throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__.a;
            }
            call(subscriber, source) {
                return source.subscribe(new TakeSubscriber(subscriber, this.total));
            }
        }
        class TakeSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(destination, total) {
                super(destination), this.total = total, this.count = 0;
            }
            _next(value) {
                const total = this.total, count = ++this.count;
                count <= total && (this.destination.next(value), count === total && (this.destination.complete(), 
                this.unsubscribe()));
            }
        }
    },
    JIr8: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return catchError;
        }));
        var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("l7GE"), _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("51Dv"), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("ZUHj");
        function catchError(selector) {
            return function(source) {
                const operator = new CatchOperator(selector), caught = source.lift(operator);
                return operator.caught = caught;
            };
        }
        class CatchOperator {
            constructor(selector) {
                this.selector = selector;
            }
            call(subscriber, source) {
                return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
            }
        }
        class CatchSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(destination, selector, caught) {
                super(destination), this.selector = selector, this.caught = caught;
            }
            error(err) {
                if (!this.isStopped) {
                    let result;
                    try {
                        result = this.selector(err, this.caught);
                    } catch (err2) {
                        return void super.error(err2);
                    }
                    this._unsubscribeAndRecycle();
                    const innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__.a(this, void 0, void 0);
                    this.add(innerSubscriber), Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__.a)(this, result, void 0, void 0, innerSubscriber);
                }
            }
        }
    },
    JX91: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return startWith;
        }));
        var _observable_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("GyhO"), _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("z+Ro");
        function startWith(...array) {
            const scheduler = array[array.length - 1];
            return Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__.a)(scheduler) ? (array.pop(), 
            source => Object(_observable_concat__WEBPACK_IMPORTED_MODULE_0__.a)(array, source, scheduler)) : source => Object(_observable_concat__WEBPACK_IMPORTED_MODULE_0__.a)(array, source);
        }
    },
    Jho9: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        var common = __webpack_require__("ofXK"), core = __webpack_require__("fXoL"), defer = __webpack_require__("NXyV"), throwError = __webpack_require__("z6cu"), fromEvent = __webpack_require__("xgIS"), of = __webpack_require__("LRne"), concat = __webpack_require__("GyhO"), Subject = __webpack_require__("XNiG"), never = __webpack_require__("5yfJ"), merge = __webpack_require__("VRyK"), map = __webpack_require__("lJxs"), filter = __webpack_require__("pLZG"), switchMap = __webpack_require__("eIep"), multicast = __webpack_require__("oB13"), take = __webpack_require__("IzEk"), tap = __webpack_require__("vkgz"), scheduler_async = __webpack_require__("D0XW"), Subscriber = __webpack_require__("7o/Q"), Notification = __webpack_require__("WMd4");
        class DelayOperator {
            constructor(delay, scheduler) {
                this.delay = delay, this.scheduler = scheduler;
            }
            call(subscriber, source) {
                return source.subscribe(new delay_DelaySubscriber(subscriber, this.delay, this.scheduler));
            }
        }
        class delay_DelaySubscriber extends Subscriber.a {
            constructor(destination, delay, scheduler) {
                super(destination), this.delay = delay, this.scheduler = scheduler, this.queue = [], 
                this.active = !1, this.errored = !1;
            }
            static dispatch(state) {
                const source = state.source, queue = source.queue, scheduler = state.scheduler, destination = state.destination;
                for (;queue.length > 0 && queue[0].time - scheduler.now() <= 0; ) queue.shift().notification.observe(destination);
                if (queue.length > 0) {
                    const delay = Math.max(0, queue[0].time - scheduler.now());
                    this.schedule(state, delay);
                } else this.unsubscribe(), source.active = !1;
            }
            _schedule(scheduler) {
                this.active = !0, this.destination.add(scheduler.schedule(delay_DelaySubscriber.dispatch, this.delay, {
                    source: this,
                    destination: this.destination,
                    scheduler: scheduler
                }));
            }
            scheduleNotification(notification) {
                if (!0 === this.errored) return;
                const scheduler = this.scheduler, message = new DelayMessage(scheduler.now() + this.delay, notification);
                this.queue.push(message), !1 === this.active && this._schedule(scheduler);
            }
            _next(value) {
                this.scheduleNotification(Notification.a.createNext(value));
            }
            _error(err) {
                this.errored = !0, this.queue = [], this.destination.error(err), this.unsubscribe();
            }
            _complete() {
                this.scheduleNotification(Notification.a.createComplete()), this.unsubscribe();
            }
        }
        class DelayMessage {
            constructor(time, notification) {
                this.time = time, this.notification = notification;
            }
        }
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return service_worker_ServiceWorkerModule;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return service_worker_SwUpdate;
        }));
        const ERR_SW_NOT_SUPPORTED = "Service workers are disabled or not supported by this browser";
        class service_worker_NgswCommChannel {
            constructor(serviceWorker) {
                if (this.serviceWorker = serviceWorker, serviceWorker) {
                    const controllerChanges = Object(fromEvent.a)(serviceWorker, "controllerchange").pipe(Object(map.a)(() => serviceWorker.controller)), currentController = Object(defer.a)(() => Object(of.a)(serviceWorker.controller)), controllerWithChanges = Object(concat.a)(currentController, controllerChanges);
                    this.worker = controllerWithChanges.pipe(Object(filter.a)(c => !!c)), this.registration = this.worker.pipe(Object(switchMap.a)(() => serviceWorker.getRegistration()));
                    const events = Object(fromEvent.a)(serviceWorker, "message").pipe(Object(map.a)(event => event.data)).pipe(Object(filter.a)(event => event && event.type)).pipe(Object(multicast.a)(new Subject.a));
                    events.connect(), this.events = events;
                } else this.worker = this.events = this.registration = (message = ERR_SW_NOT_SUPPORTED, 
                Object(defer.a)(() => Object(throwError.a)(new Error(message))));
                var message;
            }
            postMessage(action, payload) {
                return this.worker.pipe(Object(take.a)(1), Object(tap.a)(sw => {
                    sw.postMessage(Object.assign({
                        action: action
                    }, payload));
                })).toPromise().then(() => void 0);
            }
            postMessageWithStatus(type, payload, nonce) {
                const waitForStatus = this.waitForStatus(nonce), postMessage = this.postMessage(type, payload);
                return Promise.all([ waitForStatus, postMessage ]).then(() => void 0);
            }
            generateNonce() {
                return Math.round(1e7 * Math.random());
            }
            eventsOfType(type) {
                return this.events.pipe(Object(filter.a)(event => event.type === type));
            }
            nextEventOfType(type) {
                return this.eventsOfType(type).pipe(Object(take.a)(1));
            }
            waitForStatus(nonce) {
                return this.eventsOfType("STATUS").pipe(Object(filter.a)(event => event.nonce === nonce), Object(take.a)(1), Object(map.a)(event => {
                    if (!event.status) throw new Error(event.error);
                })).toPromise();
            }
            get isEnabled() {
                return !!this.serviceWorker;
            }
        }
        let service_worker_SwPush = (() => {
            class SwPush {
                constructor(sw) {
                    if (this.sw = sw, this.subscriptionChanges = new Subject.a, !sw.isEnabled) return this.messages = never.a, 
                    this.notificationClicks = never.a, void (this.subscription = never.a);
                    this.messages = this.sw.eventsOfType("PUSH").pipe(Object(map.a)(message => message.data)), 
                    this.notificationClicks = this.sw.eventsOfType("NOTIFICATION_CLICK").pipe(Object(map.a)(message => message.data)), 
                    this.pushManager = this.sw.registration.pipe(Object(map.a)(registration => registration.pushManager));
                    const workerDrivenSubscriptions = this.pushManager.pipe(Object(switchMap.a)(pm => pm.getSubscription()));
                    this.subscription = Object(merge.a)(workerDrivenSubscriptions, this.subscriptionChanges);
                }
                get isEnabled() {
                    return this.sw.isEnabled;
                }
                requestSubscription(options) {
                    if (!this.sw.isEnabled) return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));
                    const pushOptions = {
                        userVisibleOnly: !0
                    };
                    let key = this.decodeBase64(options.serverPublicKey.replace(/_/g, "/").replace(/-/g, "+")), applicationServerKey = new Uint8Array(new ArrayBuffer(key.length));
                    for (let i = 0; i < key.length; i++) applicationServerKey[i] = key.charCodeAt(i);
                    return pushOptions.applicationServerKey = applicationServerKey, this.pushManager.pipe(Object(switchMap.a)(pm => pm.subscribe(pushOptions)), Object(take.a)(1)).toPromise().then(sub => (this.subscriptionChanges.next(sub), 
                    sub));
                }
                unsubscribe() {
                    return this.sw.isEnabled ? this.subscription.pipe(Object(take.a)(1), Object(switchMap.a)(sub => {
                        if (null === sub) throw new Error("Not subscribed to push notifications.");
                        return sub.unsubscribe().then(success => {
                            if (!success) throw new Error("Unsubscribe failed!");
                            this.subscriptionChanges.next(null);
                        });
                    })).toPromise() : Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));
                }
                decodeBase64(input) {
                    return atob(input);
                }
            }
            return SwPush.ɵfac = function(t) {
                return new (t || SwPush)(core.Zb(service_worker_NgswCommChannel));
            }, SwPush.ɵprov = core.Lb({
                token: SwPush,
                factory: function(t) {
                    return SwPush.ɵfac(t);
                },
                providedIn: null
            }), SwPush;
        })(), service_worker_SwUpdate = (() => {
            class SwUpdate {
                constructor(sw) {
                    if (this.sw = sw, !sw.isEnabled) return this.available = never.a, void (this.activated = never.a);
                    this.available = this.sw.eventsOfType("UPDATE_AVAILABLE"), this.activated = this.sw.eventsOfType("UPDATE_ACTIVATED");
                }
                get isEnabled() {
                    return this.sw.isEnabled;
                }
                checkForUpdate() {
                    if (!this.sw.isEnabled) return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));
                    const statusNonce = this.sw.generateNonce();
                    return this.sw.postMessageWithStatus("CHECK_FOR_UPDATES", {
                        statusNonce: statusNonce
                    }, statusNonce);
                }
                activateUpdate() {
                    if (!this.sw.isEnabled) return Promise.reject(new Error(ERR_SW_NOT_SUPPORTED));
                    const statusNonce = this.sw.generateNonce();
                    return this.sw.postMessageWithStatus("ACTIVATE_UPDATE", {
                        statusNonce: statusNonce
                    }, statusNonce);
                }
            }
            return SwUpdate.ɵfac = function(t) {
                return new (t || SwUpdate)(core.Zb(service_worker_NgswCommChannel));
            }, SwUpdate.ɵprov = core.Lb({
                token: SwUpdate,
                factory: function(t) {
                    return SwUpdate.ɵfac(t);
                },
                providedIn: null
            }), SwUpdate;
        })();
        class SwRegistrationOptions {}
        const SCRIPT = new core.p("NGSW_REGISTER_SCRIPT");
        function ngswAppInitializer(injector, script, options, platformId) {
            return () => {
                if (!(Object(common.s)(platformId) && "serviceWorker" in navigator && !1 !== options.enabled)) return;
                let readyToRegister$;
                if (navigator.serviceWorker.addEventListener("controllerchange", () => {
                    null !== navigator.serviceWorker.controller && navigator.serviceWorker.controller.postMessage({
                        action: "INITIALIZE"
                    });
                }), "function" == typeof options.registrationStrategy) readyToRegister$ = options.registrationStrategy(); else {
                    const [strategy, ...args] = (options.registrationStrategy || "registerWhenStable").split(":");
                    switch (strategy) {
                      case "registerImmediately":
                        readyToRegister$ = Object(of.a)(null);
                        break;

                      case "registerWithDelay":
                        readyToRegister$ = Object(of.a)(null).pipe(function(delay, scheduler = scheduler_async.a) {
                            var value;
                            const delayFor = (value = delay) instanceof Date && !isNaN(+value) ? +delay - scheduler.now() : Math.abs(delay);
                            return source => source.lift(new DelayOperator(delayFor, scheduler));
                        }(+args[0] || 0));
                        break;

                      case "registerWhenStable":
                        readyToRegister$ = injector.get(core.g).isStable.pipe(Object(filter.a)(stable => stable));
                        break;

                      default:
                        throw new Error(`Unknown ServiceWorker registration strategy: ${options.registrationStrategy}`);
                    }
                }
                readyToRegister$.pipe(Object(take.a)(1)).subscribe(() => navigator.serviceWorker.register(script, {
                    scope: options.scope
                }).catch(err => console.error("Service worker registration failed with:", err)));
            };
        }
        function ngswCommChannelFactory(opts, platformId) {
            return new service_worker_NgswCommChannel(Object(common.s)(platformId) && !1 !== opts.enabled ? navigator.serviceWorker : void 0);
        }
        let service_worker_ServiceWorkerModule = (() => {
            class ServiceWorkerModule {
                static register(script, opts = {}) {
                    return {
                        ngModule: ServiceWorkerModule,
                        providers: [ {
                            provide: SCRIPT,
                            useValue: script
                        }, {
                            provide: SwRegistrationOptions,
                            useValue: opts
                        }, {
                            provide: service_worker_NgswCommChannel,
                            useFactory: ngswCommChannelFactory,
                            deps: [ SwRegistrationOptions, core.A ]
                        }, {
                            provide: core.d,
                            useFactory: ngswAppInitializer,
                            deps: [ core.q, SCRIPT, SwRegistrationOptions, core.A ],
                            multi: !0
                        } ]
                    };
                }
            }
            return ServiceWorkerModule.ɵmod = core.Nb({
                type: ServiceWorkerModule
            }), ServiceWorkerModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || ServiceWorkerModule);
                },
                providers: [ service_worker_SwPush, service_worker_SwUpdate ]
            }), ServiceWorkerModule;
        })();
    },
    Kj3r: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return debounceTime;
        }));
        var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7o/Q"), _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("D0XW");
        function debounceTime(dueTime, scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.a) {
            return source => source.lift(new DebounceTimeOperator(dueTime, scheduler));
        }
        class DebounceTimeOperator {
            constructor(dueTime, scheduler) {
                this.dueTime = dueTime, this.scheduler = scheduler;
            }
            call(subscriber, source) {
                return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
            }
        }
        class DebounceTimeSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(destination, dueTime, scheduler) {
                super(destination), this.dueTime = dueTime, this.scheduler = scheduler, this.debouncedSubscription = null, 
                this.lastValue = null, this.hasValue = !1;
            }
            _next(value) {
                this.clearDebounce(), this.lastValue = value, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
            }
            _complete() {
                this.debouncedNext(), this.destination.complete();
            }
            debouncedNext() {
                if (this.clearDebounce(), this.hasValue) {
                    const {lastValue: lastValue} = this;
                    this.lastValue = null, this.hasValue = !1, this.destination.next(lastValue);
                }
            }
            clearDebounce() {
                const debouncedSubscription = this.debouncedSubscription;
                null !== debouncedSubscription && (this.remove(debouncedSubscription), debouncedSubscription.unsubscribe(), 
                this.debouncedSubscription = null);
            }
        }
        function dispatchNext(subscriber) {
            subscriber.debouncedNext();
        }
    },
    KqfI: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        function noop() {}
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return noop;
        }));
    },
    LRne: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return of;
        }));
        var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("z+Ro"), _fromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("yCtX"), _scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("jZKg");
        function of(...args) {
            let scheduler = args[args.length - 1];
            return Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__.a)(scheduler) ? (args.pop(), 
            Object(_scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__.a)(args, scheduler)) : Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__.a)(args);
        }
    },
    Lhse: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        function getSymbolIterator() {
            return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator";
        }
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return iterator;
        }));
        const iterator = getSymbolIterator();
    },
    LwjS: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return SearchResultsComponent;
        }));
        var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("fXoL"), _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("ofXK");
        function SearchResultsComponent_div_1_Template(rf, ctx) {
            1 & rf && _angular_core__WEBPACK_IMPORTED_MODULE_0__.Qb(0, "div");
        }
        function SearchResultsComponent_ng_template_2_div_2_li_4_span_2_Template(rf, ctx) {
            if (1 & rf && _angular_core__WEBPACK_IMPORTED_MODULE_0__.Qb(0, "span"), 2 & rf) {
                const page_r29 = _angular_core__WEBPACK_IMPORTED_MODULE_0__.gc().$implicit;
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Eb("symbol ", page_r29.type, "");
            }
        }
        function SearchResultsComponent_ng_template_2_div_2_li_4_Template(rf, ctx) {
            if (1 & rf) {
                const _r33 = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Wb();
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(0, "li", 10), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(1, "a", 11), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.cc("click", (function($event) {
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.uc(_r33);
                    const page_r29 = ctx.$implicit;
                    return _angular_core__WEBPACK_IMPORTED_MODULE_0__.gc(3).onResultSelected(page_r29, $event);
                })), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Cc(2, SearchResultsComponent_ng_template_2_div_2_li_4_span_2_Template, 1, 3, "span", 12), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(3, "span"), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ec(4), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb(), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb(), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb();
            }
            if (2 & rf) {
                const page_r29 = ctx.$implicit, area_r26 = _angular_core__WEBPACK_IMPORTED_MODULE_0__.gc().$implicit;
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(1), _angular_core__WEBPACK_IMPORTED_MODULE_0__.mc("href", page_r29.path, _angular_core__WEBPACK_IMPORTED_MODULE_0__.wc), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(1), _angular_core__WEBPACK_IMPORTED_MODULE_0__.lc("ngIf", "api" === area_r26.name), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(1), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Fb("deprecated-api-item", page_r29.deprecated), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(1), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Fc(page_r29.title);
            }
        }
        function SearchResultsComponent_ng_template_2_div_2_li_6_span_2_Template(rf, ctx) {
            if (1 & rf && _angular_core__WEBPACK_IMPORTED_MODULE_0__.Qb(0, "span"), 2 & rf) {
                const page_r35 = _angular_core__WEBPACK_IMPORTED_MODULE_0__.gc().$implicit;
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Eb("symbol ", page_r35.type, "");
            }
        }
        function SearchResultsComponent_ng_template_2_div_2_li_6_Template(rf, ctx) {
            if (1 & rf) {
                const _r39 = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Wb();
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(0, "li", 10), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(1, "a", 11), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.cc("click", (function($event) {
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.uc(_r39);
                    const page_r35 = ctx.$implicit;
                    return _angular_core__WEBPACK_IMPORTED_MODULE_0__.gc(3).onResultSelected(page_r35, $event);
                })), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Cc(2, SearchResultsComponent_ng_template_2_div_2_li_6_span_2_Template, 1, 3, "span", 12), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(3, "span"), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ec(4), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb(), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb(), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb();
            }
            if (2 & rf) {
                const page_r35 = ctx.$implicit, area_r26 = _angular_core__WEBPACK_IMPORTED_MODULE_0__.gc().$implicit;
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(1), _angular_core__WEBPACK_IMPORTED_MODULE_0__.mc("href", page_r35.path, _angular_core__WEBPACK_IMPORTED_MODULE_0__.wc), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(1), _angular_core__WEBPACK_IMPORTED_MODULE_0__.lc("ngIf", "api" === area_r26.name), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(1), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Fb("deprecated-api-item", page_r35.deprecated), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(1), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Fc(page_r35.title);
            }
        }
        function SearchResultsComponent_ng_template_2_div_2_Template(rf, ctx) {
            if (1 & rf && (_angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(0, "div", 6), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(1, "h3", 7), 
            _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ec(2), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb(), 
            _angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(3, "ul", 8), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Cc(4, SearchResultsComponent_ng_template_2_div_2_li_4_Template, 5, 4, "li", 9), 
            _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb(), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(5, "ul"), 
            _angular_core__WEBPACK_IMPORTED_MODULE_0__.Cc(6, SearchResultsComponent_ng_template_2_div_2_li_6_Template, 5, 4, "li", 9), 
            _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb(), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb()), 
            2 & rf) {
                const area_r26 = ctx.$implicit;
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(2), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Hc("", area_r26.name, " (", area_r26.pages.length + area_r26.priorityPages.length, ")"), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(2), _angular_core__WEBPACK_IMPORTED_MODULE_0__.lc("ngForOf", area_r26.priorityPages), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(2), _angular_core__WEBPACK_IMPORTED_MODULE_0__.lc("ngForOf", area_r26.pages);
            }
        }
        function SearchResultsComponent_ng_template_2_Template(rf, ctx) {
            if (1 & rf && (_angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(0, "h2", 4), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ec(1, "Search Results"), 
            _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb(), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Cc(2, SearchResultsComponent_ng_template_2_div_2_Template, 7, 4, "div", 5)), 
            2 & rf) {
                const ctx_r22 = _angular_core__WEBPACK_IMPORTED_MODULE_0__.gc();
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(2), _angular_core__WEBPACK_IMPORTED_MODULE_0__.lc("ngForOf", ctx_r22.searchAreas);
            }
        }
        function SearchResultsComponent_ng_template_4_Template(rf, ctx) {
            if (1 & rf && (_angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(0, "p", 13), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ec(1), 
            _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb()), 2 & rf) {
                const ctx_r24 = _angular_core__WEBPACK_IMPORTED_MODULE_0__.gc();
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(1), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Fc(ctx_r24.notFoundMessage);
            }
        }
        let SearchResultsComponent = (() => {
            class SearchResultsComponent {
                constructor() {
                    this.searchResults = null, this.resultSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.m, 
                    this.defaultArea = "other", this.notFoundMessage = "Searching ...", this.topLevelFolders = [ "guide", "tutorial" ], 
                    this.searchAreas = [];
                }
                ngOnChanges() {
                    this.searchAreas = this.processSearchResults(this.searchResults);
                }
                onResultSelected(page, event) {
                    0 !== event.button || event.ctrlKey || event.metaKey || this.resultSelected.emit(page);
                }
                processSearchResults(search) {
                    if (!search) return [];
                    this.notFoundMessage = "No results found.";
                    const searchAreaMap = {};
                    return search.results.forEach(result => {
                        if (!result.title) return;
                        const areaName = this.computeAreaName(result) || this.defaultArea;
                        (searchAreaMap[areaName] = searchAreaMap[areaName] || []).push(result);
                    }), Object.keys(searchAreaMap).sort((l, r) => l > r ? 1 : -1).map(name => {
                        const {priorityPages: priorityPages, pages: pages, deprecated: deprecated} = function(allPages) {
                            const priorityPages = [], pages = [], deprecated = [];
                            for (allPages.forEach(page => {
                                page.deprecated ? deprecated.push(page) : priorityPages.length < 5 ? priorityPages.push(page) : pages.push(page);
                            }); priorityPages.length < 5 && pages.length; ) priorityPages.push(pages.shift());
                            for (;priorityPages.length < 5 && deprecated.length; ) priorityPages.push(deprecated.shift());
                            return pages.sort(compareResults), {
                                priorityPages: priorityPages,
                                pages: pages,
                                deprecated: deprecated
                            };
                        }(searchAreaMap[name]);
                        return {
                            name: name,
                            priorityPages: priorityPages,
                            pages: pages.concat(deprecated)
                        };
                    });
                }
                computeAreaName(result) {
                    if (-1 !== this.topLevelFolders.indexOf(result.path)) return result.path;
                    const [areaName, rest] = result.path.split("/", 2);
                    return rest && areaName;
                }
            }
            return SearchResultsComponent.ɵfac = function(t) {
                return new (t || SearchResultsComponent);
            }, SearchResultsComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Jb({
                type: SearchResultsComponent,
                selectors: [ [ "aio-search-results" ] ],
                inputs: {
                    searchResults: "searchResults"
                },
                outputs: {
                    resultSelected: "resultSelected"
                },
                features: [ _angular_core__WEBPACK_IMPORTED_MODULE_0__.yb() ],
                decls: 6,
                vars: 3,
                consts: [ [ 1, "search-results" ], [ 4, "ngIf", "ngIfThen", "ngIfElse" ], [ "searchResults", "" ], [ "notFound", "" ], [ 1, "visually-hidden" ], [ "class", "search-area", 4, "ngFor", "ngForOf" ], [ 1, "search-area" ], [ 1, "search-section-header" ], [ 1, "priority-pages" ], [ "class", "search-page", 4, "ngFor", "ngForOf" ], [ 1, "search-page" ], [ 1, "search-result-item", 3, "href", "click" ], [ 3, "class", 4, "ngIf" ], [ 1, "not-found" ] ],
                template: function(rf, ctx) {
                    if (1 & rf && (_angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(0, "div", 0), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Cc(1, SearchResultsComponent_div_1_Template, 1, 0, "div", 1), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb(), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Cc(2, SearchResultsComponent_ng_template_2_Template, 3, 1, "ng-template", null, 2, _angular_core__WEBPACK_IMPORTED_MODULE_0__.Dc), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.Cc(4, SearchResultsComponent_ng_template_4_Template, 2, 1, "ng-template", null, 3, _angular_core__WEBPACK_IMPORTED_MODULE_0__.Dc)), 
                    2 & rf) {
                        const _r21 = _angular_core__WEBPACK_IMPORTED_MODULE_0__.rc(3), _r23 = _angular_core__WEBPACK_IMPORTED_MODULE_0__.rc(5);
                        _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(1), _angular_core__WEBPACK_IMPORTED_MODULE_0__.lc("ngIf", ctx.searchAreas.length)("ngIfThen", _r21)("ngIfElse", _r23);
                    }
                },
                directives: [ _angular_common__WEBPACK_IMPORTED_MODULE_1__.k, _angular_common__WEBPACK_IMPORTED_MODULE_1__.j ],
                encapsulation: 2
            }), SearchResultsComponent;
        })();
        function compareResults(l, r) {
            return l.title.toUpperCase() > r.title.toUpperCase() ? 1 : -1;
        }
    },
    NFeN: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        var core = __webpack_require__("fXoL"), fesm2015_core = __webpack_require__("FKr1"), coercion = __webpack_require__("8LU1"), common = __webpack_require__("ofXK"), tap = __webpack_require__("vkgz"), map = __webpack_require__("lJxs"), catchError = __webpack_require__("JIr8"), finalize = __webpack_require__("nYR2"), share = __webpack_require__("w1tV"), take = __webpack_require__("IzEk"), http = __webpack_require__("tk/3"), platform_browser = __webpack_require__("jhN1"), of = __webpack_require__("LRne"), throwError = __webpack_require__("z6cu"), Observable = __webpack_require__("HDdC"), isArray = __webpack_require__("DH7j"), isObject = __webpack_require__("XoHu"), from = __webpack_require__("Cfvw");
        function forkJoinInternal(sources, keys) {
            return new Observable.a(subscriber => {
                const len = sources.length;
                if (0 === len) return void subscriber.complete();
                const values = new Array(len);
                let completed = 0, emitted = 0;
                for (let i = 0; i < len; i++) {
                    const source = Object(from.a)(sources[i]);
                    let hasValue = !1;
                    subscriber.add(source.subscribe({
                        next: value => {
                            hasValue || (hasValue = !0, emitted++), values[i] = value;
                        },
                        error: err => subscriber.error(err),
                        complete: () => {
                            ++completed !== len && hasValue || (emitted === len && subscriber.next(keys ? keys.reduce((result, key, i) => (result[key] = values[i], 
                            result), {}) : values), subscriber.complete());
                        }
                    }));
                }
            });
        }
        __webpack_require__.d(__webpack_exports__, "b", (function() {
            return icon_MatIconModule;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return icon_MatIcon;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return icon_MatIconRegistry;
        }));
        const _c0 = [ "role", "img", 1, "mat-icon", "notranslate" ], _c1 = [ "*" ];
        function getMatIconNameNotFoundError(iconName) {
            return Error(`Unable to find icon with the name "${iconName}"`);
        }
        function getMatIconFailedToSanitizeUrlError(url) {
            return Error("The URL provided to MatIconRegistry was not trusted as a resource URL " + `via Angular's DomSanitizer. Attempted URL was "${url}".`);
        }
        function getMatIconFailedToSanitizeLiteralError(literal) {
            return Error("The literal provided to MatIconRegistry was not trusted as safe HTML by " + `Angular's DomSanitizer. Attempted literal was "${literal}".`);
        }
        class SvgIconConfig {
            constructor(data, options) {
                this.options = options, data.nodeName ? this.svgElement = data : this.url = data;
            }
        }
        let icon_MatIconRegistry = (() => {
            class MatIconRegistry {
                constructor(_httpClient, _sanitizer, document, _errorHandler) {
                    this._httpClient = _httpClient, this._sanitizer = _sanitizer, this._errorHandler = _errorHandler, 
                    this._svgIconConfigs = new Map, this._iconSetConfigs = new Map, this._cachedIconsByUrl = new Map, 
                    this._inProgressUrlFetches = new Map, this._fontCssClassesByAlias = new Map, this._defaultFontSetClass = "material-icons", 
                    this._document = document;
                }
                addSvgIcon(iconName, url, options) {
                    return this.addSvgIconInNamespace("", iconName, url, options);
                }
                addSvgIconLiteral(iconName, literal, options) {
                    return this.addSvgIconLiteralInNamespace("", iconName, literal, options);
                }
                addSvgIconInNamespace(namespace, iconName, url, options) {
                    return this._addSvgIconConfig(namespace, iconName, new SvgIconConfig(url, options));
                }
                addSvgIconLiteralInNamespace(namespace, iconName, literal, options) {
                    const sanitizedLiteral = this._sanitizer.sanitize(core.H.HTML, literal);
                    if (!sanitizedLiteral) throw getMatIconFailedToSanitizeLiteralError(literal);
                    const svgElement = this._createSvgElementForSingleIcon(sanitizedLiteral, options);
                    return (this._addSvgIconConfig(namespace, iconName, new SvgIconConfig(svgElement, options)));
                }
                addSvgIconSet(url, options) {
                    return this.addSvgIconSetInNamespace("", url, options);
                }
                addSvgIconSetLiteral(literal, options) {
                    return this.addSvgIconSetLiteralInNamespace("", literal, options);
                }
                addSvgIconSetInNamespace(namespace, url, options) {
                    return this._addSvgIconSetConfig(namespace, new SvgIconConfig(url, options));
                }
                addSvgIconSetLiteralInNamespace(namespace, literal, options) {
                    const sanitizedLiteral = this._sanitizer.sanitize(core.H.HTML, literal);
                    if (!sanitizedLiteral) throw getMatIconFailedToSanitizeLiteralError(literal);
                    const svgElement = this._svgElementFromString(sanitizedLiteral);
                    return (this._addSvgIconSetConfig(namespace, new SvgIconConfig(svgElement, options)));
                }
                registerFontClassAlias(alias, className = alias) {
                    return this._fontCssClassesByAlias.set(alias, className), this;
                }
                classNameForFontAlias(alias) {
                    return this._fontCssClassesByAlias.get(alias) || alias;
                }
                setDefaultFontSetClass(className) {
                    return this._defaultFontSetClass = className, this;
                }
                getDefaultFontSetClass() {
                    return this._defaultFontSetClass;
                }
                getSvgIconFromUrl(safeUrl) {
                    const url = this._sanitizer.sanitize(core.H.RESOURCE_URL, safeUrl);
                    if (!url) throw getMatIconFailedToSanitizeUrlError(safeUrl);
                    const cachedIcon = this._cachedIconsByUrl.get(url);
                    return cachedIcon ? Object(of.a)(cloneSvg(cachedIcon)) : this._loadSvgIconFromConfig(new SvgIconConfig(safeUrl)).pipe(Object(tap.a)(svg => this._cachedIconsByUrl.set(url, svg)), Object(map.a)(svg => cloneSvg(svg)));
                }
                getNamedSvgIcon(name, namespace = "") {
                    const key = iconKey(namespace, name), config = this._svgIconConfigs.get(key);
                    if (config) return this._getSvgFromConfig(config);
                    const iconSetConfigs = this._iconSetConfigs.get(namespace);
                    return iconSetConfigs ? this._getSvgFromIconSetConfigs(name, iconSetConfigs) : Object(throwError.a)(getMatIconNameNotFoundError(key));
                }
                ngOnDestroy() {
                    this._svgIconConfigs.clear(), this._iconSetConfigs.clear(), this._cachedIconsByUrl.clear();
                }
                _getSvgFromConfig(config) {
                    return config.svgElement ? Object(of.a)(cloneSvg(config.svgElement)) : this._loadSvgIconFromConfig(config).pipe(Object(tap.a)(svg => config.svgElement = svg), Object(map.a)(svg => cloneSvg(svg)));
                }
                _getSvgFromIconSetConfigs(name, iconSetConfigs) {
                    const namedIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);
                    return namedIcon ? Object(of.a)(namedIcon) : function(...sources) {
                        if (1 === sources.length) {
                            const first = sources[0];
                            if (Object(isArray.a)(first)) return forkJoinInternal(first, null);
                            if (Object(isObject.a)(first) && Object.getPrototypeOf(first) === Object.prototype) {
                                const keys = Object.keys(first);
                                return forkJoinInternal(keys.map(key => first[key]), keys);
                            }
                        }
                        if ("function" == typeof sources[sources.length - 1]) {
                            const resultSelector = sources.pop();
                            return forkJoinInternal(sources = 1 === sources.length && Object(isArray.a)(sources[0]) ? sources[0] : sources, null).pipe(Object(map.a)(args => resultSelector(...args)));
                        }
                        return forkJoinInternal(sources, null);
                    }(iconSetConfigs.filter(iconSetConfig => !iconSetConfig.svgElement).map(iconSetConfig => this._loadSvgIconSetFromConfig(iconSetConfig).pipe(Object(catchError.a)(err => {
                        const errorMessage = `Loading icon set URL: ${this._sanitizer.sanitize(core.H.RESOURCE_URL, iconSetConfig.url)} failed: ${err.message}`;
                        return this._errorHandler ? this._errorHandler.handleError(new Error(errorMessage)) : console.error(errorMessage), 
                        Object(of.a)(null);
                    })))).pipe(Object(map.a)(() => {
                        const foundIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);
                        if (!foundIcon) throw getMatIconNameNotFoundError(name);
                        return foundIcon;
                    }));
                }
                _extractIconWithNameFromAnySet(iconName, iconSetConfigs) {
                    for (let i = iconSetConfigs.length - 1; i >= 0; i--) {
                        const config = iconSetConfigs[i];
                        if (config.svgElement) {
                            const foundIcon = this._extractSvgIconFromSet(config.svgElement, iconName, config.options);
                            if (foundIcon) return foundIcon;
                        }
                    }
                    return null;
                }
                _loadSvgIconFromConfig(config) {
                    return this._fetchUrl(config.url).pipe(Object(map.a)(svgText => this._createSvgElementForSingleIcon(svgText, config.options)));
                }
                _loadSvgIconSetFromConfig(config) {
                    return config.svgElement ? Object(of.a)(config.svgElement) : this._fetchUrl(config.url).pipe(Object(map.a)(svgText => (config.svgElement || (config.svgElement = this._svgElementFromString(svgText)), 
                    config.svgElement)));
                }
                _createSvgElementForSingleIcon(responseText, options) {
                    const svg = this._svgElementFromString(responseText);
                    return this._setSvgAttributes(svg, options), svg;
                }
                _extractSvgIconFromSet(iconSet, iconName, options) {
                    const iconSource = iconSet.querySelector(`[id="${iconName}"]`);
                    if (!iconSource) return null;
                    const iconElement = iconSource.cloneNode(!0);
                    if (iconElement.removeAttribute("id"), "svg" === iconElement.nodeName.toLowerCase()) return this._setSvgAttributes(iconElement, options);
                    if ("symbol" === iconElement.nodeName.toLowerCase()) return this._setSvgAttributes(this._toSvgElement(iconElement), options);
                    const svg = this._svgElementFromString("<svg></svg>");
                    return svg.appendChild(iconElement), this._setSvgAttributes(svg, options);
                }
                _svgElementFromString(str) {
                    const div = this._document.createElement("DIV");
                    div.innerHTML = str;
                    const svg = div.querySelector("svg");
                    if (!svg) throw Error("<svg> tag not found");
                    return svg;
                }
                _toSvgElement(element) {
                    const svg = this._svgElementFromString("<svg></svg>"), attributes = element.attributes;
                    for (let i = 0; i < attributes.length; i++) {
                        const {name: name, value: value} = attributes[i];
                        "id" !== name && svg.setAttribute(name, value);
                    }
                    for (let i = 0; i < element.childNodes.length; i++) element.childNodes[i].nodeType === this._document.ELEMENT_NODE && svg.appendChild(element.childNodes[i].cloneNode(!0));
                    return svg;
                }
                _setSvgAttributes(svg, options) {
                    return svg.setAttribute("fit", ""), svg.setAttribute("height", "100%"), svg.setAttribute("width", "100%"), 
                    svg.setAttribute("preserveAspectRatio", "xMidYMid meet"), svg.setAttribute("focusable", "false"), 
                    options && options.viewBox && svg.setAttribute("viewBox", options.viewBox), svg;
                }
                _fetchUrl(safeUrl) {
                    if (!this._httpClient) throw Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports.");
                    if (null == safeUrl) throw Error(`Cannot fetch icon from URL "${safeUrl}".`);
                    const url = this._sanitizer.sanitize(core.H.RESOURCE_URL, safeUrl);
                    if (!url) throw getMatIconFailedToSanitizeUrlError(safeUrl);
                    const inProgressFetch = this._inProgressUrlFetches.get(url);
                    if (inProgressFetch) return inProgressFetch;
                    const req = this._httpClient.get(url, {
                        responseType: "text"
                    }).pipe(Object(finalize.a)(() => this._inProgressUrlFetches.delete(url)), Object(share.a)());
                    return this._inProgressUrlFetches.set(url, req), req;
                }
                _addSvgIconConfig(namespace, iconName, config) {
                    return this._svgIconConfigs.set(iconKey(namespace, iconName), config), this;
                }
                _addSvgIconSetConfig(namespace, config) {
                    const configNamespace = this._iconSetConfigs.get(namespace);
                    return configNamespace ? configNamespace.push(config) : this._iconSetConfigs.set(namespace, [ config ]), 
                    this;
                }
            }
            return MatIconRegistry.ɵfac = function(t) {
                return new (t || MatIconRegistry)(core.Zb(http.a, 8), core.Zb(platform_browser.b), core.Zb(common.d, 8), core.Zb(core.l, 8));
            }, MatIconRegistry.ɵprov = core.Lb({
                token: MatIconRegistry,
                factory: function(t) {
                    return MatIconRegistry.ɵfac(t);
                },
                providedIn: "root"
            }), MatIconRegistry.ngInjectableDef = Object(core.Lb)({
                factory: function() {
                    return new MatIconRegistry(Object(core.Zb)(http.a, 8), Object(core.Zb)(platform_browser.b), Object(core.Zb)(common.d, 8), Object(core.Zb)(core.l, 8));
                },
                token: MatIconRegistry,
                providedIn: "root"
            }), MatIconRegistry;
        })();
        function cloneSvg(svg) {
            return svg.cloneNode(!0);
        }
        function iconKey(namespace, name) {
            return namespace + ":" + name;
        }
        class MatIconBase {
            constructor(_elementRef) {
                this._elementRef = _elementRef;
            }
        }
        const _MatIconMixinBase = Object(fesm2015_core.f)(MatIconBase), MAT_ICON_LOCATION = new core.p("mat-icon-location", {
            providedIn: "root",
            factory: function() {
                const _document = Object(core.V)(common.d), _location = _document ? _document.location : null;
                return {
                    getPathname: () => _location ? _location.pathname + _location.search : ""
                };
            }
        }), funcIriAttributes = [ "clip-path", "color-profile", "src", "cursor", "fill", "filter", "marker", "marker-start", "marker-mid", "marker-end", "mask", "stroke" ], funcIriAttributeSelector = funcIriAttributes.map(attr => `[${attr}]`).join(", "), funcIriPattern = /^url\(['"]?#(.*?)['"]?\)$/;
        let icon_MatIcon = (() => {
            class MatIcon extends _MatIconMixinBase {
                constructor(elementRef, _iconRegistry, ariaHidden, _location, _errorHandler) {
                    super(elementRef), this._iconRegistry = _iconRegistry, this._location = _location, 
                    this._errorHandler = _errorHandler, this._inline = !1, ariaHidden || elementRef.nativeElement.setAttribute("aria-hidden", "true");
                }
                get inline() {
                    return this._inline;
                }
                set inline(inline) {
                    this._inline = Object(coercion.b)(inline);
                }
                get fontSet() {
                    return this._fontSet;
                }
                set fontSet(value) {
                    this._fontSet = this._cleanupFontValue(value);
                }
                get fontIcon() {
                    return this._fontIcon;
                }
                set fontIcon(value) {
                    this._fontIcon = this._cleanupFontValue(value);
                }
                _splitIconName(iconName) {
                    if (!iconName) return [ "", "" ];
                    const parts = iconName.split(":");
                    switch (parts.length) {
                      case 1:
                        return [ "", parts[0] ];

                      case 2:
                        return parts;

                      default:
                        throw Error(`Invalid icon name: "${iconName}"`);
                    }
                }
                ngOnChanges(changes) {
                    const svgIconChanges = changes.svgIcon;
                    if (svgIconChanges) if (this.svgIcon) {
                        const [namespace, iconName] = this._splitIconName(this.svgIcon);
                        this._iconRegistry.getNamedSvgIcon(iconName, namespace).pipe(Object(take.a)(1)).subscribe(svg => this._setSvgElement(svg), err => {
                            const errorMessage = `Error retrieving icon ${namespace}:${iconName}! ${err.message}`;
                            this._errorHandler ? this._errorHandler.handleError(new Error(errorMessage)) : console.error(errorMessage);
                        });
                    } else svgIconChanges.previousValue && this._clearSvgElement();
                    this._usingFontIcon() && this._updateFontIconClasses();
                }
                ngOnInit() {
                    this._usingFontIcon() && this._updateFontIconClasses();
                }
                ngAfterViewChecked() {
                    const cachedElements = this._elementsWithExternalReferences;
                    if (cachedElements && this._location && cachedElements.size) {
                        const newPath = this._location.getPathname();
                        newPath !== this._previousPath && (this._previousPath = newPath, this._prependPathToReferences(newPath));
                    }
                }
                ngOnDestroy() {
                    this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear();
                }
                _usingFontIcon() {
                    return !this.svgIcon;
                }
                _setSvgElement(svg) {
                    this._clearSvgElement();
                    const styleTags = svg.querySelectorAll("style");
                    for (let i = 0; i < styleTags.length; i++) styleTags[i].textContent += " ";
                    if (this._location) {
                        const path = this._location.getPathname();
                        this._previousPath = path, this._cacheChildrenWithExternalReferences(svg), this._prependPathToReferences(path);
                    }
                    this._elementRef.nativeElement.appendChild(svg);
                }
                _clearSvgElement() {
                    const layoutElement = this._elementRef.nativeElement;
                    let childCount = layoutElement.childNodes.length;
                    for (this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear(); childCount--; ) {
                        const child = layoutElement.childNodes[childCount];
                        1 === child.nodeType && "svg" !== child.nodeName.toLowerCase() || layoutElement.removeChild(child);
                    }
                }
                _updateFontIconClasses() {
                    if (!this._usingFontIcon()) return;
                    const elem = this._elementRef.nativeElement, fontSetClass = this.fontSet ? this._iconRegistry.classNameForFontAlias(this.fontSet) : this._iconRegistry.getDefaultFontSetClass();
                    fontSetClass != this._previousFontSetClass && (this._previousFontSetClass && elem.classList.remove(this._previousFontSetClass), 
                    fontSetClass && elem.classList.add(fontSetClass), this._previousFontSetClass = fontSetClass), 
                    this.fontIcon != this._previousFontIconClass && (this._previousFontIconClass && elem.classList.remove(this._previousFontIconClass), 
                    this.fontIcon && elem.classList.add(this.fontIcon), this._previousFontIconClass = this.fontIcon);
                }
                _cleanupFontValue(value) {
                    return "string" == typeof value ? value.trim().split(" ")[0] : value;
                }
                _prependPathToReferences(path) {
                    const elements = this._elementsWithExternalReferences;
                    elements && elements.forEach((attrs, element) => {
                        attrs.forEach(attr => {
                            element.setAttribute(attr.name, `url('${path}#${attr.value}')`);
                        });
                    });
                }
                _cacheChildrenWithExternalReferences(element) {
                    const elementsWithFuncIri = element.querySelectorAll(funcIriAttributeSelector), elements = this._elementsWithExternalReferences = this._elementsWithExternalReferences || new Map;
                    for (let i = 0; i < elementsWithFuncIri.length; i++) funcIriAttributes.forEach(attr => {
                        const elementWithReference = elementsWithFuncIri[i], value = elementWithReference.getAttribute(attr), match = value ? value.match(funcIriPattern) : null;
                        if (match) {
                            let attributes = elements.get(elementWithReference);
                            attributes || elements.set(elementWithReference, attributes = []), attributes.push({
                                name: attr,
                                value: match[1]
                            });
                        }
                    });
                }
            }
            return MatIcon.ɵfac = function(t) {
                return new (t || MatIcon)(core.Pb(core.k), core.Pb(icon_MatIconRegistry), core.ac("aria-hidden"), core.Pb(MAT_ICON_LOCATION, 8), core.Pb(core.l, 8));
            }, MatIcon.ɵcmp = core.Jb({
                type: MatIcon,
                selectors: [ [ "mat-icon" ] ],
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (core.Bb(2), core.Ub(_c0)), 2 & rf && (core.Fb("mat-icon-inline", ctx.inline), 
                    core.Fb("mat-icon-no-color", "primary" !== ctx.color && "accent" !== ctx.color && "warn" !== ctx.color));
                },
                inputs: {
                    color: "color",
                    inline: "inline",
                    fontSet: "fontSet",
                    fontIcon: "fontIcon",
                    svgIcon: "svgIcon"
                },
                exportAs: [ "matIcon" ],
                features: [ core.xb, core.yb() ],
                ngContentSelectors: _c1,
                decls: 1,
                vars: 0,
                template: function(rf, ctx) {
                    1 & rf && (core.kc(), core.jc(0));
                },
                styles: [ ".mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}/*# sourceMappingURL=icon.css.map */\n" ],
                encapsulation: 2,
                changeDetection: 0
            }), MatIcon;
        })(), icon_MatIconModule = (() => {
            class MatIconModule {}
            return MatIconModule.ɵmod = core.Nb({
                type: MatIconModule
            }), MatIconModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || MatIconModule);
                },
                imports: [ [ fesm2015_core.b ], fesm2015_core.b ]
            }), MatIconModule;
        })();
    },
    "NHP+": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AsyncSubject;
        }));
        var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("XNiG"), _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("quSY");
        class AsyncSubject extends _Subject__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor() {
                super(...arguments), this.value = null, this.hasNext = !1, this.hasCompleted = !1;
            }
            _subscribe(subscriber) {
                return this.hasError ? (subscriber.error(this.thrownError), _Subscription__WEBPACK_IMPORTED_MODULE_1__.a.EMPTY) : this.hasCompleted && this.hasNext ? (subscriber.next(this.value), 
                subscriber.complete(), _Subscription__WEBPACK_IMPORTED_MODULE_1__.a.EMPTY) : super._subscribe(subscriber);
            }
            next(value) {
                this.hasCompleted || (this.value = value, this.hasNext = !0);
            }
            error(error) {
                this.hasCompleted || super.error(error);
            }
            complete() {
                this.hasCompleted = !0, this.hasNext && super.next(this.value), super.complete();
            }
        }
    },
    NJ4a: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        function hostReportError(err) {
            setTimeout(() => {
                throw err;
            }, 0);
        }
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return hostReportError;
        }));
    },
    NXyV: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return defer;
        }));
        var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("HDdC"), _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Cfvw"), _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("EY2u");
        function defer(observableFactory) {
            return new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(subscriber => {
                let input;
                try {
                    input = observableFactory();
                } catch (err) {
                    return void subscriber.error(err);
                }
                return (input ? Object(_from__WEBPACK_IMPORTED_MODULE_1__.a)(input) : Object(_empty__WEBPACK_IMPORTED_MODULE_2__.b)()).subscribe(subscriber);
            });
        }
    },
    Nv8m: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return race;
        }));
        var _util_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("DH7j"), _fromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("yCtX"), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("l7GE"), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("ZUHj");
        function race(...observables) {
            if (1 === observables.length) {
                if (!Object(_util_isArray__WEBPACK_IMPORTED_MODULE_0__.a)(observables[0])) return observables[0];
                observables = observables[0];
            }
            return Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__.a)(observables, void 0).lift(new RaceOperator);
        }
        class RaceOperator {
            call(subscriber, source) {
                return source.subscribe(new RaceSubscriber(subscriber));
            }
        }
        class RaceSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__.a {
            constructor(destination) {
                super(destination), this.hasFirst = !1, this.observables = [], this.subscriptions = [];
            }
            _next(observable) {
                this.observables.push(observable);
            }
            _complete() {
                const observables = this.observables, len = observables.length;
                if (0 === len) this.destination.complete(); else {
                    for (let i = 0; i < len && !this.hasFirst; i++) {
                        let observable = observables[i], subscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__.a)(this, observable, observable, i);
                        this.subscriptions && this.subscriptions.push(subscription), this.add(subscription);
                    }
                    this.observables = null;
                }
            }
            notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                if (!this.hasFirst) {
                    this.hasFirst = !0;
                    for (let i = 0; i < this.subscriptions.length; i++) if (i !== outerIndex) {
                        let subscription = this.subscriptions[i];
                        subscription.unsubscribe(), this.remove(subscription);
                    }
                    this.subscriptions = null;
                }
                this.destination.next(innerValue);
            }
        }
    },
    PCNd: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return SharedModule;
        }));
        var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ofXK"), _angular_core__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_require__("LwjS"), 
        __webpack_require__("x4lQ"), __webpack_require__("fXoL"));
        let SharedModule = (() => {
            class SharedModule {}
            return SharedModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_3__.Nb({
                type: SharedModule
            }), SharedModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_3__.Mb({
                factory: function(t) {
                    return new (t || SharedModule);
                },
                imports: [ [ _angular_common__WEBPACK_IMPORTED_MODULE_0__.c ] ]
            }), SharedModule;
        })();
    },
    PqYM: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return timer;
        }));
        var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("HDdC"), _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("D0XW"), _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("Y7HM"), _util_isScheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("z+Ro");
        function timer(dueTime = 0, periodOrScheduler, scheduler) {
            let period = -1;
            return Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__.a)(periodOrScheduler) ? period = Number(periodOrScheduler) < 1 ? 1 : Number(periodOrScheduler) : Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__.a)(periodOrScheduler) && (scheduler = periodOrScheduler), 
            Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__.a)(scheduler) || (scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.a), 
            new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(subscriber => {
                const due = Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__.a)(dueTime) ? dueTime : +dueTime - scheduler.now();
                return scheduler.schedule(dispatch, due, {
                    index: 0,
                    period: period,
                    subscriber: subscriber
                });
            });
        }
        function dispatch(state) {
            const {index: index, period: period, subscriber: subscriber} = state;
            if (subscriber.next(index), !subscriber.closed) {
                if (-1 === period) return subscriber.complete();
                state.index = index + 1, this.schedule(state, period);
            }
        }
    },
    R0Ic: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return AUTO_STYLE;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return AnimationBuilder;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return AnimationFactory;
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return NoopAnimationPlayer;
        })), __webpack_require__.d(__webpack_exports__, "e", (function() {
            return animate;
        })), __webpack_require__.d(__webpack_exports__, "f", (function() {
            return sequence;
        })), __webpack_require__.d(__webpack_exports__, "g", (function() {
            return state;
        })), __webpack_require__.d(__webpack_exports__, "h", (function() {
            return style;
        })), __webpack_require__.d(__webpack_exports__, "i", (function() {
            return transition;
        })), __webpack_require__.d(__webpack_exports__, "j", (function() {
            return trigger;
        })), __webpack_require__.d(__webpack_exports__, "k", (function() {
            return AnimationGroupPlayer;
        })), __webpack_require__.d(__webpack_exports__, "l", (function() {
            return ɵPRE_STYLE;
        }));
        class AnimationBuilder {}
        class AnimationFactory {}
        const AUTO_STYLE = "*";
        function trigger(name, definitions) {
            return {
                type: 7,
                name: name,
                definitions: definitions,
                options: {}
            };
        }
        function animate(timings, styles = null) {
            return {
                type: 4,
                styles: styles,
                timings: timings
            };
        }
        function sequence(steps, options = null) {
            return {
                type: 2,
                steps: steps,
                options: options
            };
        }
        function style(tokens) {
            return {
                type: 6,
                styles: tokens,
                offset: null
            };
        }
        function state(name, styles, options) {
            return {
                type: 0,
                name: name,
                styles: styles,
                options: options
            };
        }
        function transition(stateChangeExpr, steps, options = null) {
            return {
                type: 1,
                expr: stateChangeExpr,
                animation: steps,
                options: options
            };
        }
        function scheduleMicroTask(cb) {
            Promise.resolve(null).then(cb);
        }
        class NoopAnimationPlayer {
            constructor(duration = 0, delay = 0) {
                this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, 
                this._destroyed = !1, this._finished = !1, this.parentPlayer = null, this.totalTime = duration + delay;
            }
            _onFinish() {
                this._finished || (this._finished = !0, this._onDoneFns.forEach(fn => fn()), this._onDoneFns = []);
            }
            onStart(fn) {
                this._onStartFns.push(fn);
            }
            onDone(fn) {
                this._onDoneFns.push(fn);
            }
            onDestroy(fn) {
                this._onDestroyFns.push(fn);
            }
            hasStarted() {
                return this._started;
            }
            init() {}
            play() {
                this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0;
            }
            triggerMicrotask() {
                scheduleMicroTask(() => this._onFinish());
            }
            _onStart() {
                this._onStartFns.forEach(fn => fn()), this._onStartFns = [];
            }
            pause() {}
            restart() {}
            finish() {
                this._onFinish();
            }
            destroy() {
                this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), 
                this.finish(), this._onDestroyFns.forEach(fn => fn()), this._onDestroyFns = []);
            }
            reset() {}
            setPosition(position) {}
            getPosition() {
                return 0;
            }
            triggerCallback(phaseName) {
                const methods = "start" == phaseName ? this._onStartFns : this._onDoneFns;
                methods.forEach(fn => fn()), methods.length = 0;
            }
        }
        class AnimationGroupPlayer {
            constructor(_players) {
                this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, 
                this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, 
                this.players = _players;
                let doneCount = 0, destroyCount = 0, startCount = 0;
                const total = this.players.length;
                0 == total ? scheduleMicroTask(() => this._onFinish()) : this.players.forEach(player => {
                    player.onDone(() => {
                        ++doneCount == total && this._onFinish();
                    }), player.onDestroy(() => {
                        ++destroyCount == total && this._onDestroy();
                    }), player.onStart(() => {
                        ++startCount == total && this._onStart();
                    });
                }), this.totalTime = this.players.reduce((time, player) => Math.max(time, player.totalTime), 0);
            }
            _onFinish() {
                this._finished || (this._finished = !0, this._onDoneFns.forEach(fn => fn()), this._onDoneFns = []);
            }
            init() {
                this.players.forEach(player => player.init());
            }
            onStart(fn) {
                this._onStartFns.push(fn);
            }
            _onStart() {
                this.hasStarted() || (this._started = !0, this._onStartFns.forEach(fn => fn()), 
                this._onStartFns = []);
            }
            onDone(fn) {
                this._onDoneFns.push(fn);
            }
            onDestroy(fn) {
                this._onDestroyFns.push(fn);
            }
            hasStarted() {
                return this._started;
            }
            play() {
                this.parentPlayer || this.init(), this._onStart(), this.players.forEach(player => player.play());
            }
            pause() {
                this.players.forEach(player => player.pause());
            }
            restart() {
                this.players.forEach(player => player.restart());
            }
            finish() {
                this._onFinish(), this.players.forEach(player => player.finish());
            }
            destroy() {
                this._onDestroy();
            }
            _onDestroy() {
                this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(player => player.destroy()), 
                this._onDestroyFns.forEach(fn => fn()), this._onDestroyFns = []);
            }
            reset() {
                this.players.forEach(player => player.reset()), this._destroyed = !1, this._finished = !1, 
                this._started = !1;
            }
            setPosition(p) {
                const timeAtPosition = p * this.totalTime;
                this.players.forEach(player => {
                    const position = player.totalTime ? Math.min(1, timeAtPosition / player.totalTime) : 1;
                    player.setPosition(position);
                });
            }
            getPosition() {
                let min = 0;
                return this.players.forEach(player => {
                    const p = player.getPosition();
                    min = Math.min(p, min);
                }), min;
            }
            beforeDestroy() {
                this.players.forEach(player => {
                    player.beforeDestroy && player.beforeDestroy();
                });
            }
            triggerCallback(phaseName) {
                const methods = "start" == phaseName ? this._onStartFns : this._onDoneFns;
                methods.forEach(fn => fn()), methods.length = 0;
            }
        }
        const ɵPRE_STYLE = "!";
    },
    R1ws: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        var core = __webpack_require__("fXoL"), platform_browser = __webpack_require__("jhN1"), animations = __webpack_require__("R0Ic");
        function isNode() {
            return "undefined" != typeof process;
        }
        function optimizeGroupPlayer(players) {
            switch (players.length) {
              case 0:
                return new animations.d;

              case 1:
                return players[0];

              default:
                return new animations.k(players);
            }
        }
        function normalizeKeyframes(driver, normalizer, element, keyframes, preStyles = {}, postStyles = {}) {
            const errors = [], normalizedKeyframes = [];
            let previousOffset = -1, previousKeyframe = null;
            if (keyframes.forEach(kf => {
                const offset = kf.offset, isSameOffset = offset == previousOffset, normalizedKeyframe = isSameOffset && previousKeyframe || {};
                Object.keys(kf).forEach(prop => {
                    let normalizedProp = prop, normalizedValue = kf[prop];
                    if ("offset" !== prop) switch (normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors), 
                    normalizedValue) {
                      case animations.l:
                        normalizedValue = preStyles[prop];
                        break;

                      case animations.a:
                        normalizedValue = postStyles[prop];
                        break;

                      default:
                        normalizedValue = normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);
                    }
                    normalizedKeyframe[normalizedProp] = normalizedValue;
                }), isSameOffset || normalizedKeyframes.push(normalizedKeyframe), previousKeyframe = normalizedKeyframe, 
                previousOffset = offset;
            }), errors.length) {
                const LINE_START = "\n - ";
                throw new Error(`Unable to animate due to the following errors:${LINE_START}${errors.join(LINE_START)}`);
            }
            return normalizedKeyframes;
        }
        function listenOnPlayer(player, eventName, event, callback) {
            switch (eventName) {
              case "start":
                player.onStart(() => callback(event && copyAnimationEvent(event, "start", player)));
                break;

              case "done":
                player.onDone(() => callback(event && copyAnimationEvent(event, "done", player)));
                break;

              case "destroy":
                player.onDestroy(() => callback(event && copyAnimationEvent(event, "destroy", player)));
            }
        }
        function copyAnimationEvent(e, phaseName, player) {
            const totalTime = player.totalTime, event = makeAnimationEvent(e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName, null == totalTime ? e.totalTime : totalTime, !!player.disabled), data = e._data;
            return null != data && (event._data = data), event;
        }
        function makeAnimationEvent(element, triggerName, fromState, toState, phaseName = "", totalTime = 0, disabled) {
            return {
                element: element,
                triggerName: triggerName,
                fromState: fromState,
                toState: toState,
                phaseName: phaseName,
                totalTime: totalTime,
                disabled: !!disabled
            };
        }
        function getOrSetAsInMap(map, key, defaultValue) {
            let value;
            return map instanceof Map ? (value = map.get(key)) || map.set(key, value = defaultValue) : (value = map[key]) || (value = map[key] = defaultValue), 
            value;
        }
        function parseTimelineCommand(command) {
            const separatorPos = command.indexOf(":");
            return [ command.substring(1, separatorPos), command.substr(separatorPos + 1) ];
        }
        let _contains = (elm1, elm2) => !1, _matches = (element, selector) => !1, _query = (element, selector, multi) => [];
        const _isNode = isNode();
        (_isNode || "undefined" != typeof Element) && (_contains = (elm1, elm2) => elm1.contains(elm2), 
        _matches = (() => {
            if (_isNode || Element.prototype.matches) return (element, selector) => element.matches(selector);
            {
                const proto = Element.prototype, fn = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
                return fn ? (element, selector) => fn.apply(element, [ selector ]) : _matches;
            }
        })(), _query = (element, selector, multi) => {
            let results = [];
            if (multi) results.push(...element.querySelectorAll(selector)); else {
                const elm = element.querySelector(selector);
                elm && results.push(elm);
            }
            return results;
        });
        let _CACHED_BODY = null, _IS_WEBKIT = !1;
        function validateStyleProperty(prop) {
            _CACHED_BODY || (_CACHED_BODY = ("undefined" != typeof document ? document.body : null) || {}, 
            _IS_WEBKIT = !!_CACHED_BODY.style && "WebkitAppearance" in _CACHED_BODY.style);
            let result = !0;
            return _CACHED_BODY.style && !function(prop) {
                return "ebkit" == prop.substring(1, 6);
            }(prop) && !(result = prop in _CACHED_BODY.style) && _IS_WEBKIT && (result = "Webkit" + prop.charAt(0).toUpperCase() + prop.substr(1) in _CACHED_BODY.style), 
            result;
        }
        const matchesElement = _matches, containsElement = _contains, invokeQuery = _query;
        function hypenatePropsObject(object) {
            const newObj = {};
            return Object.keys(object).forEach(prop => {
                const newProp = prop.replace(/([a-z])([A-Z])/g, "$1-$2");
                newObj[newProp] = object[prop];
            }), newObj;
        }
        let browser_NoopAnimationDriver = (() => {
            class NoopAnimationDriver {
                validateStyleProperty(prop) {
                    return validateStyleProperty(prop);
                }
                matchesElement(element, selector) {
                    return matchesElement(element, selector);
                }
                containsElement(elm1, elm2) {
                    return containsElement(elm1, elm2);
                }
                query(element, selector, multi) {
                    return invokeQuery(element, selector, multi);
                }
                computeStyle(element, prop, defaultValue) {
                    return defaultValue || "";
                }
                animate(element, keyframes, duration, delay, easing, previousPlayers = [], scrubberAccessRequested) {
                    return new animations.d(duration, delay);
                }
            }
            return NoopAnimationDriver.ɵfac = function(t) {
                return new (t || NoopAnimationDriver);
            }, NoopAnimationDriver.ɵprov = core.Lb({
                token: NoopAnimationDriver,
                factory: function(t) {
                    return NoopAnimationDriver.ɵfac(t);
                },
                providedIn: null
            }), NoopAnimationDriver;
        })(), AnimationDriver = (() => {
            class AnimationDriver {}
            return AnimationDriver.NOOP = new browser_NoopAnimationDriver, AnimationDriver;
        })();
        const ONE_SECOND = 1e3, SUBSTITUTION_EXPR_START = "{{", ENTER_CLASSNAME = "ng-enter", LEAVE_CLASSNAME = "ng-leave", NG_TRIGGER_CLASSNAME = "ng-trigger", NG_TRIGGER_SELECTOR = ".ng-trigger", NG_ANIMATING_CLASSNAME = "ng-animating", NG_ANIMATING_SELECTOR = ".ng-animating";
        function resolveTimingValue(value) {
            if ("number" == typeof value) return value;
            const matches = value.match(/^(-?[\.\d]+)(m?s)/);
            return !matches || matches.length < 2 ? 0 : _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
        }
        function _convertTimeValueToMS(value, unit) {
            switch (unit) {
              case "s":
                return value * ONE_SECOND;

              default:
                return value;
            }
        }
        function resolveTiming(timings, errors, allowNegativeValues) {
            return timings.hasOwnProperty("duration") ? timings : function(exp, errors, allowNegativeValues) {
                let duration, delay = 0, easing = "";
                if ("string" == typeof exp) {
                    const matches = exp.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);
                    if (null === matches) return errors.push(`The provided timing value "${exp}" is invalid.`), 
                    {
                        duration: 0,
                        delay: 0,
                        easing: ""
                    };
                    duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
                    const delayMatch = matches[3];
                    null != delayMatch && (delay = _convertTimeValueToMS(parseFloat(delayMatch), matches[4]));
                    const easingVal = matches[5];
                    easingVal && (easing = easingVal);
                } else duration = exp;
                if (!allowNegativeValues) {
                    let containsErrors = !1, startIndex = errors.length;
                    duration < 0 && (errors.push("Duration values below 0 are not allowed for this animation step."), 
                    containsErrors = !0), delay < 0 && (errors.push("Delay values below 0 are not allowed for this animation step."), 
                    containsErrors = !0), containsErrors && errors.splice(startIndex, 0, `The provided timing value "${exp}" is invalid.`);
                }
                return {
                    duration: duration,
                    delay: delay,
                    easing: easing
                };
            }(timings, errors, allowNegativeValues);
        }
        function copyObj(obj, destination = {}) {
            return Object.keys(obj).forEach(prop => {
                destination[prop] = obj[prop];
            }), destination;
        }
        function copyStyles(styles, readPrototype, destination = {}) {
            if (readPrototype) for (let prop in styles) destination[prop] = styles[prop]; else copyObj(styles, destination);
            return destination;
        }
        function getStyleAttributeString(element, key, value) {
            return value ? key + ":" + value + ";" : "";
        }
        function writeStyleAttribute(element) {
            let styleAttrValue = "";
            for (let i = 0; i < element.style.length; i++) {
                const key = element.style.item(i);
                styleAttrValue += getStyleAttributeString(0, key, element.style.getPropertyValue(key));
            }
            for (const key in element.style) element.style.hasOwnProperty(key) && !key.startsWith("_") && (styleAttrValue += getStyleAttributeString(0, key.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), element.style[key]));
            element.setAttribute("style", styleAttrValue);
        }
        function setStyles(element, styles, formerStyles) {
            element.style && (Object.keys(styles).forEach(prop => {
                const camelProp = dashCaseToCamelCase(prop);
                formerStyles && !formerStyles.hasOwnProperty(prop) && (formerStyles[prop] = element.style[camelProp]), 
                element.style[camelProp] = styles[prop];
            }), isNode() && writeStyleAttribute(element));
        }
        function eraseStyles(element, styles) {
            element.style && (Object.keys(styles).forEach(prop => {
                const camelProp = dashCaseToCamelCase(prop);
                element.style[camelProp] = "";
            }), isNode() && writeStyleAttribute(element));
        }
        function normalizeAnimationEntry(steps) {
            return Array.isArray(steps) ? 1 == steps.length ? steps[0] : Object(animations.f)(steps) : steps;
        }
        const PARAM_REGEX = new RegExp(`${SUBSTITUTION_EXPR_START}\\s*(.+?)\\s*}}`, "g");
        function extractStyleParams(value) {
            let params = [];
            if ("string" == typeof value) {
                let match;
                for (;match = PARAM_REGEX.exec(value); ) params.push(match[1]);
                PARAM_REGEX.lastIndex = 0;
            }
            return params;
        }
        function interpolateParams(value, params, errors) {
            const original = value.toString(), str = original.replace(PARAM_REGEX, (_, varName) => {
                let localVal = params[varName];
                return params.hasOwnProperty(varName) || (errors.push(`Please provide a value for the animation param ${varName}`), 
                localVal = ""), localVal.toString();
            });
            return str == original ? value : str;
        }
        function iteratorToArray(iterator) {
            const arr = [];
            let item = iterator.next();
            for (;!item.done; ) arr.push(item.value), item = iterator.next();
            return arr;
        }
        const DASH_CASE_REGEXP = /-+([a-z0-9])/g;
        function dashCaseToCamelCase(input) {
            return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());
        }
        function allowPreviousPlayerStylesMerge(duration, delay) {
            return 0 === duration || 0 === delay;
        }
        function balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles) {
            const previousStyleProps = Object.keys(previousStyles);
            if (previousStyleProps.length && keyframes.length) {
                let startingKeyframe = keyframes[0], missingStyleProps = [];
                if (previousStyleProps.forEach(prop => {
                    startingKeyframe.hasOwnProperty(prop) || missingStyleProps.push(prop), startingKeyframe[prop] = previousStyles[prop];
                }), missingStyleProps.length) for (var i = 1; i < keyframes.length; i++) {
                    let kf = keyframes[i];
                    missingStyleProps.forEach((function(prop) {
                        kf[prop] = computeStyle(element, prop);
                    }));
                }
            }
            return keyframes;
        }
        function visitDslNode(visitor, node, context) {
            switch (node.type) {
              case 7:
                return visitor.visitTrigger(node, context);

              case 0:
                return visitor.visitState(node, context);

              case 1:
                return visitor.visitTransition(node, context);

              case 2:
                return visitor.visitSequence(node, context);

              case 3:
                return visitor.visitGroup(node, context);

              case 4:
                return visitor.visitAnimate(node, context);

              case 5:
                return visitor.visitKeyframes(node, context);

              case 6:
                return visitor.visitStyle(node, context);

              case 8:
                return visitor.visitReference(node, context);

              case 9:
                return visitor.visitAnimateChild(node, context);

              case 10:
                return visitor.visitAnimateRef(node, context);

              case 11:
                return visitor.visitQuery(node, context);

              case 12:
                return visitor.visitStagger(node, context);

              default:
                throw new Error(`Unable to resolve animation metadata node #${node.type}`);
            }
        }
        function computeStyle(element, prop) {
            return window.getComputedStyle(element)[prop];
        }
        const ANY_STATE = "*";
        function parseTransitionExpr(transitionValue, errors) {
            const expressions = [];
            return "string" == typeof transitionValue ? transitionValue.split(/\s*,\s*/).forEach(str => (function(eventStr, expressions, errors) {
                if (":" == eventStr[0]) {
                    const result = function(alias, errors) {
                        switch (alias) {
                          case ":enter":
                            return "void => *";

                          case ":leave":
                            return "* => void";

                          case ":increment":
                            return (fromState, toState) => parseFloat(toState) > parseFloat(fromState);

                          case ":decrement":
                            return (fromState, toState) => parseFloat(toState) < parseFloat(fromState);

                          default:
                            return errors.push(`The transition alias value "${alias}" is not supported`), "* => *";
                        }
                    }(eventStr, errors);
                    if ("function" == typeof result) return void expressions.push(result);
                    eventStr = result;
                }
                const match = eventStr.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
                if (null == match || match.length < 4) return errors.push(`The provided transition expression "${eventStr}" is not supported`), 
                expressions;
                const fromState = match[1], separator = match[2], toState = match[3];
                expressions.push(makeLambdaFromStates(fromState, toState)), "<" != separator[0] || fromState == ANY_STATE && toState == ANY_STATE || expressions.push(makeLambdaFromStates(toState, fromState));
            })(str, expressions, errors)) : expressions.push(transitionValue), expressions;
        }
        const TRUE_BOOLEAN_VALUES = new Set([ "true", "1" ]), FALSE_BOOLEAN_VALUES = new Set([ "false", "0" ]);
        function makeLambdaFromStates(lhs, rhs) {
            const LHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(lhs) || FALSE_BOOLEAN_VALUES.has(lhs), RHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(rhs) || FALSE_BOOLEAN_VALUES.has(rhs);
            return (fromState, toState) => {
                let lhsMatch = lhs == ANY_STATE || lhs == fromState, rhsMatch = rhs == ANY_STATE || rhs == toState;
                return !lhsMatch && LHS_MATCH_BOOLEAN && "boolean" == typeof fromState && (lhsMatch = fromState ? TRUE_BOOLEAN_VALUES.has(lhs) : FALSE_BOOLEAN_VALUES.has(lhs)), 
                !rhsMatch && RHS_MATCH_BOOLEAN && "boolean" == typeof toState && (rhsMatch = toState ? TRUE_BOOLEAN_VALUES.has(rhs) : FALSE_BOOLEAN_VALUES.has(rhs)), 
                lhsMatch && rhsMatch;
            };
        }
        const SELF_TOKEN = ":self", SELF_TOKEN_REGEX = new RegExp(`s*${SELF_TOKEN}s*,?`, "g");
        function buildAnimationAst(driver, metadata, errors) {
            return new browser_AnimationAstBuilderVisitor(driver).build(metadata, errors);
        }
        const ROOT_SELECTOR = "";
        class browser_AnimationAstBuilderVisitor {
            constructor(_driver) {
                this._driver = _driver;
            }
            build(metadata, errors) {
                const context = new AnimationAstBuilderContext(errors);
                return this._resetContextStyleTimingState(context), visitDslNode(this, normalizeAnimationEntry(metadata), context);
            }
            _resetContextStyleTimingState(context) {
                context.currentQuerySelector = ROOT_SELECTOR, context.collectedStyles = {}, context.collectedStyles[ROOT_SELECTOR] = {}, 
                context.currentTime = 0;
            }
            visitTrigger(metadata, context) {
                let queryCount = context.queryCount = 0, depCount = context.depCount = 0;
                const states = [], transitions = [];
                return "@" == metadata.name.charAt(0) && context.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"), 
                metadata.definitions.forEach(def => {
                    if (this._resetContextStyleTimingState(context), 0 == def.type) {
                        const stateDef = def, name = stateDef.name;
                        name.toString().split(/\s*,\s*/).forEach(n => {
                            stateDef.name = n, states.push(this.visitState(stateDef, context));
                        }), stateDef.name = name;
                    } else if (1 == def.type) {
                        const transition = this.visitTransition(def, context);
                        queryCount += transition.queryCount, depCount += transition.depCount, transitions.push(transition);
                    } else context.errors.push("only state() and transition() definitions can sit inside of a trigger()");
                }), {
                    type: 7,
                    name: metadata.name,
                    states: states,
                    transitions: transitions,
                    queryCount: queryCount,
                    depCount: depCount,
                    options: null
                };
            }
            visitState(metadata, context) {
                const styleAst = this.visitStyle(metadata.styles, context), astParams = metadata.options && metadata.options.params || null;
                if (styleAst.containsDynamicStyles) {
                    const missingSubs = new Set, params = astParams || {};
                    if (styleAst.styles.forEach(value => {
                        if (isObject(value)) {
                            const stylesObj = value;
                            Object.keys(stylesObj).forEach(prop => {
                                extractStyleParams(stylesObj[prop]).forEach(sub => {
                                    params.hasOwnProperty(sub) || missingSubs.add(sub);
                                });
                            });
                        }
                    }), missingSubs.size) {
                        const missingSubsArr = iteratorToArray(missingSubs.values());
                        context.errors.push(`state("${metadata.name}", ...) must define default values for all the following style substitutions: ${missingSubsArr.join(", ")}`);
                    }
                }
                return {
                    type: 0,
                    name: metadata.name,
                    style: styleAst,
                    options: astParams ? {
                        params: astParams
                    } : null
                };
            }
            visitTransition(metadata, context) {
                context.queryCount = 0, context.depCount = 0;
                const animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);
                return {
                    type: 1,
                    matchers: parseTransitionExpr(metadata.expr, context.errors),
                    animation: animation,
                    queryCount: context.queryCount,
                    depCount: context.depCount,
                    options: normalizeAnimationOptions(metadata.options)
                };
            }
            visitSequence(metadata, context) {
                return {
                    type: 2,
                    steps: metadata.steps.map(s => visitDslNode(this, s, context)),
                    options: normalizeAnimationOptions(metadata.options)
                };
            }
            visitGroup(metadata, context) {
                const currentTime = context.currentTime;
                let furthestTime = 0;
                const steps = metadata.steps.map(step => {
                    context.currentTime = currentTime;
                    const innerAst = visitDslNode(this, step, context);
                    return furthestTime = Math.max(furthestTime, context.currentTime), innerAst;
                });
                return context.currentTime = furthestTime, {
                    type: 3,
                    steps: steps,
                    options: normalizeAnimationOptions(metadata.options)
                };
            }
            visitAnimate(metadata, context) {
                const timingAst = function(value, errors) {
                    let timings = null;
                    if (value.hasOwnProperty("duration")) timings = value; else if ("number" == typeof value) return makeTimingAst(resolveTiming(value, errors).duration, 0, "");
                    const strValue = value;
                    if (strValue.split(/\s+/).some(v => "{" == v.charAt(0) && "{" == v.charAt(1))) {
                        const ast = makeTimingAst(0, 0, "");
                        return ast.dynamic = !0, ast.strValue = strValue, ast;
                    }
                    return makeTimingAst((timings = timings || resolveTiming(strValue, errors)).duration, timings.delay, timings.easing);
                }(metadata.timings, context.errors);
                let styleAst;
                context.currentAnimateTimings = timingAst;
                let styleMetadata = metadata.styles ? metadata.styles : Object(animations.h)({});
                if (5 == styleMetadata.type) styleAst = this.visitKeyframes(styleMetadata, context); else {
                    let styleMetadata = metadata.styles, isEmpty = !1;
                    if (!styleMetadata) {
                        isEmpty = !0;
                        const newStyleData = {};
                        timingAst.easing && (newStyleData.easing = timingAst.easing), styleMetadata = Object(animations.h)(newStyleData);
                    }
                    context.currentTime += timingAst.duration + timingAst.delay;
                    const _styleAst = this.visitStyle(styleMetadata, context);
                    _styleAst.isEmptyStep = isEmpty, styleAst = _styleAst;
                }
                return context.currentAnimateTimings = null, {
                    type: 4,
                    timings: timingAst,
                    style: styleAst,
                    options: null
                };
            }
            visitStyle(metadata, context) {
                const ast = this._makeStyleAst(metadata, context);
                return this._validateStyleAst(ast, context), ast;
            }
            _makeStyleAst(metadata, context) {
                const styles = [];
                Array.isArray(metadata.styles) ? metadata.styles.forEach(styleTuple => {
                    "string" == typeof styleTuple ? styleTuple == animations.a ? styles.push(styleTuple) : context.errors.push(`The provided style string value ${styleTuple} is not allowed.`) : styles.push(styleTuple);
                }) : styles.push(metadata.styles);
                let containsDynamicStyles = !1, collectedEasing = null;
                return styles.forEach(styleData => {
                    if (isObject(styleData)) {
                        const styleMap = styleData, easing = styleMap.easing;
                        if (easing && (collectedEasing = easing, delete styleMap.easing), !containsDynamicStyles) for (let prop in styleMap) if (styleMap[prop].toString().indexOf(SUBSTITUTION_EXPR_START) >= 0) {
                            containsDynamicStyles = !0;
                            break;
                        }
                    }
                }), {
                    type: 6,
                    styles: styles,
                    easing: collectedEasing,
                    offset: metadata.offset,
                    containsDynamicStyles: containsDynamicStyles,
                    options: null
                };
            }
            _validateStyleAst(ast, context) {
                const timings = context.currentAnimateTimings;
                let endTime = context.currentTime, startTime = context.currentTime;
                timings && startTime > 0 && (startTime -= timings.duration + timings.delay), ast.styles.forEach(tuple => {
                    "string" != typeof tuple && Object.keys(tuple).forEach(prop => {
                        if (!this._driver.validateStyleProperty(prop)) return void context.errors.push(`The provided animation property "${prop}" is not a supported CSS property for animations`);
                        const collectedStyles = context.collectedStyles[context.currentQuerySelector], collectedEntry = collectedStyles[prop];
                        let updateCollectedStyle = !0;
                        collectedEntry && (startTime != endTime && startTime >= collectedEntry.startTime && endTime <= collectedEntry.endTime && (context.errors.push(`The CSS property "${prop}" that exists between the times of "${collectedEntry.startTime}ms" and "${collectedEntry.endTime}ms" is also being animated in a parallel animation between the times of "${startTime}ms" and "${endTime}ms"`), 
                        updateCollectedStyle = !1), startTime = collectedEntry.startTime), updateCollectedStyle && (collectedStyles[prop] = {
                            startTime: startTime,
                            endTime: endTime
                        }), context.options && function(value, options, errors) {
                            const params = options.params || {}, matches = extractStyleParams(value);
                            matches.length && matches.forEach(varName => {
                                params.hasOwnProperty(varName) || errors.push(`Unable to resolve the local animation param ${varName} in the given list of values`);
                            });
                        }(tuple[prop], context.options, context.errors);
                    });
                });
            }
            visitKeyframes(metadata, context) {
                const ast = {
                    type: 5,
                    styles: [],
                    options: null
                };
                if (!context.currentAnimateTimings) return context.errors.push("keyframes() must be placed inside of a call to animate()"), 
                ast;
                let totalKeyframesWithOffsets = 0;
                const offsets = [];
                let offsetsOutOfOrder = !1, keyframesOutOfRange = !1, previousOffset = 0;
                const keyframes = metadata.steps.map(styles => {
                    const style = this._makeStyleAst(styles, context);
                    let offsetVal = null != style.offset ? style.offset : function(styles) {
                        if ("string" == typeof styles) return null;
                        let offset = null;
                        if (Array.isArray(styles)) styles.forEach(styleTuple => {
                            if (isObject(styleTuple) && styleTuple.hasOwnProperty("offset")) {
                                const obj = styleTuple;
                                offset = parseFloat(obj.offset), delete obj.offset;
                            }
                        }); else if (isObject(styles) && styles.hasOwnProperty("offset")) {
                            const obj = styles;
                            offset = parseFloat(obj.offset), delete obj.offset;
                        }
                        return offset;
                    }(style.styles), offset = 0;
                    return null != offsetVal && (totalKeyframesWithOffsets++, offset = style.offset = offsetVal), 
                    keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1, offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset, 
                    previousOffset = offset, offsets.push(offset), style;
                });
                keyframesOutOfRange && context.errors.push("Please ensure that all keyframe offsets are between 0 and 1"), 
                offsetsOutOfOrder && context.errors.push("Please ensure that all keyframe offsets are in order");
                const length = metadata.steps.length;
                let generatedOffset = 0;
                totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length ? context.errors.push("Not all style() steps within the declared keyframes() contain offsets") : 0 == totalKeyframesWithOffsets && (generatedOffset = 1 / (length - 1));
                const limit = length - 1, currentTime = context.currentTime, currentAnimateTimings = context.currentAnimateTimings, animateDuration = currentAnimateTimings.duration;
                return keyframes.forEach((kf, i) => {
                    const offset = generatedOffset > 0 ? i == limit ? 1 : generatedOffset * i : offsets[i], durationUpToThisFrame = offset * animateDuration;
                    context.currentTime = currentTime + currentAnimateTimings.delay + durationUpToThisFrame, 
                    currentAnimateTimings.duration = durationUpToThisFrame, this._validateStyleAst(kf, context), 
                    kf.offset = offset, ast.styles.push(kf);
                }), ast;
            }
            visitReference(metadata, context) {
                return {
                    type: 8,
                    animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),
                    options: normalizeAnimationOptions(metadata.options)
                };
            }
            visitAnimateChild(metadata, context) {
                return context.depCount++, {
                    type: 9,
                    options: normalizeAnimationOptions(metadata.options)
                };
            }
            visitAnimateRef(metadata, context) {
                return {
                    type: 10,
                    animation: this.visitReference(metadata.animation, context),
                    options: normalizeAnimationOptions(metadata.options)
                };
            }
            visitQuery(metadata, context) {
                const parentSelector = context.currentQuerySelector, options = metadata.options || {};
                context.queryCount++, context.currentQuery = metadata;
                const [selector, includeSelf] = function(selector) {
                    const hasAmpersand = !!selector.split(/\s*,\s*/).find(token => token == SELF_TOKEN);
                    return hasAmpersand && (selector = selector.replace(SELF_TOKEN_REGEX, "")), [ selector = selector.replace(/@\*/g, NG_TRIGGER_SELECTOR).replace(/@\w+/g, match => NG_TRIGGER_SELECTOR + "-" + match.substr(1)).replace(/:animating/g, NG_ANIMATING_SELECTOR), hasAmpersand ];
                }(metadata.selector);
                context.currentQuerySelector = parentSelector.length ? parentSelector + " " + selector : selector, 
                getOrSetAsInMap(context.collectedStyles, context.currentQuerySelector, {});
                const animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);
                return context.currentQuery = null, context.currentQuerySelector = parentSelector, 
                {
                    type: 11,
                    selector: selector,
                    limit: options.limit || 0,
                    optional: !!options.optional,
                    includeSelf: includeSelf,
                    animation: animation,
                    originalSelector: metadata.selector,
                    options: normalizeAnimationOptions(metadata.options)
                };
            }
            visitStagger(metadata, context) {
                context.currentQuery || context.errors.push("stagger() can only be used inside of query()");
                const timings = "full" === metadata.timings ? {
                    duration: 0,
                    delay: 0,
                    easing: "full"
                } : resolveTiming(metadata.timings, context.errors, !0);
                return {
                    type: 12,
                    animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),
                    timings: timings,
                    options: null
                };
            }
        }
        class AnimationAstBuilderContext {
            constructor(errors) {
                this.errors = errors, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, 
                this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, 
                this.currentTime = 0, this.collectedStyles = {}, this.options = null;
            }
        }
        function isObject(value) {
            return !Array.isArray(value) && "object" == typeof value;
        }
        function normalizeAnimationOptions(options) {
            var obj;
            return options ? (options = copyObj(options)).params && (options.params = (obj = options.params) ? copyObj(obj) : null) : options = {}, 
            options;
        }
        function makeTimingAst(duration, delay, easing) {
            return {
                duration: duration,
                delay: delay,
                easing: easing
            };
        }
        function createTimelineInstruction(element, keyframes, preStyleProps, postStyleProps, duration, delay, easing = null, subTimeline = !1) {
            return {
                type: 1,
                element: element,
                keyframes: keyframes,
                preStyleProps: preStyleProps,
                postStyleProps: postStyleProps,
                duration: duration,
                delay: delay,
                totalTime: duration + delay,
                easing: easing,
                subTimeline: subTimeline
            };
        }
        class ElementInstructionMap {
            constructor() {
                this._map = new Map;
            }
            consume(element) {
                let instructions = this._map.get(element);
                return instructions ? this._map.delete(element) : instructions = [], instructions;
            }
            append(element, instructions) {
                let existingInstructions = this._map.get(element);
                existingInstructions || this._map.set(element, existingInstructions = []), existingInstructions.push(...instructions);
            }
            has(element) {
                return this._map.has(element);
            }
            clear() {
                this._map.clear();
            }
        }
        const ONE_FRAME_IN_MILLISECONDS = 1, ENTER_TOKEN_REGEX = new RegExp(":enter", "g"), LEAVE_TOKEN_REGEX = new RegExp(":leave", "g");
        function buildAnimationTimelines(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles = {}, finalStyles = {}, options, subInstructions, errors = []) {
            return (new AnimationTimelineBuilderVisitor).buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors);
        }
        class AnimationTimelineBuilderVisitor {
            buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors = []) {
                subInstructions = subInstructions || new ElementInstructionMap;
                const context = new AnimationTimelineContext(driver, rootElement, subInstructions, enterClassName, leaveClassName, errors, []);
                context.options = options, context.currentTimeline.setStyles([ startingStyles ], null, context.errors, options), 
                visitDslNode(this, ast, context);
                const timelines = context.timelines.filter(timeline => timeline.containsAnimation());
                if (timelines.length && Object.keys(finalStyles).length) {
                    const tl = timelines[timelines.length - 1];
                    tl.allowOnlyTimelineStyles() || tl.setStyles([ finalStyles ], null, context.errors, options);
                }
                return timelines.length ? timelines.map(timeline => timeline.buildKeyframes()) : [ createTimelineInstruction(rootElement, [], [], [], 0, 0, "", !1) ];
            }
            visitTrigger(ast, context) {}
            visitState(ast, context) {}
            visitTransition(ast, context) {}
            visitAnimateChild(ast, context) {
                const elementInstructions = context.subInstructions.consume(context.element);
                if (elementInstructions) {
                    const innerContext = context.createSubContext(ast.options), startTime = context.currentTimeline.currentTime, endTime = this._visitSubInstructions(elementInstructions, innerContext, innerContext.options);
                    startTime != endTime && context.transformIntoNewTimeline(endTime);
                }
                context.previousNode = ast;
            }
            visitAnimateRef(ast, context) {
                const innerContext = context.createSubContext(ast.options);
                innerContext.transformIntoNewTimeline(), this.visitReference(ast.animation, innerContext), 
                context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime), context.previousNode = ast;
            }
            _visitSubInstructions(instructions, context, options) {
                let furthestTime = context.currentTimeline.currentTime;
                const duration = null != options.duration ? resolveTimingValue(options.duration) : null, delay = null != options.delay ? resolveTimingValue(options.delay) : null;
                return 0 !== duration && instructions.forEach(instruction => {
                    const instructionTimings = context.appendInstructionToTimeline(instruction, duration, delay);
                    furthestTime = Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);
                }), furthestTime;
            }
            visitReference(ast, context) {
                context.updateOptions(ast.options, !0), visitDslNode(this, ast.animation, context), 
                context.previousNode = ast;
            }
            visitSequence(ast, context) {
                const subContextCount = context.subContextCount;
                let ctx = context;
                const options = ast.options;
                if (options && (options.params || options.delay) && ((ctx = context.createSubContext(options)).transformIntoNewTimeline(), 
                null != options.delay)) {
                    6 == ctx.previousNode.type && (ctx.currentTimeline.snapshotCurrentStyles(), ctx.previousNode = DEFAULT_NOOP_PREVIOUS_NODE);
                    const delay = resolveTimingValue(options.delay);
                    ctx.delayNextStep(delay);
                }
                ast.steps.length && (ast.steps.forEach(s => visitDslNode(this, s, ctx)), ctx.currentTimeline.applyStylesToKeyframe(), 
                ctx.subContextCount > subContextCount && ctx.transformIntoNewTimeline()), context.previousNode = ast;
            }
            visitGroup(ast, context) {
                const innerTimelines = [];
                let furthestTime = context.currentTimeline.currentTime;
                const delay = ast.options && ast.options.delay ? resolveTimingValue(ast.options.delay) : 0;
                ast.steps.forEach(s => {
                    const innerContext = context.createSubContext(ast.options);
                    delay && innerContext.delayNextStep(delay), visitDslNode(this, s, innerContext), 
                    furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime), 
                    innerTimelines.push(innerContext.currentTimeline);
                }), innerTimelines.forEach(timeline => context.currentTimeline.mergeTimelineCollectedStyles(timeline)), 
                context.transformIntoNewTimeline(furthestTime), context.previousNode = ast;
            }
            _visitTiming(ast, context) {
                if (ast.dynamic) {
                    const strValue = ast.strValue;
                    return resolveTiming(context.params ? interpolateParams(strValue, context.params, context.errors) : strValue, context.errors);
                }
                return {
                    duration: ast.duration,
                    delay: ast.delay,
                    easing: ast.easing
                };
            }
            visitAnimate(ast, context) {
                const timings = context.currentAnimateTimings = this._visitTiming(ast.timings, context), timeline = context.currentTimeline;
                timings.delay && (context.incrementTime(timings.delay), timeline.snapshotCurrentStyles());
                const style = ast.style;
                5 == style.type ? this.visitKeyframes(style, context) : (context.incrementTime(timings.duration), 
                this.visitStyle(style, context), timeline.applyStylesToKeyframe()), context.currentAnimateTimings = null, 
                context.previousNode = ast;
            }
            visitStyle(ast, context) {
                const timeline = context.currentTimeline, timings = context.currentAnimateTimings;
                !timings && timeline.getCurrentStyleProperties().length && timeline.forwardFrame();
                const easing = timings && timings.easing || ast.easing;
                ast.isEmptyStep ? timeline.applyEmptyStep(easing) : timeline.setStyles(ast.styles, easing, context.errors, context.options), 
                context.previousNode = ast;
            }
            visitKeyframes(ast, context) {
                const currentAnimateTimings = context.currentAnimateTimings, startTime = context.currentTimeline.duration, duration = currentAnimateTimings.duration, innerTimeline = context.createSubContext().currentTimeline;
                innerTimeline.easing = currentAnimateTimings.easing, ast.styles.forEach(step => {
                    innerTimeline.forwardTime((step.offset || 0) * duration), innerTimeline.setStyles(step.styles, step.easing, context.errors, context.options), 
                    innerTimeline.applyStylesToKeyframe();
                }), context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline), context.transformIntoNewTimeline(startTime + duration), 
                context.previousNode = ast;
            }
            visitQuery(ast, context) {
                const startTime = context.currentTimeline.currentTime, options = ast.options || {}, delay = options.delay ? resolveTimingValue(options.delay) : 0;
                delay && (6 === context.previousNode.type || 0 == startTime && context.currentTimeline.getCurrentStyleProperties().length) && (context.currentTimeline.snapshotCurrentStyles(), 
                context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE);
                let furthestTime = startTime;
                const elms = context.invokeQuery(ast.selector, ast.originalSelector, ast.limit, ast.includeSelf, !!options.optional, context.errors);
                context.currentQueryTotal = elms.length;
                let sameElementTimeline = null;
                elms.forEach((element, i) => {
                    context.currentQueryIndex = i;
                    const innerContext = context.createSubContext(ast.options, element);
                    delay && innerContext.delayNextStep(delay), element === context.element && (sameElementTimeline = innerContext.currentTimeline), 
                    visitDslNode(this, ast.animation, innerContext), innerContext.currentTimeline.applyStylesToKeyframe(), 
                    furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);
                }), context.currentQueryIndex = 0, context.currentQueryTotal = 0, context.transformIntoNewTimeline(furthestTime), 
                sameElementTimeline && (context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline), 
                context.currentTimeline.snapshotCurrentStyles()), context.previousNode = ast;
            }
            visitStagger(ast, context) {
                const parentContext = context.parentContext, tl = context.currentTimeline, timings = ast.timings, duration = Math.abs(timings.duration), maxTime = duration * (context.currentQueryTotal - 1);
                let delay = duration * context.currentQueryIndex;
                switch (timings.duration < 0 ? "reverse" : timings.easing) {
                  case "reverse":
                    delay = maxTime - delay;
                    break;

                  case "full":
                    delay = parentContext.currentStaggerTime;
                }
                const timeline = context.currentTimeline;
                delay && timeline.delayNextStep(delay);
                const startingTime = timeline.currentTime;
                visitDslNode(this, ast.animation, context), context.previousNode = ast, parentContext.currentStaggerTime = tl.currentTime - startingTime + (tl.startTime - parentContext.currentTimeline.startTime);
            }
        }
        const DEFAULT_NOOP_PREVIOUS_NODE = {};
        class AnimationTimelineContext {
            constructor(_driver, element, subInstructions, _enterClassName, _leaveClassName, errors, timelines, initialTimeline) {
                this._driver = _driver, this.element = element, this.subInstructions = subInstructions, 
                this._enterClassName = _enterClassName, this._leaveClassName = _leaveClassName, 
                this.errors = errors, this.timelines = timelines, this.parentContext = null, this.currentAnimateTimings = null, 
                this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE, this.subContextCount = 0, this.options = {}, 
                this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, 
                this.currentTimeline = initialTimeline || new browser_TimelineBuilder(this._driver, element, 0), 
                timelines.push(this.currentTimeline);
            }
            get params() {
                return this.options.params;
            }
            updateOptions(options, skipIfExists) {
                if (!options) return;
                const newOptions = options;
                let optionsToUpdate = this.options;
                null != newOptions.duration && (optionsToUpdate.duration = resolveTimingValue(newOptions.duration)), 
                null != newOptions.delay && (optionsToUpdate.delay = resolveTimingValue(newOptions.delay));
                const newParams = newOptions.params;
                if (newParams) {
                    let paramsToUpdate = optionsToUpdate.params;
                    paramsToUpdate || (paramsToUpdate = this.options.params = {}), Object.keys(newParams).forEach(name => {
                        skipIfExists && paramsToUpdate.hasOwnProperty(name) || (paramsToUpdate[name] = interpolateParams(newParams[name], paramsToUpdate, this.errors));
                    });
                }
            }
            _copyOptions() {
                const options = {};
                if (this.options) {
                    const oldParams = this.options.params;
                    if (oldParams) {
                        const params = options.params = {};
                        Object.keys(oldParams).forEach(name => {
                            params[name] = oldParams[name];
                        });
                    }
                }
                return options;
            }
            createSubContext(options = null, element, newTime) {
                const target = element || this.element, context = new AnimationTimelineContext(this._driver, target, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(target, newTime || 0));
                return context.previousNode = this.previousNode, context.currentAnimateTimings = this.currentAnimateTimings, 
                context.options = this._copyOptions(), context.updateOptions(options), context.currentQueryIndex = this.currentQueryIndex, 
                context.currentQueryTotal = this.currentQueryTotal, context.parentContext = this, 
                this.subContextCount++, context;
            }
            transformIntoNewTimeline(newTime) {
                return this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE, this.currentTimeline = this.currentTimeline.fork(this.element, newTime), 
                this.timelines.push(this.currentTimeline), this.currentTimeline;
            }
            appendInstructionToTimeline(instruction, duration, delay) {
                const updatedTimings = {
                    duration: null != duration ? duration : instruction.duration,
                    delay: this.currentTimeline.currentTime + (null != delay ? delay : 0) + instruction.delay,
                    easing: ""
                }, builder = new SubTimelineBuilder(this._driver, instruction.element, instruction.keyframes, instruction.preStyleProps, instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);
                return this.timelines.push(builder), updatedTimings;
            }
            incrementTime(time) {
                this.currentTimeline.forwardTime(this.currentTimeline.duration + time);
            }
            delayNextStep(delay) {
                delay > 0 && this.currentTimeline.delayNextStep(delay);
            }
            invokeQuery(selector, originalSelector, limit, includeSelf, optional, errors) {
                let results = [];
                if (includeSelf && results.push(this.element), selector.length > 0) {
                    selector = (selector = selector.replace(ENTER_TOKEN_REGEX, "." + this._enterClassName)).replace(LEAVE_TOKEN_REGEX, "." + this._leaveClassName);
                    let elements = this._driver.query(this.element, selector, 1 != limit);
                    0 !== limit && (elements = limit < 0 ? elements.slice(elements.length + limit, elements.length) : elements.slice(0, limit)), 
                    results.push(...elements);
                }
                return optional || 0 != results.length || errors.push(`\`query("${originalSelector}")\` returned zero elements. (Use \`query("${originalSelector}", { optional: true })\` if you wish to allow this.)`), 
                results;
            }
        }
        class browser_TimelineBuilder {
            constructor(_driver, element, startTime, _elementTimelineStylesLookup) {
                this._driver = _driver, this.element = element, this.startTime = startTime, this._elementTimelineStylesLookup = _elementTimelineStylesLookup, 
                this.duration = 0, this._previousKeyframe = {}, this._currentKeyframe = {}, this._keyframes = new Map, 
                this._styleSummary = {}, this._pendingStyles = {}, this._backFill = {}, this._currentEmptyStepKeyframe = null, 
                this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), 
                this._localTimelineStyles = Object.create(this._backFill, {}), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(element), 
                this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, 
                this._elementTimelineStylesLookup.set(element, this._localTimelineStyles)), this._loadKeyframe();
            }
            containsAnimation() {
                switch (this._keyframes.size) {
                  case 0:
                    return !1;

                  case 1:
                    return this.getCurrentStyleProperties().length > 0;

                  default:
                    return !0;
                }
            }
            getCurrentStyleProperties() {
                return Object.keys(this._currentKeyframe);
            }
            get currentTime() {
                return this.startTime + this.duration;
            }
            delayNextStep(delay) {
                const hasPreStyleStep = 1 == this._keyframes.size && Object.keys(this._pendingStyles).length;
                this.duration || hasPreStyleStep ? (this.forwardTime(this.currentTime + delay), 
                hasPreStyleStep && this.snapshotCurrentStyles()) : this.startTime += delay;
            }
            fork(element, currentTime) {
                return this.applyStylesToKeyframe(), new browser_TimelineBuilder(this._driver, element, currentTime || this.currentTime, this._elementTimelineStylesLookup);
            }
            _loadKeyframe() {
                this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), 
                this._currentKeyframe || (this._currentKeyframe = Object.create(this._backFill, {}), 
                this._keyframes.set(this.duration, this._currentKeyframe));
            }
            forwardFrame() {
                this.duration += ONE_FRAME_IN_MILLISECONDS, this._loadKeyframe();
            }
            forwardTime(time) {
                this.applyStylesToKeyframe(), this.duration = time, this._loadKeyframe();
            }
            _updateStyle(prop, value) {
                this._localTimelineStyles[prop] = value, this._globalTimelineStyles[prop] = value, 
                this._styleSummary[prop] = {
                    time: this.currentTime,
                    value: value
                };
            }
            allowOnlyTimelineStyles() {
                return this._currentEmptyStepKeyframe !== this._currentKeyframe;
            }
            applyEmptyStep(easing) {
                easing && (this._previousKeyframe.easing = easing), Object.keys(this._globalTimelineStyles).forEach(prop => {
                    this._backFill[prop] = this._globalTimelineStyles[prop] || animations.a, this._currentKeyframe[prop] = animations.a;
                }), this._currentEmptyStepKeyframe = this._currentKeyframe;
            }
            setStyles(input, easing, errors, options) {
                easing && (this._previousKeyframe.easing = easing);
                const params = options && options.params || {}, styles = function(input, allStyles) {
                    const styles = {};
                    let allProperties;
                    return input.forEach(token => {
                        "*" === token ? (allProperties = allProperties || Object.keys(allStyles)).forEach(prop => {
                            styles[prop] = animations.a;
                        }) : copyStyles(token, !1, styles);
                    }), styles;
                }(input, this._globalTimelineStyles);
                Object.keys(styles).forEach(prop => {
                    const val = interpolateParams(styles[prop], params, errors);
                    this._pendingStyles[prop] = val, this._localTimelineStyles.hasOwnProperty(prop) || (this._backFill[prop] = this._globalTimelineStyles.hasOwnProperty(prop) ? this._globalTimelineStyles[prop] : animations.a), 
                    this._updateStyle(prop, val);
                });
            }
            applyStylesToKeyframe() {
                const styles = this._pendingStyles, props = Object.keys(styles);
                0 != props.length && (this._pendingStyles = {}, props.forEach(prop => {
                    this._currentKeyframe[prop] = styles[prop];
                }), Object.keys(this._localTimelineStyles).forEach(prop => {
                    this._currentKeyframe.hasOwnProperty(prop) || (this._currentKeyframe[prop] = this._localTimelineStyles[prop]);
                }));
            }
            snapshotCurrentStyles() {
                Object.keys(this._localTimelineStyles).forEach(prop => {
                    const val = this._localTimelineStyles[prop];
                    this._pendingStyles[prop] = val, this._updateStyle(prop, val);
                });
            }
            getFinalKeyframe() {
                return this._keyframes.get(this.duration);
            }
            get properties() {
                const properties = [];
                for (let prop in this._currentKeyframe) properties.push(prop);
                return properties;
            }
            mergeTimelineCollectedStyles(timeline) {
                Object.keys(timeline._styleSummary).forEach(prop => {
                    const details0 = this._styleSummary[prop], details1 = timeline._styleSummary[prop];
                    (!details0 || details1.time > details0.time) && this._updateStyle(prop, details1.value);
                });
            }
            buildKeyframes() {
                this.applyStylesToKeyframe();
                const preStyleProps = new Set, postStyleProps = new Set, isEmpty = 1 === this._keyframes.size && 0 === this.duration;
                let finalKeyframes = [];
                this._keyframes.forEach((keyframe, time) => {
                    const finalKeyframe = copyStyles(keyframe, !0);
                    Object.keys(finalKeyframe).forEach(prop => {
                        const value = finalKeyframe[prop];
                        value == animations.l ? preStyleProps.add(prop) : value == animations.a && postStyleProps.add(prop);
                    }), isEmpty || (finalKeyframe.offset = time / this.duration), finalKeyframes.push(finalKeyframe);
                });
                const preProps = preStyleProps.size ? iteratorToArray(preStyleProps.values()) : [], postProps = postStyleProps.size ? iteratorToArray(postStyleProps.values()) : [];
                if (isEmpty) {
                    const kf0 = finalKeyframes[0], kf1 = copyObj(kf0);
                    kf0.offset = 0, kf1.offset = 1, finalKeyframes = [ kf0, kf1 ];
                }
                return createTimelineInstruction(this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime, this.easing, !1);
            }
        }
        class SubTimelineBuilder extends browser_TimelineBuilder {
            constructor(driver, element, keyframes, preStyleProps, postStyleProps, timings, _stretchStartingKeyframe = !1) {
                super(driver, element, timings.delay), this.element = element, this.keyframes = keyframes, 
                this.preStyleProps = preStyleProps, this.postStyleProps = postStyleProps, this._stretchStartingKeyframe = _stretchStartingKeyframe, 
                this.timings = {
                    duration: timings.duration,
                    delay: timings.delay,
                    easing: timings.easing
                };
            }
            containsAnimation() {
                return this.keyframes.length > 1;
            }
            buildKeyframes() {
                let keyframes = this.keyframes, {delay: delay, duration: duration, easing: easing} = this.timings;
                if (this._stretchStartingKeyframe && delay) {
                    const newKeyframes = [], totalTime = duration + delay, startingGap = delay / totalTime, newFirstKeyframe = copyStyles(keyframes[0], !1);
                    newFirstKeyframe.offset = 0, newKeyframes.push(newFirstKeyframe);
                    const oldFirstKeyframe = copyStyles(keyframes[0], !1);
                    oldFirstKeyframe.offset = roundOffset(startingGap), newKeyframes.push(oldFirstKeyframe);
                    const limit = keyframes.length - 1;
                    for (let i = 1; i <= limit; i++) {
                        let kf = copyStyles(keyframes[i], !1);
                        kf.offset = roundOffset((delay + kf.offset * duration) / totalTime), newKeyframes.push(kf);
                    }
                    duration = totalTime, delay = 0, easing = "", keyframes = newKeyframes;
                }
                return createTimelineInstruction(this.element, keyframes, this.preStyleProps, this.postStyleProps, duration, delay, easing, !0);
            }
        }
        function roundOffset(offset, decimalPoints = 3) {
            const mult = Math.pow(10, decimalPoints - 1);
            return Math.round(offset * mult) / mult;
        }
        class AnimationStyleNormalizer {}
        class WebAnimationsStyleNormalizer extends AnimationStyleNormalizer {
            normalizePropertyName(propertyName, errors) {
                return dashCaseToCamelCase(propertyName);
            }
            normalizeStyleValue(userProvidedProperty, normalizedProperty, value, errors) {
                let unit = "";
                const strVal = value.toString().trim();
                if (DIMENSIONAL_PROP_MAP[normalizedProperty] && 0 !== value && "0" !== value) if ("number" == typeof value) unit = "px"; else {
                    const valAndSuffixMatch = value.match(/^[+-]?[\d\.]+([a-z]*)$/);
                    valAndSuffixMatch && 0 == valAndSuffixMatch[1].length && errors.push(`Please provide a CSS unit value for ${userProvidedProperty}:${value}`);
                }
                return strVal + unit;
            }
        }
        const DIMENSIONAL_PROP_MAP = (() => (function(keys) {
            const map = {};
            return keys.forEach(key => map[key] = !0), map;
        })("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))();
        function createTransitionInstruction(element, triggerName, fromState, toState, isRemovalTransition, fromStyles, toStyles, timelines, queriedElements, preStyleProps, postStyleProps, totalTime, errors) {
            return {
                type: 0,
                element: element,
                triggerName: triggerName,
                isRemovalTransition: isRemovalTransition,
                fromState: fromState,
                fromStyles: fromStyles,
                toState: toState,
                toStyles: toStyles,
                timelines: timelines,
                queriedElements: queriedElements,
                preStyleProps: preStyleProps,
                postStyleProps: postStyleProps,
                totalTime: totalTime,
                errors: errors
            };
        }
        const EMPTY_OBJECT = {};
        class AnimationTransitionFactory {
            constructor(_triggerName, ast, _stateStyles) {
                this._triggerName = _triggerName, this.ast = ast, this._stateStyles = _stateStyles;
            }
            match(currentState, nextState, element, params) {
                return function(matchFns, currentState, nextState, element, params) {
                    return matchFns.some(fn => fn(currentState, nextState, element, params));
                }(this.ast.matchers, currentState, nextState, element, params);
            }
            buildStyles(stateName, params, errors) {
                const backupStateStyler = this._stateStyles["*"], stateStyler = this._stateStyles[stateName], backupStyles = backupStateStyler ? backupStateStyler.buildStyles(params, errors) : {};
                return stateStyler ? stateStyler.buildStyles(params, errors) : backupStyles;
            }
            build(driver, element, currentState, nextState, enterClassName, leaveClassName, currentOptions, nextOptions, subInstructions, skipAstBuild) {
                const errors = [], transitionAnimationParams = this.ast.options && this.ast.options.params || EMPTY_OBJECT, currentStateStyles = this.buildStyles(currentState, currentOptions && currentOptions.params || EMPTY_OBJECT, errors), nextAnimationParams = nextOptions && nextOptions.params || EMPTY_OBJECT, nextStateStyles = this.buildStyles(nextState, nextAnimationParams, errors), queriedElements = new Set, preStyleMap = new Map, postStyleMap = new Map, isRemoval = "void" === nextState, animationOptions = {
                    params: Object.assign(Object.assign({}, transitionAnimationParams), nextAnimationParams)
                }, timelines = skipAstBuild ? [] : buildAnimationTimelines(driver, element, this.ast.animation, enterClassName, leaveClassName, currentStateStyles, nextStateStyles, animationOptions, subInstructions, errors);
                let totalTime = 0;
                if (timelines.forEach(tl => {
                    totalTime = Math.max(tl.duration + tl.delay, totalTime);
                }), errors.length) return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, [], [], preStyleMap, postStyleMap, totalTime, errors);
                timelines.forEach(tl => {
                    const elm = tl.element, preProps = getOrSetAsInMap(preStyleMap, elm, {});
                    tl.preStyleProps.forEach(prop => preProps[prop] = !0);
                    const postProps = getOrSetAsInMap(postStyleMap, elm, {});
                    tl.postStyleProps.forEach(prop => postProps[prop] = !0), elm !== element && queriedElements.add(elm);
                });
                const queriedElementsList = iteratorToArray(queriedElements.values());
                return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, timelines, queriedElementsList, preStyleMap, postStyleMap, totalTime);
            }
        }
        class AnimationStateStyles {
            constructor(styles, defaultParams) {
                this.styles = styles, this.defaultParams = defaultParams;
            }
            buildStyles(params, errors) {
                const finalStyles = {}, combinedParams = copyObj(this.defaultParams);
                return Object.keys(params).forEach(key => {
                    const value = params[key];
                    null != value && (combinedParams[key] = value);
                }), this.styles.styles.forEach(value => {
                    if ("string" != typeof value) {
                        const styleObj = value;
                        Object.keys(styleObj).forEach(prop => {
                            let val = styleObj[prop];
                            val.length > 1 && (val = interpolateParams(val, combinedParams, errors)), finalStyles[prop] = val;
                        });
                    }
                }), finalStyles;
            }
        }
        class AnimationTrigger {
            constructor(name, ast) {
                this.name = name, this.ast = ast, this.transitionFactories = [], this.states = {}, 
                ast.states.forEach(ast => {
                    this.states[ast.name] = new AnimationStateStyles(ast.style, ast.options && ast.options.params || {});
                }), balanceProperties(this.states, "true", "1"), balanceProperties(this.states, "false", "0"), 
                ast.transitions.forEach(ast => {
                    this.transitionFactories.push(new AnimationTransitionFactory(name, ast, this.states));
                }), this.fallbackTransition = new AnimationTransitionFactory(name, {
                    type: 1,
                    animation: {
                        type: 2,
                        steps: [],
                        options: null
                    },
                    matchers: [ (fromState, toState) => !0 ],
                    options: null,
                    queryCount: 0,
                    depCount: 0
                }, this.states);
            }
            get containsQueries() {
                return this.ast.queryCount > 0;
            }
            matchTransition(currentState, nextState, element, params) {
                return this.transitionFactories.find(f => f.match(currentState, nextState, element, params)) || null;
            }
            matchStyles(currentState, params, errors) {
                return this.fallbackTransition.buildStyles(currentState, params, errors);
            }
        }
        function balanceProperties(obj, key1, key2) {
            obj.hasOwnProperty(key1) ? obj.hasOwnProperty(key2) || (obj[key2] = obj[key1]) : obj.hasOwnProperty(key2) && (obj[key1] = obj[key2]);
        }
        const EMPTY_INSTRUCTION_MAP = new ElementInstructionMap;
        class browser_TimelineAnimationEngine {
            constructor(bodyNode, _driver, _normalizer) {
                this.bodyNode = bodyNode, this._driver = _driver, this._normalizer = _normalizer, 
                this._animations = {}, this._playersById = {}, this.players = [];
            }
            register(id, metadata) {
                const errors = [], ast = buildAnimationAst(this._driver, metadata, errors);
                if (errors.length) throw new Error(`Unable to build the animation due to the following errors: ${errors.join("\n")}`);
                this._animations[id] = ast;
            }
            _buildPlayer(i, preStyles, postStyles) {
                const element = i.element, keyframes = normalizeKeyframes(0, this._normalizer, 0, i.keyframes, preStyles, postStyles);
                return this._driver.animate(element, keyframes, i.duration, i.delay, i.easing, [], !0);
            }
            create(id, element, options = {}) {
                const errors = [], ast = this._animations[id];
                let instructions;
                const autoStylesMap = new Map;
                if (ast ? (instructions = buildAnimationTimelines(this._driver, element, ast, ENTER_CLASSNAME, LEAVE_CLASSNAME, {}, {}, options, EMPTY_INSTRUCTION_MAP, errors)).forEach(inst => {
                    const styles = getOrSetAsInMap(autoStylesMap, inst.element, {});
                    inst.postStyleProps.forEach(prop => styles[prop] = null);
                }) : (errors.push("The requested animation doesn't exist or has already been destroyed"), 
                instructions = []), errors.length) throw new Error(`Unable to create the animation due to the following errors: ${errors.join("\n")}`);
                autoStylesMap.forEach((styles, element) => {
                    Object.keys(styles).forEach(prop => {
                        styles[prop] = this._driver.computeStyle(element, prop, animations.a);
                    });
                });
                const player = optimizeGroupPlayer(instructions.map(i => {
                    const styles = autoStylesMap.get(i.element);
                    return this._buildPlayer(i, {}, styles);
                }));
                return this._playersById[id] = player, player.onDestroy(() => this.destroy(id)), 
                this.players.push(player), player;
            }
            destroy(id) {
                const player = this._getPlayer(id);
                player.destroy(), delete this._playersById[id];
                const index = this.players.indexOf(player);
                index >= 0 && this.players.splice(index, 1);
            }
            _getPlayer(id) {
                const player = this._playersById[id];
                if (!player) throw new Error(`Unable to find the timeline player referenced by ${id}`);
                return player;
            }
            listen(id, element, eventName, callback) {
                const baseEvent = makeAnimationEvent(element, "", "", "");
                return listenOnPlayer(this._getPlayer(id), eventName, baseEvent, callback), () => {};
            }
            command(id, element, command, args) {
                if ("register" == command) return void this.register(id, args[0]);
                if ("create" == command) return void this.create(id, element, args[0] || {});
                const player = this._getPlayer(id);
                switch (command) {
                  case "play":
                    player.play();
                    break;

                  case "pause":
                    player.pause();
                    break;

                  case "reset":
                    player.reset();
                    break;

                  case "restart":
                    player.restart();
                    break;

                  case "finish":
                    player.finish();
                    break;

                  case "init":
                    player.init();
                    break;

                  case "setPosition":
                    player.setPosition(parseFloat(args[0]));
                    break;

                  case "destroy":
                    this.destroy(id);
                }
            }
        }
        const QUEUED_CLASSNAME = "ng-animate-queued", QUEUED_SELECTOR = ".ng-animate-queued", DISABLED_CLASSNAME = "ng-animate-disabled", DISABLED_SELECTOR = ".ng-animate-disabled", STAR_CLASSNAME = "ng-star-inserted", STAR_SELECTOR = ".ng-star-inserted", EMPTY_PLAYER_ARRAY = [], NULL_REMOVAL_STATE = {
            namespaceId: "",
            setForRemoval: !1,
            setForMove: !1,
            hasAnimation: !1,
            removedBeforeQueried: !1
        }, NULL_REMOVED_QUERIED_STATE = {
            namespaceId: "",
            setForMove: !1,
            setForRemoval: !1,
            hasAnimation: !1,
            removedBeforeQueried: !0
        }, REMOVAL_FLAG = "__ng_removed";
        class StateValue {
            constructor(input, namespaceId = "") {
                this.namespaceId = namespaceId;
                const isObj = input && input.hasOwnProperty("value");
                if (this.value = null != (value = isObj ? input.value : input) ? value : null, isObj) {
                    const options = copyObj(input);
                    delete options.value, this.options = options;
                } else this.options = {};
                var value;
                this.options.params || (this.options.params = {});
            }
            get params() {
                return this.options.params;
            }
            absorbOptions(options) {
                const newParams = options.params;
                if (newParams) {
                    const oldParams = this.options.params;
                    Object.keys(newParams).forEach(prop => {
                        null == oldParams[prop] && (oldParams[prop] = newParams[prop]);
                    });
                }
            }
        }
        const VOID_VALUE = "void", DEFAULT_STATE_VALUE = new StateValue(VOID_VALUE);
        class AnimationTransitionNamespace {
            constructor(id, hostElement, _engine) {
                this.id = id, this.hostElement = hostElement, this._engine = _engine, this.players = [], 
                this._triggers = {}, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + id, 
                addClass(hostElement, this._hostClassName);
            }
            listen(element, name, phase, callback) {
                if (!this._triggers.hasOwnProperty(name)) throw new Error(`Unable to listen on the animation trigger event "${phase}" because the animation trigger "${name}" doesn't exist!`);
                if (null == phase || 0 == phase.length) throw new Error(`Unable to listen on the animation trigger "${name}" because the provided event is undefined!`);
                if ("start" != (eventName = phase) && "done" != eventName) throw new Error(`The provided animation trigger event "${phase}" for the animation trigger "${name}" is not supported!`);
                var eventName;
                const listeners = getOrSetAsInMap(this._elementListeners, element, []), data = {
                    name: name,
                    phase: phase,
                    callback: callback
                };
                listeners.push(data);
                const triggersWithStates = getOrSetAsInMap(this._engine.statesByElement, element, {});
                return triggersWithStates.hasOwnProperty(name) || (addClass(element, NG_TRIGGER_CLASSNAME), 
                addClass(element, NG_TRIGGER_CLASSNAME + "-" + name), triggersWithStates[name] = DEFAULT_STATE_VALUE), 
                () => {
                    this._engine.afterFlush(() => {
                        const index = listeners.indexOf(data);
                        index >= 0 && listeners.splice(index, 1), this._triggers[name] || delete triggersWithStates[name];
                    });
                };
            }
            register(name, ast) {
                return !this._triggers[name] && (this._triggers[name] = ast, !0);
            }
            _getTrigger(name) {
                const trigger = this._triggers[name];
                if (!trigger) throw new Error(`The provided animation trigger "${name}" has not been registered!`);
                return trigger;
            }
            trigger(element, triggerName, value, defaultToFallback = !0) {
                const trigger = this._getTrigger(triggerName), player = new browser_TransitionAnimationPlayer(this.id, triggerName, element);
                let triggersWithStates = this._engine.statesByElement.get(element);
                triggersWithStates || (addClass(element, NG_TRIGGER_CLASSNAME), addClass(element, NG_TRIGGER_CLASSNAME + "-" + triggerName), 
                this._engine.statesByElement.set(element, triggersWithStates = {}));
                let fromState = triggersWithStates[triggerName];
                const toState = new StateValue(value, this.id);
                if (!(value && value.hasOwnProperty("value")) && fromState && toState.absorbOptions(fromState.options), 
                triggersWithStates[triggerName] = toState, fromState || (fromState = DEFAULT_STATE_VALUE), 
                toState.value !== VOID_VALUE && fromState.value === toState.value) {
                    if (!function(a, b) {
                        const k1 = Object.keys(a), k2 = Object.keys(b);
                        if (k1.length != k2.length) return !1;
                        for (let i = 0; i < k1.length; i++) {
                            const prop = k1[i];
                            if (!b.hasOwnProperty(prop) || a[prop] !== b[prop]) return !1;
                        }
                        return !0;
                    }(fromState.params, toState.params)) {
                        const errors = [], fromStyles = trigger.matchStyles(fromState.value, fromState.params, errors), toStyles = trigger.matchStyles(toState.value, toState.params, errors);
                        errors.length ? this._engine.reportError(errors) : this._engine.afterFlush(() => {
                            eraseStyles(element, fromStyles), setStyles(element, toStyles);
                        });
                    }
                    return;
                }
                const playersOnElement = getOrSetAsInMap(this._engine.playersByElement, element, []);
                playersOnElement.forEach(player => {
                    player.namespaceId == this.id && player.triggerName == triggerName && player.queued && player.destroy();
                });
                let transition = trigger.matchTransition(fromState.value, toState.value, element, toState.params), isFallbackTransition = !1;
                if (!transition) {
                    if (!defaultToFallback) return;
                    transition = trigger.fallbackTransition, isFallbackTransition = !0;
                }
                return this._engine.totalQueuedPlayers++, this._queue.push({
                    element: element,
                    triggerName: triggerName,
                    transition: transition,
                    fromState: fromState,
                    toState: toState,
                    player: player,
                    isFallbackTransition: isFallbackTransition
                }), isFallbackTransition || (addClass(element, QUEUED_CLASSNAME), player.onStart(() => {
                    removeClass(element, QUEUED_CLASSNAME);
                })), player.onDone(() => {
                    let index = this.players.indexOf(player);
                    index >= 0 && this.players.splice(index, 1);
                    const players = this._engine.playersByElement.get(element);
                    if (players) {
                        let index = players.indexOf(player);
                        index >= 0 && players.splice(index, 1);
                    }
                }), this.players.push(player), playersOnElement.push(player), player;
            }
            deregister(name) {
                delete this._triggers[name], this._engine.statesByElement.forEach((stateMap, element) => {
                    delete stateMap[name];
                }), this._elementListeners.forEach((listeners, element) => {
                    this._elementListeners.set(element, listeners.filter(entry => entry.name != name));
                });
            }
            clearElementCache(element) {
                this._engine.statesByElement.delete(element), this._elementListeners.delete(element);
                const elementPlayers = this._engine.playersByElement.get(element);
                elementPlayers && (elementPlayers.forEach(player => player.destroy()), this._engine.playersByElement.delete(element));
            }
            _signalRemovalForInnerTriggers(rootElement, context, animate = !1) {
                this._engine.driver.query(rootElement, NG_TRIGGER_SELECTOR, !0).forEach(elm => {
                    if (elm[REMOVAL_FLAG]) return;
                    const namespaces = this._engine.fetchNamespacesByElement(elm);
                    namespaces.size ? namespaces.forEach(ns => ns.triggerLeaveAnimation(elm, context, !1, !0)) : this.clearElementCache(elm);
                });
            }
            triggerLeaveAnimation(element, context, destroyAfterComplete, defaultToFallback) {
                const triggerStates = this._engine.statesByElement.get(element);
                if (triggerStates) {
                    const players = [];
                    if (Object.keys(triggerStates).forEach(triggerName => {
                        if (this._triggers[triggerName]) {
                            const player = this.trigger(element, triggerName, VOID_VALUE, defaultToFallback);
                            player && players.push(player);
                        }
                    }), players.length) return this._engine.markElementAsRemoved(this.id, element, !0, context), 
                    destroyAfterComplete && optimizeGroupPlayer(players).onDone(() => this._engine.processLeaveNode(element)), 
                    !0;
                }
                return !1;
            }
            prepareLeaveAnimationListeners(element) {
                const listeners = this._elementListeners.get(element);
                if (listeners) {
                    const visitedTriggers = new Set;
                    listeners.forEach(listener => {
                        const triggerName = listener.name;
                        if (visitedTriggers.has(triggerName)) return;
                        visitedTriggers.add(triggerName);
                        const transition = this._triggers[triggerName].fallbackTransition, fromState = this._engine.statesByElement.get(element)[triggerName] || DEFAULT_STATE_VALUE, toState = new StateValue(VOID_VALUE), player = new browser_TransitionAnimationPlayer(this.id, triggerName, element);
                        this._engine.totalQueuedPlayers++, this._queue.push({
                            element: element,
                            triggerName: triggerName,
                            transition: transition,
                            fromState: fromState,
                            toState: toState,
                            player: player,
                            isFallbackTransition: !0
                        });
                    });
                }
            }
            removeNode(element, context) {
                const engine = this._engine;
                if (element.childElementCount && this._signalRemovalForInnerTriggers(element, context, !0), 
                this.triggerLeaveAnimation(element, context, !0)) return;
                let containsPotentialParentTransition = !1;
                if (engine.totalAnimations) {
                    const currentPlayers = engine.players.length ? engine.playersByQueriedElement.get(element) : [];
                    if (currentPlayers && currentPlayers.length) containsPotentialParentTransition = !0; else {
                        let parent = element;
                        for (;parent = parent.parentNode; ) if (engine.statesByElement.get(parent)) {
                            containsPotentialParentTransition = !0;
                            break;
                        }
                    }
                }
                this.prepareLeaveAnimationListeners(element), containsPotentialParentTransition ? engine.markElementAsRemoved(this.id, element, !1, context) : (engine.afterFlush(() => this.clearElementCache(element)), 
                engine.destroyInnerAnimations(element), engine._onRemovalComplete(element, context));
            }
            insertNode(element, parent) {
                addClass(element, this._hostClassName);
            }
            drainQueuedTransitions(microtaskId) {
                const instructions = [];
                return this._queue.forEach(entry => {
                    const player = entry.player;
                    if (player.destroyed) return;
                    const element = entry.element, listeners = this._elementListeners.get(element);
                    listeners && listeners.forEach(listener => {
                        if (listener.name == entry.triggerName) {
                            const baseEvent = makeAnimationEvent(element, entry.triggerName, entry.fromState.value, entry.toState.value);
                            baseEvent._data = microtaskId, listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);
                        }
                    }), player.markedForDestroy ? this._engine.afterFlush(() => {
                        player.destroy();
                    }) : instructions.push(entry);
                }), this._queue = [], instructions.sort((a, b) => {
                    const d0 = a.transition.ast.depCount, d1 = b.transition.ast.depCount;
                    return 0 == d0 || 0 == d1 ? d0 - d1 : this._engine.driver.containsElement(a.element, b.element) ? 1 : -1;
                });
            }
            destroy(context) {
                this.players.forEach(p => p.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, context);
            }
            elementContainsData(element) {
                let containsData = !1;
                return this._elementListeners.has(element) && (containsData = !0), !!this._queue.find(entry => entry.element === element) || containsData;
            }
        }
        class browser_TransitionAnimationEngine {
            constructor(bodyNode, driver, _normalizer) {
                this.bodyNode = bodyNode, this.driver = driver, this._normalizer = _normalizer, 
                this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, 
                this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, 
                this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, 
                this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, 
                this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (element, context) => {};
            }
            _onRemovalComplete(element, context) {
                this.onRemovalComplete(element, context);
            }
            get queuedPlayers() {
                const players = [];
                return this._namespaceList.forEach(ns => {
                    ns.players.forEach(player => {
                        player.queued && players.push(player);
                    });
                }), players;
            }
            createNamespace(namespaceId, hostElement) {
                const ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);
                return hostElement.parentNode ? this._balanceNamespaceList(ns, hostElement) : (this.newHostElements.set(hostElement, ns), 
                this.collectEnterElement(hostElement)), this._namespaceLookup[namespaceId] = ns;
            }
            _balanceNamespaceList(ns, hostElement) {
                const limit = this._namespaceList.length - 1;
                if (limit >= 0) {
                    let found = !1;
                    for (let i = limit; i >= 0; i--) if (this.driver.containsElement(this._namespaceList[i].hostElement, hostElement)) {
                        this._namespaceList.splice(i + 1, 0, ns), found = !0;
                        break;
                    }
                    found || this._namespaceList.splice(0, 0, ns);
                } else this._namespaceList.push(ns);
                return this.namespacesByHostElement.set(hostElement, ns), ns;
            }
            register(namespaceId, hostElement) {
                let ns = this._namespaceLookup[namespaceId];
                return ns || (ns = this.createNamespace(namespaceId, hostElement)), ns;
            }
            registerTrigger(namespaceId, name, trigger) {
                let ns = this._namespaceLookup[namespaceId];
                ns && ns.register(name, trigger) && this.totalAnimations++;
            }
            destroy(namespaceId, context) {
                if (!namespaceId) return;
                const ns = this._fetchNamespace(namespaceId);
                this.afterFlush(() => {
                    this.namespacesByHostElement.delete(ns.hostElement), delete this._namespaceLookup[namespaceId];
                    const index = this._namespaceList.indexOf(ns);
                    index >= 0 && this._namespaceList.splice(index, 1);
                }), this.afterFlushAnimationsDone(() => ns.destroy(context));
            }
            _fetchNamespace(id) {
                return this._namespaceLookup[id];
            }
            fetchNamespacesByElement(element) {
                const namespaces = new Set, elementStates = this.statesByElement.get(element);
                if (elementStates) {
                    const keys = Object.keys(elementStates);
                    for (let i = 0; i < keys.length; i++) {
                        const nsId = elementStates[keys[i]].namespaceId;
                        if (nsId) {
                            const ns = this._fetchNamespace(nsId);
                            ns && namespaces.add(ns);
                        }
                    }
                }
                return namespaces;
            }
            trigger(namespaceId, element, name, value) {
                if (isElementNode(element)) {
                    const ns = this._fetchNamespace(namespaceId);
                    if (ns) return ns.trigger(element, name, value), !0;
                }
                return !1;
            }
            insertNode(namespaceId, element, parent, insertBefore) {
                if (!isElementNode(element)) return;
                const details = element[REMOVAL_FLAG];
                if (details && details.setForRemoval) {
                    details.setForRemoval = !1, details.setForMove = !0;
                    const index = this.collectedLeaveElements.indexOf(element);
                    index >= 0 && this.collectedLeaveElements.splice(index, 1);
                }
                if (namespaceId) {
                    const ns = this._fetchNamespace(namespaceId);
                    ns && ns.insertNode(element, parent);
                }
                insertBefore && this.collectEnterElement(element);
            }
            collectEnterElement(element) {
                this.collectedEnterElements.push(element);
            }
            markElementAsDisabled(element, value) {
                value ? this.disabledNodes.has(element) || (this.disabledNodes.add(element), addClass(element, DISABLED_CLASSNAME)) : this.disabledNodes.has(element) && (this.disabledNodes.delete(element), 
                removeClass(element, DISABLED_CLASSNAME));
            }
            removeNode(namespaceId, element, isHostElement, context) {
                if (isElementNode(element)) {
                    const ns = namespaceId ? this._fetchNamespace(namespaceId) : null;
                    if (ns ? ns.removeNode(element, context) : this.markElementAsRemoved(namespaceId, element, !1, context), 
                    isHostElement) {
                        const hostNS = this.namespacesByHostElement.get(element);
                        hostNS && hostNS.id !== namespaceId && hostNS.removeNode(element, context);
                    }
                } else this._onRemovalComplete(element, context);
            }
            markElementAsRemoved(namespaceId, element, hasAnimation, context) {
                this.collectedLeaveElements.push(element), element[REMOVAL_FLAG] = {
                    namespaceId: namespaceId,
                    setForRemoval: context,
                    hasAnimation: hasAnimation,
                    removedBeforeQueried: !1
                };
            }
            listen(namespaceId, element, name, phase, callback) {
                return isElementNode(element) ? this._fetchNamespace(namespaceId).listen(element, name, phase, callback) : () => {};
            }
            _buildInstruction(entry, subTimelines, enterClassName, leaveClassName, skipBuildAst) {
                return entry.transition.build(this.driver, entry.element, entry.fromState.value, entry.toState.value, enterClassName, leaveClassName, entry.fromState.options, entry.toState.options, subTimelines, skipBuildAst);
            }
            destroyInnerAnimations(containerElement) {
                let elements = this.driver.query(containerElement, NG_TRIGGER_SELECTOR, !0);
                elements.forEach(element => this.destroyActiveAnimationsForElement(element)), 0 != this.playersByQueriedElement.size && (elements = this.driver.query(containerElement, NG_ANIMATING_SELECTOR, !0)).forEach(element => this.finishActiveQueriedAnimationOnElement(element));
            }
            destroyActiveAnimationsForElement(element) {
                const players = this.playersByElement.get(element);
                players && players.forEach(player => {
                    player.queued ? player.markedForDestroy = !0 : player.destroy();
                });
            }
            finishActiveQueriedAnimationOnElement(element) {
                const players = this.playersByQueriedElement.get(element);
                players && players.forEach(player => player.finish());
            }
            whenRenderingDone() {
                return new Promise(resolve => {
                    if (this.players.length) return optimizeGroupPlayer(this.players).onDone(() => resolve());
                    resolve();
                });
            }
            processLeaveNode(element) {
                const details = element[REMOVAL_FLAG];
                if (details && details.setForRemoval) {
                    if (element[REMOVAL_FLAG] = NULL_REMOVAL_STATE, details.namespaceId) {
                        this.destroyInnerAnimations(element);
                        const ns = this._fetchNamespace(details.namespaceId);
                        ns && ns.clearElementCache(element);
                    }
                    this._onRemovalComplete(element, details.setForRemoval);
                }
                this.driver.matchesElement(element, DISABLED_SELECTOR) && this.markElementAsDisabled(element, !1), 
                this.driver.query(element, DISABLED_SELECTOR, !0).forEach(node => {
                    this.markElementAsDisabled(node, !1);
                });
            }
            flush(microtaskId = -1) {
                let players = [];
                if (this.newHostElements.size && (this.newHostElements.forEach((ns, element) => this._balanceNamespaceList(ns, element)), 
                this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let i = 0; i < this.collectedEnterElements.length; i++) addClass(this.collectedEnterElements[i], STAR_CLASSNAME);
                if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
                    const cleanupFns = [];
                    try {
                        players = this._flushAnimations(cleanupFns, microtaskId);
                    } finally {
                        for (let i = 0; i < cleanupFns.length; i++) cleanupFns[i]();
                    }
                } else for (let i = 0; i < this.collectedLeaveElements.length; i++) this.processLeaveNode(this.collectedLeaveElements[i]);
                if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, 
                this._flushFns.forEach(fn => fn()), this._flushFns = [], this._whenQuietFns.length) {
                    const quietFns = this._whenQuietFns;
                    this._whenQuietFns = [], players.length ? optimizeGroupPlayer(players).onDone(() => {
                        quietFns.forEach(fn => fn());
                    }) : quietFns.forEach(fn => fn());
                }
            }
            reportError(errors) {
                throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${errors.join("\n")}`);
            }
            _flushAnimations(cleanupFns, microtaskId) {
                const subTimelines = new ElementInstructionMap, skippedPlayers = [], skippedPlayersMap = new Map, queuedInstructions = [], queriedElements = new Map, allPreStyleElements = new Map, allPostStyleElements = new Map, disabledElementsSet = new Set;
                this.disabledNodes.forEach(node => {
                    disabledElementsSet.add(node);
                    const nodesThatAreDisabled = this.driver.query(node, QUEUED_SELECTOR, !0);
                    for (let i = 0; i < nodesThatAreDisabled.length; i++) disabledElementsSet.add(nodesThatAreDisabled[i]);
                });
                const bodyNode = this.bodyNode, allTriggerElements = Array.from(this.statesByElement.keys()), enterNodeMap = buildRootMap(allTriggerElements, this.collectedEnterElements), enterNodeMapIds = new Map;
                let i = 0;
                enterNodeMap.forEach((nodes, root) => {
                    const className = ENTER_CLASSNAME + i++;
                    enterNodeMapIds.set(root, className), nodes.forEach(node => addClass(node, className));
                });
                const allLeaveNodes = [], mergedLeaveNodes = new Set, leaveNodesWithoutAnimations = new Set;
                for (let i = 0; i < this.collectedLeaveElements.length; i++) {
                    const element = this.collectedLeaveElements[i], details = element[REMOVAL_FLAG];
                    details && details.setForRemoval && (allLeaveNodes.push(element), mergedLeaveNodes.add(element), 
                    details.hasAnimation ? this.driver.query(element, STAR_SELECTOR, !0).forEach(elm => mergedLeaveNodes.add(elm)) : leaveNodesWithoutAnimations.add(element));
                }
                const leaveNodeMapIds = new Map, leaveNodeMap = buildRootMap(allTriggerElements, Array.from(mergedLeaveNodes));
                leaveNodeMap.forEach((nodes, root) => {
                    const className = LEAVE_CLASSNAME + i++;
                    leaveNodeMapIds.set(root, className), nodes.forEach(node => addClass(node, className));
                }), cleanupFns.push(() => {
                    enterNodeMap.forEach((nodes, root) => {
                        const className = enterNodeMapIds.get(root);
                        nodes.forEach(node => removeClass(node, className));
                    }), leaveNodeMap.forEach((nodes, root) => {
                        const className = leaveNodeMapIds.get(root);
                        nodes.forEach(node => removeClass(node, className));
                    }), allLeaveNodes.forEach(element => {
                        this.processLeaveNode(element);
                    });
                });
                const allPlayers = [], erroneousTransitions = [];
                for (let i = this._namespaceList.length - 1; i >= 0; i--) this._namespaceList[i].drainQueuedTransitions(microtaskId).forEach(entry => {
                    const player = entry.player, element = entry.element;
                    if (allPlayers.push(player), this.collectedEnterElements.length) {
                        const details = element[REMOVAL_FLAG];
                        if (details && details.setForMove) return void player.destroy();
                    }
                    const nodeIsOrphaned = !bodyNode || !this.driver.containsElement(bodyNode, element), leaveClassName = leaveNodeMapIds.get(element), enterClassName = enterNodeMapIds.get(element), instruction = this._buildInstruction(entry, subTimelines, enterClassName, leaveClassName, nodeIsOrphaned);
                    if (!instruction.errors || !instruction.errors.length) return nodeIsOrphaned ? (player.onStart(() => eraseStyles(element, instruction.fromStyles)), 
                    player.onDestroy(() => setStyles(element, instruction.toStyles)), void skippedPlayers.push(player)) : entry.isFallbackTransition ? (player.onStart(() => eraseStyles(element, instruction.fromStyles)), 
                    player.onDestroy(() => setStyles(element, instruction.toStyles)), void skippedPlayers.push(player)) : (instruction.timelines.forEach(tl => tl.stretchStartingKeyframe = !0), 
                    subTimelines.append(element, instruction.timelines), queuedInstructions.push({
                        instruction: instruction,
                        player: player,
                        element: element
                    }), instruction.queriedElements.forEach(element => getOrSetAsInMap(queriedElements, element, []).push(player)), 
                    instruction.preStyleProps.forEach((stringMap, element) => {
                        const props = Object.keys(stringMap);
                        if (props.length) {
                            let setVal = allPreStyleElements.get(element);
                            setVal || allPreStyleElements.set(element, setVal = new Set), props.forEach(prop => setVal.add(prop));
                        }
                    }), void instruction.postStyleProps.forEach((stringMap, element) => {
                        const props = Object.keys(stringMap);
                        let setVal = allPostStyleElements.get(element);
                        setVal || allPostStyleElements.set(element, setVal = new Set), props.forEach(prop => setVal.add(prop));
                    }));
                    erroneousTransitions.push(instruction);
                });
                if (erroneousTransitions.length) {
                    const errors = [];
                    erroneousTransitions.forEach(instruction => {
                        errors.push(`@${instruction.triggerName} has failed due to:\n`), instruction.errors.forEach(error => errors.push(`- ${error}\n`));
                    }), allPlayers.forEach(player => player.destroy()), this.reportError(errors);
                }
                const allPreviousPlayersMap = new Map, animationElementMap = new Map;
                queuedInstructions.forEach(entry => {
                    const element = entry.element;
                    subTimelines.has(element) && (animationElementMap.set(element, element), this._beforeAnimationBuild(entry.player.namespaceId, entry.instruction, allPreviousPlayersMap));
                }), skippedPlayers.forEach(player => {
                    const element = player.element;
                    this._getPreviousPlayers(element, !1, player.namespaceId, player.triggerName, null).forEach(prevPlayer => {
                        getOrSetAsInMap(allPreviousPlayersMap, element, []).push(prevPlayer), prevPlayer.destroy();
                    });
                });
                const replaceNodes = allLeaveNodes.filter(node => replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements)), postStylesMap = new Map;
                cloakAndComputeStyles(postStylesMap, this.driver, leaveNodesWithoutAnimations, allPostStyleElements, animations.a).forEach(node => {
                    replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements) && replaceNodes.push(node);
                });
                const preStylesMap = new Map;
                enterNodeMap.forEach((nodes, root) => {
                    cloakAndComputeStyles(preStylesMap, this.driver, new Set(nodes), allPreStyleElements, animations.l);
                }), replaceNodes.forEach(node => {
                    const post = postStylesMap.get(node), pre = preStylesMap.get(node);
                    postStylesMap.set(node, Object.assign(Object.assign({}, post), pre));
                });
                const rootPlayers = [], subPlayers = [], NO_PARENT_ANIMATION_ELEMENT_DETECTED = {};
                queuedInstructions.forEach(entry => {
                    const {element: element, player: player, instruction: instruction} = entry;
                    if (subTimelines.has(element)) {
                        if (disabledElementsSet.has(element)) return player.onDestroy(() => setStyles(element, instruction.toStyles)), 
                        player.disabled = !0, player.overrideTotalTime(instruction.totalTime), void skippedPlayers.push(player);
                        let parentWithAnimation = NO_PARENT_ANIMATION_ELEMENT_DETECTED;
                        if (animationElementMap.size > 1) {
                            let elm = element;
                            const parentsToAdd = [];
                            for (;elm = elm.parentNode; ) {
                                const detectedParent = animationElementMap.get(elm);
                                if (detectedParent) {
                                    parentWithAnimation = detectedParent;
                                    break;
                                }
                                parentsToAdd.push(elm);
                            }
                            parentsToAdd.forEach(parent => animationElementMap.set(parent, parentWithAnimation));
                        }
                        const innerPlayer = this._buildAnimation(player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap);
                        if (player.setRealPlayer(innerPlayer), parentWithAnimation === NO_PARENT_ANIMATION_ELEMENT_DETECTED) rootPlayers.push(player); else {
                            const parentPlayers = this.playersByElement.get(parentWithAnimation);
                            parentPlayers && parentPlayers.length && (player.parentPlayer = optimizeGroupPlayer(parentPlayers)), 
                            skippedPlayers.push(player);
                        }
                    } else eraseStyles(element, instruction.fromStyles), player.onDestroy(() => setStyles(element, instruction.toStyles)), 
                    subPlayers.push(player), disabledElementsSet.has(element) && skippedPlayers.push(player);
                }), subPlayers.forEach(player => {
                    const playersForElement = skippedPlayersMap.get(player.element);
                    if (playersForElement && playersForElement.length) {
                        const innerPlayer = optimizeGroupPlayer(playersForElement);
                        player.setRealPlayer(innerPlayer);
                    }
                }), skippedPlayers.forEach(player => {
                    player.parentPlayer ? player.syncPlayerEvents(player.parentPlayer) : player.destroy();
                });
                for (let i = 0; i < allLeaveNodes.length; i++) {
                    const element = allLeaveNodes[i], details = element[REMOVAL_FLAG];
                    if (removeClass(element, LEAVE_CLASSNAME), details && details.hasAnimation) continue;
                    let players = [];
                    if (queriedElements.size) {
                        let queriedPlayerResults = queriedElements.get(element);
                        queriedPlayerResults && queriedPlayerResults.length && players.push(...queriedPlayerResults);
                        let queriedInnerElements = this.driver.query(element, NG_ANIMATING_SELECTOR, !0);
                        for (let j = 0; j < queriedInnerElements.length; j++) {
                            let queriedPlayers = queriedElements.get(queriedInnerElements[j]);
                            queriedPlayers && queriedPlayers.length && players.push(...queriedPlayers);
                        }
                    }
                    const activePlayers = players.filter(p => !p.destroyed);
                    activePlayers.length ? removeNodesAfterAnimationDone(this, element, activePlayers) : this.processLeaveNode(element);
                }
                return allLeaveNodes.length = 0, rootPlayers.forEach(player => {
                    this.players.push(player), player.onDone(() => {
                        player.destroy();
                        const index = this.players.indexOf(player);
                        this.players.splice(index, 1);
                    }), player.play();
                }), rootPlayers;
            }
            elementContainsData(namespaceId, element) {
                let containsData = !1;
                const details = element[REMOVAL_FLAG];
                return details && details.setForRemoval && (containsData = !0), this.playersByElement.has(element) && (containsData = !0), 
                this.playersByQueriedElement.has(element) && (containsData = !0), this.statesByElement.has(element) && (containsData = !0), 
                this._fetchNamespace(namespaceId).elementContainsData(element) || containsData;
            }
            afterFlush(callback) {
                this._flushFns.push(callback);
            }
            afterFlushAnimationsDone(callback) {
                this._whenQuietFns.push(callback);
            }
            _getPreviousPlayers(element, isQueriedElement, namespaceId, triggerName, toStateValue) {
                let players = [];
                if (isQueriedElement) {
                    const queriedElementPlayers = this.playersByQueriedElement.get(element);
                    queriedElementPlayers && (players = queriedElementPlayers);
                } else {
                    const elementPlayers = this.playersByElement.get(element);
                    if (elementPlayers) {
                        const isRemovalAnimation = !toStateValue || toStateValue == VOID_VALUE;
                        elementPlayers.forEach(player => {
                            player.queued || (isRemovalAnimation || player.triggerName == triggerName) && players.push(player);
                        });
                    }
                }
                return (namespaceId || triggerName) && (players = players.filter(player => !(namespaceId && namespaceId != player.namespaceId || triggerName && triggerName != player.triggerName))), 
                players;
            }
            _beforeAnimationBuild(namespaceId, instruction, allPreviousPlayersMap) {
                const rootElement = instruction.element, targetNameSpaceId = instruction.isRemovalTransition ? void 0 : namespaceId, targetTriggerName = instruction.isRemovalTransition ? void 0 : instruction.triggerName;
                for (const timelineInstruction of instruction.timelines) {
                    const element = timelineInstruction.element, isQueriedElement = element !== rootElement, players = getOrSetAsInMap(allPreviousPlayersMap, element, []);
                    this._getPreviousPlayers(element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState).forEach(player => {
                        const realPlayer = player.getRealPlayer();
                        realPlayer.beforeDestroy && realPlayer.beforeDestroy(), player.destroy(), players.push(player);
                    });
                }
                eraseStyles(rootElement, instruction.fromStyles);
            }
            _buildAnimation(namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap) {
                const triggerName = instruction.triggerName, rootElement = instruction.element, allQueriedPlayers = [], allConsumedElements = new Set, allSubElements = new Set, allNewPlayers = instruction.timelines.map(timelineInstruction => {
                    const element = timelineInstruction.element;
                    allConsumedElements.add(element);
                    const details = element[REMOVAL_FLAG];
                    if (details && details.removedBeforeQueried) return new animations.d(timelineInstruction.duration, timelineInstruction.delay);
                    const isQueriedElement = element !== rootElement, previousPlayers = function(players) {
                        const finalPlayers = [];
                        return function _flattenGroupPlayersRecur(players, finalPlayers) {
                            for (let i = 0; i < players.length; i++) {
                                const player = players[i];
                                player instanceof animations.k ? _flattenGroupPlayersRecur(player.players, finalPlayers) : finalPlayers.push(player);
                            }
                        }(players, finalPlayers), finalPlayers;
                    }((allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY).map(p => p.getRealPlayer())).filter(p => !!p.element && p.element === element), preStyles = preStylesMap.get(element), postStyles = postStylesMap.get(element), keyframes = normalizeKeyframes(0, this._normalizer, 0, timelineInstruction.keyframes, preStyles, postStyles), player = this._buildPlayer(timelineInstruction, keyframes, previousPlayers);
                    if (timelineInstruction.subTimeline && skippedPlayersMap && allSubElements.add(element), 
                    isQueriedElement) {
                        const wrappedPlayer = new browser_TransitionAnimationPlayer(namespaceId, triggerName, element);
                        wrappedPlayer.setRealPlayer(player), allQueriedPlayers.push(wrappedPlayer);
                    }
                    return player;
                });
                allQueriedPlayers.forEach(player => {
                    getOrSetAsInMap(this.playersByQueriedElement, player.element, []).push(player), 
                    player.onDone(() => (function(map, key, value) {
                        let currentValues;
                        if (map instanceof Map) {
                            if (currentValues = map.get(key)) {
                                if (currentValues.length) {
                                    const index = currentValues.indexOf(value);
                                    currentValues.splice(index, 1);
                                }
                                0 == currentValues.length && map.delete(key);
                            }
                        } else if (currentValues = map[key]) {
                            if (currentValues.length) {
                                const index = currentValues.indexOf(value);
                                currentValues.splice(index, 1);
                            }
                            0 == currentValues.length && delete map[key];
                        }
                        return currentValues;
                    })(this.playersByQueriedElement, player.element, player));
                }), allConsumedElements.forEach(element => addClass(element, NG_ANIMATING_CLASSNAME));
                const player = optimizeGroupPlayer(allNewPlayers);
                return player.onDestroy(() => {
                    allConsumedElements.forEach(element => removeClass(element, NG_ANIMATING_CLASSNAME)), 
                    setStyles(rootElement, instruction.toStyles);
                }), allSubElements.forEach(element => {
                    getOrSetAsInMap(skippedPlayersMap, element, []).push(player);
                }), player;
            }
            _buildPlayer(instruction, keyframes, previousPlayers) {
                return keyframes.length > 0 ? this.driver.animate(instruction.element, keyframes, instruction.duration, instruction.delay, instruction.easing, previousPlayers) : new animations.d(instruction.duration, instruction.delay);
            }
        }
        class browser_TransitionAnimationPlayer {
            constructor(namespaceId, triggerName, element) {
                this.namespaceId = namespaceId, this.triggerName = triggerName, this.element = element, 
                this._player = new animations.d, this._containsRealPlayer = !1, this._queuedCallbacks = {}, 
                this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, 
                this.totalTime = 0;
            }
            setRealPlayer(player) {
                this._containsRealPlayer || (this._player = player, Object.keys(this._queuedCallbacks).forEach(phase => {
                    this._queuedCallbacks[phase].forEach(callback => listenOnPlayer(player, phase, void 0, callback));
                }), this._queuedCallbacks = {}, this._containsRealPlayer = !0, this.overrideTotalTime(player.totalTime), 
                this.queued = !1);
            }
            getRealPlayer() {
                return this._player;
            }
            overrideTotalTime(totalTime) {
                this.totalTime = totalTime;
            }
            syncPlayerEvents(player) {
                const p = this._player;
                p.triggerCallback && player.onStart(() => p.triggerCallback("start")), player.onDone(() => this.finish()), 
                player.onDestroy(() => this.destroy());
            }
            _queueEvent(name, callback) {
                getOrSetAsInMap(this._queuedCallbacks, name, []).push(callback);
            }
            onDone(fn) {
                this.queued && this._queueEvent("done", fn), this._player.onDone(fn);
            }
            onStart(fn) {
                this.queued && this._queueEvent("start", fn), this._player.onStart(fn);
            }
            onDestroy(fn) {
                this.queued && this._queueEvent("destroy", fn), this._player.onDestroy(fn);
            }
            init() {
                this._player.init();
            }
            hasStarted() {
                return !this.queued && this._player.hasStarted();
            }
            play() {
                !this.queued && this._player.play();
            }
            pause() {
                !this.queued && this._player.pause();
            }
            restart() {
                !this.queued && this._player.restart();
            }
            finish() {
                this._player.finish();
            }
            destroy() {
                this.destroyed = !0, this._player.destroy();
            }
            reset() {
                !this.queued && this._player.reset();
            }
            setPosition(p) {
                this.queued || this._player.setPosition(p);
            }
            getPosition() {
                return this.queued ? 0 : this._player.getPosition();
            }
            triggerCallback(phaseName) {
                const p = this._player;
                p.triggerCallback && p.triggerCallback(phaseName);
            }
        }
        function isElementNode(node) {
            return node && 1 === node.nodeType;
        }
        function cloakElement(element, value) {
            const oldValue = element.style.display;
            return element.style.display = null != value ? value : "none", oldValue;
        }
        function cloakAndComputeStyles(valuesMap, driver, elements, elementPropsMap, defaultStyle) {
            const cloakVals = [];
            elements.forEach(element => cloakVals.push(cloakElement(element)));
            const failedElements = [];
            elementPropsMap.forEach((props, element) => {
                const styles = {};
                props.forEach(prop => {
                    const value = styles[prop] = driver.computeStyle(element, prop, defaultStyle);
                    value && 0 != value.length || (element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE, 
                    failedElements.push(element));
                }), valuesMap.set(element, styles);
            });
            let i = 0;
            return elements.forEach(element => cloakElement(element, cloakVals[i++])), failedElements;
        }
        function buildRootMap(roots, nodes) {
            const rootMap = new Map;
            if (roots.forEach(root => rootMap.set(root, [])), 0 == nodes.length) return rootMap;
            const nodeSet = new Set(nodes), localRootMap = new Map;
            return nodes.forEach(node => {
                const root = function getRoot(node) {
                    if (!node) return 1;
                    let root = localRootMap.get(node);
                    if (root) return root;
                    const parent = node.parentNode;
                    return root = rootMap.has(parent) ? parent : nodeSet.has(parent) ? 1 : getRoot(parent), 
                    localRootMap.set(node, root), root;
                }(node);
                1 !== root && rootMap.get(root).push(node);
            }), rootMap;
        }
        const CLASSES_CACHE_KEY = "$$classes";
        function addClass(element, className) {
            if (element.classList) element.classList.add(className); else {
                let classes = element[CLASSES_CACHE_KEY];
                classes || (classes = element[CLASSES_CACHE_KEY] = {}), classes[className] = !0;
            }
        }
        function removeClass(element, className) {
            if (element.classList) element.classList.remove(className); else {
                let classes = element[CLASSES_CACHE_KEY];
                classes && delete classes[className];
            }
        }
        function removeNodesAfterAnimationDone(engine, element, players) {
            optimizeGroupPlayer(players).onDone(() => engine.processLeaveNode(element));
        }
        function replacePostStylesAsPre(element, allPreStyleElements, allPostStyleElements) {
            const postEntry = allPostStyleElements.get(element);
            if (!postEntry) return !1;
            let preEntry = allPreStyleElements.get(element);
            return preEntry ? postEntry.forEach(data => preEntry.add(data)) : allPreStyleElements.set(element, postEntry), 
            allPostStyleElements.delete(element), !0;
        }
        class AnimationEngine {
            constructor(bodyNode, _driver, normalizer) {
                this.bodyNode = bodyNode, this._driver = _driver, this._triggerCache = {}, this.onRemovalComplete = (element, context) => {}, 
                this._transitionEngine = new browser_TransitionAnimationEngine(bodyNode, _driver, normalizer), 
                this._timelineEngine = new browser_TimelineAnimationEngine(bodyNode, _driver, normalizer), 
                this._transitionEngine.onRemovalComplete = (element, context) => this.onRemovalComplete(element, context);
            }
            registerTrigger(componentId, namespaceId, hostElement, name, metadata) {
                const cacheKey = componentId + "-" + name;
                let trigger = this._triggerCache[cacheKey];
                if (!trigger) {
                    const errors = [], ast = buildAnimationAst(this._driver, metadata, errors);
                    if (errors.length) throw new Error(`The animation trigger "${name}" has failed to build due to the following errors:\n - ${errors.join("\n - ")}`);
                    trigger = function(name, ast) {
                        return new AnimationTrigger(name, ast);
                    }(name, ast), this._triggerCache[cacheKey] = trigger;
                }
                this._transitionEngine.registerTrigger(namespaceId, name, trigger);
            }
            register(namespaceId, hostElement) {
                this._transitionEngine.register(namespaceId, hostElement);
            }
            destroy(namespaceId, context) {
                this._transitionEngine.destroy(namespaceId, context);
            }
            onInsert(namespaceId, element, parent, insertBefore) {
                this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);
            }
            onRemove(namespaceId, element, context, isHostElement) {
                this._transitionEngine.removeNode(namespaceId, element, isHostElement || !1, context);
            }
            disableAnimations(element, disable) {
                this._transitionEngine.markElementAsDisabled(element, disable);
            }
            process(namespaceId, element, property, value) {
                if ("@" == property.charAt(0)) {
                    const [id, action] = parseTimelineCommand(property);
                    this._timelineEngine.command(id, element, action, value);
                } else this._transitionEngine.trigger(namespaceId, element, property, value);
            }
            listen(namespaceId, element, eventName, eventPhase, callback) {
                if ("@" == eventName.charAt(0)) {
                    const [id, action] = parseTimelineCommand(eventName);
                    return this._timelineEngine.listen(id, element, action, callback);
                }
                return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);
            }
            flush(microtaskId = -1) {
                this._transitionEngine.flush(microtaskId);
            }
            get players() {
                return this._transitionEngine.players.concat(this._timelineEngine.players);
            }
            whenRenderingDone() {
                return this._transitionEngine.whenRenderingDone();
            }
        }
        function packageNonAnimatableStyles(element, styles) {
            let startStyles = null, endStyles = null;
            return Array.isArray(styles) && styles.length ? (startStyles = filterNonAnimatableStyles(styles[0]), 
            styles.length > 1 && (endStyles = filterNonAnimatableStyles(styles[styles.length - 1]))) : styles && (startStyles = filterNonAnimatableStyles(styles)), 
            startStyles || endStyles ? new SpecialCasedStyles(element, startStyles, endStyles) : null;
        }
        let SpecialCasedStyles = (() => {
            class SpecialCasedStyles {
                constructor(_element, _startStyles, _endStyles) {
                    this._element = _element, this._startStyles = _startStyles, this._endStyles = _endStyles, 
                    this._state = 0;
                    let initialStyles = SpecialCasedStyles.initialStylesByElement.get(_element);
                    initialStyles || SpecialCasedStyles.initialStylesByElement.set(_element, initialStyles = {}), 
                    this._initialStyles = initialStyles;
                }
                start() {
                    this._state < 1 && (this._startStyles && setStyles(this._element, this._startStyles, this._initialStyles), 
                    this._state = 1);
                }
                finish() {
                    this.start(), this._state < 2 && (setStyles(this._element, this._initialStyles), 
                    this._endStyles && (setStyles(this._element, this._endStyles), this._endStyles = null), 
                    this._state = 1);
                }
                destroy() {
                    this.finish(), this._state < 3 && (SpecialCasedStyles.initialStylesByElement.delete(this._element), 
                    this._startStyles && (eraseStyles(this._element, this._startStyles), this._endStyles = null), 
                    this._endStyles && (eraseStyles(this._element, this._endStyles), this._endStyles = null), 
                    setStyles(this._element, this._initialStyles), this._state = 3);
                }
            }
            return SpecialCasedStyles.initialStylesByElement = new WeakMap, SpecialCasedStyles;
        })();
        function filterNonAnimatableStyles(styles) {
            let result = null;
            const props = Object.keys(styles);
            for (let i = 0; i < props.length; i++) {
                const prop = props[i];
                isNonAnimatableStyle(prop) && ((result = result || {})[prop] = styles[prop]);
            }
            return result;
        }
        function isNonAnimatableStyle(prop) {
            return "display" === prop || "position" === prop;
        }
        const ELAPSED_TIME_MAX_DECIMAL_PLACES = 3, ANIMATION_PROP = "animation", ANIMATIONEND_EVENT = "animationend", ONE_SECOND$1 = 1e3;
        class ElementAnimationStyleHandler {
            constructor(_element, _name, _duration, _delay, _easing, _fillMode, _onDoneFn) {
                this._element = _element, this._name = _name, this._duration = _duration, this._delay = _delay, 
                this._easing = _easing, this._fillMode = _fillMode, this._onDoneFn = _onDoneFn, 
                this._finished = !1, this._destroyed = !1, this._startTime = 0, this._position = 0, 
                this._eventFn = e => this._handleCallback(e);
            }
            apply() {
                !function(element, value) {
                    const anim = getAnimationStyle(element, "").trim();
                    anim.length && (function(value, char) {
                        let count = 0;
                        for (let i = 0; i < value.length; i++) "," === value.charAt(i) && count++;
                    }(anim), value = `${anim}, ${value}`), setAnimationStyle(element, "", value);
                }(this._element, `${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`), 
                addRemoveAnimationEvent(this._element, this._eventFn, !1), this._startTime = Date.now();
            }
            pause() {
                playPauseAnimation(this._element, this._name, "paused");
            }
            resume() {
                playPauseAnimation(this._element, this._name, "running");
            }
            setPosition(position) {
                const index = findIndexForAnimation(this._element, this._name);
                this._position = position * this._duration, setAnimationStyle(this._element, "Delay", `-${this._position}ms`, index);
            }
            getPosition() {
                return this._position;
            }
            _handleCallback(event) {
                const timestamp = event._ngTestManualTimestamp || Date.now(), elapsedTime = parseFloat(event.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES)) * ONE_SECOND$1;
                event.animationName == this._name && Math.max(timestamp - this._startTime, 0) >= this._delay && elapsedTime >= this._duration && this.finish();
            }
            finish() {
                this._finished || (this._finished = !0, this._onDoneFn(), addRemoveAnimationEvent(this._element, this._eventFn, !0));
            }
            destroy() {
                this._destroyed || (this._destroyed = !0, this.finish(), function(element, name) {
                    const tokens = getAnimationStyle(element, "").split(","), index = findMatchingTokenIndex(tokens, name);
                    index >= 0 && (tokens.splice(index, 1), setAnimationStyle(element, "", tokens.join(",")));
                }(this._element, this._name));
            }
        }
        function playPauseAnimation(element, name, status) {
            setAnimationStyle(element, "PlayState", status, findIndexForAnimation(element, name));
        }
        function findIndexForAnimation(element, value) {
            const anim = getAnimationStyle(element, "");
            return anim.indexOf(",") > 0 ? findMatchingTokenIndex(anim.split(","), value) : findMatchingTokenIndex([ anim ], value);
        }
        function findMatchingTokenIndex(tokens, searchToken) {
            for (let i = 0; i < tokens.length; i++) if (tokens[i].indexOf(searchToken) >= 0) return i;
            return -1;
        }
        function addRemoveAnimationEvent(element, fn, doRemove) {
            doRemove ? element.removeEventListener(ANIMATIONEND_EVENT, fn) : element.addEventListener(ANIMATIONEND_EVENT, fn);
        }
        function setAnimationStyle(element, name, value, index) {
            const prop = ANIMATION_PROP + name;
            if (null != index) {
                const oldValue = element.style[prop];
                if (oldValue.length) {
                    const tokens = oldValue.split(",");
                    tokens[index] = value, value = tokens.join(",");
                }
            }
            element.style[prop] = value;
        }
        function getAnimationStyle(element, name) {
            return element.style[ANIMATION_PROP + name];
        }
        const DEFAULT_FILL_MODE = "forwards", DEFAULT_EASING = "linear";
        class CssKeyframesPlayer {
            constructor(element, keyframes, animationName, _duration, _delay, easing, _finalStyles, _specialStyles) {
                this.element = element, this.keyframes = keyframes, this.animationName = animationName, 
                this._duration = _duration, this._delay = _delay, this._finalStyles = _finalStyles, 
                this._specialStyles = _specialStyles, this._onDoneFns = [], this._onStartFns = [], 
                this._onDestroyFns = [], this._started = !1, this.currentSnapshot = {}, this._state = 0, 
                this.easing = easing || DEFAULT_EASING, this.totalTime = _duration + _delay, this._buildStyler();
            }
            onStart(fn) {
                this._onStartFns.push(fn);
            }
            onDone(fn) {
                this._onDoneFns.push(fn);
            }
            onDestroy(fn) {
                this._onDestroyFns.push(fn);
            }
            destroy() {
                this.init(), this._state >= 4 || (this._state = 4, this._styler.destroy(), this._flushStartFns(), 
                this._flushDoneFns(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(fn => fn()), 
                this._onDestroyFns = []);
            }
            _flushDoneFns() {
                this._onDoneFns.forEach(fn => fn()), this._onDoneFns = [];
            }
            _flushStartFns() {
                this._onStartFns.forEach(fn => fn()), this._onStartFns = [];
            }
            finish() {
                this.init(), this._state >= 3 || (this._state = 3, this._styler.finish(), this._flushStartFns(), 
                this._specialStyles && this._specialStyles.finish(), this._flushDoneFns());
            }
            setPosition(value) {
                this._styler.setPosition(value);
            }
            getPosition() {
                return this._styler.getPosition();
            }
            hasStarted() {
                return this._state >= 2;
            }
            init() {
                this._state >= 1 || (this._state = 1, this._styler.apply(), this._delay && this._styler.pause());
            }
            play() {
                this.init(), this.hasStarted() || (this._flushStartFns(), this._state = 2, this._specialStyles && this._specialStyles.start()), 
                this._styler.resume();
            }
            pause() {
                this.init(), this._styler.pause();
            }
            restart() {
                this.reset(), this.play();
            }
            reset() {
                this._styler.destroy(), this._buildStyler(), this._styler.apply();
            }
            _buildStyler() {
                this._styler = new ElementAnimationStyleHandler(this.element, this.animationName, this._duration, this._delay, this.easing, DEFAULT_FILL_MODE, () => this.finish());
            }
            triggerCallback(phaseName) {
                const methods = "start" == phaseName ? this._onStartFns : this._onDoneFns;
                methods.forEach(fn => fn()), methods.length = 0;
            }
            beforeDestroy() {
                this.init();
                const styles = {};
                if (this.hasStarted()) {
                    const finished = this._state >= 3;
                    Object.keys(this._finalStyles).forEach(prop => {
                        "offset" != prop && (styles[prop] = finished ? this._finalStyles[prop] : computeStyle(this.element, prop));
                    });
                }
                this.currentSnapshot = styles;
            }
        }
        class browser_DirectStylePlayer extends animations.d {
            constructor(element, styles) {
                super(), this.element = element, this._startingStyles = {}, this.__initialized = !1, 
                this._styles = hypenatePropsObject(styles);
            }
            init() {
                !this.__initialized && this._startingStyles && (this.__initialized = !0, Object.keys(this._styles).forEach(prop => {
                    this._startingStyles[prop] = this.element.style[prop];
                }), super.init());
            }
            play() {
                this._startingStyles && (this.init(), Object.keys(this._styles).forEach(prop => this.element.style.setProperty(prop, this._styles[prop])), 
                super.play());
            }
            destroy() {
                this._startingStyles && (Object.keys(this._startingStyles).forEach(prop => {
                    const value = this._startingStyles[prop];
                    value ? this.element.style.setProperty(prop, value) : this.element.style.removeProperty(prop);
                }), this._startingStyles = null, super.destroy());
            }
        }
        const KEYFRAMES_NAME_PREFIX = "gen_css_kf_", TAB_SPACE = " ";
        class CssKeyframesDriver {
            constructor() {
                this._count = 0, this._head = document.querySelector("head"), this._warningIssued = !1;
            }
            validateStyleProperty(prop) {
                return validateStyleProperty(prop);
            }
            matchesElement(element, selector) {
                return matchesElement(element, selector);
            }
            containsElement(elm1, elm2) {
                return containsElement(elm1, elm2);
            }
            query(element, selector, multi) {
                return invokeQuery(element, selector, multi);
            }
            computeStyle(element, prop, defaultValue) {
                return window.getComputedStyle(element)[prop];
            }
            buildKeyframeElement(element, name, keyframes) {
                keyframes = keyframes.map(kf => hypenatePropsObject(kf));
                let keyframeStr = `@keyframes ${name} {\n`, tab = "";
                keyframes.forEach(kf => {
                    tab = TAB_SPACE;
                    const offset = parseFloat(kf.offset);
                    keyframeStr += `${tab}${100 * offset}% {\n`, tab += TAB_SPACE, Object.keys(kf).forEach(prop => {
                        const value = kf[prop];
                        switch (prop) {
                          case "offset":
                            return;

                          case "easing":
                            return void (value && (keyframeStr += `${tab}animation-timing-function: ${value};\n`));

                          default:
                            return void (keyframeStr += `${tab}${prop}: ${value};\n`);
                        }
                    }), keyframeStr += `${tab}}\n`;
                }), keyframeStr += "}\n";
                const kfElm = document.createElement("style");
                return kfElm.innerHTML = keyframeStr, kfElm;
            }
            animate(element, keyframes, duration, delay, easing, previousPlayers = [], scrubberAccessRequested) {
                scrubberAccessRequested && this._notifyFaultyScrubber();
                const previousCssKeyframePlayers = previousPlayers.filter(player => player instanceof CssKeyframesPlayer), previousStyles = {};
                allowPreviousPlayerStylesMerge(duration, delay) && previousCssKeyframePlayers.forEach(player => {
                    let styles = player.currentSnapshot;
                    Object.keys(styles).forEach(prop => previousStyles[prop] = styles[prop]);
                });
                const finalStyles = function(keyframes) {
                    let flatKeyframes = {};
                    return keyframes && (Array.isArray(keyframes) ? keyframes : [ keyframes ]).forEach(kf => {
                        Object.keys(kf).forEach(prop => {
                            "offset" != prop && "easing" != prop && (flatKeyframes[prop] = kf[prop]);
                        });
                    }), flatKeyframes;
                }(keyframes = balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles));
                if (0 == duration) return new browser_DirectStylePlayer(element, finalStyles);
                const animationName = `${KEYFRAMES_NAME_PREFIX}${this._count++}`, kfElm = this.buildKeyframeElement(element, animationName, keyframes);
                document.querySelector("head").appendChild(kfElm);
                const specialStyles = packageNonAnimatableStyles(element, keyframes), player = new CssKeyframesPlayer(element, keyframes, animationName, duration, delay, easing, finalStyles, specialStyles);
                return player.onDestroy(() => (function(node) {
                    node.parentNode.removeChild(node);
                })(kfElm)), player;
            }
            _notifyFaultyScrubber() {
                this._warningIssued || (console.warn("@angular/animations: please load the web-animations.js polyfill to allow programmatic access...\n", "  visit http://bit.ly/IWukam to learn more about using the web-animation-js polyfill."), 
                this._warningIssued = !0);
            }
        }
        class WebAnimationsPlayer {
            constructor(element, keyframes, options, _specialStyles) {
                this.element = element, this.keyframes = keyframes, this.options = options, this._specialStyles = _specialStyles, 
                this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, 
                this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, 
                this.currentSnapshot = {}, this._duration = options.duration, this._delay = options.delay || 0, 
                this.time = this._duration + this._delay;
            }
            _onFinish() {
                this._finished || (this._finished = !0, this._onDoneFns.forEach(fn => fn()), this._onDoneFns = []);
            }
            init() {
                this._buildPlayer(), this._preparePlayerBeforeStart();
            }
            _buildPlayer() {
                if (this._initialized) return;
                this._initialized = !0;
                const keyframes = this.keyframes;
                this.domPlayer = this._triggerWebAnimation(this.element, keyframes, this.options), 
                this._finalKeyframe = keyframes.length ? keyframes[keyframes.length - 1] : {}, this.domPlayer.addEventListener("finish", () => this._onFinish());
            }
            _preparePlayerBeforeStart() {
                this._delay ? this._resetDomPlayerState() : this.domPlayer.pause();
            }
            _triggerWebAnimation(element, keyframes, options) {
                return element.animate(keyframes, options);
            }
            onStart(fn) {
                this._onStartFns.push(fn);
            }
            onDone(fn) {
                this._onDoneFns.push(fn);
            }
            onDestroy(fn) {
                this._onDestroyFns.push(fn);
            }
            play() {
                this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(fn => fn()), 
                this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), 
                this.domPlayer.play();
            }
            pause() {
                this.init(), this.domPlayer.pause();
            }
            finish() {
                this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), 
                this.domPlayer.finish();
            }
            reset() {
                this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1;
            }
            _resetDomPlayerState() {
                this.domPlayer && this.domPlayer.cancel();
            }
            restart() {
                this.reset(), this.play();
            }
            hasStarted() {
                return this._started;
            }
            destroy() {
                this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), 
                this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(fn => fn()), 
                this._onDestroyFns = []);
            }
            setPosition(p) {
                this.domPlayer.currentTime = p * this.time;
            }
            getPosition() {
                return this.domPlayer.currentTime / this.time;
            }
            get totalTime() {
                return this._delay + this._duration;
            }
            beforeDestroy() {
                const styles = {};
                this.hasStarted() && Object.keys(this._finalKeyframe).forEach(prop => {
                    "offset" != prop && (styles[prop] = this._finished ? this._finalKeyframe[prop] : computeStyle(this.element, prop));
                }), this.currentSnapshot = styles;
            }
            triggerCallback(phaseName) {
                const methods = "start" == phaseName ? this._onStartFns : this._onDoneFns;
                methods.forEach(fn => fn()), methods.length = 0;
            }
        }
        class WebAnimationsDriver {
            constructor() {
                this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(getElementAnimateFn().toString()), 
                this._cssKeyframesDriver = new CssKeyframesDriver;
            }
            validateStyleProperty(prop) {
                return validateStyleProperty(prop);
            }
            matchesElement(element, selector) {
                return matchesElement(element, selector);
            }
            containsElement(elm1, elm2) {
                return containsElement(elm1, elm2);
            }
            query(element, selector, multi) {
                return invokeQuery(element, selector, multi);
            }
            computeStyle(element, prop, defaultValue) {
                return window.getComputedStyle(element)[prop];
            }
            overrideWebAnimationsSupport(supported) {
                this._isNativeImpl = supported;
            }
            animate(element, keyframes, duration, delay, easing, previousPlayers = [], scrubberAccessRequested) {
                if (!scrubberAccessRequested && !this._isNativeImpl) return this._cssKeyframesDriver.animate(element, keyframes, duration, delay, easing, previousPlayers);
                const playerOptions = {
                    duration: duration,
                    delay: delay,
                    fill: 0 == delay ? "both" : "forwards"
                };
                easing && (playerOptions.easing = easing);
                const previousStyles = {}, previousWebAnimationPlayers = previousPlayers.filter(player => player instanceof WebAnimationsPlayer);
                allowPreviousPlayerStylesMerge(duration, delay) && previousWebAnimationPlayers.forEach(player => {
                    let styles = player.currentSnapshot;
                    Object.keys(styles).forEach(prop => previousStyles[prop] = styles[prop]);
                });
                const specialStyles = packageNonAnimatableStyles(element, keyframes = balancePreviousStylesIntoKeyframes(element, keyframes = keyframes.map(styles => copyStyles(styles, !1)), previousStyles));
                return new WebAnimationsPlayer(element, keyframes, playerOptions, specialStyles);
            }
        }
        function getElementAnimateFn() {
            return "undefined" != typeof window && void 0 !== window.document && Element.prototype.animate || {};
        }
        var common = __webpack_require__("ofXK");
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return ANIMATION_MODULE_TYPE;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return animations_BrowserAnimationsModule;
        }));
        let animations_BrowserAnimationBuilder = (() => {
            class BrowserAnimationBuilder extends animations.b {
                constructor(rootRenderer, doc) {
                    super(), this._nextAnimationId = 0, this._renderer = rootRenderer.createRenderer(doc.body, {
                        id: "0",
                        encapsulation: core.P.None,
                        styles: [],
                        data: {
                            animation: []
                        }
                    });
                }
                build(animation) {
                    const id = this._nextAnimationId.toString();
                    this._nextAnimationId++;
                    const entry = Array.isArray(animation) ? Object(animations.f)(animation) : animation;
                    return issueAnimationCommand(this._renderer, null, id, "register", [ entry ]), new animations_BrowserAnimationFactory(id, this._renderer);
                }
            }
            return BrowserAnimationBuilder.ɵfac = function(t) {
                return new (t || BrowserAnimationBuilder)(core.Zb(core.E), core.Zb(common.d));
            }, BrowserAnimationBuilder.ɵprov = core.Lb({
                token: BrowserAnimationBuilder,
                factory: function(t) {
                    return BrowserAnimationBuilder.ɵfac(t);
                },
                providedIn: null
            }), BrowserAnimationBuilder;
        })();
        class animations_BrowserAnimationFactory extends animations.c {
            constructor(_id, _renderer) {
                super(), this._id = _id, this._renderer = _renderer;
            }
            create(element, options) {
                return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);
            }
        }
        class RendererAnimationPlayer {
            constructor(id, element, options, _renderer) {
                this.id = id, this.element = element, this._renderer = _renderer, this.parentPlayer = null, 
                this._started = !1, this.totalTime = 0, this._command("create", options);
            }
            _listen(eventName, callback) {
                return this._renderer.listen(this.element, `@@${this.id}:${eventName}`, callback);
            }
            _command(command, ...args) {
                return issueAnimationCommand(this._renderer, this.element, this.id, command, args);
            }
            onDone(fn) {
                this._listen("done", fn);
            }
            onStart(fn) {
                this._listen("start", fn);
            }
            onDestroy(fn) {
                this._listen("destroy", fn);
            }
            init() {
                this._command("init");
            }
            hasStarted() {
                return this._started;
            }
            play() {
                this._command("play"), this._started = !0;
            }
            pause() {
                this._command("pause");
            }
            restart() {
                this._command("restart");
            }
            finish() {
                this._command("finish");
            }
            destroy() {
                this._command("destroy");
            }
            reset() {
                this._command("reset");
            }
            setPosition(p) {
                this._command("setPosition", p);
            }
            getPosition() {
                return 0;
            }
        }
        function issueAnimationCommand(renderer, element, id, command, args) {
            return renderer.setProperty(element, `@@${id}:${command}`, args);
        }
        const ANIMATION_PREFIX = "@", DISABLE_ANIMATIONS_FLAG = "@.disabled";
        let animations_AnimationRendererFactory = (() => {
            class AnimationRendererFactory {
                constructor(delegate, engine, _zone) {
                    this.delegate = delegate, this.engine = engine, this._zone = _zone, this._currentId = 0, 
                    this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, 
                    this._cdRecurDepth = 0, this.promise = Promise.resolve(0), engine.onRemovalComplete = (element, delegate) => {
                        delegate && delegate.parentNode(element) && delegate.removeChild(element.parentNode, element);
                    };
                }
                createRenderer(hostElement, type) {
                    const delegate = this.delegate.createRenderer(hostElement, type);
                    if (!(hostElement && type && type.data && type.data.animation)) {
                        let renderer = this._rendererCache.get(delegate);
                        return renderer || (renderer = new BaseAnimationRenderer("", delegate, this.engine), 
                        this._rendererCache.set(delegate, renderer)), renderer;
                    }
                    const componentId = type.id, namespaceId = type.id + "-" + this._currentId;
                    this._currentId++, this.engine.register(namespaceId, hostElement);
                    const registerTrigger = trigger => {
                        Array.isArray(trigger) ? trigger.forEach(registerTrigger) : this.engine.registerTrigger(componentId, namespaceId, hostElement, trigger.name, trigger);
                    };
                    return type.data.animation.forEach(registerTrigger), new AnimationRenderer(this, namespaceId, delegate, this.engine);
                }
                begin() {
                    this._cdRecurDepth++, this.delegate.begin && this.delegate.begin();
                }
                _scheduleCountTask() {
                    this.promise.then(() => {
                        this._microtaskId++;
                    });
                }
                scheduleListenerCallback(count, fn, data) {
                    count >= 0 && count < this._microtaskId ? this._zone.run(() => fn(data)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => {
                        this._zone.run(() => {
                            this._animationCallbacksBuffer.forEach(tuple => {
                                const [fn, data] = tuple;
                                fn(data);
                            }), this._animationCallbacksBuffer = [];
                        });
                    }), this._animationCallbacksBuffer.push([ fn, data ]));
                }
                end() {
                    this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => {
                        this._scheduleCountTask(), this.engine.flush(this._microtaskId);
                    }), this.delegate.end && this.delegate.end();
                }
                whenRenderingDone() {
                    return this.engine.whenRenderingDone();
                }
            }
            return AnimationRendererFactory.ɵfac = function(t) {
                return new (t || AnimationRendererFactory)(core.Zb(core.E), core.Zb(AnimationEngine), core.Zb(core.y));
            }, AnimationRendererFactory.ɵprov = core.Lb({
                token: AnimationRendererFactory,
                factory: function(t) {
                    return AnimationRendererFactory.ɵfac(t);
                },
                providedIn: null
            }), AnimationRendererFactory;
        })();
        class BaseAnimationRenderer {
            constructor(namespaceId, delegate, engine) {
                this.namespaceId = namespaceId, this.delegate = delegate, this.engine = engine, 
                this.destroyNode = this.delegate.destroyNode ? n => delegate.destroyNode(n) : null;
            }
            get data() {
                return this.delegate.data;
            }
            destroy() {
                this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy();
            }
            createElement(name, namespace) {
                return this.delegate.createElement(name, namespace);
            }
            createComment(value) {
                return this.delegate.createComment(value);
            }
            createText(value) {
                return this.delegate.createText(value);
            }
            appendChild(parent, newChild) {
                this.delegate.appendChild(parent, newChild), this.engine.onInsert(this.namespaceId, newChild, parent, !1);
            }
            insertBefore(parent, newChild, refChild) {
                this.delegate.insertBefore(parent, newChild, refChild), this.engine.onInsert(this.namespaceId, newChild, parent, !0);
            }
            removeChild(parent, oldChild, isHostElement) {
                this.engine.onRemove(this.namespaceId, oldChild, this.delegate, isHostElement);
            }
            selectRootElement(selectorOrNode, preserveContent) {
                return this.delegate.selectRootElement(selectorOrNode, preserveContent);
            }
            parentNode(node) {
                return this.delegate.parentNode(node);
            }
            nextSibling(node) {
                return this.delegate.nextSibling(node);
            }
            setAttribute(el, name, value, namespace) {
                this.delegate.setAttribute(el, name, value, namespace);
            }
            removeAttribute(el, name, namespace) {
                this.delegate.removeAttribute(el, name, namespace);
            }
            addClass(el, name) {
                this.delegate.addClass(el, name);
            }
            removeClass(el, name) {
                this.delegate.removeClass(el, name);
            }
            setStyle(el, style, value, flags) {
                this.delegate.setStyle(el, style, value, flags);
            }
            removeStyle(el, style, flags) {
                this.delegate.removeStyle(el, style, flags);
            }
            setProperty(el, name, value) {
                name.charAt(0) == ANIMATION_PREFIX && name == DISABLE_ANIMATIONS_FLAG ? this.disableAnimations(el, !!value) : this.delegate.setProperty(el, name, value);
            }
            setValue(node, value) {
                this.delegate.setValue(node, value);
            }
            listen(target, eventName, callback) {
                return this.delegate.listen(target, eventName, callback);
            }
            disableAnimations(element, value) {
                this.engine.disableAnimations(element, value);
            }
        }
        class AnimationRenderer extends BaseAnimationRenderer {
            constructor(factory, namespaceId, delegate, engine) {
                super(namespaceId, delegate, engine), this.factory = factory, this.namespaceId = namespaceId;
            }
            setProperty(el, name, value) {
                name.charAt(0) == ANIMATION_PREFIX ? "." == name.charAt(1) && name == DISABLE_ANIMATIONS_FLAG ? this.disableAnimations(el, value = void 0 === value || !!value) : this.engine.process(this.namespaceId, el, name.substr(1), value) : this.delegate.setProperty(el, name, value);
            }
            listen(target, eventName, callback) {
                if (eventName.charAt(0) == ANIMATION_PREFIX) {
                    const element = function(target) {
                        switch (target) {
                          case "body":
                            return document.body;

                          case "document":
                            return document;

                          case "window":
                            return window;

                          default:
                            return target;
                        }
                    }(target);
                    let name = eventName.substr(1), phase = "";
                    return name.charAt(0) != ANIMATION_PREFIX && ([name, phase] = function(triggerName) {
                        const dotIndex = triggerName.indexOf(".");
                        return [ triggerName.substring(0, dotIndex), triggerName.substr(dotIndex + 1) ];
                    }(name)), this.engine.listen(this.namespaceId, element, name, phase, event => {
                        this.factory.scheduleListenerCallback(event._data || -1, callback, event);
                    });
                }
                return this.delegate.listen(target, eventName, callback);
            }
        }
        let animations_InjectableAnimationEngine = (() => {
            class InjectableAnimationEngine extends AnimationEngine {
                constructor(doc, driver, normalizer) {
                    super(doc.body, driver, normalizer);
                }
            }
            return InjectableAnimationEngine.ɵfac = function(t) {
                return new (t || InjectableAnimationEngine)(core.Zb(common.d), core.Zb(AnimationDriver), core.Zb(AnimationStyleNormalizer));
            }, InjectableAnimationEngine.ɵprov = core.Lb({
                token: InjectableAnimationEngine,
                factory: function(t) {
                    return InjectableAnimationEngine.ɵfac(t);
                },
                providedIn: null
            }), InjectableAnimationEngine;
        })();
        const ANIMATION_MODULE_TYPE = new core.p("AnimationModuleType"), BROWSER_ANIMATIONS_PROVIDERS = [ {
            provide: AnimationDriver,
            useFactory: function() {
                return "function" == typeof getElementAnimateFn() ? new WebAnimationsDriver : new CssKeyframesDriver;
            }
        }, {
            provide: ANIMATION_MODULE_TYPE,
            useValue: "BrowserAnimations"
        }, {
            provide: animations.b,
            useClass: animations_BrowserAnimationBuilder
        }, {
            provide: AnimationStyleNormalizer,
            useFactory: function() {
                return new WebAnimationsStyleNormalizer;
            }
        }, {
            provide: AnimationEngine,
            useClass: animations_InjectableAnimationEngine
        }, {
            provide: core.E,
            useFactory: function(renderer, engine, zone) {
                return new animations_AnimationRendererFactory(renderer, engine, zone);
            },
            deps: [ platform_browser.g, AnimationEngine, core.y ]
        } ];
        let animations_BrowserAnimationsModule = (() => {
            class BrowserAnimationsModule {}
            return BrowserAnimationsModule.ɵmod = core.Nb({
                type: BrowserAnimationsModule
            }), BrowserAnimationsModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || BrowserAnimationsModule);
                },
                providers: BROWSER_ANIMATIONS_PROVIDERS,
                imports: [ platform_browser.a ]
            }), BrowserAnimationsModule;
        })();
    },
    SeVD: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        var subscribeToArray = __webpack_require__("ngJS"), hostReportError = __webpack_require__("NJ4a"), symbol_iterator = __webpack_require__("Lhse"), observable = __webpack_require__("kJWO"), isArrayLike = __webpack_require__("I55L"), isPromise = __webpack_require__("c2HN"), isObject = __webpack_require__("XoHu");
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return subscribeTo;
        }));
        const subscribeTo = result => {
            if (result && "function" == typeof result[observable.a]) return (obj => subscriber => {
                const obs = obj[observable.a]();
                if ("function" != typeof obs.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable");
                return obs.subscribe(subscriber);
            })(result);
            if (Object(isArrayLike.a)(result)) return Object(subscribeToArray.a)(result);
            if (Object(isPromise.a)(result)) return (promise => subscriber => (promise.then(value => {
                subscriber.closed || (subscriber.next(value), subscriber.complete());
            }, err => subscriber.error(err)).then(null, hostReportError.a), subscriber))(result);
            if (result && "function" == typeof result[symbol_iterator.a]) return (iterable => subscriber => {
                const iterator = iterable[symbol_iterator.a]();
                for (;;) {
                    const item = iterator.next();
                    if (item.done) {
                        subscriber.complete();
                        break;
                    }
                    if (subscriber.next(item.value), subscriber.closed) break;
                }
                return "function" == typeof iterator.return && subscriber.add(() => {
                    iterator.return && iterator.return();
                }), subscriber;
            })(result);
            {
                const value = Object(isObject.a)(result) ? "an invalid object" : `'${result}'`;
                throw new TypeError(`You provided ${value} where a stream was expected.` + " You can provide an Observable, Promise, Array, or Iterable.");
            }
        };
    },
    SpAZ: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        function identity(x) {
            return x;
        }
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return identity;
        }));
    },
    SxV6: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return first;
        }));
        var _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("sVev"), _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("pLZG"), _take__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("IzEk"), _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("xbPD"), _throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("XDbj"), _util_identity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("SpAZ");
        function first(predicate, defaultValue) {
            const hasDefaultValue = arguments.length >= 2;
            return source => source.pipe(predicate ? Object(_filter__WEBPACK_IMPORTED_MODULE_1__.a)((v, i) => predicate(v, i, source)) : _util_identity__WEBPACK_IMPORTED_MODULE_5__.a, Object(_take__WEBPACK_IMPORTED_MODULE_2__.a)(1), hasDefaultValue ? Object(_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__.a)(defaultValue) : Object(_throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__.a)(() => new _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__.a));
        }
    },
    TNhP: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return TocService;
        }));
        var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ofXK"), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("jtHE"), _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("fXoL"), _angular_platform_browser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("jhN1"), app_shared_scroll_spy_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("FiGy");
        let TocService = (() => {
            class TocService {
                constructor(document, domSanitizer, scrollSpyService) {
                    this.document = document, this.domSanitizer = domSanitizer, this.scrollSpyService = scrollSpyService, 
                    this.tocList = new rxjs__WEBPACK_IMPORTED_MODULE_1__.a(1), this.activeItemIndex = new rxjs__WEBPACK_IMPORTED_MODULE_1__.a(1), 
                    this.scrollSpyInfo = null;
                }
                genToc(docElement, docId = "") {
                    if (this.resetScrollSpyInfo(), !docElement) return void this.tocList.next([]);
                    const headings = this.findTocHeadings(docElement), idMap = new Map, tocList = headings.map(heading => {
                        const {title: title, content: content} = this.extractHeadingSafeHtml(heading);
                        return {
                            level: heading.tagName.toLowerCase(),
                            href: `${docId}#${this.getId(heading, idMap)}`,
                            title: title,
                            content: content
                        };
                    });
                    this.tocList.next(tocList), this.scrollSpyInfo = this.scrollSpyService.spyOn(headings), 
                    this.scrollSpyInfo.active.subscribe(item => this.activeItemIndex.next(item && item.index));
                }
                reset() {
                    this.resetScrollSpyInfo(), this.tocList.next([]);
                }
                extractHeadingSafeHtml(heading) {
                    const div = this.document.createElement("div");
                    return div.innerHTML = heading.innerHTML, querySelectorAll(div, ".github-links, .header-link").forEach(removeNode), 
                    querySelectorAll(div, "a").forEach(anchorLink => {
                        const parent = anchorLink.parentNode;
                        for (;anchorLink.childNodes.length; ) parent.insertBefore(anchorLink.childNodes[0], anchorLink);
                        removeNode(anchorLink);
                    }), {
                        content: this.domSanitizer.bypassSecurityTrustHtml(div.innerHTML.trim()),
                        title: (div.textContent || "").trim()
                    };
                }
                findTocHeadings(docElement) {
                    return querySelectorAll(docElement, "h1,h2,h3").filter(heading => !/(?:no-toc|notoc)/i.test(heading.className));
                }
                resetScrollSpyInfo() {
                    this.scrollSpyInfo && (this.scrollSpyInfo.unspy(), this.scrollSpyInfo = null), this.activeItemIndex.next(null);
                }
                getId(h, idMap) {
                    let id = h.id;
                    return id ? addToMap(id) : (id = addToMap(id = (h.textContent || "").trim().toLowerCase().replace(/\W+/g, "-")), 
                    h.id = id), id;
                    function addToMap(key) {
                        const count = (idMap.get(key) || 0) + 1;
                        return idMap.set(key, count), 1 === count ? key : `${key}-${count}`;
                    }
                }
            }
            return TocService.ɵfac = function(t) {
                return new (t || TocService)(_angular_core__WEBPACK_IMPORTED_MODULE_2__.Zb(_angular_common__WEBPACK_IMPORTED_MODULE_0__.d), _angular_core__WEBPACK_IMPORTED_MODULE_2__.Zb(_angular_platform_browser__WEBPACK_IMPORTED_MODULE_3__.b), _angular_core__WEBPACK_IMPORTED_MODULE_2__.Zb(app_shared_scroll_spy_service__WEBPACK_IMPORTED_MODULE_4__.a));
            }, TocService.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_2__.Lb({
                token: TocService,
                factory: function(t) {
                    return TocService.ɵfac(t);
                },
                providedIn: null
            }), TocService;
        })();
        function querySelectorAll(parent, selector) {
            return Array.from(parent.querySelectorAll(selector));
        }
        function removeNode(node) {
            null !== node.parentNode && node.parentNode.removeChild(node);
        }
    },
    V90o: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return CodeModule;
        }));
        var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ofXK"), _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_require__("6CTB"), 
        __webpack_require__("dNgK")), _pretty_printer_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("vVVL"), app_shared_copier_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("/ck9"), _angular_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("fXoL");
        let CodeModule = (() => {
            class CodeModule {}
            return CodeModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_5__.Nb({
                type: CodeModule
            }), CodeModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_5__.Mb({
                factory: function(t) {
                    return new (t || CodeModule);
                },
                providers: [ _pretty_printer_service__WEBPACK_IMPORTED_MODULE_3__.a, app_shared_copier_service__WEBPACK_IMPORTED_MODULE_4__.a ],
                imports: [ [ _angular_common__WEBPACK_IMPORTED_MODULE_0__.c, _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_2__.b ] ]
            }), CodeModule;
        })();
    },
    VRyK: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return merge;
        }));
        var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("HDdC"), _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("z+Ro"), _operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("bHdf"), _fromArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("yCtX");
        function merge(...observables) {
            let concurrent = Number.POSITIVE_INFINITY, scheduler = null, last = observables[observables.length - 1];
            return Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__.a)(last) ? (scheduler = observables.pop(), 
            observables.length > 1 && "number" == typeof observables[observables.length - 1] && (concurrent = observables.pop())) : "number" == typeof last && (concurrent = observables.pop()), 
            null === scheduler && 1 === observables.length && observables[0] instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__.a ? observables[0] : Object(_operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__.a)(concurrent)(Object(_fromArray__WEBPACK_IMPORTED_MODULE_3__.a)(observables, scheduler));
        }
    },
    WMd4: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Notification;
        }));
        var _observable_empty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("EY2u"), _observable_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("LRne"), _observable_throwError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("z6cu");
        let Notification = (() => {
            class Notification {
                constructor(kind, value, error) {
                    this.kind = kind, this.value = value, this.error = error, this.hasValue = "N" === kind;
                }
                observe(observer) {
                    switch (this.kind) {
                      case "N":
                        return observer.next && observer.next(this.value);

                      case "E":
                        return observer.error && observer.error(this.error);

                      case "C":
                        return observer.complete && observer.complete();
                    }
                }
                do(next, error, complete) {
                    switch (this.kind) {
                      case "N":
                        return next && next(this.value);

                      case "E":
                        return error && error(this.error);

                      case "C":
                        return complete && complete();
                    }
                }
                accept(nextOrObserver, error, complete) {
                    return nextOrObserver && "function" == typeof nextOrObserver.next ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
                }
                toObservable() {
                    switch (this.kind) {
                      case "N":
                        return Object(_observable_of__WEBPACK_IMPORTED_MODULE_1__.a)(this.value);

                      case "E":
                        return Object(_observable_throwError__WEBPACK_IMPORTED_MODULE_2__.a)(this.error);

                      case "C":
                        return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_0__.b)();
                    }
                    throw new Error("unexpected notification kind value");
                }
                static createNext(value) {
                    return void 0 !== value ? new Notification("N", value) : Notification.undefinedValueNotification;
                }
                static createError(err) {
                    return new Notification("E", void 0, err);
                }
                static createComplete() {
                    return Notification.completeNotification;
                }
            }
            return Notification.completeNotification = new Notification("C"), Notification.undefinedValueNotification = new Notification("N", void 0), 
            Notification;
        })();
    },
    XDbj: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return throwIfEmpty;
        }));
        var _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("sVev"), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("7o/Q");
        function throwIfEmpty(errorFactory = defaultErrorFactory) {
            return source => source.lift(new ThrowIfEmptyOperator(errorFactory));
        }
        class ThrowIfEmptyOperator {
            constructor(errorFactory) {
                this.errorFactory = errorFactory;
            }
            call(subscriber, source) {
                return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
            }
        }
        class ThrowIfEmptySubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_1__.a {
            constructor(destination, errorFactory) {
                super(destination), this.errorFactory = errorFactory, this.hasValue = !1;
            }
            _next(value) {
                this.hasValue = !0, this.destination.next(value);
            }
            _complete() {
                if (this.hasValue) return this.destination.complete();
                {
                    let err;
                    try {
                        err = this.errorFactory();
                    } catch (e) {
                        err = e;
                    }
                    this.destination.error(err);
                }
            }
        }
        function defaultErrorFactory() {
            return new _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__.a;
        }
    },
    XNiG: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "b", (function() {
            return SubjectSubscriber;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Subject;
        }));
        var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("HDdC"), _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("7o/Q"), _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("quSY"), _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("9ppp"), _SubjectSubscription__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("Ylt2"), _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("2QA8");
        class SubjectSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_1__.a {
            constructor(destination) {
                super(destination), this.destination = destination;
            }
        }
        let Subject = (() => {
            class Subject extends _Observable__WEBPACK_IMPORTED_MODULE_0__.a {
                constructor() {
                    super(), this.observers = [], this.closed = !1, this.isStopped = !1, this.hasError = !1, 
                    this.thrownError = null;
                }
                [_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_5__.a]() {
                    return new SubjectSubscriber(this);
                }
                lift(operator) {
                    const subject = new AnonymousSubject(this, this);
                    return subject.operator = operator, subject;
                }
                next(value) {
                    if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__.a;
                    if (!this.isStopped) {
                        const {observers: observers} = this, len = observers.length, copy = observers.slice();
                        for (let i = 0; i < len; i++) copy[i].next(value);
                    }
                }
                error(err) {
                    if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__.a;
                    this.hasError = !0, this.thrownError = err, this.isStopped = !0;
                    const {observers: observers} = this, len = observers.length, copy = observers.slice();
                    for (let i = 0; i < len; i++) copy[i].error(err);
                    this.observers.length = 0;
                }
                complete() {
                    if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__.a;
                    this.isStopped = !0;
                    const {observers: observers} = this, len = observers.length, copy = observers.slice();
                    for (let i = 0; i < len; i++) copy[i].complete();
                    this.observers.length = 0;
                }
                unsubscribe() {
                    this.isStopped = !0, this.closed = !0, this.observers = null;
                }
                _trySubscribe(subscriber) {
                    if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__.a;
                    return super._trySubscribe(subscriber);
                }
                _subscribe(subscriber) {
                    if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__.a;
                    return this.hasError ? (subscriber.error(this.thrownError), _Subscription__WEBPACK_IMPORTED_MODULE_2__.a.EMPTY) : this.isStopped ? (subscriber.complete(), 
                    _Subscription__WEBPACK_IMPORTED_MODULE_2__.a.EMPTY) : (this.observers.push(subscriber), 
                    new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_4__.a(this, subscriber));
                }
                asObservable() {
                    const observable = new _Observable__WEBPACK_IMPORTED_MODULE_0__.a;
                    return observable.source = this, observable;
                }
            }
            return Subject.create = (destination, source) => new AnonymousSubject(destination, source), 
            Subject;
        })();
        class AnonymousSubject extends Subject {
            constructor(destination, source) {
                super(), this.destination = destination, this.source = source;
            }
            next(value) {
                const {destination: destination} = this;
                destination && destination.next && destination.next(value);
            }
            error(err) {
                const {destination: destination} = this;
                destination && destination.error && this.destination.error(err);
            }
            complete() {
                const {destination: destination} = this;
                destination && destination.complete && this.destination.complete();
            }
            _subscribe(subscriber) {
                const {source: source} = this;
                return source ? this.source.subscribe(subscriber) : _Subscription__WEBPACK_IMPORTED_MODULE_2__.a.EMPTY;
            }
        }
    },
    XQjc: function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__.p + "0.worker.js";
    },
    XoHu: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        function isObject(x) {
            return null !== x && "object" == typeof x;
        }
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return isObject;
        }));
    },
    Y7HM: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return isNumeric;
        }));
        var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("DH7j");
        function isNumeric(val) {
            return !Object(_isArray__WEBPACK_IMPORTED_MODULE_0__.a)(val) && val - parseFloat(val) + 1 >= 0;
        }
    },
    Ylt2: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return SubjectSubscription;
        }));
        var _Subscription__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("quSY");
        class SubjectSubscription extends _Subscription__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(subject, subscriber) {
                super(), this.subject = subject, this.subscriber = subscriber, this.closed = !1;
            }
            unsubscribe() {
                if (this.closed) return;
                this.closed = !0;
                const subject = this.subject, observers = subject.observers;
                if (this.subject = null, !observers || 0 === observers.length || subject.isStopped || subject.closed) return;
                const subscriberIndex = observers.indexOf(this.subscriber);
                -1 !== subscriberIndex && observers.splice(subscriberIndex, 1);
            }
        }
    },
    ZUHj: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return subscribeToResult;
        }));
        var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("51Dv"), _subscribeTo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("SeVD"), _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("HDdC");
        function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__.a(outerSubscriber, outerValue, outerIndex)) {
            if (!destination.closed) return result instanceof _Observable__WEBPACK_IMPORTED_MODULE_2__.a ? result.subscribe(destination) : Object(_subscribeTo__WEBPACK_IMPORTED_MODULE_1__.a)(result)(destination);
        }
    },
    bHdf: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return mergeAll;
        }));
        var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5+tZ"), _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("SpAZ");
        function mergeAll(concurrent = Number.POSITIVE_INFINITY) {
            return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__.a)(_util_identity__WEBPACK_IMPORTED_MODULE_1__.a, concurrent);
        }
    },
    bOdf: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return concatMap;
        }));
        var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5+tZ");
        function concatMap(project, resultSelector) {
            return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__.a)(project, resultSelector, 1);
        }
    },
    bTqV: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "b", (function() {
            return MatButtonModule;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return MatButton;
        }));
        var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ofXK"), _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("fXoL"), _angular_material_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("FKr1"), _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("u47x"), _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("R1ws");
        const _c0 = [ "mat-button", "" ], _c1 = [ "*" ], DEFAULT_ROUND_BUTTON_COLOR = "accent", BUTTON_HOST_ATTRIBUTES = [ "mat-button", "mat-flat-button", "mat-icon-button", "mat-raised-button", "mat-stroked-button", "mat-mini-fab", "mat-fab" ];
        class MatButtonBase {
            constructor(_elementRef) {
                this._elementRef = _elementRef;
            }
        }
        const _MatButtonMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_2__.f)(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_2__.h)(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_2__.g)(MatButtonBase)));
        let MatButton = (() => {
            class MatButton extends _MatButtonMixinBase {
                constructor(elementRef, _focusMonitor, _animationMode) {
                    super(elementRef), this._focusMonitor = _focusMonitor, this._animationMode = _animationMode, 
                    this.isRoundButton = this._hasHostAttributes("mat-fab", "mat-mini-fab"), this.isIconButton = this._hasHostAttributes("mat-icon-button");
                    for (const attr of BUTTON_HOST_ATTRIBUTES) this._hasHostAttributes(attr) && this._getHostElement().classList.add(attr);
                    elementRef.nativeElement.classList.add("mat-button-base"), this._focusMonitor.monitor(this._elementRef, !0), 
                    this.isRoundButton && (this.color = DEFAULT_ROUND_BUTTON_COLOR);
                }
                ngOnDestroy() {
                    this._focusMonitor.stopMonitoring(this._elementRef);
                }
                focus(origin = "program", options) {
                    this._focusMonitor.focusVia(this._getHostElement(), origin, options);
                }
                _getHostElement() {
                    return this._elementRef.nativeElement;
                }
                _isRippleDisabled() {
                    return this.disableRipple || this.disabled;
                }
                _hasHostAttributes(...attributes) {
                    return attributes.some(attribute => this._getHostElement().hasAttribute(attribute));
                }
            }
            return MatButton.ɵfac = function(t) {
                return new (t || MatButton)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_1__.k), _angular_core__WEBPACK_IMPORTED_MODULE_1__.Pb(_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_3__.d), _angular_core__WEBPACK_IMPORTED_MODULE_1__.Pb(_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_4__.a, 8));
            }, MatButton.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Jb({
                type: MatButton,
                selectors: [ [ "button", "mat-button", "" ], [ "button", "mat-raised-button", "" ], [ "button", "mat-icon-button", "" ], [ "button", "mat-fab", "" ], [ "button", "mat-mini-fab", "" ], [ "button", "mat-stroked-button", "" ], [ "button", "mat-flat-button", "" ] ],
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && _angular_core__WEBPACK_IMPORTED_MODULE_1__.Jc(_angular_material_core__WEBPACK_IMPORTED_MODULE_2__.c, !0), 
                    2 & rf && _angular_core__WEBPACK_IMPORTED_MODULE_1__.qc(_t = _angular_core__WEBPACK_IMPORTED_MODULE_1__.dc()) && (ctx.ripple = _t.first);
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && _angular_core__WEBPACK_IMPORTED_MODULE_1__.Bb(2), 2 & rf && (_angular_core__WEBPACK_IMPORTED_MODULE_1__.Cb("disabled", ctx.disabled || null), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_1__.Fb("_mat-animation-noopable", "NoopAnimations" === ctx._animationMode));
                },
                inputs: {
                    disabled: "disabled",
                    disableRipple: "disableRipple",
                    color: "color"
                },
                exportAs: [ "matButton" ],
                features: [ _angular_core__WEBPACK_IMPORTED_MODULE_1__.xb ],
                attrs: _c0,
                ngContentSelectors: _c1,
                decls: 4,
                vars: 4,
                consts: [ [ 1, "mat-button-wrapper" ], [ "matRipple", "", 1, "mat-button-ripple", 3, "matRippleDisabled", "matRippleCentered", "matRippleTrigger" ], [ 1, "mat-button-focus-overlay" ] ],
                template: function(rf, ctx) {
                    1 & rf && (_angular_core__WEBPACK_IMPORTED_MODULE_1__.kc(), _angular_core__WEBPACK_IMPORTED_MODULE_1__.Vb(0, "span", 0), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_1__.jc(1), _angular_core__WEBPACK_IMPORTED_MODULE_1__.Tb(), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_1__.Qb(2, "div", 1), _angular_core__WEBPACK_IMPORTED_MODULE_1__.Qb(3, "div", 2)), 
                    2 & rf && (_angular_core__WEBPACK_IMPORTED_MODULE_1__.Ab(2), _angular_core__WEBPACK_IMPORTED_MODULE_1__.Fb("mat-button-ripple-round", ctx.isRoundButton || ctx.isIconButton), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_1__.lc("matRippleDisabled", ctx._isRippleDisabled())("matRippleCentered", ctx.isIconButton)("matRippleTrigger", ctx._getHostElement()));
                },
                directives: [ _angular_material_core__WEBPACK_IMPORTED_MODULE_2__.c ],
                styles: [ ".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button[disabled],.mat-icon-button[disabled],.mat-stroked-button[disabled],.mat-flat-button[disabled]{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button[disabled]{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab[disabled]{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab[disabled]{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}@media(-ms-high-contrast: active){.mat-button-focus-overlay{background-color:#fff}}@media(-ms-high-contrast: black-on-white){.mat-button-focus-overlay{background-color:#000}}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:block;font-size:inherit;width:2.5em;height:2.5em}@media(-ms-high-contrast: active){.mat-button,.mat-flat-button,.mat-raised-button,.mat-icon-button,.mat-fab,.mat-mini-fab{outline:solid 1px}}/*# sourceMappingURL=button.css.map */\n" ],
                encapsulation: 2,
                changeDetection: 0
            }), MatButton;
        })(), MatButtonModule = (() => {
            class MatButtonModule {}
            return MatButtonModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Nb({
                type: MatButtonModule
            }), MatButtonModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Mb({
                factory: function(t) {
                    return new (t || MatButtonModule);
                },
                imports: [ [ _angular_common__WEBPACK_IMPORTED_MODULE_0__.c, _angular_material_core__WEBPACK_IMPORTED_MODULE_2__.d, _angular_material_core__WEBPACK_IMPORTED_MODULE_2__.b ], _angular_material_core__WEBPACK_IMPORTED_MODULE_2__.b ]
            }), MatButtonModule;
        })();
    },
    c2HN: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        function isPromise(value) {
            return !!value && "function" != typeof value.subscribe && "function" == typeof value.then;
        }
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return isPromise;
        }));
    },
    cH1L: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "b", (function() {
            return Directionality;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return BidiModule;
        }));
        var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("fXoL"), _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("ofXK");
        const DIR_DOCUMENT = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.p("cdk-dir-doc", {
            providedIn: "root",
            factory: function() {
                return Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.V)(_angular_common__WEBPACK_IMPORTED_MODULE_1__.d);
            }
        });
        let Directionality = (() => {
            class Directionality {
                constructor(_document) {
                    if (this.value = "ltr", this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.m, 
                    _document) {
                        const htmlDir = _document.documentElement ? _document.documentElement.dir : null, value = (_document.body ? _document.body.dir : null) || htmlDir;
                        this.value = "ltr" === value || "rtl" === value ? value : "ltr";
                    }
                }
                ngOnDestroy() {
                    this.change.complete();
                }
            }
            return Directionality.ɵfac = function(t) {
                return new (t || Directionality)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb(DIR_DOCUMENT, 8));
            }, Directionality.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb({
                token: Directionality,
                factory: function(t) {
                    return Directionality.ɵfac(t);
                },
                providedIn: "root"
            }), Directionality.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb)({
                factory: function() {
                    return new Directionality(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb)(DIR_DOCUMENT, 8));
                },
                token: Directionality,
                providedIn: "root"
            }), Directionality;
        })(), BidiModule = (() => {
            class BidiModule {}
            return BidiModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Nb({
                type: BidiModule
            }), BidiModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Mb({
                factory: function(t) {
                    return new (t || BidiModule);
                }
            }), BidiModule;
        })();
    },
    dNgK: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        var scrolling = __webpack_require__("vxfF"), core = __webpack_require__("fXoL"), common = __webpack_require__("ofXK"), coercion = __webpack_require__("8LU1"), bidi = __webpack_require__("cH1L"), fesm2015_portal = __webpack_require__("+rOU"), Subject = __webpack_require__("XNiG"), Subscription = __webpack_require__("quSY"), Observable = __webpack_require__("HDdC"), merge = __webpack_require__("VRyK"), take = __webpack_require__("IzEk"), takeUntil = __webpack_require__("1G5W"), platform = __webpack_require__("nLfN");
        __webpack_require__("FtGj");
        class overlay_BlockScrollStrategy {
            constructor(_viewportRuler, document) {
                this._viewportRuler = _viewportRuler, this._previousHTMLStyles = {
                    top: "",
                    left: ""
                }, this._isEnabled = !1, this._document = document;
            }
            attach() {}
            enable() {
                if (this._canBeEnabled()) {
                    const root = this._document.documentElement;
                    this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition(), 
                    this._previousHTMLStyles.left = root.style.left || "", this._previousHTMLStyles.top = root.style.top || "", 
                    root.style.left = Object(coercion.c)(-this._previousScrollPosition.left), root.style.top = Object(coercion.c)(-this._previousScrollPosition.top), 
                    root.classList.add("cdk-global-scrollblock"), this._isEnabled = !0;
                }
            }
            disable() {
                if (this._isEnabled) {
                    const html = this._document.documentElement, htmlStyle = html.style, bodyStyle = this._document.body.style, previousHtmlScrollBehavior = htmlStyle.scrollBehavior || "", previousBodyScrollBehavior = bodyStyle.scrollBehavior || "";
                    this._isEnabled = !1, htmlStyle.left = this._previousHTMLStyles.left, htmlStyle.top = this._previousHTMLStyles.top, 
                    html.classList.remove("cdk-global-scrollblock"), htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = "auto", 
                    window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top), 
                    htmlStyle.scrollBehavior = previousHtmlScrollBehavior, bodyStyle.scrollBehavior = previousBodyScrollBehavior;
                }
            }
            _canBeEnabled() {
                if (this._document.documentElement.classList.contains("cdk-global-scrollblock") || this._isEnabled) return !1;
                const body = this._document.body, viewport = this._viewportRuler.getViewportSize();
                return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;
            }
        }
        function getMatScrollStrategyAlreadyAttachedError() {
            return Error("Scroll strategy has already been attached.");
        }
        class CloseScrollStrategy {
            constructor(_scrollDispatcher, _ngZone, _viewportRuler, _config) {
                this._scrollDispatcher = _scrollDispatcher, this._ngZone = _ngZone, this._viewportRuler = _viewportRuler, 
                this._config = _config, this._scrollSubscription = null, this._detach = () => {
                    this.disable(), this._overlayRef.hasAttached() && this._ngZone.run(() => this._overlayRef.detach());
                };
            }
            attach(overlayRef) {
                if (this._overlayRef) throw getMatScrollStrategyAlreadyAttachedError();
                this._overlayRef = overlayRef;
            }
            enable() {
                if (this._scrollSubscription) return;
                const stream = this._scrollDispatcher.scrolled(0);
                this._config && this._config.threshold && this._config.threshold > 1 ? (this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top, 
                this._scrollSubscription = stream.subscribe(() => {
                    const scrollPosition = this._viewportRuler.getViewportScrollPosition().top;
                    Math.abs(scrollPosition - this._initialScrollPosition) > this._config.threshold ? this._detach() : this._overlayRef.updatePosition();
                })) : this._scrollSubscription = stream.subscribe(this._detach);
            }
            disable() {
                this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null);
            }
            detach() {
                this.disable(), this._overlayRef = null;
            }
        }
        class NoopScrollStrategy {
            enable() {}
            disable() {}
            attach() {}
        }
        function isElementScrolledOutsideView(element, scrollContainers) {
            return scrollContainers.some(containerBounds => element.bottom < containerBounds.top || element.top > containerBounds.bottom || element.right < containerBounds.left || element.left > containerBounds.right);
        }
        function isElementClippedByScrolling(element, scrollContainers) {
            return scrollContainers.some(scrollContainerRect => element.top < scrollContainerRect.top || element.bottom > scrollContainerRect.bottom || element.left < scrollContainerRect.left || element.right > scrollContainerRect.right);
        }
        class RepositionScrollStrategy {
            constructor(_scrollDispatcher, _viewportRuler, _ngZone, _config) {
                this._scrollDispatcher = _scrollDispatcher, this._viewportRuler = _viewportRuler, 
                this._ngZone = _ngZone, this._config = _config, this._scrollSubscription = null;
            }
            attach(overlayRef) {
                if (this._overlayRef) throw getMatScrollStrategyAlreadyAttachedError();
                this._overlayRef = overlayRef;
            }
            enable() {
                this._scrollSubscription || (this._scrollSubscription = this._scrollDispatcher.scrolled(this._config ? this._config.scrollThrottle : 0).subscribe(() => {
                    if (this._overlayRef.updatePosition(), this._config && this._config.autoClose) {
                        const overlayRect = this._overlayRef.overlayElement.getBoundingClientRect(), {width: width, height: height} = this._viewportRuler.getViewportSize();
                        isElementScrolledOutsideView(overlayRect, [ {
                            width: width,
                            height: height,
                            bottom: height,
                            right: width,
                            top: 0,
                            left: 0
                        } ]) && (this.disable(), this._ngZone.run(() => this._overlayRef.detach()));
                    }
                }));
            }
            disable() {
                this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null);
            }
            detach() {
                this.disable(), this._overlayRef = null;
            }
        }
        let overlay_ScrollStrategyOptions = (() => {
            class ScrollStrategyOptions {
                constructor(_scrollDispatcher, _viewportRuler, _ngZone, document) {
                    this._scrollDispatcher = _scrollDispatcher, this._viewportRuler = _viewportRuler, 
                    this._ngZone = _ngZone, this.noop = () => new NoopScrollStrategy, this.close = config => new CloseScrollStrategy(this._scrollDispatcher, this._ngZone, this._viewportRuler, config), 
                    this.block = () => new overlay_BlockScrollStrategy(this._viewportRuler, this._document), 
                    this.reposition = config => new RepositionScrollStrategy(this._scrollDispatcher, this._viewportRuler, this._ngZone, config), 
                    this._document = document;
                }
            }
            return ScrollStrategyOptions.ɵfac = function(t) {
                return new (t || ScrollStrategyOptions)(core.Zb(scrolling.b), core.Zb(scrolling.e), core.Zb(core.y), core.Zb(common.d));
            }, ScrollStrategyOptions.ɵprov = core.Lb({
                token: ScrollStrategyOptions,
                factory: function(t) {
                    return ScrollStrategyOptions.ɵfac(t);
                },
                providedIn: "root"
            }), ScrollStrategyOptions.ngInjectableDef = Object(core.Lb)({
                factory: function() {
                    return new ScrollStrategyOptions(Object(core.Zb)(scrolling.b), Object(core.Zb)(scrolling.e), Object(core.Zb)(core.y), Object(core.Zb)(common.d));
                },
                token: ScrollStrategyOptions,
                providedIn: "root"
            }), ScrollStrategyOptions;
        })();
        class OverlayConfig {
            constructor(config) {
                if (this.scrollStrategy = new NoopScrollStrategy, this.panelClass = "", this.hasBackdrop = !1, 
                this.backdropClass = "cdk-overlay-dark-backdrop", this.disposeOnNavigation = !1, 
                config) {
                    const configKeys = Object.keys(config);
                    for (const key of configKeys) void 0 !== config[key] && (this[key] = config[key]);
                }
            }
        }
        class ConnectionPositionPair {
            constructor(origin, overlay, offsetX, offsetY, panelClass) {
                this.offsetX = offsetX, this.offsetY = offsetY, this.panelClass = panelClass, this.originX = origin.originX, 
                this.originY = origin.originY, this.overlayX = overlay.overlayX, this.overlayY = overlay.overlayY;
            }
        }
        class ConnectedOverlayPositionChange {
            constructor(connectionPair, scrollableViewProperties) {
                this.connectionPair = connectionPair, this.scrollableViewProperties = scrollableViewProperties;
            }
        }
        function validateVerticalPosition(property, value) {
            if ("top" !== value && "bottom" !== value && "center" !== value) throw Error(`ConnectedPosition: Invalid ${property} "${value}". ` + 'Expected "top", "bottom" or "center".');
        }
        function validateHorizontalPosition(property, value) {
            if ("start" !== value && "end" !== value && "center" !== value) throw Error(`ConnectedPosition: Invalid ${property} "${value}". ` + 'Expected "start", "end" or "center".');
        }
        let overlay_OverlayKeyboardDispatcher = (() => {
            class OverlayKeyboardDispatcher {
                constructor(document) {
                    this._attachedOverlays = [], this._keydownListener = event => {
                        const overlays = this._attachedOverlays;
                        for (let i = overlays.length - 1; i > -1; i--) if (overlays[i]._keydownEventSubscriptions > 0) {
                            overlays[i]._keydownEvents.next(event);
                            break;
                        }
                    }, this._document = document;
                }
                ngOnDestroy() {
                    this._detach();
                }
                add(overlayRef) {
                    this.remove(overlayRef), this._isAttached || (this._document.body.addEventListener("keydown", this._keydownListener), 
                    this._isAttached = !0), this._attachedOverlays.push(overlayRef);
                }
                remove(overlayRef) {
                    const index = this._attachedOverlays.indexOf(overlayRef);
                    index > -1 && this._attachedOverlays.splice(index, 1), 0 === this._attachedOverlays.length && this._detach();
                }
                _detach() {
                    this._isAttached && (this._document.body.removeEventListener("keydown", this._keydownListener), 
                    this._isAttached = !1);
                }
            }
            return OverlayKeyboardDispatcher.ɵfac = function(t) {
                return new (t || OverlayKeyboardDispatcher)(core.Zb(common.d));
            }, OverlayKeyboardDispatcher.ɵprov = core.Lb({
                token: OverlayKeyboardDispatcher,
                factory: function(t) {
                    return OverlayKeyboardDispatcher.ɵfac(t);
                },
                providedIn: "root"
            }), OverlayKeyboardDispatcher.ngInjectableDef = Object(core.Lb)({
                factory: function() {
                    return new OverlayKeyboardDispatcher(Object(core.Zb)(common.d));
                },
                token: OverlayKeyboardDispatcher,
                providedIn: "root"
            }), OverlayKeyboardDispatcher;
        })(), overlay_OverlayContainer = (() => {
            class OverlayContainer {
                constructor(document) {
                    this._document = document;
                }
                ngOnDestroy() {
                    this._containerElement && this._containerElement.parentNode && this._containerElement.parentNode.removeChild(this._containerElement);
                }
                getContainerElement() {
                    return this._containerElement || this._createContainer(), this._containerElement;
                }
                _createContainer() {
                    const previousContainers = this._document.getElementsByClassName("cdk-overlay-container");
                    for (let i = 0; i < previousContainers.length; i++) previousContainers[i].parentNode.removeChild(previousContainers[i]);
                    const container = this._document.createElement("div");
                    container.classList.add("cdk-overlay-container"), this._document.body.appendChild(container), 
                    this._containerElement = container;
                }
            }
            return OverlayContainer.ɵfac = function(t) {
                return new (t || OverlayContainer)(core.Zb(common.d));
            }, OverlayContainer.ɵprov = core.Lb({
                token: OverlayContainer,
                factory: function(t) {
                    return OverlayContainer.ɵfac(t);
                },
                providedIn: "root"
            }), OverlayContainer.ngInjectableDef = Object(core.Lb)({
                factory: function() {
                    return new OverlayContainer(Object(core.Zb)(common.d));
                },
                token: OverlayContainer,
                providedIn: "root"
            }), OverlayContainer;
        })();
        class overlay_OverlayRef {
            constructor(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document, _location) {
                this._portalOutlet = _portalOutlet, this._host = _host, this._pane = _pane, this._config = _config, 
                this._ngZone = _ngZone, this._keyboardDispatcher = _keyboardDispatcher, this._document = _document, 
                this._location = _location, this._backdropElement = null, this._backdropClick = new Subject.a, 
                this._attachments = new Subject.a, this._detachments = new Subject.a, this._locationChanges = Subscription.a.EMPTY, 
                this._backdropClickHandler = event => this._backdropClick.next(event), this._keydownEventsObservable = new Observable.a(observer => {
                    const subscription = this._keydownEvents.subscribe(observer);
                    return this._keydownEventSubscriptions++, () => {
                        subscription.unsubscribe(), this._keydownEventSubscriptions--;
                    };
                }), this._keydownEvents = new Subject.a, this._keydownEventSubscriptions = 0, _config.scrollStrategy && (this._scrollStrategy = _config.scrollStrategy, 
                this._scrollStrategy.attach(this)), this._positionStrategy = _config.positionStrategy;
            }
            get overlayElement() {
                return this._pane;
            }
            get backdropElement() {
                return this._backdropElement;
            }
            get hostElement() {
                return this._host;
            }
            attach(portal) {
                let attachResult = this._portalOutlet.attach(portal);
                return this._positionStrategy && this._positionStrategy.attach(this), !this._host.parentElement && this._previousHostParent && this._previousHostParent.appendChild(this._host), 
                this._updateStackingOrder(), this._updateElementSize(), this._updateElementDirection(), 
                this._scrollStrategy && this._scrollStrategy.enable(), this._ngZone.onStable.asObservable().pipe(Object(take.a)(1)).subscribe(() => {
                    this.hasAttached() && this.updatePosition();
                }), this._togglePointerEvents(!0), this._config.hasBackdrop && this._attachBackdrop(), 
                this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !0), 
                this._attachments.next(), this._keyboardDispatcher.add(this), this._config.disposeOnNavigation && this._location && (this._locationChanges = this._location.subscribe(() => this.dispose())), 
                attachResult;
            }
            detach() {
                if (!this.hasAttached()) return;
                this.detachBackdrop(), this._togglePointerEvents(!1), this._positionStrategy && this._positionStrategy.detach && this._positionStrategy.detach(), 
                this._scrollStrategy && this._scrollStrategy.disable();
                const detachmentResult = this._portalOutlet.detach();
                return this._detachments.next(), this._keyboardDispatcher.remove(this), this._detachContentWhenStable(), 
                this._locationChanges.unsubscribe(), detachmentResult;
            }
            dispose() {
                const isAttached = this.hasAttached();
                this._positionStrategy && this._positionStrategy.dispose(), this._disposeScrollStrategy(), 
                this.detachBackdrop(), this._locationChanges.unsubscribe(), this._keyboardDispatcher.remove(this), 
                this._portalOutlet.dispose(), this._attachments.complete(), this._backdropClick.complete(), 
                this._keydownEvents.complete(), this._host && this._host.parentNode && (this._host.parentNode.removeChild(this._host), 
                this._host = null), this._previousHostParent = this._pane = null, isAttached && this._detachments.next(), 
                this._detachments.complete();
            }
            hasAttached() {
                return this._portalOutlet.hasAttached();
            }
            backdropClick() {
                return this._backdropClick.asObservable();
            }
            attachments() {
                return this._attachments.asObservable();
            }
            detachments() {
                return this._detachments.asObservable();
            }
            keydownEvents() {
                return this._keydownEventsObservable;
            }
            getConfig() {
                return this._config;
            }
            updatePosition() {
                this._positionStrategy && this._positionStrategy.apply();
            }
            updatePositionStrategy(strategy) {
                strategy !== this._positionStrategy && (this._positionStrategy && this._positionStrategy.dispose(), 
                this._positionStrategy = strategy, this.hasAttached() && (strategy.attach(this), 
                this.updatePosition()));
            }
            updateSize(sizeConfig) {
                this._config = Object.assign({}, this._config, sizeConfig), this._updateElementSize();
            }
            setDirection(dir) {
                this._config = Object.assign({}, this._config, {
                    direction: dir
                }), this._updateElementDirection();
            }
            addPanelClass(classes) {
                this._pane && this._toggleClasses(this._pane, classes, !0);
            }
            removePanelClass(classes) {
                this._pane && this._toggleClasses(this._pane, classes, !1);
            }
            getDirection() {
                const direction = this._config.direction;
                return direction ? "string" == typeof direction ? direction : direction.value : "ltr";
            }
            updateScrollStrategy(strategy) {
                strategy !== this._scrollStrategy && (this._disposeScrollStrategy(), this._scrollStrategy = strategy, 
                this.hasAttached() && (strategy.attach(this), strategy.enable()));
            }
            _updateElementDirection() {
                this._host.setAttribute("dir", this.getDirection());
            }
            _updateElementSize() {
                if (!this._pane) return;
                const style = this._pane.style;
                style.width = Object(coercion.c)(this._config.width), style.height = Object(coercion.c)(this._config.height), 
                style.minWidth = Object(coercion.c)(this._config.minWidth), style.minHeight = Object(coercion.c)(this._config.minHeight), 
                style.maxWidth = Object(coercion.c)(this._config.maxWidth), style.maxHeight = Object(coercion.c)(this._config.maxHeight);
            }
            _togglePointerEvents(enablePointer) {
                this._pane.style.pointerEvents = enablePointer ? "auto" : "none";
            }
            _attachBackdrop() {
                this._backdropElement = this._document.createElement("div"), this._backdropElement.classList.add("cdk-overlay-backdrop"), 
                this._config.backdropClass && this._toggleClasses(this._backdropElement, this._config.backdropClass, !0), 
                this._host.parentElement.insertBefore(this._backdropElement, this._host), this._backdropElement.addEventListener("click", this._backdropClickHandler), 
                "undefined" != typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => {
                    requestAnimationFrame(() => {
                        this._backdropElement && this._backdropElement.classList.add("cdk-overlay-backdrop-showing");
                    });
                }) : this._backdropElement.classList.add("cdk-overlay-backdrop-showing");
            }
            _updateStackingOrder() {
                this._host.nextSibling && this._host.parentNode.appendChild(this._host);
            }
            detachBackdrop() {
                let timeoutId, backdropToDetach = this._backdropElement;
                if (!backdropToDetach) return;
                let finishDetach = () => {
                    backdropToDetach && (backdropToDetach.removeEventListener("click", this._backdropClickHandler), 
                    backdropToDetach.removeEventListener("transitionend", finishDetach), backdropToDetach.parentNode && backdropToDetach.parentNode.removeChild(backdropToDetach)), 
                    this._backdropElement == backdropToDetach && (this._backdropElement = null), this._config.backdropClass && this._toggleClasses(backdropToDetach, this._config.backdropClass, !1), 
                    clearTimeout(timeoutId);
                };
                backdropToDetach.classList.remove("cdk-overlay-backdrop-showing"), this._ngZone.runOutsideAngular(() => {
                    backdropToDetach.addEventListener("transitionend", finishDetach);
                }), backdropToDetach.style.pointerEvents = "none", timeoutId = this._ngZone.runOutsideAngular(() => setTimeout(finishDetach, 500));
            }
            _toggleClasses(element, cssClasses, isAdd) {
                const classList = element.classList;
                Object(coercion.a)(cssClasses).forEach(cssClass => {
                    cssClass && (isAdd ? classList.add(cssClass) : classList.remove(cssClass));
                });
            }
            _detachContentWhenStable() {
                this._ngZone.runOutsideAngular(() => {
                    const subscription = this._ngZone.onStable.asObservable().pipe(Object(takeUntil.a)(Object(merge.a)(this._attachments, this._detachments))).subscribe(() => {
                        this._pane && this._host && 0 !== this._pane.children.length || (this._pane && this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !1), 
                        this._host && this._host.parentElement && (this._previousHostParent = this._host.parentElement, 
                        this._previousHostParent.removeChild(this._host)), subscription.unsubscribe());
                    });
                });
            }
            _disposeScrollStrategy() {
                const scrollStrategy = this._scrollStrategy;
                scrollStrategy && (scrollStrategy.disable(), scrollStrategy.detach && scrollStrategy.detach());
            }
        }
        const boundingBoxClass = "cdk-overlay-connected-position-bounding-box";
        class overlay_FlexibleConnectedPositionStrategy {
            constructor(connectedTo, _viewportRuler, _document, _platform, _overlayContainer) {
                this._viewportRuler = _viewportRuler, this._document = _document, this._platform = _platform, 
                this._overlayContainer = _overlayContainer, this._lastBoundingBoxSize = {
                    width: 0,
                    height: 0
                }, this._isPushed = !1, this._canPush = !0, this._growAfterOpen = !1, this._hasFlexibleDimensions = !0, 
                this._positionLocked = !1, this._viewportMargin = 0, this._scrollables = [], this._preferredPositions = [], 
                this._positionChanges = new Subject.a, this._resizeSubscription = Subscription.a.EMPTY, 
                this._offsetX = 0, this._offsetY = 0, this._appliedPanelClasses = [], this.positionChanges = this._positionChanges.asObservable(), 
                this.setOrigin(connectedTo);
            }
            get positions() {
                return this._preferredPositions;
            }
            attach(overlayRef) {
                if (this._overlayRef && overlayRef !== this._overlayRef) throw Error("This position strategy is already attached to an overlay");
                this._validatePositions(), overlayRef.hostElement.classList.add(boundingBoxClass), 
                this._overlayRef = overlayRef, this._boundingBox = overlayRef.hostElement, this._pane = overlayRef.overlayElement, 
                this._isDisposed = !1, this._isInitialRender = !0, this._lastPosition = null, this._resizeSubscription.unsubscribe(), 
                this._resizeSubscription = this._viewportRuler.change().subscribe(() => {
                    this._isInitialRender = !0, this.apply();
                });
            }
            apply() {
                if (this._isDisposed || !this._platform.isBrowser) return;
                if (!this._isInitialRender && this._positionLocked && this._lastPosition) return void this.reapplyLastPosition();
                this._clearPanelClasses(), this._resetOverlayElementStyles(), this._resetBoundingBoxStyles(), 
                this._viewportRect = this._getNarrowedViewportRect(), this._originRect = this._getOriginRect(), 
                this._overlayRect = this._pane.getBoundingClientRect();
                const originRect = this._originRect, overlayRect = this._overlayRect, viewportRect = this._viewportRect, flexibleFits = [];
                let fallback;
                for (let pos of this._preferredPositions) {
                    let originPoint = this._getOriginPoint(originRect, pos), overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos), overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);
                    if (overlayFit.isCompletelyWithinViewport) return this._isPushed = !1, void this._applyPosition(pos, originPoint);
                    this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect) ? flexibleFits.push({
                        position: pos,
                        origin: originPoint,
                        overlayRect: overlayRect,
                        boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)
                    }) : (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) && (fallback = {
                        overlayFit: overlayFit,
                        overlayPoint: overlayPoint,
                        originPoint: originPoint,
                        position: pos,
                        overlayRect: overlayRect
                    });
                }
                if (flexibleFits.length) {
                    let bestFit = null, bestScore = -1;
                    for (const fit of flexibleFits) {
                        const score = fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);
                        score > bestScore && (bestScore = score, bestFit = fit);
                    }
                    return this._isPushed = !1, void this._applyPosition(bestFit.position, bestFit.origin);
                }
                if (this._canPush) return this._isPushed = !0, void this._applyPosition(fallback.position, fallback.originPoint);
                this._applyPosition(fallback.position, fallback.originPoint);
            }
            detach() {
                this._clearPanelClasses(), this._lastPosition = null, this._previousPushAmount = null, 
                this._resizeSubscription.unsubscribe();
            }
            dispose() {
                this._isDisposed || (this._boundingBox && extendStyles(this._boundingBox.style, {
                    top: "",
                    left: "",
                    right: "",
                    bottom: "",
                    height: "",
                    width: "",
                    alignItems: "",
                    justifyContent: ""
                }), this._pane && this._resetOverlayElementStyles(), this._overlayRef && this._overlayRef.hostElement.classList.remove(boundingBoxClass), 
                this.detach(), this._positionChanges.complete(), this._overlayRef = this._boundingBox = null, 
                this._isDisposed = !0);
            }
            reapplyLastPosition() {
                if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) {
                    this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(), 
                    this._viewportRect = this._getNarrowedViewportRect();
                    const lastPosition = this._lastPosition || this._preferredPositions[0], originPoint = this._getOriginPoint(this._originRect, lastPosition);
                    this._applyPosition(lastPosition, originPoint);
                }
            }
            withScrollableContainers(scrollables) {
                return this._scrollables = scrollables, this;
            }
            withPositions(positions) {
                return this._preferredPositions = positions, -1 === positions.indexOf(this._lastPosition) && (this._lastPosition = null), 
                this._validatePositions(), this;
            }
            withViewportMargin(margin) {
                return this._viewportMargin = margin, this;
            }
            withFlexibleDimensions(flexibleDimensions = !0) {
                return this._hasFlexibleDimensions = flexibleDimensions, this;
            }
            withGrowAfterOpen(growAfterOpen = !0) {
                return this._growAfterOpen = growAfterOpen, this;
            }
            withPush(canPush = !0) {
                return this._canPush = canPush, this;
            }
            withLockedPosition(isLocked = !0) {
                return this._positionLocked = isLocked, this;
            }
            setOrigin(origin) {
                return this._origin = origin, this;
            }
            withDefaultOffsetX(offset) {
                return this._offsetX = offset, this;
            }
            withDefaultOffsetY(offset) {
                return this._offsetY = offset, this;
            }
            withTransformOriginOn(selector) {
                return this._transformOriginSelector = selector, this;
            }
            _getOriginPoint(originRect, pos) {
                let x, y;
                if ("center" == pos.originX) x = originRect.left + originRect.width / 2; else {
                    const startX = this._isRtl() ? originRect.right : originRect.left, endX = this._isRtl() ? originRect.left : originRect.right;
                    x = "start" == pos.originX ? startX : endX;
                }
                return {
                    x: x,
                    y: y = "center" == pos.originY ? originRect.top + originRect.height / 2 : "top" == pos.originY ? originRect.top : originRect.bottom
                };
            }
            _getOverlayPoint(originPoint, overlayRect, pos) {
                let overlayStartX, overlayStartY;
                return overlayStartX = "center" == pos.overlayX ? -overlayRect.width / 2 : "start" === pos.overlayX ? this._isRtl() ? -overlayRect.width : 0 : this._isRtl() ? 0 : -overlayRect.width, 
                {
                    x: originPoint.x + overlayStartX,
                    y: originPoint.y + (overlayStartY = "center" == pos.overlayY ? -overlayRect.height / 2 : "top" == pos.overlayY ? 0 : -overlayRect.height)
                };
            }
            _getOverlayFit(point, overlay, viewport, position) {
                let {x: x, y: y} = point, offsetX = this._getOffset(position, "x"), offsetY = this._getOffset(position, "y");
                offsetX && (x += offsetX), offsetY && (y += offsetY);
                let topOverflow = 0 - y, bottomOverflow = y + overlay.height - viewport.height, visibleWidth = this._subtractOverflows(overlay.width, 0 - x, x + overlay.width - viewport.width), visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow), visibleArea = visibleWidth * visibleHeight;
                return {
                    visibleArea: visibleArea,
                    isCompletelyWithinViewport: overlay.width * overlay.height === visibleArea,
                    fitsInViewportVertically: visibleHeight === overlay.height,
                    fitsInViewportHorizontally: visibleWidth == overlay.width
                };
            }
            _canFitWithFlexibleDimensions(fit, point, viewport) {
                if (this._hasFlexibleDimensions) {
                    const availableHeight = viewport.bottom - point.y, availableWidth = viewport.right - point.x, minHeight = this._overlayRef.getConfig().minHeight, minWidth = this._overlayRef.getConfig().minWidth, horizontalFit = fit.fitsInViewportHorizontally || null != minWidth && minWidth <= availableWidth;
                    return (fit.fitsInViewportVertically || null != minHeight && minHeight <= availableHeight) && horizontalFit;
                }
                return !1;
            }
            _pushOverlayOnScreen(start, overlay, scrollPosition) {
                if (this._previousPushAmount && this._positionLocked) return {
                    x: start.x + this._previousPushAmount.x,
                    y: start.y + this._previousPushAmount.y
                };
                const viewport = this._viewportRect, overflowRight = Math.max(start.x + overlay.width - viewport.right, 0), overflowBottom = Math.max(start.y + overlay.height - viewport.bottom, 0), overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0), overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);
                let pushX = 0, pushY = 0;
                return this._previousPushAmount = {
                    x: pushX = overlay.width <= viewport.width ? overflowLeft || -overflowRight : start.x < this._viewportMargin ? viewport.left - scrollPosition.left - start.x : 0,
                    y: pushY = overlay.height <= viewport.height ? overflowTop || -overflowBottom : start.y < this._viewportMargin ? viewport.top - scrollPosition.top - start.y : 0
                }, {
                    x: start.x + pushX,
                    y: start.y + pushY
                };
            }
            _applyPosition(position, originPoint) {
                if (this._setTransformOrigin(position), this._setOverlayElementStyles(originPoint, position), 
                this._setBoundingBoxStyles(originPoint, position), position.panelClass && this._addPanelClasses(position.panelClass), 
                this._lastPosition = position, this._positionChanges.observers.length) {
                    const scrollableViewProperties = this._getScrollVisibility(), changeEvent = new ConnectedOverlayPositionChange(position, scrollableViewProperties);
                    this._positionChanges.next(changeEvent);
                }
                this._isInitialRender = !1;
            }
            _setTransformOrigin(position) {
                if (!this._transformOriginSelector) return;
                const elements = this._boundingBox.querySelectorAll(this._transformOriginSelector);
                let xOrigin, yOrigin = position.overlayY;
                xOrigin = "center" === position.overlayX ? "center" : this._isRtl() ? "start" === position.overlayX ? "right" : "left" : "start" === position.overlayX ? "left" : "right";
                for (let i = 0; i < elements.length; i++) elements[i].style.transformOrigin = `${xOrigin} ${yOrigin}`;
            }
            _calculateBoundingBoxRect(origin, position) {
                const viewport = this._viewportRect, isRtl = this._isRtl();
                let height, top, bottom, width, left, right;
                if ("top" === position.overlayY) height = viewport.height - (top = origin.y) + this._viewportMargin; else if ("bottom" === position.overlayY) height = viewport.height - (bottom = viewport.height - origin.y + 2 * this._viewportMargin) + this._viewportMargin; else {
                    const smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y + viewport.top, origin.y), previousHeight = this._lastBoundingBoxSize.height;
                    top = origin.y - smallestDistanceToViewportEdge, (height = 2 * smallestDistanceToViewportEdge) > previousHeight && !this._isInitialRender && !this._growAfterOpen && (top = origin.y - previousHeight / 2);
                }
                if ("end" === position.overlayX && !isRtl || "start" === position.overlayX && isRtl) right = viewport.width - origin.x + this._viewportMargin, 
                width = origin.x - this._viewportMargin; else if ("start" === position.overlayX && !isRtl || "end" === position.overlayX && isRtl) left = origin.x, 
                width = viewport.right - origin.x; else {
                    const smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x + viewport.left, origin.x), previousWidth = this._lastBoundingBoxSize.width;
                    left = origin.x - smallestDistanceToViewportEdge, (width = 2 * smallestDistanceToViewportEdge) > previousWidth && !this._isInitialRender && !this._growAfterOpen && (left = origin.x - previousWidth / 2);
                }
                return {
                    top: top,
                    left: left,
                    bottom: bottom,
                    right: right,
                    width: width,
                    height: height
                };
            }
            _setBoundingBoxStyles(origin, position) {
                const boundingBoxRect = this._calculateBoundingBoxRect(origin, position);
                this._isInitialRender || this._growAfterOpen || (boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height), 
                boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width));
                const styles = {};
                if (this._hasExactPosition()) styles.top = styles.left = "0", styles.bottom = styles.right = "", 
                styles.width = styles.height = "100%"; else {
                    const maxHeight = this._overlayRef.getConfig().maxHeight, maxWidth = this._overlayRef.getConfig().maxWidth;
                    styles.height = Object(coercion.c)(boundingBoxRect.height), styles.top = Object(coercion.c)(boundingBoxRect.top), 
                    styles.bottom = Object(coercion.c)(boundingBoxRect.bottom), styles.width = Object(coercion.c)(boundingBoxRect.width), 
                    styles.left = Object(coercion.c)(boundingBoxRect.left), styles.right = Object(coercion.c)(boundingBoxRect.right), 
                    styles.alignItems = "center" === position.overlayX ? "center" : "end" === position.overlayX ? "flex-end" : "flex-start", 
                    styles.justifyContent = "center" === position.overlayY ? "center" : "bottom" === position.overlayY ? "flex-end" : "flex-start", 
                    maxHeight && (styles.maxHeight = Object(coercion.c)(maxHeight)), maxWidth && (styles.maxWidth = Object(coercion.c)(maxWidth));
                }
                this._lastBoundingBoxSize = boundingBoxRect, extendStyles(this._boundingBox.style, styles);
            }
            _resetBoundingBoxStyles() {
                extendStyles(this._boundingBox.style, {
                    top: "0",
                    left: "0",
                    right: "0",
                    bottom: "0",
                    height: "",
                    width: "",
                    alignItems: "",
                    justifyContent: ""
                });
            }
            _resetOverlayElementStyles() {
                extendStyles(this._pane.style, {
                    top: "",
                    left: "",
                    bottom: "",
                    right: "",
                    position: "",
                    transform: ""
                });
            }
            _setOverlayElementStyles(originPoint, position) {
                const styles = {};
                if (this._hasExactPosition()) {
                    const scrollPosition = this._viewportRuler.getViewportScrollPosition();
                    extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition)), 
                    extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));
                } else styles.position = "static";
                let transformString = "", offsetX = this._getOffset(position, "x"), offsetY = this._getOffset(position, "y");
                offsetX && (transformString += `translateX(${offsetX}px) `), offsetY && (transformString += `translateY(${offsetY}px)`), 
                styles.transform = transformString.trim(), this._hasFlexibleDimensions && this._overlayRef.getConfig().maxHeight && (styles.maxHeight = ""), 
                this._hasFlexibleDimensions && this._overlayRef.getConfig().maxWidth && (styles.maxWidth = ""), 
                extendStyles(this._pane.style, styles);
            }
            _getExactOverlayY(position, originPoint, scrollPosition) {
                let styles = {
                    top: null,
                    bottom: null
                }, overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);
                this._isPushed && (overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition));
                let virtualKeyboardOffset = this._overlayContainer.getContainerElement().getBoundingClientRect().top;
                return overlayPoint.y -= virtualKeyboardOffset, "bottom" === position.overlayY ? styles.bottom = `${this._document.documentElement.clientHeight - (overlayPoint.y + this._overlayRect.height)}px` : styles.top = Object(coercion.c)(overlayPoint.y), 
                styles;
            }
            _getExactOverlayX(position, originPoint, scrollPosition) {
                let horizontalStyleProperty, styles = {
                    left: null,
                    right: null
                }, overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);
                return this._isPushed && (overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition)), 
                "right" == (horizontalStyleProperty = this._isRtl() ? "end" === position.overlayX ? "left" : "right" : "end" === position.overlayX ? "right" : "left") ? styles.right = `${this._document.documentElement.clientWidth - (overlayPoint.x + this._overlayRect.width)}px` : styles.left = Object(coercion.c)(overlayPoint.x), 
                styles;
            }
            _getScrollVisibility() {
                const originBounds = this._getOriginRect(), overlayBounds = this._pane.getBoundingClientRect(), scrollContainerBounds = this._scrollables.map(scrollable => scrollable.getElementRef().nativeElement.getBoundingClientRect());
                return {
                    isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),
                    isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),
                    isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),
                    isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds)
                };
            }
            _subtractOverflows(length, ...overflows) {
                return overflows.reduce((currentValue, currentOverflow) => currentValue - Math.max(currentOverflow, 0), length);
            }
            _getNarrowedViewportRect() {
                const width = this._document.documentElement.clientWidth, height = this._document.documentElement.clientHeight, scrollPosition = this._viewportRuler.getViewportScrollPosition();
                return {
                    top: scrollPosition.top + this._viewportMargin,
                    left: scrollPosition.left + this._viewportMargin,
                    right: scrollPosition.left + width - this._viewportMargin,
                    bottom: scrollPosition.top + height - this._viewportMargin,
                    width: width - 2 * this._viewportMargin,
                    height: height - 2 * this._viewportMargin
                };
            }
            _isRtl() {
                return "rtl" === this._overlayRef.getDirection();
            }
            _hasExactPosition() {
                return !this._hasFlexibleDimensions || this._isPushed;
            }
            _getOffset(position, axis) {
                return "x" === axis ? null == position.offsetX ? this._offsetX : position.offsetX : null == position.offsetY ? this._offsetY : position.offsetY;
            }
            _validatePositions() {
                if (!this._preferredPositions.length) throw Error("FlexibleConnectedPositionStrategy: At least one position is required.");
                this._preferredPositions.forEach(pair => {
                    validateHorizontalPosition("originX", pair.originX), validateVerticalPosition("originY", pair.originY), 
                    validateHorizontalPosition("overlayX", pair.overlayX), validateVerticalPosition("overlayY", pair.overlayY);
                });
            }
            _addPanelClasses(cssClasses) {
                this._pane && Object(coercion.a)(cssClasses).forEach(cssClass => {
                    "" !== cssClass && -1 === this._appliedPanelClasses.indexOf(cssClass) && (this._appliedPanelClasses.push(cssClass), 
                    this._pane.classList.add(cssClass));
                });
            }
            _clearPanelClasses() {
                this._pane && (this._appliedPanelClasses.forEach(cssClass => {
                    this._pane.classList.remove(cssClass);
                }), this._appliedPanelClasses = []);
            }
            _getOriginRect() {
                const origin = this._origin;
                if (origin instanceof core.k) return origin.nativeElement.getBoundingClientRect();
                if (origin instanceof HTMLElement) return origin.getBoundingClientRect();
                const width = origin.width || 0, height = origin.height || 0;
                return {
                    top: origin.y,
                    bottom: origin.y + height,
                    left: origin.x,
                    right: origin.x + width,
                    height: height,
                    width: width
                };
            }
        }
        function extendStyles(dest, source) {
            for (let key in source) source.hasOwnProperty(key) && (dest[key] = source[key]);
            return dest;
        }
        class ConnectedPositionStrategy {
            constructor(originPos, overlayPos, connectedTo, viewportRuler, document, platform, overlayContainer) {
                this._preferredPositions = [], this._positionStrategy = new overlay_FlexibleConnectedPositionStrategy(connectedTo, viewportRuler, document, platform, overlayContainer).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0), 
                this.withFallbackPosition(originPos, overlayPos);
            }
            get _isRtl() {
                return "rtl" === this._overlayRef.getDirection();
            }
            get onPositionChange() {
                return this._positionStrategy.positionChanges;
            }
            get positions() {
                return this._preferredPositions;
            }
            attach(overlayRef) {
                this._overlayRef = overlayRef, this._positionStrategy.attach(overlayRef), this._direction && (overlayRef.setDirection(this._direction), 
                this._direction = null);
            }
            dispose() {
                this._positionStrategy.dispose();
            }
            detach() {
                this._positionStrategy.detach();
            }
            apply() {
                this._positionStrategy.apply();
            }
            recalculateLastPosition() {
                this._positionStrategy.reapplyLastPosition();
            }
            withScrollableContainers(scrollables) {
                this._positionStrategy.withScrollableContainers(scrollables);
            }
            withFallbackPosition(originPos, overlayPos, offsetX, offsetY) {
                const position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);
                return this._preferredPositions.push(position), this._positionStrategy.withPositions(this._preferredPositions), 
                this;
            }
            withDirection(dir) {
                return this._overlayRef ? this._overlayRef.setDirection(dir) : this._direction = dir, 
                this;
            }
            withOffsetX(offset) {
                return this._positionStrategy.withDefaultOffsetX(offset), this;
            }
            withOffsetY(offset) {
                return this._positionStrategy.withDefaultOffsetY(offset), this;
            }
            withLockedPosition(isLocked) {
                return this._positionStrategy.withLockedPosition(isLocked), this;
            }
            withPositions(positions) {
                return this._preferredPositions = positions.slice(), this._positionStrategy.withPositions(this._preferredPositions), 
                this;
            }
            setOrigin(origin) {
                return this._positionStrategy.setOrigin(origin), this;
            }
        }
        const wrapperClass = "cdk-global-overlay-wrapper";
        class GlobalPositionStrategy {
            constructor() {
                this._cssPosition = "static", this._topOffset = "", this._bottomOffset = "", this._leftOffset = "", 
                this._rightOffset = "", this._alignItems = "", this._justifyContent = "", this._width = "", 
                this._height = "";
            }
            attach(overlayRef) {
                const config = overlayRef.getConfig();
                this._overlayRef = overlayRef, this._width && !config.width && overlayRef.updateSize({
                    width: this._width
                }), this._height && !config.height && overlayRef.updateSize({
                    height: this._height
                }), overlayRef.hostElement.classList.add(wrapperClass), this._isDisposed = !1;
            }
            top(value = "") {
                return this._bottomOffset = "", this._topOffset = value, this._alignItems = "flex-start", 
                this;
            }
            left(value = "") {
                return this._rightOffset = "", this._leftOffset = value, this._justifyContent = "flex-start", 
                this;
            }
            bottom(value = "") {
                return this._topOffset = "", this._bottomOffset = value, this._alignItems = "flex-end", 
                this;
            }
            right(value = "") {
                return this._leftOffset = "", this._rightOffset = value, this._justifyContent = "flex-end", 
                this;
            }
            width(value = "") {
                return this._overlayRef ? this._overlayRef.updateSize({
                    width: value
                }) : this._width = value, this;
            }
            height(value = "") {
                return this._overlayRef ? this._overlayRef.updateSize({
                    height: value
                }) : this._height = value, this;
            }
            centerHorizontally(offset = "") {
                return this.left(offset), this._justifyContent = "center", this;
            }
            centerVertically(offset = "") {
                return this.top(offset), this._alignItems = "center", this;
            }
            apply() {
                if (!this._overlayRef || !this._overlayRef.hasAttached()) return;
                const styles = this._overlayRef.overlayElement.style, parentStyles = this._overlayRef.hostElement.style, config = this._overlayRef.getConfig();
                styles.position = this._cssPosition, styles.marginLeft = "100%" === config.width ? "0" : this._leftOffset, 
                styles.marginTop = "100%" === config.height ? "0" : this._topOffset, styles.marginBottom = this._bottomOffset, 
                styles.marginRight = this._rightOffset, "100%" === config.width ? parentStyles.justifyContent = "flex-start" : "center" === this._justifyContent ? parentStyles.justifyContent = "center" : "rtl" === this._overlayRef.getConfig().direction ? "flex-start" === this._justifyContent ? parentStyles.justifyContent = "flex-end" : "flex-end" === this._justifyContent && (parentStyles.justifyContent = "flex-start") : parentStyles.justifyContent = this._justifyContent, 
                parentStyles.alignItems = "100%" === config.height ? "flex-start" : this._alignItems;
            }
            dispose() {
                if (this._isDisposed || !this._overlayRef) return;
                const styles = this._overlayRef.overlayElement.style, parent = this._overlayRef.hostElement, parentStyles = parent.style;
                parent.classList.remove(wrapperClass), parentStyles.justifyContent = parentStyles.alignItems = styles.marginTop = styles.marginBottom = styles.marginLeft = styles.marginRight = styles.position = "", 
                this._overlayRef = null, this._isDisposed = !0;
            }
        }
        let overlay_OverlayPositionBuilder = (() => {
            class OverlayPositionBuilder {
                constructor(_viewportRuler, _document, _platform, _overlayContainer) {
                    this._viewportRuler = _viewportRuler, this._document = _document, this._platform = _platform, 
                    this._overlayContainer = _overlayContainer;
                }
                global() {
                    return new GlobalPositionStrategy;
                }
                connectedTo(elementRef, originPos, overlayPos) {
                    return new ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document, this._platform, this._overlayContainer);
                }
                flexibleConnectedTo(origin) {
                    return new overlay_FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);
                }
            }
            return OverlayPositionBuilder.ɵfac = function(t) {
                return new (t || OverlayPositionBuilder)(core.Zb(scrolling.e), core.Zb(common.d), core.Zb(platform.a), core.Zb(overlay_OverlayContainer));
            }, OverlayPositionBuilder.ɵprov = core.Lb({
                token: OverlayPositionBuilder,
                factory: function(t) {
                    return OverlayPositionBuilder.ɵfac(t);
                },
                providedIn: "root"
            }), OverlayPositionBuilder.ngInjectableDef = Object(core.Lb)({
                factory: function() {
                    return new OverlayPositionBuilder(Object(core.Zb)(scrolling.e), Object(core.Zb)(common.d), Object(core.Zb)(platform.a), Object(core.Zb)(overlay_OverlayContainer));
                },
                token: OverlayPositionBuilder,
                providedIn: "root"
            }), OverlayPositionBuilder;
        })(), nextUniqueId = 0, overlay_Overlay = (() => {
            class Overlay {
                constructor(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _injector, _ngZone, _document, _directionality, _location) {
                    this.scrollStrategies = scrollStrategies, this._overlayContainer = _overlayContainer, 
                    this._componentFactoryResolver = _componentFactoryResolver, this._positionBuilder = _positionBuilder, 
                    this._keyboardDispatcher = _keyboardDispatcher, this._injector = _injector, this._ngZone = _ngZone, 
                    this._document = _document, this._directionality = _directionality, this._location = _location;
                }
                create(config) {
                    const host = this._createHostElement(), pane = this._createPaneElement(host), portalOutlet = this._createPortalOutlet(pane), overlayConfig = new OverlayConfig(config);
                    return overlayConfig.direction = overlayConfig.direction || this._directionality.value, 
                    new overlay_OverlayRef(portalOutlet, host, pane, overlayConfig, this._ngZone, this._keyboardDispatcher, this._document, this._location);
                }
                position() {
                    return this._positionBuilder;
                }
                _createPaneElement(host) {
                    const pane = this._document.createElement("div");
                    return pane.id = `cdk-overlay-${nextUniqueId++}`, pane.classList.add("cdk-overlay-pane"), 
                    host.appendChild(pane), pane;
                }
                _createHostElement() {
                    const host = this._document.createElement("div");
                    return this._overlayContainer.getContainerElement().appendChild(host), host;
                }
                _createPortalOutlet(pane) {
                    return this._appRef || (this._appRef = this._injector.get(core.g)), new fesm2015_portal.e(pane, this._componentFactoryResolver, this._appRef, this._injector);
                }
            }
            return Overlay.ɵfac = function(t) {
                return new (t || Overlay)(core.Zb(overlay_ScrollStrategyOptions), core.Zb(overlay_OverlayContainer), core.Zb(core.j), core.Zb(overlay_OverlayPositionBuilder), core.Zb(overlay_OverlayKeyboardDispatcher), core.Zb(core.q), core.Zb(core.y), core.Zb(common.d), core.Zb(bidi.b), core.Zb(common.g, 8));
            }, Overlay.ɵprov = core.Lb({
                token: Overlay,
                factory: function(t) {
                    return Overlay.ɵfac(t);
                },
                providedIn: null
            }), Overlay;
        })();
        const CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {
            provide: new core.p("cdk-connected-overlay-scroll-strategy"),
            deps: [ overlay_Overlay ],
            useFactory: function(overlay) {
                return () => overlay.scrollStrategies.reposition();
            }
        };
        let overlay_OverlayModule = (() => {
            class OverlayModule {}
            return OverlayModule.ɵmod = core.Nb({
                type: OverlayModule
            }), OverlayModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || OverlayModule);
                },
                providers: [ overlay_Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER ],
                imports: [ [ bidi.a, fesm2015_portal.h, scrolling.c ], scrolling.c ]
            }), OverlayModule;
        })();
        var fesm2015_core = __webpack_require__("FKr1"), fesm2015_button = __webpack_require__("bTqV"), animations = __webpack_require__("R0Ic"), a11y = __webpack_require__("u47x"), combineLatest = __webpack_require__("itXk"), concat = __webpack_require__("GyhO"), Subscriber = __webpack_require__("7o/Q");
        class SkipOperator {
            constructor(total) {
                this.total = total;
            }
            call(subscriber, source) {
                return source.subscribe(new skip_SkipSubscriber(subscriber, this.total));
            }
        }
        class skip_SkipSubscriber extends Subscriber.a {
            constructor(destination, total) {
                super(destination), this.total = total, this.count = 0;
            }
            _next(x) {
                ++this.count > this.total && this.destination.next(x);
            }
        }
        var debounceTime = __webpack_require__("Kj3r"), map = __webpack_require__("lJxs"), startWith = __webpack_require__("JX91");
        const mediaQueriesForWebkitCompatibility = new Set;
        let mediaQueryStyleNode, layout_MediaMatcher = (() => {
            class MediaMatcher {
                constructor(_platform) {
                    this._platform = _platform, this._matchMedia = this._platform.isBrowser && window.matchMedia ? window.matchMedia.bind(window) : noopMatchMedia;
                }
                matchMedia(query) {
                    return this._platform.WEBKIT && function(query) {
                        if (!mediaQueriesForWebkitCompatibility.has(query)) try {
                            mediaQueryStyleNode || ((mediaQueryStyleNode = document.createElement("style")).setAttribute("type", "text/css"), 
                            document.head.appendChild(mediaQueryStyleNode)), mediaQueryStyleNode.sheet && (mediaQueryStyleNode.sheet.insertRule(`@media ${query} {.fx-query-test{ }}`, 0), 
                            mediaQueriesForWebkitCompatibility.add(query));
                        } catch (e) {
                            console.error(e);
                        }
                    }(query), this._matchMedia(query);
                }
            }
            return MediaMatcher.ɵfac = function(t) {
                return new (t || MediaMatcher)(core.Zb(platform.a));
            }, MediaMatcher.ɵprov = core.Lb({
                token: MediaMatcher,
                factory: function(t) {
                    return MediaMatcher.ɵfac(t);
                },
                providedIn: "root"
            }), MediaMatcher.ngInjectableDef = Object(core.Lb)({
                factory: function() {
                    return new MediaMatcher(Object(core.Zb)(platform.a));
                },
                token: MediaMatcher,
                providedIn: "root"
            }), MediaMatcher;
        })();
        function noopMatchMedia(query) {
            return {
                matches: "all" === query || "" === query,
                media: query,
                addListener: () => {},
                removeListener: () => {}
            };
        }
        let layout_BreakpointObserver = (() => {
            class BreakpointObserver {
                constructor(_mediaMatcher, _zone) {
                    this._mediaMatcher = _mediaMatcher, this._zone = _zone, this._queries = new Map, 
                    this._destroySubject = new Subject.a;
                }
                ngOnDestroy() {
                    this._destroySubject.next(), this._destroySubject.complete();
                }
                isMatched(value) {
                    return splitQueries(Object(coercion.a)(value)).some(mediaQuery => this._registerQuery(mediaQuery).mql.matches);
                }
                observe(value) {
                    const observables = splitQueries(Object(coercion.a)(value)).map(query => this._registerQuery(query).observable);
                    let stateObservable = Object(combineLatest.a)(observables);
                    return (stateObservable = Object(concat.a)(stateObservable.pipe(Object(take.a)(1)), stateObservable.pipe(source => source.lift(new SkipOperator(1)), Object(debounceTime.a)(0)))).pipe(Object(map.a)(breakpointStates => {
                        const response = {
                            matches: !1,
                            breakpoints: {}
                        };
                        return breakpointStates.forEach(state => {
                            response.matches = response.matches || state.matches, response.breakpoints[state.query] = state.matches;
                        }), response;
                    }));
                }
                _registerQuery(query) {
                    if (this._queries.has(query)) return this._queries.get(query);
                    const mql = this._mediaMatcher.matchMedia(query), output = {
                        observable: new Observable.a(observer => {
                            const handler = e => this._zone.run(() => observer.next(e));
                            return mql.addListener(handler), () => {
                                mql.removeListener(handler);
                            };
                        }).pipe(Object(startWith.a)(mql), Object(map.a)(nextMql => ({
                            query: query,
                            matches: nextMql.matches
                        })), Object(takeUntil.a)(this._destroySubject)),
                        mql: mql
                    };
                    return this._queries.set(query, output), output;
                }
            }
            return BreakpointObserver.ɵfac = function(t) {
                return new (t || BreakpointObserver)(core.Zb(layout_MediaMatcher), core.Zb(core.y));
            }, BreakpointObserver.ɵprov = core.Lb({
                token: BreakpointObserver,
                factory: function(t) {
                    return BreakpointObserver.ɵfac(t);
                },
                providedIn: "root"
            }), BreakpointObserver.ngInjectableDef = Object(core.Lb)({
                factory: function() {
                    return new BreakpointObserver(Object(core.Zb)(layout_MediaMatcher), Object(core.Zb)(core.y));
                },
                token: BreakpointObserver,
                providedIn: "root"
            }), BreakpointObserver;
        })();
        function splitQueries(queries) {
            return queries.map(query => query.split(",")).reduce((a1, a2) => a1.concat(a2)).map(query => query.trim());
        }
        const Breakpoints = {
            XSmall: "(max-width: 599.99px)",
            Small: "(min-width: 600px) and (max-width: 959.99px)",
            Medium: "(min-width: 960px) and (max-width: 1279.99px)",
            Large: "(min-width: 1280px) and (max-width: 1919.99px)",
            XLarge: "(min-width: 1920px)",
            Handset: "(max-width: 599.99px) and (orientation: portrait), (max-width: 959.99px) and (orientation: landscape)",
            Tablet: "(min-width: 600px) and (max-width: 839.99px) and (orientation: portrait), (min-width: 960px) and (max-width: 1279.99px) and (orientation: landscape)",
            Web: "(min-width: 840px) and (orientation: portrait), (min-width: 1280px) and (orientation: landscape)",
            HandsetPortrait: "(max-width: 599.99px) and (orientation: portrait)",
            TabletPortrait: "(min-width: 600px) and (max-width: 839.99px) and (orientation: portrait)",
            WebPortrait: "(min-width: 840px) and (orientation: portrait)",
            HandsetLandscape: "(max-width: 959.99px) and (orientation: landscape)",
            TabletLandscape: "(min-width: 960px) and (max-width: 1279.99px) and (orientation: landscape)",
            WebLandscape: "(min-width: 1280px) and (orientation: landscape)"
        };
        __webpack_require__.d(__webpack_exports__, "b", (function() {
            return snack_bar_MatSnackBarModule;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return snack_bar_MatSnackBar;
        }));
        const _c0 = [ 1, "mat-simple-snackbar" ];
        function SimpleSnackBar_div_2_Template(rf, ctx) {
            if (1 & rf) {
                const _r13 = core.Wb();
                core.Vb(0, "div", 1), core.Vb(1, "button", 2), core.cc("click", (function($event) {
                    return core.uc(_r13), core.gc().action();
                })), core.Ec(2), core.Tb(), core.Tb();
            }
            if (2 & rf) {
                const ctx_r11 = core.gc();
                core.Ab(2), core.Fc(ctx_r11.data.action);
            }
        }
        const _c1 = [ 1, "mat-snack-bar-container" ];
        function MatSnackBarContainer_ng_template_0_Template(rf, ctx) {}
        class snack_bar_MatSnackBarRef {
            constructor(containerInstance, _overlayRef) {
                this._overlayRef = _overlayRef, this._afterDismissed = new Subject.a, this._afterOpened = new Subject.a, 
                this._onAction = new Subject.a, this._dismissedByAction = !1, this.containerInstance = containerInstance, 
                this.onAction().subscribe(() => this.dismiss()), containerInstance._onExit.subscribe(() => this._finishDismiss());
            }
            dismiss() {
                this._afterDismissed.closed || this.containerInstance.exit(), clearTimeout(this._durationTimeoutId);
            }
            dismissWithAction() {
                this._onAction.closed || (this._dismissedByAction = !0, this._onAction.next(), this._onAction.complete());
            }
            closeWithAction() {
                this.dismissWithAction();
            }
            _dismissAfter(duration) {
                this._durationTimeoutId = setTimeout(() => this.dismiss(), duration);
            }
            _open() {
                this._afterOpened.closed || (this._afterOpened.next(), this._afterOpened.complete());
            }
            _finishDismiss() {
                this._overlayRef.dispose(), this._onAction.closed || this._onAction.complete(), 
                this._afterDismissed.next({
                    dismissedByAction: this._dismissedByAction
                }), this._afterDismissed.complete(), this._dismissedByAction = !1;
            }
            afterDismissed() {
                return this._afterDismissed.asObservable();
            }
            afterOpened() {
                return this.containerInstance._onEnter;
            }
            onAction() {
                return this._onAction.asObservable();
            }
        }
        const MAT_SNACK_BAR_DATA = new core.p("MatSnackBarData");
        class MatSnackBarConfig {
            constructor() {
                this.politeness = "assertive", this.announcementMessage = "", this.duration = 0, 
                this.data = null, this.horizontalPosition = "center", this.verticalPosition = "bottom";
            }
        }
        let snack_bar_SimpleSnackBar = (() => {
            class SimpleSnackBar {
                constructor(snackBarRef, data) {
                    this.snackBarRef = snackBarRef, this.data = data;
                }
                action() {
                    this.snackBarRef.dismissWithAction();
                }
                get hasAction() {
                    return !!this.data.action;
                }
            }
            return SimpleSnackBar.ɵfac = function(t) {
                return new (t || SimpleSnackBar)(core.Pb(snack_bar_MatSnackBarRef), core.Pb(MAT_SNACK_BAR_DATA));
            }, SimpleSnackBar.ɵcmp = core.Jb({
                type: SimpleSnackBar,
                selectors: [ [ "simple-snack-bar" ] ],
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && core.Ub(_c0);
                },
                decls: 3,
                vars: 2,
                consts: [ [ "class", "mat-simple-snackbar-action", 4, "ngIf" ], [ 1, "mat-simple-snackbar-action" ], [ "mat-button", "", 3, "click" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.Vb(0, "span"), core.Ec(1), core.Tb(), core.Cc(2, SimpleSnackBar_div_2_Template, 3, 1, "div", 0)), 
                    2 & rf && (core.Ab(1), core.Fc(ctx.data.message), core.Ab(1), core.lc("ngIf", ctx.hasAction));
                },
                directives: [ common.k, fesm2015_button.a ],
                styles: [ ".mat-simple-snackbar{display:flex;justify-content:space-between;align-items:center;line-height:20px;opacity:1}.mat-simple-snackbar-action{flex-shrink:0;margin:-8px -8px -8px 8px}.mat-simple-snackbar-action button{max-height:36px;min-width:0}[dir=rtl] .mat-simple-snackbar-action{margin-left:-8px;margin-right:8px}/*# sourceMappingURL=simple-snack-bar.css.map */\n" ],
                encapsulation: 2,
                changeDetection: 0
            }), SimpleSnackBar;
        })();
        const matSnackBarAnimations = {
            snackBarState: Object(animations.j)("state", [ Object(animations.g)("void, hidden", Object(animations.h)({
                transform: "scale(0.8)",
                opacity: 0
            })), Object(animations.g)("visible", Object(animations.h)({
                transform: "scale(1)",
                opacity: 1
            })), Object(animations.i)("* => visible", Object(animations.e)("150ms cubic-bezier(0, 0, 0.2, 1)")), Object(animations.i)("* => void, * => hidden", Object(animations.e)("75ms cubic-bezier(0.4, 0.0, 1, 1)", Object(animations.h)({
                opacity: 0
            }))) ])
        };
        let snack_bar_MatSnackBarContainer = (() => {
            class MatSnackBarContainer extends fesm2015_portal.a {
                constructor(_ngZone, _elementRef, _changeDetectorRef, snackBarConfig) {
                    super(), this._ngZone = _ngZone, this._elementRef = _elementRef, this._changeDetectorRef = _changeDetectorRef, 
                    this.snackBarConfig = snackBarConfig, this._destroyed = !1, this._onExit = new Subject.a, 
                    this._onEnter = new Subject.a, this._animationState = "void", this._role = "assertive" !== snackBarConfig.politeness || snackBarConfig.announcementMessage ? "off" === snackBarConfig.politeness ? null : "status" : "alert";
                }
                attachComponentPortal(portal) {
                    return this._assertNotAttached(), this._applySnackBarClasses(), this._portalOutlet.attachComponentPortal(portal);
                }
                attachTemplatePortal(portal) {
                    return this._assertNotAttached(), this._applySnackBarClasses(), this._portalOutlet.attachTemplatePortal(portal);
                }
                onAnimationEnd(event) {
                    const {fromState: fromState, toState: toState} = event;
                    if (("void" === toState && "void" !== fromState || "hidden" === toState) && this._completeExit(), 
                    "visible" === toState) {
                        const onEnter = this._onEnter;
                        this._ngZone.run(() => {
                            onEnter.next(), onEnter.complete();
                        });
                    }
                }
                enter() {
                    this._destroyed || (this._animationState = "visible", this._changeDetectorRef.detectChanges());
                }
                exit() {
                    return this._animationState = "hidden", this._onExit;
                }
                ngOnDestroy() {
                    this._destroyed = !0, this._completeExit();
                }
                _completeExit() {
                    this._ngZone.onMicrotaskEmpty.asObservable().pipe(Object(take.a)(1)).subscribe(() => {
                        this._onExit.next(), this._onExit.complete();
                    });
                }
                _applySnackBarClasses() {
                    const element = this._elementRef.nativeElement, panelClasses = this.snackBarConfig.panelClass;
                    panelClasses && (Array.isArray(panelClasses) ? panelClasses.forEach(cssClass => element.classList.add(cssClass)) : element.classList.add(panelClasses)), 
                    "center" === this.snackBarConfig.horizontalPosition && element.classList.add("mat-snack-bar-center"), 
                    "top" === this.snackBarConfig.verticalPosition && element.classList.add("mat-snack-bar-top");
                }
                _assertNotAttached() {
                    if (this._portalOutlet.hasAttached()) throw Error("Attempting to attach snack bar content after content is already attached");
                }
            }
            return MatSnackBarContainer.ɵfac = function(t) {
                return new (t || MatSnackBarContainer)(core.Pb(core.y), core.Pb(core.k), core.Pb(core.h), core.Pb(MatSnackBarConfig));
            }, MatSnackBarContainer.ɵcmp = core.Jb({
                type: MatSnackBarContainer,
                selectors: [ [ "snack-bar-container" ] ],
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && core.yc(fesm2015_portal.c, !0), 2 & rf && core.qc(_t = core.dc()) && (ctx._portalOutlet = _t.first);
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (core.Bb(2), core.Gb("@state.done", (function($event) {
                        return ctx.onAnimationEnd($event);
                    })), core.Ub(_c1)), 2 & rf && (core.Cb("role", ctx._role), core.Ic("@state", ctx._animationState));
                },
                features: [ core.xb ],
                decls: 1,
                vars: 0,
                consts: [ [ "cdkPortalOutlet", "" ] ],
                template: function(rf, ctx) {
                    1 & rf && core.Cc(0, MatSnackBarContainer_ng_template_0_Template, 0, 0, "ng-template", 0);
                },
                directives: [ fesm2015_portal.c ],
                styles: [ ".mat-snack-bar-container{border-radius:4px;box-sizing:border-box;display:block;margin:24px;max-width:33vw;min-width:344px;padding:14px 16px;min-height:48px;transform-origin:center}@media(-ms-high-contrast: active){.mat-snack-bar-container{border:solid 1px}}.mat-snack-bar-handset{width:100%}.mat-snack-bar-handset .mat-snack-bar-container{margin:8px;max-width:100%;min-width:0;width:100%}/*# sourceMappingURL=snack-bar-container.css.map */\n" ],
                encapsulation: 2,
                data: {
                    animation: [ matSnackBarAnimations.snackBarState ]
                }
            }), MatSnackBarContainer;
        })(), snack_bar_MatSnackBarModule = (() => {
            class MatSnackBarModule {}
            return MatSnackBarModule.ɵmod = core.Nb({
                type: MatSnackBarModule
            }), MatSnackBarModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || MatSnackBarModule);
                },
                imports: [ [ overlay_OverlayModule, fesm2015_portal.h, common.c, fesm2015_button.b, fesm2015_core.b ], fesm2015_core.b ]
            }), MatSnackBarModule;
        })();
        const MAT_SNACK_BAR_DEFAULT_OPTIONS = new core.p("mat-snack-bar-default-options", {
            providedIn: "root",
            factory: function() {
                return new MatSnackBarConfig;
            }
        });
        let snack_bar_MatSnackBar = (() => {
            class MatSnackBar {
                constructor(_overlay, _live, _injector, _breakpointObserver, _parentSnackBar, _defaultConfig) {
                    this._overlay = _overlay, this._live = _live, this._injector = _injector, this._breakpointObserver = _breakpointObserver, 
                    this._parentSnackBar = _parentSnackBar, this._defaultConfig = _defaultConfig, this._snackBarRefAtThisLevel = null;
                }
                get _openedSnackBarRef() {
                    const parent = this._parentSnackBar;
                    return parent ? parent._openedSnackBarRef : this._snackBarRefAtThisLevel;
                }
                set _openedSnackBarRef(value) {
                    this._parentSnackBar ? this._parentSnackBar._openedSnackBarRef = value : this._snackBarRefAtThisLevel = value;
                }
                openFromComponent(component, config) {
                    return this._attach(component, config);
                }
                openFromTemplate(template, config) {
                    return this._attach(template, config);
                }
                open(message, action = "", config) {
                    const _config = Object.assign({}, this._defaultConfig, config);
                    return _config.data = {
                        message: message,
                        action: action
                    }, _config.announcementMessage || (_config.announcementMessage = message), this.openFromComponent(snack_bar_SimpleSnackBar, _config);
                }
                dismiss() {
                    this._openedSnackBarRef && this._openedSnackBarRef.dismiss();
                }
                ngOnDestroy() {
                    this._snackBarRefAtThisLevel && this._snackBarRefAtThisLevel.dismiss();
                }
                _attachSnackBarContainer(overlayRef, config) {
                    const injector = new fesm2015_portal.g(config && config.viewContainerRef && config.viewContainerRef.injector || this._injector, new WeakMap([ [ MatSnackBarConfig, config ] ])), containerPortal = new fesm2015_portal.d(snack_bar_MatSnackBarContainer, config.viewContainerRef, injector), containerRef = overlayRef.attach(containerPortal);
                    return containerRef.instance.snackBarConfig = config, containerRef.instance;
                }
                _attach(content, userConfig) {
                    const config = Object.assign({}, new MatSnackBarConfig, this._defaultConfig, userConfig), overlayRef = this._createOverlay(config), container = this._attachSnackBarContainer(overlayRef, config), snackBarRef = new snack_bar_MatSnackBarRef(container, overlayRef);
                    if (content instanceof core.L) {
                        const portal = new fesm2015_portal.i(content, null, {
                            $implicit: config.data,
                            snackBarRef: snackBarRef
                        });
                        snackBarRef.instance = container.attachTemplatePortal(portal);
                    } else {
                        const injector = this._createInjector(config, snackBarRef), portal = new fesm2015_portal.d(content, void 0, injector), contentRef = container.attachComponentPortal(portal);
                        snackBarRef.instance = contentRef.instance;
                    }
                    return this._breakpointObserver.observe(Breakpoints.HandsetPortrait).pipe(Object(takeUntil.a)(overlayRef.detachments())).subscribe(state => {
                        const classList = overlayRef.overlayElement.classList;
                        state.matches ? classList.add("mat-snack-bar-handset") : classList.remove("mat-snack-bar-handset");
                    }), this._animateSnackBar(snackBarRef, config), this._openedSnackBarRef = snackBarRef, 
                    this._openedSnackBarRef;
                }
                _animateSnackBar(snackBarRef, config) {
                    snackBarRef.afterDismissed().subscribe(() => {
                        this._openedSnackBarRef == snackBarRef && (this._openedSnackBarRef = null), config.announcementMessage && this._live.clear();
                    }), this._openedSnackBarRef ? (this._openedSnackBarRef.afterDismissed().subscribe(() => {
                        snackBarRef.containerInstance.enter();
                    }), this._openedSnackBarRef.dismiss()) : snackBarRef.containerInstance.enter(), 
                    config.duration && config.duration > 0 && snackBarRef.afterOpened().subscribe(() => snackBarRef._dismissAfter(config.duration)), 
                    config.announcementMessage && this._live.announce(config.announcementMessage, config.politeness);
                }
                _createOverlay(config) {
                    const overlayConfig = new OverlayConfig;
                    overlayConfig.direction = config.direction;
                    let positionStrategy = this._overlay.position().global();
                    const isRtl = "rtl" === config.direction, isLeft = "left" === config.horizontalPosition || "start" === config.horizontalPosition && !isRtl || "end" === config.horizontalPosition && isRtl, isRight = !isLeft && "center" !== config.horizontalPosition;
                    return isLeft ? positionStrategy.left("0") : isRight ? positionStrategy.right("0") : positionStrategy.centerHorizontally(), 
                    "top" === config.verticalPosition ? positionStrategy.top("0") : positionStrategy.bottom("0"), 
                    overlayConfig.positionStrategy = positionStrategy, this._overlay.create(overlayConfig);
                }
                _createInjector(config, snackBarRef) {
                    return new fesm2015_portal.g(config && config.viewContainerRef && config.viewContainerRef.injector || this._injector, new WeakMap([ [ snack_bar_MatSnackBarRef, snackBarRef ], [ MAT_SNACK_BAR_DATA, config.data ] ]));
                }
            }
            return MatSnackBar.ɵfac = function(t) {
                return new (t || MatSnackBar)(core.Zb(overlay_Overlay), core.Zb(a11y.f), core.Zb(core.q), core.Zb(layout_BreakpointObserver), core.Zb(MatSnackBar, 12), core.Zb(MAT_SNACK_BAR_DEFAULT_OPTIONS));
            }, MatSnackBar.ɵprov = core.Lb({
                token: MatSnackBar,
                factory: function(t) {
                    return MatSnackBar.ɵfac(t);
                },
                providedIn: snack_bar_MatSnackBarModule
            }), MatSnackBar.ngInjectableDef = Object(core.Lb)({
                factory: function() {
                    return new MatSnackBar(Object(core.Zb)(overlay_Overlay), Object(core.Zb)(a11y.f), Object(core.Zb)(core.n), Object(core.Zb)(layout_BreakpointObserver), Object(core.Zb)(MatSnackBar, 12), Object(core.Zb)(MAT_SNACK_BAR_DEFAULT_OPTIONS));
                },
                token: MatSnackBar,
                providedIn: snack_bar_MatSnackBarModule
            }), MatSnackBar;
        })();
    },
    dth9: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var common = __webpack_require__("ofXK"), fesm2015_http = __webpack_require__("tk/3"), shared_module = __webpack_require__("PCNd"), ReplaySubject = __webpack_require__("jtHE"), combineLatest = __webpack_require__("itXk"), map = __webpack_require__("lJxs"), core = __webpack_require__("fXoL"), Subject = __webpack_require__("XNiG"), takeUntil = __webpack_require__("1G5W"), tap = __webpack_require__("vkgz"), document_service = __webpack_require__("jn67"), logger_service = __webpack_require__("vHPH");
        let api_service_ApiService = (() => {
            class ApiService {
                constructor(http, logger) {
                    this.http = http, this.logger = logger, this.apiBase = document_service.b + "api/", 
                    this.apiListJsonDefault = "api-list.json", this.firstTime = !0, this.onDestroy = new Subject.a, 
                    this.sectionsSubject = new ReplaySubject.a(1), this._sections = this.sectionsSubject.pipe(Object(takeUntil.a)(this.onDestroy));
                }
                get sections() {
                    return this.firstTime && (this.firstTime = !1, this.fetchSections(), this._sections.subscribe(sections => this.logger.log(`ApiService got API ${sections.length} section(s)`))), 
                    this._sections.pipe(Object(tap.a)(sections => {
                        sections.forEach(section => {
                            section.deprecated = !!section.items && section.items.every(item => "deprecated" === item.stability);
                        });
                    }));
                }
                ngOnDestroy() {
                    this.onDestroy.next();
                }
                fetchSections(src) {
                    const url = this.apiBase + (src || this.apiListJsonDefault);
                    this.http.get(url).pipe(Object(takeUntil.a)(this.onDestroy), Object(tap.a)(() => this.logger.log(`Got API sections from ${url}`))).subscribe(sections => this.sectionsSubject.next(sections), err => {
                        throw this.logger.error(err), err;
                    });
                }
            }
            return ApiService.ɵfac = function(t) {
                return new (t || ApiService)(core.Zb(fesm2015_http.a), core.Zb(logger_service.a));
            }, ApiService.ɵprov = core.Lb({
                token: ApiService,
                factory: function(t) {
                    return ApiService.ɵfac(t);
                },
                providedIn: null
            }), ApiService;
        })();
        var location_service = __webpack_require__("/lUL"), select_component = __webpack_require__("x4lQ");
        const _c0 = [ "filter" ];
        function ApiListComponent_div_9_h2_1_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "h2"), core.Vb(1, "a", 11), core.Ec(2), core.Tb(), core.Tb()), 
            2 & rf) {
                const section_r55 = core.gc().$implicit;
                core.Ab(1), core.Fb("deprecated-api-item", section_r55.deprecated), core.lc("href", section_r55.path, core.wc), 
                core.Ab(1), core.Fc(section_r55.title);
            }
        }
        function ApiListComponent_div_9_ul_2_ng_container_1_Template(rf, ctx) {
            if (1 & rf && (core.Sb(0), core.Vb(1, "li", 13), core.Vb(2, "a", 11), core.Qb(3, "span"), 
            core.Ec(4), core.Tb(), core.Tb(), core.Rb()), 2 & rf) {
                const item_r60 = ctx.$implicit;
                core.Ab(2), core.Fb("deprecated-api-item", "deprecated" === item_r60.stability), 
                core.lc("href", item_r60.path, core.wc), core.Ab(1), core.Eb("symbol ", item_r60.docType, ""), 
                core.Ab(1), core.Gc(" ", item_r60.title, " ");
            }
        }
        function ApiListComponent_div_9_ul_2_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "ul", 12), core.Cc(1, ApiListComponent_div_9_ul_2_ng_container_1_Template, 5, 6, "ng-container", 8), 
            core.Tb()), 2 & rf) {
                const section_r55 = core.gc().$implicit;
                core.Ab(1), core.lc("ngForOf", section_r55.items);
            }
        }
        function ApiListComponent_div_9_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "div"), core.Cc(1, ApiListComponent_div_9_h2_1_Template, 3, 3, "h2", 9), 
            core.Cc(2, ApiListComponent_div_9_ul_2_Template, 2, 1, "ul", 10), core.Tb()), 2 & rf) {
                const section_r55 = ctx.$implicit;
                core.Ab(1), core.lc("ngIf", section_r55.items), core.Ab(1), core.lc("ngIf", section_r55.items && section_r55.items.length);
            }
        }
        class SearchCriteria {
            constructor() {
                this.query = "", this.status = "all", this.type = "all";
            }
        }
        let api_list_component_ApiListComponent = (() => {
            class ApiListComponent {
                constructor(apiService, locationService) {
                    this.apiService = apiService, this.locationService = locationService, this.showStatusMenu = !1, 
                    this.showTypeMenu = !1, this.criteriaSubject = new ReplaySubject.a(1), this.searchCriteria = new SearchCriteria, 
                    this.types = [ {
                        value: "all",
                        title: "All"
                    }, {
                        value: "class",
                        title: "Class"
                    }, {
                        value: "const",
                        title: "Const"
                    }, {
                        value: "decorator",
                        title: "Decorator"
                    }, {
                        value: "directive",
                        title: "Directive"
                    }, {
                        value: "enum",
                        title: "Enum"
                    }, {
                        value: "function",
                        title: "Function"
                    }, {
                        value: "interface",
                        title: "Interface"
                    }, {
                        value: "pipe",
                        title: "Pipe"
                    }, {
                        value: "ngmodule",
                        title: "NgModule"
                    }, {
                        value: "type-alias",
                        title: "Type alias"
                    }, {
                        value: "package",
                        title: "Package"
                    } ], this.statuses = [ {
                        value: "all",
                        title: "All"
                    }, {
                        value: "deprecated",
                        title: "Deprecated"
                    }, {
                        value: "security-risk",
                        title: "Security Risk"
                    } ];
                }
                ngOnInit() {
                    this.filteredSections = Object(combineLatest.a)([ this.apiService.sections, this.criteriaSubject ]).pipe(Object(map.a)(results => ({
                        sections: results[0],
                        criteria: results[1]
                    })), Object(map.a)(results => results.sections.map(section => Object.assign(Object.assign({}, section), {
                        items: this.filterSection(section, results.criteria)
                    })))), this.initializeSearchCriteria();
                }
                setQuery(query) {
                    this.setSearchCriteria({
                        query: (query || "").toLowerCase().trim()
                    });
                }
                setStatus(status) {
                    this.toggleStatusMenu(), this.status = status, this.setSearchCriteria({
                        status: status.value
                    });
                }
                setType(type) {
                    this.toggleTypeMenu(), this.type = type, this.setSearchCriteria({
                        type: type.value
                    });
                }
                toggleStatusMenu() {
                    this.showStatusMenu = !this.showStatusMenu;
                }
                toggleTypeMenu() {
                    this.showTypeMenu = !this.showTypeMenu;
                }
                filterSection(section, {query: query, status: status, type: type}) {
                    const sectionNameMatches = !query || -1 !== section.name.indexOf(query), items = section.items.filter(item => (item => "all" === type || type === item.docType)(item) && (item => "all" === status || status === item.stability || "security-risk" === status && item.securityRisk)(item) && (item => sectionNameMatches || -1 !== item.name.indexOf(query))(item));
                    return items.length ? items : sectionNameMatches && "package" === type ? [] : null;
                }
                initializeSearchCriteria() {
                    const {query: query, status: status, type: type} = this.locationService.search(), q = (query || "").toLowerCase();
                    this.queryEl.nativeElement.value = q, this.status = this.statuses.find(x => x.value === status) || this.statuses[0], 
                    this.type = this.types.find(x => x.value === type) || this.types[0], this.searchCriteria = {
                        query: q,
                        status: this.status.value,
                        type: this.type.value
                    }, this.criteriaSubject.next(this.searchCriteria);
                }
                setLocationSearch() {
                    const {query: query, status: status, type: type} = this.searchCriteria;
                    this.locationService.setSearch("API Search", {
                        query: query || void 0,
                        status: "all" !== status ? status : void 0,
                        type: "all" !== type ? type : void 0
                    });
                }
                setSearchCriteria(criteria) {
                    this.criteriaSubject.next(Object.assign(this.searchCriteria, criteria)), this.setLocationSearch();
                }
            }
            return ApiListComponent.ɵfac = function(t) {
                return new (t || ApiListComponent)(core.Pb(api_service_ApiService), core.Pb(location_service.a));
            }, ApiListComponent.ɵcmp = core.Jb({
                type: ApiListComponent,
                selectors: [ [ "aio-api-list" ] ],
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && core.yc(_c0, !0), 2 & rf && core.qc(_t = core.dc()) && (ctx.queryEl = _t.first);
                },
                decls: 11,
                vars: 9,
                consts: [ [ 1, "l-flex-wrap", "api-filter" ], [ "label", "Type:", 3, "options", "selected", "showSymbol", "change" ], [ "label", "Status:", 3, "options", "selected", "disabled", "change" ], [ 1, "form-search" ], [ "placeholder", "Filter", "aria-label", "Filter Search", 3, "input" ], [ "filter", "" ], [ 1, "material-icons" ], [ 1, "api-list-container", "l-content-small", "docs-content" ], [ 4, "ngFor", "ngForOf" ], [ 4, "ngIf" ], [ "class", "api-list", 4, "ngIf" ], [ 3, "href" ], [ 1, "api-list" ], [ 1, "api-item" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.Vb(0, "div", 0), core.Vb(1, "aio-select", 1), core.cc("change", (function($event) {
                        return ctx.setType($event.option);
                    })), core.Tb(), core.Vb(2, "aio-select", 2), core.cc("change", (function($event) {
                        return ctx.setStatus($event.option);
                    })), core.Tb(), core.Vb(3, "div", 3), core.Vb(4, "input", 4, 5), core.cc("input", (function($event) {
                        return ctx.setQuery($event.target.value);
                    })), core.Tb(), core.Vb(6, "i", 6), core.Ec(7, "search"), core.Tb(), core.Tb(), 
                    core.Tb(), core.Vb(8, "article", 7), core.Cc(9, ApiListComponent_div_9_Template, 3, 2, "div", 8), 
                    core.hc(10, "async"), core.Tb()), 2 & rf && (core.Ab(1), core.lc("options", ctx.types)("selected", ctx.type)("showSymbol", !0), 
                    core.Ab(1), core.lc("options", ctx.statuses)("selected", ctx.status)("disabled", "package" === ctx.type.value), 
                    core.Ab(7), core.lc("ngForOf", core.ic(10, 7, ctx.filteredSections)));
                },
                directives: [ select_component.a, common.j, common.k ],
                pipes: [ common.b ],
                encapsulation: 2
            }), ApiListComponent;
        })();
        __webpack_require__.d(__webpack_exports__, "ApiListModule", (function() {
            return api_list_module_ApiListModule;
        }));
        let api_list_module_ApiListModule = (() => {
            class ApiListModule {
                constructor() {
                    this.customElementComponent = api_list_component_ApiListComponent;
                }
            }
            return ApiListModule.ɵmod = core.Nb({
                type: ApiListModule
            }), ApiListModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || ApiListModule);
                },
                providers: [ api_service_ApiService ],
                imports: [ [ common.c, shared_module.a, fesm2015_http.b ] ]
            }), ApiListModule;
        })();
    },
    eIep: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return switchMap;
        }));
        var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("l7GE"), _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("51Dv"), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("ZUHj"), _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("lJxs"), _observable_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("Cfvw");
        function switchMap(project, resultSelector) {
            return "function" == typeof resultSelector ? source => source.pipe(switchMap((a, i) => Object(_observable_from__WEBPACK_IMPORTED_MODULE_4__.a)(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_3__.a)((b, ii) => resultSelector(a, b, i, ii))))) : source => source.lift(new SwitchMapOperator(project));
        }
        class SwitchMapOperator {
            constructor(project) {
                this.project = project;
            }
            call(subscriber, source) {
                return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
            }
        }
        class SwitchMapSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(destination, project) {
                super(destination), this.project = project, this.index = 0;
            }
            _next(value) {
                let result;
                const index = this.index++;
                try {
                    result = this.project(value, index);
                } catch (error) {
                    return void this.destination.error(error);
                }
                this._innerSub(result, value, index);
            }
            _innerSub(result, value, index) {
                const innerSubscription = this.innerSubscription;
                innerSubscription && innerSubscription.unsubscribe();
                const innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__.a(this, void 0, void 0);
                this.destination.add(innerSubscriber), this.innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__.a)(this, result, value, index, innerSubscriber);
            }
            _complete() {
                const {innerSubscription: innerSubscription} = this;
                innerSubscription && !innerSubscription.closed || super._complete(), this.unsubscribe();
            }
            _unsubscribe() {
                this.innerSubscription = null;
            }
            notifyComplete(innerSub) {
                this.destination.remove(innerSub), this.innerSubscription = null, this.isStopped && super._complete();
            }
            notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }
        }
    },
    fPy6: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var common = __webpack_require__("ofXK"), icon = __webpack_require__("NFeN"), core = __webpack_require__("fXoL"), map = __webpack_require__("lJxs"), publishLast = __webpack_require__("qZ0a"), document_service = __webpack_require__("jn67"), http = __webpack_require__("tk/3");
        const contributorsPath = document_service.a + "contributors.json", knownGroups = [ "Angular", "Collaborators", "GDE" ];
        let contributor_service_ContributorService = (() => {
            class ContributorService {
                constructor(http) {
                    this.http = http, this.contributors = this.getContributors();
                }
                getContributors() {
                    const contributors = this.http.get(contributorsPath).pipe(Object(map.a)(contribs => {
                        const contribMap = {};
                        return Object.keys(contribs).forEach(key => {
                            const contributor = contribs[key];
                            contributor.groups.forEach(group => {
                                (contribMap[group] || (contribMap[group] = [])).push(contributor);
                            });
                        }), contribMap;
                    }), Object(map.a)(cmap => Object.keys(cmap).map(key => {
                        const order = knownGroups.indexOf(key);
                        return {
                            name: key,
                            order: -1 === order ? knownGroups.length : order,
                            contributors: cmap[key].sort(compareContributors)
                        };
                    }).sort(compareGroups)), Object(publishLast.a)());
                    return contributors.connect(), contributors;
                }
            }
            return ContributorService.ɵfac = function(t) {
                return new (t || ContributorService)(core.Zb(http.a));
            }, ContributorService.ɵprov = core.Lb({
                token: ContributorService,
                factory: function(t) {
                    return ContributorService.ɵfac(t);
                },
                providedIn: null
            }), ContributorService;
        })();
        function compareContributors(l, r) {
            return l.name.toUpperCase() > r.name.toUpperCase() ? 1 : -1;
        }
        function compareGroups(l, r) {
            return l.order === r.order ? l.name > r.name ? 1 : -1 : l.order > r.order ? 1 : -1;
        }
        var location_service = __webpack_require__("/lUL");
        function ContributorComponent_a_6_Template(rf, ctx) {
            1 & rf && (core.Vb(0, "a", 7), core.Ec(1, " View Bio "), core.Tb());
        }
        function ContributorComponent_a_7_Template(rf, ctx) {
            if (1 & rf) {
                const _r75 = core.Wb();
                core.Vb(0, "a", 8), core.cc("click", (function($event) {
                    return core.uc(_r75), $event.stopPropagation();
                })), core.Qb(1, "mat-icon", 9), core.Tb();
            }
            if (2 & rf) {
                const ctx_r71 = core.gc();
                core.nc("href", "https://twitter.com/", ctx_r71.person.twitter, "", core.wc);
            }
        }
        function ContributorComponent_a_8_Template(rf, ctx) {
            if (1 & rf) {
                const _r77 = core.Wb();
                core.Vb(0, "a", 8), core.cc("click", (function($event) {
                    return core.uc(_r77), $event.stopPropagation();
                })), core.Vb(1, "mat-icon", 10), core.Ec(2, "link"), core.Tb(), core.Tb();
            }
            if (2 & rf) {
                const ctx_r72 = core.gc();
                core.mc("href", ctx_r72.person.website, core.wc);
            }
        }
        function ContributorComponent_div_9_Template(rf, ctx) {
            if (1 & rf) {
                const _r79 = core.Wb();
                core.Vb(0, "div", 11), core.cc("click", (function($event) {
                    core.uc(_r79);
                    const ctx_r78 = core.gc();
                    return ctx_r78.flipCard(ctx_r78.person);
                })), core.cc("keyup.enter", (function($event) {
                    core.uc(_r79);
                    const ctx_r80 = core.gc();
                    return ctx_r80.flipCard(ctx_r80.person);
                })), core.Vb(1, "h3"), core.Ec(2), core.Tb(), core.Vb(3, "p", 12), core.Ec(4), core.Tb(), 
                core.Tb();
            }
            if (2 & rf) {
                const ctx_r73 = core.gc();
                core.Ab(2), core.Fc(ctx_r73.person.name), core.Ab(2), core.Fc(ctx_r73.person.bio);
            }
        }
        const _c0 = function(a0) {
            return {
                flipped: a0
            };
        };
        let contributor_component_ContributorComponent = (() => {
            class ContributorComponent {
                constructor() {
                    this.noPicture = "_no-one.png", this.pictureBase = document_service.a + "images/bios/";
                }
                flipCard(person) {
                    person.isFlipped = !person.isFlipped;
                }
            }
            return ContributorComponent.ɵfac = function(t) {
                return new (t || ContributorComponent);
            }, ContributorComponent.ɵcmp = core.Jb({
                type: ContributorComponent,
                selectors: [ [ "aio-contributor" ] ],
                inputs: {
                    person: "person"
                },
                decls: 10,
                vars: 9,
                consts: [ [ 1, "contributor-card", 3, "ngClass" ], [ 1, "card-front", 3, "click", "keyup.enter" ], [ 1, "contributor-image" ], [ 1, "contributor-info" ], [ "mat-button", "", "class", "info-item", 4, "ngIf" ], [ "mat-icon-button", "", "class", "info-item icon", "target", "_blank", 3, "href", "click", 4, "ngIf" ], [ "class", "card-back", 3, "click", "keyup.enter", 4, "ngIf" ], [ "mat-button", "", 1, "info-item" ], [ "mat-icon-button", "", "target", "_blank", 1, "info-item", "icon", 3, "href", "click" ], [ "svgIcon", "logos:twitter" ], [ 1, "link-icon" ], [ 1, "card-back", 3, "click", "keyup.enter" ], [ 1, "contributor-bio" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.Vb(0, "div", 0), core.Vb(1, "div", 1), core.cc("click", (function($event) {
                        return ctx.flipCard(ctx.person);
                    })), core.cc("keyup.enter", (function($event) {
                        return ctx.flipCard(ctx.person);
                    })), core.Vb(2, "h3"), core.Ec(3), core.Tb(), core.Vb(4, "div", 2), core.Vb(5, "div", 3), 
                    core.Cc(6, ContributorComponent_a_6_Template, 2, 0, "a", 4), core.Cc(7, ContributorComponent_a_7_Template, 2, 1, "a", 5), 
                    core.Cc(8, ContributorComponent_a_8_Template, 3, 1, "a", 5), core.Tb(), core.Tb(), 
                    core.Tb(), core.Cc(9, ContributorComponent_div_9_Template, 5, 2, "div", 6), core.Tb()), 
                    2 & rf && (core.lc("ngClass", core.oc(7, _c0, ctx.person.isFlipped)), core.Ab(3), 
                    core.Fc(ctx.person.name), core.Ab(1), core.Bc(core.Ib), core.Ac("background-image", "url(" + ctx.pictureBase + (ctx.person.picture || ctx.noPicture) + ")"), 
                    core.Ab(2), core.lc("ngIf", ctx.person.bio), core.Ab(1), core.lc("ngIf", ctx.person.twitter), 
                    core.Ab(1), core.lc("ngIf", ctx.person.website), core.Ab(1), core.lc("ngIf", ctx.person.isFlipped));
                },
                directives: [ common.i, common.k, icon.a ],
                encapsulation: 2
            }), ContributorComponent;
        })();
        function ContributorListComponent_a_1_Template(rf, ctx) {
            if (1 & rf) {
                const _r66 = core.Wb();
                core.Vb(0, "a", 3), core.cc("click", (function($event) {
                    core.uc(_r66);
                    const name_r64 = ctx.$implicit;
                    return core.gc().selectGroup(name_r64);
                })), core.cc("keyup.enter", (function($event) {
                    core.uc(_r66);
                    const name_r64 = ctx.$implicit;
                    return core.gc().selectGroup(name_r64);
                })), core.Ec(1), core.Tb();
            }
            if (2 & rf) {
                const name_r64 = ctx.$implicit, ctx_r62 = core.gc();
                core.Fb("selected", name_r64 == ctx_r62.selectedGroup.name), core.Ab(1), core.Fc(name_r64);
            }
        }
        function ContributorListComponent_section_2_aio_contributor_2_Template(rf, ctx) {
            1 & rf && core.Qb(0, "aio-contributor", 7), 2 & rf && core.lc("person", ctx.$implicit);
        }
        function ContributorListComponent_section_2_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "section", 4), core.Vb(1, "div", 5), core.Cc(2, ContributorListComponent_section_2_aio_contributor_2_Template, 1, 1, "aio-contributor", 6), 
            core.Tb(), core.Tb()), 2 & rf) {
                const ctx_r63 = core.gc();
                core.Ab(2), core.lc("ngForOf", ctx_r63.selectedGroup.contributors);
            }
        }
        let contributor_list_component_ContributorListComponent = (() => {
            class ContributorListComponent {
                constructor(contributorService, locationService) {
                    this.contributorService = contributorService, this.locationService = locationService;
                }
                ngOnInit() {
                    const groupName = this.locationService.search().group || "";
                    this.contributorService.contributors.subscribe(grps => {
                        this.groups = grps, this.groupNames = grps.map(g => g.name), this.selectGroup(groupName);
                    });
                }
                selectGroup(name) {
                    name = name.toLowerCase(), this.selectedGroup = this.groups.find(g => g.name.toLowerCase() === name) || this.groups[0], 
                    this.locationService.setSearch("", {
                        group: this.selectedGroup.name
                    });
                }
            }
            return ContributorListComponent.ɵfac = function(t) {
                return new (t || ContributorListComponent)(core.Pb(contributor_service_ContributorService), core.Pb(location_service.a));
            }, ContributorListComponent.ɵcmp = core.Jb({
                type: ContributorListComponent,
                selectors: [ [ "aio-contributor-list" ] ],
                decls: 3,
                vars: 2,
                consts: [ [ 1, "flex-center", "group-buttons" ], [ "class", "button mat-button filter-button", 3, "selected", "click", "keyup.enter", 4, "ngFor", "ngForOf" ], [ "class", "grid-fluid", 4, "ngIf" ], [ 1, "button", "mat-button", "filter-button", 3, "click", "keyup.enter" ], [ 1, "grid-fluid" ], [ 1, "contributor-group" ], [ 3, "person", 4, "ngFor", "ngForOf" ], [ 3, "person" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.Vb(0, "div", 0), core.Cc(1, ContributorListComponent_a_1_Template, 2, 2, "a", 1), 
                    core.Tb(), core.Cc(2, ContributorListComponent_section_2_Template, 3, 1, "section", 2)), 
                    2 & rf && (core.Ab(1), core.lc("ngForOf", ctx.groupNames), core.Ab(1), core.lc("ngIf", ctx.selectedGroup));
                },
                directives: [ common.j, common.k, contributor_component_ContributorComponent ],
                encapsulation: 2
            }), ContributorListComponent;
        })();
        __webpack_require__.d(__webpack_exports__, "ContributorListModule", (function() {
            return contributor_list_module_ContributorListModule;
        }));
        let contributor_list_module_ContributorListModule = (() => {
            class ContributorListModule {
                constructor() {
                    this.customElementComponent = contributor_list_component_ContributorListComponent;
                }
            }
            return ContributorListModule.ɵmod = core.Nb({
                type: ContributorListModule
            }), ContributorListModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || ContributorListModule);
                },
                providers: [ contributor_service_ContributorService ],
                imports: [ [ common.c, icon.b ] ]
            }), ContributorListModule;
        })();
    },
    fXoL: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return ANALYZE_FOR_ENTRY_COMPONENTS;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return APP_BOOTSTRAP_LISTENER;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return APP_ID;
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return APP_INITIALIZER;
        })), __webpack_require__.d(__webpack_exports__, "e", (function() {
            return ApplicationInitStatus;
        })), __webpack_require__.d(__webpack_exports__, "f", (function() {
            return ApplicationModule;
        })), __webpack_require__.d(__webpack_exports__, "g", (function() {
            return ApplicationRef;
        })), __webpack_require__.d(__webpack_exports__, "h", (function() {
            return ChangeDetectorRef;
        })), __webpack_require__.d(__webpack_exports__, "i", (function() {
            return Compiler;
        })), __webpack_require__.d(__webpack_exports__, "j", (function() {
            return ComponentFactoryResolver;
        })), __webpack_require__.d(__webpack_exports__, "k", (function() {
            return ElementRef;
        })), __webpack_require__.d(__webpack_exports__, "l", (function() {
            return ErrorHandler;
        })), __webpack_require__.d(__webpack_exports__, "m", (function() {
            return EventEmitter;
        })), __webpack_require__.d(__webpack_exports__, "n", (function() {
            return INJECTOR;
        })), __webpack_require__.d(__webpack_exports__, "o", (function() {
            return Inject;
        })), __webpack_require__.d(__webpack_exports__, "p", (function() {
            return InjectionToken;
        })), __webpack_require__.d(__webpack_exports__, "q", (function() {
            return Injector;
        })), __webpack_require__.d(__webpack_exports__, "r", (function() {
            return IterableDiffers;
        })), __webpack_require__.d(__webpack_exports__, "s", (function() {
            return KeyValueDiffers;
        })), __webpack_require__.d(__webpack_exports__, "t", (function() {
            return LOCALE_ID$1;
        })), __webpack_require__.d(__webpack_exports__, "u", (function() {
            return NgModuleFactory;
        })), __webpack_require__.d(__webpack_exports__, "v", (function() {
            return NgModuleFactoryLoader;
        })), __webpack_require__.d(__webpack_exports__, "w", (function() {
            return NgModuleRef;
        })), __webpack_require__.d(__webpack_exports__, "x", (function() {
            return NgProbeToken;
        })), __webpack_require__.d(__webpack_exports__, "y", (function() {
            return NgZone;
        })), __webpack_require__.d(__webpack_exports__, "z", (function() {
            return Optional;
        })), __webpack_require__.d(__webpack_exports__, "A", (function() {
            return PLATFORM_ID;
        })), __webpack_require__.d(__webpack_exports__, "B", (function() {
            return PLATFORM_INITIALIZER;
        })), __webpack_require__.d(__webpack_exports__, "C", (function() {
            return QueryList;
        })), __webpack_require__.d(__webpack_exports__, "D", (function() {
            return Renderer2;
        })), __webpack_require__.d(__webpack_exports__, "E", (function() {
            return RendererFactory2;
        })), __webpack_require__.d(__webpack_exports__, "F", (function() {
            return RendererStyleFlags2;
        })), __webpack_require__.d(__webpack_exports__, "G", (function() {
            return Sanitizer;
        })), __webpack_require__.d(__webpack_exports__, "H", (function() {
            return SecurityContext;
        })), __webpack_require__.d(__webpack_exports__, "I", (function() {
            return SimpleChange;
        })), __webpack_require__.d(__webpack_exports__, "J", (function() {
            return SkipSelf;
        })), __webpack_require__.d(__webpack_exports__, "K", (function() {
            return SystemJsNgModuleLoader;
        })), __webpack_require__.d(__webpack_exports__, "L", (function() {
            return TemplateRef;
        })), __webpack_require__.d(__webpack_exports__, "M", (function() {
            return Testability;
        })), __webpack_require__.d(__webpack_exports__, "N", (function() {
            return Version;
        })), __webpack_require__.d(__webpack_exports__, "O", (function() {
            return ViewContainerRef;
        })), __webpack_require__.d(__webpack_exports__, "P", (function() {
            return ViewEncapsulation$1;
        })), __webpack_require__.d(__webpack_exports__, "Q", (function() {
            return WrappedValue;
        })), __webpack_require__.d(__webpack_exports__, "R", (function() {
            return createPlatformFactory;
        })), __webpack_require__.d(__webpack_exports__, "S", (function() {
            return enableProdMode;
        })), __webpack_require__.d(__webpack_exports__, "T", (function() {
            return forwardRef;
        })), __webpack_require__.d(__webpack_exports__, "U", (function() {
            return getDebugNode$1;
        })), __webpack_require__.d(__webpack_exports__, "V", (function() {
            return inject;
        })), __webpack_require__.d(__webpack_exports__, "W", (function() {
            return isDevMode;
        })), __webpack_require__.d(__webpack_exports__, "X", (function() {
            return platformCore;
        })), __webpack_require__.d(__webpack_exports__, "Y", (function() {
            return setTestabilityGetter;
        })), __webpack_require__.d(__webpack_exports__, "Z", (function() {
            return Console;
        })), __webpack_require__.d(__webpack_exports__, "ab", (function() {
            return INJECTOR_SCOPE;
        })), __webpack_require__.d(__webpack_exports__, "bb", (function() {
            return LocaleDataIndex;
        })), __webpack_require__.d(__webpack_exports__, "cb", (function() {
            return _sanitizeHtml;
        })), __webpack_require__.d(__webpack_exports__, "db", (function() {
            return _sanitizeStyle;
        })), __webpack_require__.d(__webpack_exports__, "eb", (function() {
            return _sanitizeUrl;
        })), __webpack_require__.d(__webpack_exports__, "fb", (function() {
            return allowSanitizationBypassAndThrow;
        })), __webpack_require__.d(__webpack_exports__, "gb", (function() {
            return bypassSanitizationTrustHtml;
        })), __webpack_require__.d(__webpack_exports__, "hb", (function() {
            return bypassSanitizationTrustResourceUrl;
        })), __webpack_require__.d(__webpack_exports__, "ib", (function() {
            return bypassSanitizationTrustScript;
        })), __webpack_require__.d(__webpack_exports__, "jb", (function() {
            return bypassSanitizationTrustStyle;
        })), __webpack_require__.d(__webpack_exports__, "kb", (function() {
            return bypassSanitizationTrustUrl;
        })), __webpack_require__.d(__webpack_exports__, "lb", (function() {
            return findLocaleData;
        })), __webpack_require__.d(__webpack_exports__, "mb", (function() {
            return getLocalePluralCase;
        })), __webpack_require__.d(__webpack_exports__, "nb", (function() {
            return getSanitizationBypassType;
        })), __webpack_require__.d(__webpack_exports__, "ob", (function() {
            return _global;
        })), __webpack_require__.d(__webpack_exports__, "pb", (function() {
            return isListLikeIterable$1;
        })), __webpack_require__.d(__webpack_exports__, "qb", (function() {
            return isObservable;
        })), __webpack_require__.d(__webpack_exports__, "rb", (function() {
            return isPromise;
        })), __webpack_require__.d(__webpack_exports__, "sb", (function() {
            return looseIdentical;
        })), __webpack_require__.d(__webpack_exports__, "tb", (function() {
            return registerLocaleData;
        })), __webpack_require__.d(__webpack_exports__, "ub", (function() {
            return setDocument;
        })), __webpack_require__.d(__webpack_exports__, "vb", (function() {
            return stringify;
        })), __webpack_require__.d(__webpack_exports__, "wb", (function() {
            return unwrapSafeValue;
        })), __webpack_require__.d(__webpack_exports__, "xb", (function() {
            return ɵɵInheritDefinitionFeature;
        })), __webpack_require__.d(__webpack_exports__, "yb", (function() {
            return ɵɵNgOnChangesFeature;
        })), __webpack_require__.d(__webpack_exports__, "zb", (function() {
            return ɵɵProvidersFeature;
        })), __webpack_require__.d(__webpack_exports__, "Ab", (function() {
            return ɵɵadvance;
        })), __webpack_require__.d(__webpack_exports__, "Bb", (function() {
            return ɵɵallocHostVars;
        })), __webpack_require__.d(__webpack_exports__, "Cb", (function() {
            return ɵɵattribute;
        })), __webpack_require__.d(__webpack_exports__, "Db", (function() {
            return ɵɵclassMap;
        })), __webpack_require__.d(__webpack_exports__, "Eb", (function() {
            return ɵɵclassMapInterpolate1;
        })), __webpack_require__.d(__webpack_exports__, "Fb", (function() {
            return ɵɵclassProp;
        })), __webpack_require__.d(__webpack_exports__, "Gb", (function() {
            return ɵɵcomponentHostSyntheticListener;
        })), __webpack_require__.d(__webpack_exports__, "Hb", (function() {
            return ɵɵcontentQuery;
        })), __webpack_require__.d(__webpack_exports__, "Ib", (function() {
            return ɵɵdefaultStyleSanitizer;
        })), __webpack_require__.d(__webpack_exports__, "Jb", (function() {
            return ɵɵdefineComponent;
        })), __webpack_require__.d(__webpack_exports__, "Kb", (function() {
            return ɵɵdefineDirective;
        })), __webpack_require__.d(__webpack_exports__, "Lb", (function() {
            return ɵɵdefineInjectable;
        })), __webpack_require__.d(__webpack_exports__, "Mb", (function() {
            return ɵɵdefineInjector;
        })), __webpack_require__.d(__webpack_exports__, "Nb", (function() {
            return ɵɵdefineNgModule;
        })), __webpack_require__.d(__webpack_exports__, "Ob", (function() {
            return ɵɵdefinePipe;
        })), __webpack_require__.d(__webpack_exports__, "Pb", (function() {
            return ɵɵdirectiveInject;
        })), __webpack_require__.d(__webpack_exports__, "Qb", (function() {
            return ɵɵelement;
        })), __webpack_require__.d(__webpack_exports__, "Rb", (function() {
            return ɵɵelementContainerEnd;
        })), __webpack_require__.d(__webpack_exports__, "Sb", (function() {
            return ɵɵelementContainerStart;
        })), __webpack_require__.d(__webpack_exports__, "Tb", (function() {
            return ɵɵelementEnd;
        })), __webpack_require__.d(__webpack_exports__, "Ub", (function() {
            return ɵɵelementHostAttrs;
        })), __webpack_require__.d(__webpack_exports__, "Vb", (function() {
            return ɵɵelementStart;
        })), __webpack_require__.d(__webpack_exports__, "Wb", (function() {
            return ɵɵgetCurrentView;
        })), __webpack_require__.d(__webpack_exports__, "Xb", (function() {
            return ɵɵgetInheritedFactory;
        })), __webpack_require__.d(__webpack_exports__, "Yb", (function() {
            return ɵɵhostProperty;
        })), __webpack_require__.d(__webpack_exports__, "Zb", (function() {
            return ɵɵinject;
        })), __webpack_require__.d(__webpack_exports__, "ac", (function() {
            return ɵɵinjectAttribute;
        })), __webpack_require__.d(__webpack_exports__, "bc", (function() {
            return ɵɵinvalidFactory;
        })), __webpack_require__.d(__webpack_exports__, "cc", (function() {
            return ɵɵlistener;
        })), __webpack_require__.d(__webpack_exports__, "dc", (function() {
            return ɵɵloadQuery;
        })), __webpack_require__.d(__webpack_exports__, "ec", (function() {
            return ɵɵnamespaceHTML;
        })), __webpack_require__.d(__webpack_exports__, "fc", (function() {
            return ɵɵnamespaceSVG;
        })), __webpack_require__.d(__webpack_exports__, "gc", (function() {
            return ɵɵnextContext;
        })), __webpack_require__.d(__webpack_exports__, "hc", (function() {
            return ɵɵpipe;
        })), __webpack_require__.d(__webpack_exports__, "ic", (function() {
            return ɵɵpipeBind1;
        })), __webpack_require__.d(__webpack_exports__, "jc", (function() {
            return ɵɵprojection;
        })), __webpack_require__.d(__webpack_exports__, "kc", (function() {
            return ɵɵprojectionDef;
        })), __webpack_require__.d(__webpack_exports__, "lc", (function() {
            return ɵɵproperty;
        })), __webpack_require__.d(__webpack_exports__, "mc", (function() {
            return ɵɵpropertyInterpolate;
        })), __webpack_require__.d(__webpack_exports__, "nc", (function() {
            return ɵɵpropertyInterpolate1;
        })), __webpack_require__.d(__webpack_exports__, "oc", (function() {
            return ɵɵpureFunction1;
        })), __webpack_require__.d(__webpack_exports__, "pc", (function() {
            return ɵɵpureFunction2;
        })), __webpack_require__.d(__webpack_exports__, "qc", (function() {
            return ɵɵqueryRefresh;
        })), __webpack_require__.d(__webpack_exports__, "rc", (function() {
            return ɵɵreference;
        })), __webpack_require__.d(__webpack_exports__, "sc", (function() {
            return ɵɵresolveDocument;
        })), __webpack_require__.d(__webpack_exports__, "tc", (function() {
            return ɵɵresolveWindow;
        })), __webpack_require__.d(__webpack_exports__, "uc", (function() {
            return ɵɵrestoreView;
        })), __webpack_require__.d(__webpack_exports__, "vc", (function() {
            return ɵɵsanitizeHtml;
        })), __webpack_require__.d(__webpack_exports__, "wc", (function() {
            return ɵɵsanitizeUrl;
        })), __webpack_require__.d(__webpack_exports__, "xc", (function() {
            return ɵɵstaticContentQuery;
        })), __webpack_require__.d(__webpack_exports__, "yc", (function() {
            return ɵɵstaticViewQuery;
        })), __webpack_require__.d(__webpack_exports__, "zc", (function() {
            return ɵɵstyleMap;
        })), __webpack_require__.d(__webpack_exports__, "Ac", (function() {
            return ɵɵstyleProp;
        })), __webpack_require__.d(__webpack_exports__, "Bc", (function() {
            return ɵɵstyleSanitizer;
        })), __webpack_require__.d(__webpack_exports__, "Cc", (function() {
            return ɵɵtemplate;
        })), __webpack_require__.d(__webpack_exports__, "Dc", (function() {
            return ɵɵtemplateRefExtractor;
        })), __webpack_require__.d(__webpack_exports__, "Ec", (function() {
            return ɵɵtext;
        })), __webpack_require__.d(__webpack_exports__, "Fc", (function() {
            return ɵɵtextInterpolate;
        })), __webpack_require__.d(__webpack_exports__, "Gc", (function() {
            return ɵɵtextInterpolate1;
        })), __webpack_require__.d(__webpack_exports__, "Hc", (function() {
            return ɵɵtextInterpolate2;
        })), __webpack_require__.d(__webpack_exports__, "Ic", (function() {
            return ɵɵupdateSyntheticHostBinding;
        })), __webpack_require__.d(__webpack_exports__, "Jc", (function() {
            return ɵɵviewQuery;
        }));
        var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("XNiG"), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("quSY"), rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("HDdC"), rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("VRyK"), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("w1tV");
        const PARAMETERS = "__parameters__";
        function makeParamDecorator(name, props, parentClass) {
            const metaCtor = function(props) {
                return function(...args) {
                    if (props) {
                        const values = props(...args);
                        for (const propName in values) this[propName] = values[propName];
                    }
                };
            }(props);
            function ParamDecoratorFactory(...args) {
                if (this instanceof ParamDecoratorFactory) return metaCtor.apply(this, args), this;
                const annotationInstance = new ParamDecoratorFactory(...args);
                return ParamDecorator.annotation = annotationInstance, ParamDecorator;
                function ParamDecorator(cls, unusedKey, index) {
                    const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, {
                        value: []
                    })[PARAMETERS];
                    for (;parameters.length <= index; ) parameters.push(null);
                    return (parameters[index] = parameters[index] || []).push(annotationInstance), cls;
                }
            }
            return parentClass && (ParamDecoratorFactory.prototype = Object.create(parentClass.prototype)), 
            ParamDecoratorFactory.prototype.ngMetadataName = name, ParamDecoratorFactory.annotationCls = ParamDecoratorFactory, 
            ParamDecoratorFactory;
        }
        const Inject = makeParamDecorator("Inject", token => ({
            token: token
        })), Optional = makeParamDecorator("Optional"), Self = makeParamDecorator("Self"), SkipSelf = makeParamDecorator("SkipSelf");
        var InjectFlags = function(InjectFlags) {
            return InjectFlags[InjectFlags.Default = 0] = "Default", InjectFlags[InjectFlags.Host = 1] = "Host", 
            InjectFlags[InjectFlags.Self = 2] = "Self", InjectFlags[InjectFlags.SkipSelf = 4] = "SkipSelf", 
            InjectFlags[InjectFlags.Optional = 8] = "Optional", InjectFlags;
        }({});
        function getClosureSafeProperty(objWithPropertyToExtract) {
            for (let key in objWithPropertyToExtract) if (objWithPropertyToExtract[key] === getClosureSafeProperty) return key;
            throw Error("Could not find renamed property on target object.");
        }
        function fillProperties(target, source) {
            for (const key in source) source.hasOwnProperty(key) && !target.hasOwnProperty(key) && (target[key] = source[key]);
        }
        function ɵɵdefineInjectable(opts) {
            return {
                token: opts.token,
                providedIn: opts.providedIn || null,
                factory: opts.factory,
                value: void 0
            };
        }
        function ɵɵdefineInjector(options) {
            return {
                factory: options.factory,
                providers: options.providers || [],
                imports: options.imports || []
            };
        }
        function getInjectableDef(type) {
            return getOwnDefinition(type, type[NG_PROV_DEF]) || getOwnDefinition(type, type[NG_INJECTABLE_DEF]);
        }
        function getOwnDefinition(type, def) {
            return def && def.token === type ? def : null;
        }
        function getInjectorDef(type) {
            return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ? type[NG_INJ_DEF] : null;
        }
        const NG_PROV_DEF = getClosureSafeProperty({
            "ɵprov": getClosureSafeProperty
        }), NG_INJ_DEF = getClosureSafeProperty({
            "ɵinj": getClosureSafeProperty
        }), NG_INJECTABLE_DEF = getClosureSafeProperty({
            ngInjectableDef: getClosureSafeProperty
        }), NG_INJECTOR_DEF = getClosureSafeProperty({
            ngInjectorDef: getClosureSafeProperty
        });
        function stringify(token) {
            if ("string" == typeof token) return token;
            if (Array.isArray(token)) return "[" + token.map(stringify).join(", ") + "]";
            if (null == token) return "" + token;
            if (token.overriddenName) return `${token.overriddenName}`;
            if (token.name) return `${token.name}`;
            const res = token.toString();
            if (null == res) return "" + res;
            const newLineIndex = res.indexOf("\n");
            return -1 === newLineIndex ? res : res.substring(0, newLineIndex);
        }
        const __forward_ref__ = getClosureSafeProperty({
            __forward_ref__: getClosureSafeProperty
        });
        function forwardRef(forwardRefFn) {
            return forwardRefFn.__forward_ref__ = forwardRef, forwardRefFn.toString = function() {
                return stringify(this());
            }, forwardRefFn;
        }
        function resolveForwardRef(type) {
            return isForwardRef(type) ? type() : type;
        }
        function isForwardRef(fn) {
            return "function" == typeof fn && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;
        }
        const __globalThis = "undefined" != typeof globalThis && globalThis, __window = "undefined" != typeof window && window, __self = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, __global = "undefined" != typeof global && global, _global = __globalThis || __global || __window || __self, NG_COMP_DEF = getClosureSafeProperty({
            "ɵcmp": getClosureSafeProperty
        }), NG_DIR_DEF = getClosureSafeProperty({
            "ɵdir": getClosureSafeProperty
        }), NG_PIPE_DEF = getClosureSafeProperty({
            "ɵpipe": getClosureSafeProperty
        }), NG_MOD_DEF = getClosureSafeProperty({
            "ɵmod": getClosureSafeProperty
        }), NG_LOC_ID_DEF = getClosureSafeProperty({
            "ɵloc": getClosureSafeProperty
        }), NG_FACTORY_DEF = getClosureSafeProperty({
            "ɵfac": getClosureSafeProperty
        }), NG_ELEMENT_ID = getClosureSafeProperty({
            __NG_ELEMENT_ID__: getClosureSafeProperty
        });
        class InjectionToken {
            constructor(_desc, options) {
                this._desc = _desc, this.ngMetadataName = "InjectionToken", this.ɵprov = void 0, 
                "number" == typeof options ? this.__NG_ELEMENT_ID__ = options : void 0 !== options && (this.ɵprov = ɵɵdefineInjectable({
                    token: this,
                    providedIn: options.providedIn || "root",
                    factory: options.factory
                }));
            }
            toString() {
                return `InjectionToken ${this._desc}`;
            }
        }
        const INJECTOR = new InjectionToken("INJECTOR", -1), THROW_IF_NOT_FOUND = new Object, NG_TEMP_TOKEN_PATH = "ngTempTokenPath", NG_TOKEN_PATH = "ngTokenPath", NEW_LINE = /\n/gm, NO_NEW_LINE = "ɵ", SOURCE = "__source", USE_VALUE = getClosureSafeProperty({
            provide: String,
            useValue: getClosureSafeProperty
        });
        let _injectImplementation, _currentInjector = void 0;
        function setCurrentInjector(injector) {
            const former = _currentInjector;
            return _currentInjector = injector, former;
        }
        function setInjectImplementation(impl) {
            const previous = _injectImplementation;
            return _injectImplementation = impl, previous;
        }
        function injectInjectorOnly(token, flags = InjectFlags.Default) {
            if (void 0 === _currentInjector) throw new Error("inject() must be called from an injection context");
            return null === _currentInjector ? injectRootLimpMode(token, void 0, flags) : _currentInjector.get(token, flags & InjectFlags.Optional ? null : void 0, flags);
        }
        function ɵɵinject(token, flags = InjectFlags.Default) {
            return (_injectImplementation || injectInjectorOnly)(resolveForwardRef(token), flags);
        }
        const inject = ɵɵinject;
        function injectRootLimpMode(token, notFoundValue, flags) {
            const injectableDef = getInjectableDef(token);
            if (injectableDef && "root" == injectableDef.providedIn) return void 0 === injectableDef.value ? injectableDef.value = injectableDef.factory() : injectableDef.value;
            if (flags & InjectFlags.Optional) return null;
            if (void 0 !== notFoundValue) return notFoundValue;
            throw new Error(`Injector: NOT_FOUND [${stringify(token)}]`);
        }
        function injectArgs(types) {
            const args = [];
            for (let i = 0; i < types.length; i++) {
                const arg = resolveForwardRef(types[i]);
                if (Array.isArray(arg)) {
                    if (0 === arg.length) throw new Error("Arguments array must have arguments.");
                    let type = void 0, flags = InjectFlags.Default;
                    for (let j = 0; j < arg.length; j++) {
                        const meta = arg[j];
                        meta instanceof Optional || "Optional" === meta.ngMetadataName || meta === Optional ? flags |= InjectFlags.Optional : meta instanceof SkipSelf || "SkipSelf" === meta.ngMetadataName || meta === SkipSelf ? flags |= InjectFlags.SkipSelf : meta instanceof Self || "Self" === meta.ngMetadataName || meta === Self ? flags |= InjectFlags.Self : type = meta instanceof Inject || meta === Inject ? meta.token : meta;
                    }
                    args.push(ɵɵinject(type, flags));
                } else args.push(ɵɵinject(arg));
            }
            return args;
        }
        class NullInjector {
            get(token, notFoundValue = THROW_IF_NOT_FOUND) {
                if (notFoundValue === THROW_IF_NOT_FOUND) {
                    const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);
                    throw error.name = "NullInjectorError", error;
                }
                return notFoundValue;
            }
        }
        class NgModuleRef {}
        class NgModuleFactory {}
        function deepForEach(input, fn) {
            input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));
        }
        function addToArray(arr, index, value) {
            index >= arr.length ? arr.push(value) : arr.splice(index, 0, value);
        }
        function removeFromArray(arr, index) {
            return index >= arr.length - 1 ? arr.pop() : arr.splice(index, 1)[0];
        }
        function newArray(size, value) {
            const list = [];
            for (let i = 0; i < size; i++) list.push(value);
            return list;
        }
        const ChangeDetectionStrategy = function() {
            var ChangeDetectionStrategy = {
                OnPush: 0,
                Default: 1
            };
            return ChangeDetectionStrategy[ChangeDetectionStrategy.OnPush] = "OnPush", ChangeDetectionStrategy[ChangeDetectionStrategy.Default] = "Default", 
            ChangeDetectionStrategy;
        }(), ViewEncapsulation$1 = function() {
            var ViewEncapsulation$1 = {
                Emulated: 0,
                Native: 1,
                None: 2,
                ShadowDom: 3
            };
            return ViewEncapsulation$1[ViewEncapsulation$1.Emulated] = "Emulated", ViewEncapsulation$1[ViewEncapsulation$1.Native] = "Native", 
            ViewEncapsulation$1[ViewEncapsulation$1.None] = "None", ViewEncapsulation$1[ViewEncapsulation$1.ShadowDom] = "ShadowDom", 
            ViewEncapsulation$1;
        }();
        function noSideEffects(fn) {
            return "" + {
                toString: fn
            };
        }
        const EMPTY_OBJ = {}, EMPTY_ARRAY = [];
        let _renderCompCount = 0;
        function ɵɵdefineComponent(componentDefinition) {
            const type = componentDefinition.type, typePrototype = type.prototype, declaredInputs = {}, def = {
                type: type,
                providersResolver: null,
                decls: componentDefinition.decls,
                vars: componentDefinition.vars,
                factory: null,
                template: componentDefinition.template || null,
                consts: componentDefinition.consts || null,
                ngContentSelectors: componentDefinition.ngContentSelectors,
                hostBindings: componentDefinition.hostBindings || null,
                contentQueries: componentDefinition.contentQueries || null,
                declaredInputs: declaredInputs,
                inputs: null,
                outputs: null,
                exportAs: componentDefinition.exportAs || null,
                onChanges: null,
                onInit: typePrototype.ngOnInit || null,
                doCheck: typePrototype.ngDoCheck || null,
                afterContentInit: typePrototype.ngAfterContentInit || null,
                afterContentChecked: typePrototype.ngAfterContentChecked || null,
                afterViewInit: typePrototype.ngAfterViewInit || null,
                afterViewChecked: typePrototype.ngAfterViewChecked || null,
                onDestroy: typePrototype.ngOnDestroy || null,
                onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
                directiveDefs: null,
                pipeDefs: null,
                selectors: componentDefinition.selectors || EMPTY_ARRAY,
                viewQuery: componentDefinition.viewQuery || null,
                features: componentDefinition.features || null,
                data: componentDefinition.data || {},
                encapsulation: componentDefinition.encapsulation || ViewEncapsulation$1.Emulated,
                id: "c",
                styles: componentDefinition.styles || EMPTY_ARRAY,
                _: null,
                setInput: null,
                schemas: componentDefinition.schemas || null,
                tView: null
            };
            return def._ = noSideEffects(() => {
                const directiveTypes = componentDefinition.directives, feature = componentDefinition.features, pipeTypes = componentDefinition.pipes;
                def.id += _renderCompCount++, def.inputs = invertObject(componentDefinition.inputs, declaredInputs), 
                def.outputs = invertObject(componentDefinition.outputs), feature && feature.forEach(fn => fn(def)), 
                def.directiveDefs = directiveTypes ? () => ("function" == typeof directiveTypes ? directiveTypes() : directiveTypes).map(extractDirectiveDef) : null, 
                def.pipeDefs = pipeTypes ? () => ("function" == typeof pipeTypes ? pipeTypes() : pipeTypes).map(extractPipeDef) : null;
            }), def;
        }
        function extractDirectiveDef(type) {
            return getComponentDef(type) || function(type) {
                return type[NG_DIR_DEF] || null;
            }(type);
        }
        function extractPipeDef(type) {
            return function(type) {
                return type[NG_PIPE_DEF] || null;
            }(type);
        }
        const autoRegisterModuleById = {};
        function ɵɵdefineNgModule(def) {
            const res = {
                type: def.type,
                bootstrap: def.bootstrap || EMPTY_ARRAY,
                declarations: def.declarations || EMPTY_ARRAY,
                imports: def.imports || EMPTY_ARRAY,
                exports: def.exports || EMPTY_ARRAY,
                transitiveCompileScopes: null,
                schemas: def.schemas || null,
                id: def.id || null
            };
            return null != def.id && noSideEffects(() => {
                autoRegisterModuleById[def.id] = def.type;
            }), res;
        }
        function invertObject(obj, secondary) {
            if (null == obj) return EMPTY_OBJ;
            const newLookup = {};
            for (const minifiedKey in obj) if (obj.hasOwnProperty(minifiedKey)) {
                let publicName = obj[minifiedKey], declaredName = publicName;
                Array.isArray(publicName) && (declaredName = publicName[1], publicName = publicName[0]), 
                newLookup[publicName] = minifiedKey, secondary && (secondary[publicName] = declaredName);
            }
            return newLookup;
        }
        const ɵɵdefineDirective = ɵɵdefineComponent;
        function ɵɵdefinePipe(pipeDef) {
            return {
                type: pipeDef.type,
                name: pipeDef.name,
                factory: null,
                pure: !1 !== pipeDef.pure,
                onDestroy: pipeDef.type.prototype.ngOnDestroy || null
            };
        }
        function getComponentDef(type) {
            return type[NG_COMP_DEF] || null;
        }
        function getFactoryDef(type, throwNotFound) {
            return type.hasOwnProperty(NG_FACTORY_DEF) ? type[NG_FACTORY_DEF] : null;
        }
        function getNgModuleDef(type, throwNotFound) {
            const ngModuleDef = type[NG_MOD_DEF] || null;
            if (!ngModuleDef && !0 === throwNotFound) throw new Error(`Type ${stringify(type)} does not have 'ɵmod' property.`);
            return ngModuleDef;
        }
        const HOST = 0, TVIEW = 1, FLAGS = 2, PARENT = 3, NEXT = 4, QUERIES = 5, T_HOST = 6, CLEANUP = 7, CONTEXT = 8, INJECTOR$1 = 9, RENDERER_FACTORY = 10, RENDERER = 11, SANITIZER = 12, CHILD_HEAD = 13, CHILD_TAIL = 14, DECLARATION_VIEW = 15, DECLARATION_LCONTAINER = 16, PREORDER_HOOK_FLAGS = 17, HEADER_OFFSET = 18, TYPE = 1, ACTIVE_INDEX = 2, MOVED_VIEWS = 5, NATIVE = 7, VIEW_REFS = 8, CONTAINER_HEADER_OFFSET = 9;
        function isLView(value) {
            return Array.isArray(value) && "object" == typeof value[TYPE];
        }
        function isLContainer(value) {
            return Array.isArray(value) && !0 === value[TYPE];
        }
        function isContentQueryHost(tNode) {
            return 0 != (8 & tNode.flags);
        }
        function isComponentHost(tNode) {
            return 2 == (2 & tNode.flags);
        }
        function isDirectiveHost(tNode) {
            return 1 == (1 & tNode.flags);
        }
        function isComponentDef(def) {
            return null !== def.template;
        }
        function isRootView(target) {
            return 0 != (512 & target[FLAGS]);
        }
        const TNODE = 8, PARENT_INJECTOR = 8, INJECTOR_BLOOM_PARENT_SIZE = 9, NO_PARENT_INJECTOR = -1;
        class NodeInjectorFactory {
            constructor(factory, isViewProvider, injectImplementation) {
                this.factory = factory, this.resolving = !1, this.canSeeViewProviders = isViewProvider, 
                this.injectImpl = injectImplementation;
            }
        }
        const instructionState = {
            lFrame: createLFrame(null),
            bindingsEnabled: !0,
            elementExitFn: null,
            checkNoChangesMode: !1
        };
        function setCurrentDirectiveDef(def) {
            instructionState.lFrame.currentDirectiveDef = def;
        }
        function getBindingsEnabled() {
            return instructionState.bindingsEnabled;
        }
        function getLView() {
            const lFrame = instructionState.lFrame;
            return null === lFrame ? null : lFrame.lView;
        }
        function hasActiveElementFlag(flag) {
            return (instructionState.lFrame.selectedIndex & flag) === flag;
        }
        function setActiveHostElement(elementIndex = null) {
            hasActiveElementFlag(1) && executeElementExitFn(), setSelectedIndex(null === elementIndex ? -1 : elementIndex), 
            instructionState.lFrame.activeDirectiveId = 0;
        }
        function executeElementExitFn() {
            instructionState.elementExitFn(), instructionState.lFrame.selectedIndex &= -2;
        }
        function setElementExitFn(fn) {
            instructionState.lFrame.selectedIndex |= 1, null == instructionState.elementExitFn && (instructionState.elementExitFn = fn);
        }
        function getActiveDirectiveId() {
            return instructionState.lFrame.activeDirectiveId;
        }
        function incrementActiveDirectiveId() {
            instructionState.lFrame.activeDirectiveId += 1;
        }
        function ɵɵrestoreView(viewToRestore) {
            instructionState.lFrame.contextLView = viewToRestore;
        }
        function getPreviousOrParentTNode() {
            return instructionState.lFrame.previousOrParentTNode;
        }
        function setPreviousOrParentTNode(tNode, _isParent) {
            instructionState.lFrame.previousOrParentTNode = tNode, instructionState.lFrame.isParent = _isParent;
        }
        function getIsParent() {
            return instructionState.lFrame.isParent;
        }
        function setIsNotParent() {
            instructionState.lFrame.isParent = !1;
        }
        function getCheckNoChangesMode() {
            return instructionState.checkNoChangesMode;
        }
        function setCheckNoChangesMode(mode) {
            instructionState.checkNoChangesMode = mode;
        }
        function getBindingRoot() {
            const lFrame = instructionState.lFrame;
            let index = lFrame.bindingRootIndex;
            return -1 === index && (index = lFrame.bindingRootIndex = lFrame.lView[TVIEW].bindingStartIndex), 
            index;
        }
        function getBindingIndex() {
            return instructionState.lFrame.bindingIndex;
        }
        function setBindingIndex(value) {
            return instructionState.lFrame.bindingIndex = value;
        }
        function nextBindingIndex() {
            return instructionState.lFrame.bindingIndex++;
        }
        function incrementBindingIndex(count) {
            const lFrame = instructionState.lFrame, index = lFrame.bindingIndex;
            return lFrame.bindingIndex = lFrame.bindingIndex + count, index;
        }
        function setBindingRoot(value) {
            instructionState.lFrame.bindingRootIndex = value;
        }
        function getCurrentQueryIndex() {
            return instructionState.lFrame.currentQueryIndex;
        }
        function setCurrentQueryIndex(value) {
            instructionState.lFrame.currentQueryIndex = value;
        }
        function enterDI(newView, tNode) {
            const newLFrame = allocLFrame();
            instructionState.lFrame = newLFrame, newLFrame.previousOrParentTNode = tNode, newLFrame.lView = newView;
        }
        const leaveDI = leaveView;
        function enterView(newView, tNode) {
            const newLFrame = allocLFrame();
            instructionState.lFrame = newLFrame, newLFrame.previousOrParentTNode = tNode, newLFrame.isParent = !0, 
            newLFrame.lView = newView, newLFrame.selectedIndex = 0, newLFrame.contextLView = newView, 
            newLFrame.elementDepthCount = 0, newLFrame.currentNamespace = null, newLFrame.currentSanitizer = null, 
            newLFrame.currentDirectiveDef = null, newLFrame.activeDirectiveId = 0, newLFrame.bindingRootIndex = -1, 
            newLFrame.bindingIndex = null === newView ? -1 : newView[TVIEW].bindingStartIndex, 
            newLFrame.currentQueryIndex = 0;
        }
        function allocLFrame() {
            const currentLFrame = instructionState.lFrame, childLFrame = null === currentLFrame ? null : currentLFrame.child;
            return null === childLFrame ? createLFrame(currentLFrame) : childLFrame;
        }
        function createLFrame(parent) {
            const lFrame = {
                previousOrParentTNode: null,
                isParent: !0,
                lView: null,
                selectedIndex: 0,
                contextLView: null,
                elementDepthCount: 0,
                currentNamespace: null,
                currentSanitizer: null,
                currentDirectiveDef: null,
                activeDirectiveId: 0,
                bindingRootIndex: -1,
                bindingIndex: -1,
                currentQueryIndex: 0,
                parent: parent,
                child: null
            };
            return null !== parent && (parent.child = lFrame), lFrame;
        }
        function leaveView() {
            instructionState.lFrame = instructionState.lFrame.parent;
        }
        function getSelectedIndex() {
            return instructionState.lFrame.selectedIndex >> 1;
        }
        function setSelectedIndex(index) {
            instructionState.lFrame.selectedIndex = index << 1;
        }
        function ɵɵnamespaceSVG() {
            instructionState.lFrame.currentNamespace = "http://www.w3.org/2000/svg";
        }
        function ɵɵnamespaceHTML() {
            instructionState.lFrame.currentNamespace = null;
        }
        function setCurrentStyleSanitizer(sanitizer) {
            instructionState.lFrame.currentSanitizer = sanitizer;
        }
        function getCurrentStyleSanitizer() {
            const lFrame = instructionState.lFrame;
            return null === lFrame ? null : lFrame.currentSanitizer;
        }
        let DOCUMENT = void 0;
        function setDocument(document) {
            DOCUMENT = document;
        }
        function getDocument() {
            return void 0 !== DOCUMENT ? DOCUMENT : "undefined" != typeof document ? document : void 0;
        }
        const RendererStyleFlags3 = function() {
            var RendererStyleFlags3 = {
                Important: 1,
                DashCase: 2
            };
            return RendererStyleFlags3[RendererStyleFlags3.Important] = "Important", RendererStyleFlags3[RendererStyleFlags3.DashCase] = "DashCase", 
            RendererStyleFlags3;
        }();
        function isProceduralRenderer(renderer) {
            return !!renderer.listen;
        }
        const domRendererFactory3 = {
            createRenderer: (hostElement, rendererType) => getDocument()
        };
        function setUpAttributes(renderer, native, attrs) {
            const isProc = isProceduralRenderer(renderer);
            let i = 0;
            for (;i < attrs.length; ) {
                const value = attrs[i];
                if ("number" == typeof value) {
                    if (0 !== value) break;
                    i++;
                    const namespaceURI = attrs[i++], attrName = attrs[i++], attrVal = attrs[i++];
                    isProc ? renderer.setAttribute(native, attrName, attrVal, namespaceURI) : native.setAttributeNS(namespaceURI, attrName, attrVal);
                } else {
                    const attrName = value, attrVal = attrs[++i];
                    isAnimationProp(attrName) ? isProc && renderer.setProperty(native, attrName, attrVal) : isProc ? renderer.setAttribute(native, attrName, attrVal) : native.setAttribute(attrName, attrVal), 
                    i++;
                }
            }
            return i;
        }
        function isNameOnlyAttributeMarker(marker) {
            return 3 === marker || 4 === marker || 6 === marker;
        }
        function isAnimationProp(name) {
            return 64 === name.charCodeAt(0);
        }
        function hasParentInjector(parentLocation) {
            return parentLocation !== NO_PARENT_INJECTOR;
        }
        function getParentInjectorIndex(parentLocation) {
            return 32767 & parentLocation;
        }
        function getParentInjectorViewOffset(parentLocation) {
            return parentLocation >> 16;
        }
        function getParentInjectorView(location, startView) {
            let viewOffset = getParentInjectorViewOffset(location), parentView = startView;
            for (;viewOffset > 0; ) parentView = parentView[DECLARATION_VIEW], viewOffset--;
            return parentView;
        }
        function renderStringify(value) {
            return "string" == typeof value ? value : null == value ? "" : "" + value;
        }
        function stringifyForError(value) {
            return "function" == typeof value ? value.name || value.toString() : "object" == typeof value && null != value && "function" == typeof value.type ? value.type.name || value.type.toString() : renderStringify(value);
        }
        const defaultScheduler = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(_global))();
        function ɵɵresolveWindow(element) {
            return {
                name: "window",
                target: element.ownerDocument.defaultView
            };
        }
        function ɵɵresolveDocument(element) {
            return {
                name: "document",
                target: element.ownerDocument
            };
        }
        const INTERPOLATION_DELIMITER = "�";
        function maybeUnwrapFn(value) {
            return value instanceof Function ? value() : value;
        }
        const NO_CHANGE = {}, MAP_BASED_ENTRY_PROP_NAME = "[MAP]", TEMPLATE_DIRECTIVE_INDEX = 0, DEFAULT_BINDING_VALUE = null, DEFAULT_BINDING_INDEX = 0, DEFAULT_TOTAL_SOURCES = 1, DEFAULT_GUARD_MASK_VALUE = 1;
        function allocStylingMapArray(value) {
            return [ value ];
        }
        function hasConfig(tNode, flag) {
            return 0 != (tNode.flags & flag);
        }
        function allowDirectStyling(tNode, isClassBased, firstUpdatePass) {
            let allow = !1;
            if (hasConfig(tNode, 128)) {
                if (!firstUpdatePass) {
                    const hasDuplicates = hasConfig(tNode, isClassBased ? 8192 : 262144), hasOnlyMapOrPropsFlag = isClassBased ? 1536 : 49152, hasOnlyMapsOrOnlyProps = (tNode.flags & hasOnlyMapOrPropsFlag) !== hasOnlyMapOrPropsFlag;
                    allow = !hasDuplicates && hasOnlyMapsOrOnlyProps;
                }
            } else allow = !0;
            return allow;
        }
        function patchConfig(tNode, flag) {
            tNode.flags |= flag;
        }
        function getProp(context, index) {
            return context[index + 3];
        }
        function isSanitizationRequired(context, index) {
            return 0 != (1 & function(context, index) {
                return 1 & context[index + 0];
            }(context, index));
        }
        function getGuardMask(context, index, isHostBinding) {
            return context[index + (isHostBinding ? 2 : 1)];
        }
        function getValuesCount(context) {
            return getTotalSources(context) + 1;
        }
        function getTotalSources(context) {
            return context[0];
        }
        function getBindingValue(context, index, offset) {
            return context[index + 4 + offset];
        }
        function getDefaultValue(context, index) {
            return context[index + 4 + getTotalSources(context)];
        }
        function setValue(data, bindingIndex, value) {
            data[bindingIndex] = value;
        }
        function getValue(data, bindingIndex) {
            return 0 !== bindingIndex ? data[bindingIndex] : null;
        }
        function hasValueChanged(a, b) {
            if (b === NO_CHANGE) return !1;
            const compareValueA = Array.isArray(a) ? a[0] : a, compareValueB = Array.isArray(b) ? b[0] : b;
            return !Object.is(compareValueA, compareValueB);
        }
        function isStylingValueDefined(value) {
            return null != value && "" !== value;
        }
        function concatString(a, b, separator = " ") {
            return a + (b.length && a.length ? separator : "") + b;
        }
        function hyphenate(value) {
            return value.replace(/[a-z][A-Z]/g, v => v.charAt(0) + "-" + v.charAt(1)).toLowerCase();
        }
        function getStylingMapArray(value) {
            return isStylingContext(value) ? value[1] : value;
        }
        function isStylingContext(value) {
            return Array.isArray(value) && value.length >= 2 && "string" != typeof value[1];
        }
        function getInitialStylingValue(context) {
            const map = getStylingMapArray(context);
            return map && map[0] || "";
        }
        function hasClassInput(tNode) {
            return 0 != (16 & tNode.flags);
        }
        function hasStyleInput(tNode) {
            return 0 != (32 & tNode.flags);
        }
        function getMapProp(map, index) {
            return map[index + 0];
        }
        const MAP_DIRTY_VALUE = {
            MAP_DIRTY_VALUE: !0
        };
        function setMapValue(map, index, value) {
            map[index + 1] = value;
        }
        function getMapValue(map, index) {
            return map[index + 1];
        }
        function forceStylesAsString(styles, hyphenateProps) {
            if ("string" == typeof styles) return styles;
            let str = "";
            if (styles) {
                const props = Object.keys(styles);
                for (let i = 0; i < props.length; i++) {
                    const prop = props[i], propLabel = hyphenateProps ? hyphenate(prop) : prop, value = styles[prop];
                    null !== value && (str = concatString(str, `${propLabel}:${value}`, ";"));
                }
            }
            return str;
        }
        function isHostStylingActive(directiveOrSourceId) {
            return directiveOrSourceId !== TEMPLATE_DIRECTIVE_INDEX;
        }
        function stylingMapToString(map, isClassBased) {
            let str = "";
            for (let i = 1; i < map.length; i += 2) {
                const prop = getMapProp(map, i), value = getMapValue(map, i), attrValue = concatString(prop, isClassBased ? "" : value, ":");
                str = concatString(str, attrValue, isClassBased ? " " : "; ");
            }
            return str;
        }
        function addItemToStylingMap(stylingMapArr, prop, value, allowOverwrite) {
            for (let j = 1; j < stylingMapArr.length; j += 2) {
                const propAtIndex = getMapProp(stylingMapArr, j);
                if (prop <= propAtIndex) {
                    let applied = !1;
                    if (propAtIndex === prop) {
                        const valueAtIndex = stylingMapArr[j];
                        !allowOverwrite && isStylingValueDefined(valueAtIndex) || (applied = !0, setMapValue(stylingMapArr, j, value));
                    } else applied = !0, stylingMapArr.splice(j, 0, prop, value);
                    return applied;
                }
            }
            return stylingMapArr.push(prop, value), !0;
        }
        function normalizeIntoStylingMap(bindingValue, newValues, normalizeProps) {
            const stylingMapArr = Array.isArray(bindingValue) ? bindingValue : allocStylingMapArray(null);
            stylingMapArr[0] = newValues;
            for (let j = 1; j < stylingMapArr.length; j += 2) setMapValue(stylingMapArr, j, null);
            let map, props = null, allValuesTrue = !1;
            if ("string" == typeof newValues ? allValuesTrue = null !== (props = function(text) {
                let array = null, length = text.length, start = 0, foundChar = !1;
                for (let i = 0; i < length; i++) text.charCodeAt(i) <= 32 ? (foundChar && (null === array && (array = []), 
                array.push(text.substring(start, i)), foundChar = !1), start = i + 1) : foundChar = !0;
                return foundChar && (null === array && (array = []), array.push(text.substring(start, length)), 
                foundChar = !1), array;
            }(newValues)) : (props = newValues ? Object.keys(newValues) : null, map = newValues), 
            props) for (let i = 0; i < props.length; i++) {
                const prop = props[i];
                addItemToStylingMap(stylingMapArr, normalizeProps ? hyphenate(prop) : prop, !!allValuesTrue || map[prop], !0);
            }
            return stylingMapArr;
        }
        function selectClassBasedInputName(inputs) {
            return inputs.hasOwnProperty("class") ? "class" : "className";
        }
        const MONKEY_PATCH_KEY_NAME = "__ngContext__";
        function unwrapRNode(value) {
            for (;Array.isArray(value); ) value = value[HOST];
            return (value);
        }
        function getNativeByIndex(index, lView) {
            return unwrapRNode(lView[index + HEADER_OFFSET]);
        }
        function getNativeByTNode(tNode, lView) {
            return unwrapRNode(lView[tNode.index]);
        }
        function getNativeByTNodeOrNull(tNode, lView) {
            const index = tNode.index;
            return -1 !== index ? unwrapRNode(lView[index]) : null;
        }
        function getTNode(index, view) {
            return view[TVIEW].data[index + HEADER_OFFSET];
        }
        function load(view, index) {
            return view[index + HEADER_OFFSET];
        }
        function getComponentLViewByIndex(nodeIndex, hostView) {
            const slotValue = hostView[nodeIndex];
            return isLView(slotValue) ? slotValue : slotValue[HOST];
        }
        function readPatchedData(target) {
            return target[MONKEY_PATCH_KEY_NAME] || null;
        }
        function readPatchedLView(target) {
            const value = readPatchedData(target);
            return value ? Array.isArray(value) ? value : value.lView : null;
        }
        function isCreationMode(view) {
            return 4 == (4 & view[FLAGS]);
        }
        function getConstant(consts, index) {
            return null === consts || null == index ? null : consts[index];
        }
        function resetPreOrderHookFlags(lView) {
            lView[PREORDER_HOOK_FLAGS] = 0;
        }
        function getLViewParent(lView) {
            const parent = lView[PARENT];
            return isLContainer(parent) ? parent[PARENT] : parent;
        }
        function findComponentView(lView) {
            let declaredView, rootTNode = lView[T_HOST];
            for (;null !== rootTNode && 2 === rootTNode.type && null !== (declaredView = lView[DECLARATION_VIEW]); ) rootTNode = (lView = declaredView)[T_HOST];
            return lView;
        }
        let includeViewProviders = !0;
        function setIncludeViewProviders(v) {
            const oldValue = includeViewProviders;
            return includeViewProviders = v, oldValue;
        }
        const BLOOM_MASK = 255;
        let nextNgElementId = 0;
        function getOrCreateNodeInjectorForNode(tNode, hostView) {
            const existingInjectorIndex = getInjectorIndex(tNode, hostView);
            if (-1 !== existingInjectorIndex) return existingInjectorIndex;
            const tView = hostView[TVIEW];
            tView.firstCreatePass && (tNode.injectorIndex = hostView.length, insertBloom(tView.data, tNode), 
            insertBloom(hostView, null), insertBloom(tView.blueprint, null));
            const parentLoc = getParentInjectorLocation(tNode, hostView), injectorIndex = tNode.injectorIndex;
            if (hasParentInjector(parentLoc)) {
                const parentIndex = getParentInjectorIndex(parentLoc), parentLView = getParentInjectorView(parentLoc, hostView), parentData = parentLView[TVIEW].data;
                for (let i = 0; i < 8; i++) hostView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];
            }
            return hostView[injectorIndex + PARENT_INJECTOR] = parentLoc, injectorIndex;
        }
        function insertBloom(arr, footer) {
            arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
        }
        function getInjectorIndex(tNode, hostView) {
            return -1 === tNode.injectorIndex || tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || null == hostView[tNode.injectorIndex + PARENT_INJECTOR] ? -1 : tNode.injectorIndex;
        }
        function getParentInjectorLocation(tNode, view) {
            if (tNode.parent && -1 !== tNode.parent.injectorIndex) return tNode.parent.injectorIndex;
            let hostTNode = view[T_HOST], viewOffset = 1;
            for (;hostTNode && -1 === hostTNode.injectorIndex; ) hostTNode = (view = view[DECLARATION_VIEW]) ? view[T_HOST] : null, 
            viewOffset++;
            return hostTNode ? hostTNode.injectorIndex | viewOffset << 16 : -1;
        }
        function diPublicInInjector(injectorIndex, tView, token) {
            !function(injectorIndex, tView, type) {
                let id = "string" != typeof type ? type[NG_ELEMENT_ID] : type.charCodeAt(0) || 0;
                null == id && (id = type[NG_ELEMENT_ID] = nextNgElementId++);
                const bloomBit = id & BLOOM_MASK, mask = 1 << bloomBit, b6 = 64 & bloomBit, b5 = 32 & bloomBit, tData = tView.data;
                128 & bloomBit ? b6 ? b5 ? tData[injectorIndex + 7] |= mask : tData[injectorIndex + 6] |= mask : b5 ? tData[injectorIndex + 5] |= mask : tData[injectorIndex + 4] |= mask : b6 ? b5 ? tData[injectorIndex + 3] |= mask : tData[injectorIndex + 2] |= mask : b5 ? tData[injectorIndex + 1] |= mask : tData[injectorIndex] |= mask;
            }(injectorIndex, tView, token);
        }
        function getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {
            if (tNode) {
                const bloomHash = function(token) {
                    if ("string" == typeof token) return token.charCodeAt(0) || 0;
                    const tokenId = token[NG_ELEMENT_ID];
                    return "number" == typeof tokenId && tokenId > 0 ? tokenId & BLOOM_MASK : tokenId;
                }(token);
                if ("function" == typeof bloomHash) {
                    enterDI(lView, tNode);
                    try {
                        const value = bloomHash();
                        if (null != value || flags & InjectFlags.Optional) return value;
                        throw new Error(`No provider for ${stringifyForError(token)}!`);
                    } finally {
                        leaveDI();
                    }
                } else if ("number" == typeof bloomHash) {
                    if (-1 === bloomHash) return new NodeInjector(tNode, lView);
                    let previousTView = null, injectorIndex = getInjectorIndex(tNode, lView), parentLocation = NO_PARENT_INJECTOR, hostTElementNode = flags & InjectFlags.Host ? findComponentView(lView)[T_HOST] : null;
                    for ((-1 === injectorIndex || flags & InjectFlags.SkipSelf) && (parentLocation = -1 === injectorIndex ? getParentInjectorLocation(tNode, lView) : lView[injectorIndex + PARENT_INJECTOR], 
                    shouldSearchParent(flags, !1) ? (previousTView = lView[TVIEW], injectorIndex = getParentInjectorIndex(parentLocation), 
                    lView = getParentInjectorView(parentLocation, lView)) : injectorIndex = -1); -1 !== injectorIndex; ) {
                        parentLocation = lView[injectorIndex + PARENT_INJECTOR];
                        const tView = lView[TVIEW];
                        if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
                            const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
                            if (instance !== NOT_FOUND) return instance;
                        }
                        shouldSearchParent(flags, lView[TVIEW].data[injectorIndex + TNODE] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView) ? (previousTView = tView, 
                        injectorIndex = getParentInjectorIndex(parentLocation), lView = getParentInjectorView(parentLocation, lView)) : injectorIndex = -1;
                    }
                }
            }
            if (flags & InjectFlags.Optional && void 0 === notFoundValue && (notFoundValue = null), 
            0 == (flags & (InjectFlags.Self | InjectFlags.Host))) {
                const moduleInjector = lView[INJECTOR$1], previousInjectImplementation = setInjectImplementation(void 0);
                try {
                    return moduleInjector ? moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional) : injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);
                } finally {
                    setInjectImplementation(previousInjectImplementation);
                }
            }
            if (flags & InjectFlags.Optional) return notFoundValue;
            throw new Error(`NodeInjector: NOT_FOUND [${stringifyForError(token)}]`);
        }
        const NOT_FOUND = {};
        function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
            const currentTView = lView[TVIEW], tNode = currentTView.data[injectorIndex + TNODE], injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, null == previousTView ? isComponentHost(tNode) && includeViewProviders : previousTView != currentTView && 3 === tNode.type, flags & InjectFlags.Host && hostTElementNode === tNode);
            return null !== injectableIdx ? getNodeInjectable(currentTView.data, lView, injectableIdx, tNode) : NOT_FOUND;
        }
        function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
            const nodeProviderIndexes = tNode.providerIndexes, tInjectables = tView.data, injectablesStart = 65535 & nodeProviderIndexes, directivesStart = tNode.directiveStart, cptViewProvidersCount = nodeProviderIndexes >> 16, endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : tNode.directiveEnd;
            for (let i = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount; i < endIndex; i++) {
                const providerTokenOrDef = tInjectables[i];
                if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) return i;
            }
            if (isHostSpecialCase) {
                const dirDef = tInjectables[directivesStart];
                if (dirDef && isComponentDef(dirDef) && dirDef.type === token) return directivesStart;
            }
            return null;
        }
        function getNodeInjectable(tData, lView, index, tNode) {
            let value = lView[index];
            if (value instanceof NodeInjectorFactory) {
                const factory = value;
                if (factory.resolving) throw new Error(`Circular dep for ${stringifyForError(tData[index])}`);
                const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
                let previousInjectImplementation;
                factory.resolving = !0, factory.injectImpl && (previousInjectImplementation = setInjectImplementation(factory.injectImpl)), 
                enterDI(lView, tNode);
                try {
                    value = lView[index] = factory.factory(void 0, tData, lView, tNode);
                } finally {
                    factory.injectImpl && setInjectImplementation(previousInjectImplementation), setIncludeViewProviders(previousIncludeViewProviders), 
                    factory.resolving = !1, leaveDI();
                }
            }
            return value;
        }
        function bloomHasToken(bloomHash, injectorIndex, injectorView) {
            const b6 = 64 & bloomHash, b5 = 32 & bloomHash;
            let value;
            return !!((value = 128 & bloomHash ? b6 ? b5 ? injectorView[injectorIndex + 7] : injectorView[injectorIndex + 6] : b5 ? injectorView[injectorIndex + 5] : injectorView[injectorIndex + 4] : b6 ? b5 ? injectorView[injectorIndex + 3] : injectorView[injectorIndex + 2] : b5 ? injectorView[injectorIndex + 1] : injectorView[injectorIndex]) & 1 << bloomHash);
        }
        function shouldSearchParent(flags, isFirstHostTNode) {
            return !(flags & InjectFlags.Self || flags & InjectFlags.Host && isFirstHostTNode);
        }
        class NodeInjector {
            constructor(_tNode, _lView) {
                this._tNode = _tNode, this._lView = _lView;
            }
            get(token, notFoundValue) {
                return getOrCreateInjectable(this._tNode, this._lView, token, void 0, notFoundValue);
            }
        }
        function ɵɵgetInheritedFactory(type) {
            const proto = Object.getPrototypeOf(type.prototype).constructor, factory = proto[NG_FACTORY_DEF] || function ɵɵgetFactoryOf(type) {
                const typeAny = type;
                if (isForwardRef(type)) return () => {
                    const factory = ɵɵgetFactoryOf(resolveForwardRef(typeAny));
                    return factory ? factory() : null;
                };
                let factory = getFactoryDef(typeAny);
                if (null === factory) {
                    const injectorDef = getInjectorDef(typeAny);
                    factory = injectorDef && injectorDef.factory;
                }
                return factory || null;
            }(proto);
            return null !== factory ? factory : t => new t;
        }
        const ERROR_DEBUG_CONTEXT = "ngDebugContext", ERROR_ORIGINAL_ERROR = "ngOriginalError", ERROR_LOGGER = "ngErrorLogger";
        function getDebugContext(error) {
            return error[ERROR_DEBUG_CONTEXT];
        }
        function getOriginalError(error) {
            return error[ERROR_ORIGINAL_ERROR];
        }
        function defaultErrorLogger(console, ...values) {
            console.error(...values);
        }
        class ErrorHandler {
            constructor() {
                this._console = console;
            }
            handleError(error) {
                const originalError = this._findOriginalError(error), context = this._findContext(error), errorLogger = function(error) {
                    return error[ERROR_LOGGER] || defaultErrorLogger;
                }(error);
                errorLogger(this._console, "ERROR", error), originalError && errorLogger(this._console, "ORIGINAL ERROR", originalError), 
                context && errorLogger(this._console, "ERROR CONTEXT", context);
            }
            _findContext(error) {
                return error ? getDebugContext(error) ? getDebugContext(error) : this._findContext(getOriginalError(error)) : null;
            }
            _findOriginalError(error) {
                let e = getOriginalError(error);
                for (;e && getOriginalError(e); ) e = getOriginalError(e);
                return e;
            }
        }
        class SafeValueImpl {
            constructor(changingThisBreaksApplicationSecurity) {
                this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
            }
            toString() {
                return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` + " (see http://g.co/ng/security#xss)";
            }
        }
        class SafeHtmlImpl extends SafeValueImpl {
            getTypeName() {
                return "HTML";
            }
        }
        class SafeStyleImpl extends SafeValueImpl {
            getTypeName() {
                return "Style";
            }
        }
        class SafeScriptImpl extends SafeValueImpl {
            getTypeName() {
                return "Script";
            }
        }
        class SafeUrlImpl extends SafeValueImpl {
            getTypeName() {
                return "URL";
            }
        }
        class SafeResourceUrlImpl extends SafeValueImpl {
            getTypeName() {
                return "ResourceURL";
            }
        }
        function unwrapSafeValue(value) {
            return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;
        }
        function allowSanitizationBypassAndThrow(value, type) {
            const actualType = getSanitizationBypassType(value);
            if (null != actualType && actualType !== type) {
                if ("ResourceURL" === actualType && "URL" === type) return !0;
                throw new Error(`Required a safe ${type}, got a ${actualType} (see http://g.co/ng/security#xss)`);
            }
            return actualType === type;
        }
        function getSanitizationBypassType(value) {
            return value instanceof SafeValueImpl && value.getTypeName() || null;
        }
        function bypassSanitizationTrustHtml(trustedHtml) {
            return new SafeHtmlImpl(trustedHtml);
        }
        function bypassSanitizationTrustStyle(trustedStyle) {
            return new SafeStyleImpl(trustedStyle);
        }
        function bypassSanitizationTrustScript(trustedScript) {
            return new SafeScriptImpl(trustedScript);
        }
        function bypassSanitizationTrustUrl(trustedUrl) {
            return new SafeUrlImpl(trustedUrl);
        }
        function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {
            return new SafeResourceUrlImpl(trustedResourceUrl);
        }
        let _devMode = !0, _runModeLocked = !1;
        function isDevMode() {
            return _runModeLocked = !0, _devMode;
        }
        function enableProdMode() {
            if (_runModeLocked) throw new Error("Cannot enable prod mode after platform setup.");
            _devMode = !1;
        }
        class InertBodyHelper {
            constructor(defaultDoc) {
                if (this.defaultDoc = defaultDoc, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), 
                this.inertBodyElement = this.inertDocument.body, null == this.inertBodyElement) {
                    const inertHtml = this.inertDocument.createElement("html");
                    this.inertDocument.appendChild(inertHtml), this.inertBodyElement = this.inertDocument.createElement("body"), 
                    inertHtml.appendChild(this.inertBodyElement);
                }
                this.inertBodyElement.innerHTML = '<svg><g onload="this.parentNode.remove()"></g></svg>', 
                !this.inertBodyElement.querySelector || this.inertBodyElement.querySelector("svg") ? (this.inertBodyElement.innerHTML = '<svg><p><style><img src="</style><img src=x onerror=alert(1)//">', 
                this.getInertBodyElement = this.inertBodyElement.querySelector && this.inertBodyElement.querySelector("svg img") && function() {
                    try {
                        return !!window.DOMParser;
                    } catch (_a) {
                        return !1;
                    }
                }() ? this.getInertBodyElement_DOMParser : this.getInertBodyElement_InertDocument) : this.getInertBodyElement = this.getInertBodyElement_XHR;
            }
            getInertBodyElement_XHR(html) {
                html = "<body><remove></remove>" + html + "</body>";
                try {
                    html = encodeURI(html);
                } catch (_a) {
                    return null;
                }
                const xhr = new XMLHttpRequest;
                xhr.responseType = "document", xhr.open("GET", "data:text/html;charset=utf-8," + html, !1), 
                xhr.send(void 0);
                const body = xhr.response.body;
                return body.removeChild(body.firstChild), body;
            }
            getInertBodyElement_DOMParser(html) {
                html = "<body><remove></remove>" + html + "</body>";
                try {
                    const body = (new window.DOMParser).parseFromString(html, "text/html").body;
                    return body.removeChild(body.firstChild), body;
                } catch (_a) {
                    return null;
                }
            }
            getInertBodyElement_InertDocument(html) {
                const templateEl = this.inertDocument.createElement("template");
                return "content" in templateEl ? (templateEl.innerHTML = html, templateEl) : (this.inertBodyElement.innerHTML = html, 
                this.defaultDoc.documentMode && this.stripCustomNsAttrs(this.inertBodyElement), 
                this.inertBodyElement);
            }
            stripCustomNsAttrs(el) {
                const elAttrs = el.attributes;
                for (let i = elAttrs.length - 1; 0 < i; i--) {
                    const attrName = elAttrs.item(i).name;
                    "xmlns:ns1" !== attrName && 0 !== attrName.indexOf("ns1:") || el.removeAttribute(attrName);
                }
                let childNode = el.firstChild;
                for (;childNode; ) childNode.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(childNode), 
                childNode = childNode.nextSibling;
            }
        }
        const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi, DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
        function _sanitizeUrl(url) {
            return (url = String(url)).match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN) ? url : (isDevMode() && console.warn(`WARNING: sanitizing unsafe URL value ${url} (see http://g.co/ng/security#xss)`), 
            "unsafe:" + url);
        }
        function tagSet(tags) {
            const res = {};
            for (const t of tags.split(",")) res[t] = !0;
            return res;
        }
        function merge(...sets) {
            const res = {};
            for (const s of sets) for (const v in s) s.hasOwnProperty(v) && (res[v] = !0);
            return res;
        }
        const VOID_ELEMENTS = tagSet("area,br,col,hr,img,wbr"), OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet("rp,rt"), OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS), VALID_ELEMENTS = merge(VOID_ELEMENTS, merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), OPTIONAL_END_TAG_ELEMENTS), URI_ATTRS = tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), SRCSET_ATTRS = tagSet("srcset"), VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet("script,style,template");
        class SanitizingHtmlSerializer {
            constructor() {
                this.sanitizedSomething = !1, this.buf = [];
            }
            sanitizeChildren(el) {
                let current = el.firstChild, traverseContent = !0;
                for (;current; ) if (current.nodeType === Node.ELEMENT_NODE ? traverseContent = this.startElement(current) : current.nodeType === Node.TEXT_NODE ? this.chars(current.nodeValue) : this.sanitizedSomething = !0, 
                traverseContent && current.firstChild) current = current.firstChild; else for (;current; ) {
                    current.nodeType === Node.ELEMENT_NODE && this.endElement(current);
                    let next = this.checkClobberedElement(current, current.nextSibling);
                    if (next) {
                        current = next;
                        break;
                    }
                    current = this.checkClobberedElement(current, current.parentNode);
                }
                return this.buf.join("");
            }
            startElement(element) {
                const tagName = element.nodeName.toLowerCase();
                if (!VALID_ELEMENTS.hasOwnProperty(tagName)) return this.sanitizedSomething = !0, 
                !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
                this.buf.push("<"), this.buf.push(tagName);
                const elAttrs = element.attributes;
                for (let i = 0; i < elAttrs.length; i++) {
                    const elAttr = elAttrs.item(i), attrName = elAttr.name, lower = attrName.toLowerCase();
                    if (!VALID_ATTRS.hasOwnProperty(lower)) {
                        this.sanitizedSomething = !0;
                        continue;
                    }
                    let value = elAttr.value;
                    URI_ATTRS[lower] && (value = _sanitizeUrl(value)), SRCSET_ATTRS[lower] && (srcset = value, 
                    value = (srcset = String(srcset)).split(",").map(srcset => _sanitizeUrl(srcset.trim())).join(", ")), 
                    this.buf.push(" ", attrName, '="', encodeEntities(value), '"');
                }
                var srcset;
                return this.buf.push(">"), !0;
            }
            endElement(current) {
                const tagName = current.nodeName.toLowerCase();
                VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName) && (this.buf.push("</"), 
                this.buf.push(tagName), this.buf.push(">"));
            }
            chars(chars) {
                this.buf.push(encodeEntities(chars));
            }
            checkClobberedElement(node, nextNode) {
                if (nextNode && (node.compareDocumentPosition(nextNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);
                return nextNode;
            }
        }
        const SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
        function encodeEntities(value) {
            return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, (function(match) {
                return "&#" + (1024 * (match.charCodeAt(0) - 55296) + (match.charCodeAt(1) - 56320) + 65536) + ";";
            })).replace(NON_ALPHANUMERIC_REGEXP, (function(match) {
                return "&#" + match.charCodeAt(0) + ";";
            })).replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }
        let inertBodyHelper;
        function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
            let inertBodyElement = null;
            try {
                inertBodyHelper = inertBodyHelper || new InertBodyHelper(defaultDoc);
                let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : "";
                inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
                let mXSSAttempts = 5, parsedHtml = unsafeHtml;
                do {
                    if (0 === mXSSAttempts) throw new Error("Failed to sanitize html because the input is unstable");
                    mXSSAttempts--, unsafeHtml = parsedHtml, parsedHtml = inertBodyElement.innerHTML, 
                    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
                } while (unsafeHtml !== parsedHtml);
                const sanitizer = new SanitizingHtmlSerializer, safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
                return isDevMode() && sanitizer.sanitizedSomething && console.warn("WARNING: sanitizing HTML stripped some content, see http://g.co/ng/security#xss"), 
                safeHtml;
            } finally {
                if (inertBodyElement) {
                    const parent = getTemplateContent(inertBodyElement) || inertBodyElement;
                    for (;parent.firstChild; ) parent.removeChild(parent.firstChild);
                }
            }
        }
        function getTemplateContent(el) {
            return "content" in el && function(el) {
                return el.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === el.nodeName;
            }(el) ? el.content : null;
        }
        const SecurityContext = function() {
            var SecurityContext = {
                NONE: 0,
                HTML: 1,
                STYLE: 2,
                SCRIPT: 3,
                URL: 4,
                RESOURCE_URL: 5
            };
            return SecurityContext[SecurityContext.NONE] = "NONE", SecurityContext[SecurityContext.HTML] = "HTML", 
            SecurityContext[SecurityContext.STYLE] = "STYLE", SecurityContext[SecurityContext.SCRIPT] = "SCRIPT", 
            SecurityContext[SecurityContext.URL] = "URL", SecurityContext[SecurityContext.RESOURCE_URL] = "RESOURCE_URL", 
            SecurityContext;
        }(), SAFE_STYLE_VALUE = new RegExp("^([-,.\"'%_!# a-zA-Z0-9]+|(?:(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|Z|3d)?|(?:rgb|hsl)a?|(?:repeating-)?(?:linear|radial)-gradient|(?:calc|attr))\\([-0-9.%, #a-zA-Z]+\\))$", "g"), URL_RE = /^url\(([^)]+)\)$/;
        function _sanitizeStyle(value) {
            if (!(value = String(value).trim())) return "";
            const urlMatch = value.match(URL_RE);
            return urlMatch && _sanitizeUrl(urlMatch[1]) === urlMatch[1] || value.match(SAFE_STYLE_VALUE) && function(value) {
                let outsideSingle = !0, outsideDouble = !0;
                for (let i = 0; i < value.length; i++) {
                    const c = value.charAt(i);
                    "'" === c && outsideDouble ? outsideSingle = !outsideSingle : '"' === c && outsideSingle && (outsideDouble = !outsideDouble);
                }
                return outsideSingle && outsideDouble;
            }(value) ? value : (isDevMode() && console.warn(`WARNING: sanitizing unsafe style value ${value} (see http://g.co/ng/security#xss).`), 
            "unsafe");
        }
        function ɵɵsanitizeHtml(unsafeHtml) {
            const sanitizer = getSanitizer();
            return sanitizer ? sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || "" : allowSanitizationBypassAndThrow(unsafeHtml, "HTML") ? unwrapSafeValue(unsafeHtml) : _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));
        }
        function ɵɵsanitizeUrl(unsafeUrl) {
            const sanitizer = getSanitizer();
            return sanitizer ? sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || "" : allowSanitizationBypassAndThrow(unsafeUrl, "URL") ? unwrapSafeValue(unsafeUrl) : _sanitizeUrl(renderStringify(unsafeUrl));
        }
        const ɵɵdefaultStyleSanitizer = function(prop, value, mode) {
            let doSanitizeValue = !0;
            return 1 & (mode = mode || 3) && (doSanitizeValue = "background-image" === prop || "background" === prop || "border-image" === prop || "filter" === prop || "list-style" === prop || "list-style-image" === prop || "clip-path" === prop), 
            2 & mode ? doSanitizeValue ? function(unsafeStyle) {
                const sanitizer = getSanitizer();
                return sanitizer ? sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || "" : allowSanitizationBypassAndThrow(unsafeStyle, "Style") ? unwrapSafeValue(unsafeStyle) : _sanitizeStyle(renderStringify(unsafeStyle));
            }(value) : value : doSanitizeValue;
        };
        function getSanitizer() {
            const lView = getLView();
            return lView && lView[SANITIZER];
        }
        function createLContext(lView, nodeIndex, native) {
            return {
                lView: lView,
                nodeIndex: nodeIndex,
                native: native,
                component: void 0,
                directives: void 0,
                localRefs: void 0
            };
        }
        function attachPatchData(target, data) {
            target[MONKEY_PATCH_KEY_NAME] = data;
        }
        function findViaNativeElement(lView, target) {
            let tNode = lView[TVIEW].firstChild;
            for (;tNode; ) {
                if (getNativeByTNodeOrNull(tNode, lView) === target) return tNode.index;
                tNode = traverseNextElement(tNode);
            }
            return -1;
        }
        function traverseNextElement(tNode) {
            if (tNode.child) return tNode.child;
            if (tNode.next) return tNode.next;
            for (;tNode.parent && !tNode.parent.next; ) tNode = tNode.parent;
            return tNode.parent && tNode.parent.next;
        }
        function throwMultipleComponentError(tNode) {
            throw new Error(`Multiple components match node with tagname ${tNode.tagName}`);
        }
        function throwMixedMultiProviderError() {
            throw new Error("Cannot mix multi providers and regular providers");
        }
        function registerPreOrderHooks(directiveIndex, directiveDef, tView, nodeIndex, initialPreOrderHooksLength, initialPreOrderCheckHooksLength) {
            const {onChanges: onChanges, onInit: onInit, doCheck: doCheck} = directiveDef;
            initialPreOrderHooksLength >= 0 && (!tView.preOrderHooks || initialPreOrderHooksLength === tView.preOrderHooks.length) && (onChanges || onInit || doCheck) && (tView.preOrderHooks || (tView.preOrderHooks = [])).push(nodeIndex), 
            initialPreOrderCheckHooksLength >= 0 && (!tView.preOrderCheckHooks || initialPreOrderCheckHooksLength === tView.preOrderCheckHooks.length) && (onChanges || doCheck) && (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(nodeIndex), 
            onChanges && ((tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, onChanges), 
            (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, onChanges)), 
            onInit && (tView.preOrderHooks || (tView.preOrderHooks = [])).push(-directiveIndex, onInit), 
            doCheck && ((tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, doCheck), 
            (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, doCheck));
        }
        function registerPostOrderHooks(tView, tNode) {
            for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {
                const directiveDef = tView.data[i];
                directiveDef.afterContentInit && (tView.contentHooks || (tView.contentHooks = [])).push(-i, directiveDef.afterContentInit), 
                directiveDef.afterContentChecked && ((tView.contentHooks || (tView.contentHooks = [])).push(i, directiveDef.afterContentChecked), 
                (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, directiveDef.afterContentChecked)), 
                directiveDef.afterViewInit && (tView.viewHooks || (tView.viewHooks = [])).push(-i, directiveDef.afterViewInit), 
                directiveDef.afterViewChecked && ((tView.viewHooks || (tView.viewHooks = [])).push(i, directiveDef.afterViewChecked), 
                (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, directiveDef.afterViewChecked)), 
                null != directiveDef.onDestroy && (tView.destroyHooks || (tView.destroyHooks = [])).push(i, directiveDef.onDestroy);
            }
        }
        function executeCheckHooks(lView, hooks, nodeIndex) {
            callHooks(lView, hooks, 3, nodeIndex);
        }
        function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
            (3 & lView[FLAGS]) === initPhase && callHooks(lView, hooks, initPhase, nodeIndex);
        }
        function incrementInitPhaseFlags(lView, initPhase) {
            let flags = lView[FLAGS];
            (3 & flags) === initPhase && (flags &= 1023, lView[FLAGS] = flags += 1);
        }
        function callHooks(currentView, arr, initPhase, currentNodeIndex) {
            const nodeIndexLimit = null != currentNodeIndex ? currentNodeIndex : -1;
            let lastNodeIndexFound = 0;
            for (let i = void 0 !== currentNodeIndex ? 65535 & currentView[PREORDER_HOOK_FLAGS] : 0; i < arr.length; i++) if ("number" == typeof arr[i + 1]) {
                if (lastNodeIndexFound = arr[i], null != currentNodeIndex && lastNodeIndexFound >= currentNodeIndex) break;
            } else arr[i] < 0 && (currentView[PREORDER_HOOK_FLAGS] += 65536), (lastNodeIndexFound < nodeIndexLimit || -1 == nodeIndexLimit) && (callHook(currentView, initPhase, arr, i), 
            currentView[PREORDER_HOOK_FLAGS] = (4294901760 & currentView[PREORDER_HOOK_FLAGS]) + i + 2), 
            i++;
        }
        function callHook(currentView, initPhase, arr, i) {
            const isInitHook = arr[i] < 0, hook = arr[i + 1], directive = currentView[isInitHook ? -arr[i] : arr[i]];
            isInitHook ? currentView[FLAGS] >> 10 < currentView[PREORDER_HOOK_FLAGS] >> 16 && (3 & currentView[FLAGS]) === initPhase && (currentView[FLAGS] += 1024, 
            hook.call(directive)) : hook.call(directive);
        }
        const NG_TEMPLATE_SELECTOR = "ng-template";
        function isCssClassMatching(nodeClassAttrVal, cssClassToMatch) {
            const nodeClassesLen = nodeClassAttrVal.length, matchIndex = nodeClassAttrVal.toLowerCase().indexOf(cssClassToMatch), matchEndIdx = matchIndex + cssClassToMatch.length;
            return !(-1 === matchIndex || matchIndex > 0 && " " !== nodeClassAttrVal[matchIndex - 1] || matchEndIdx < nodeClassesLen && " " !== nodeClassAttrVal[matchEndIdx]);
        }
        function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
            return currentSelector === (0 !== tNode.type || isProjectionMode ? tNode.tagName : NG_TEMPLATE_SELECTOR);
        }
        function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
            let mode = 4;
            const nodeAttrs = tNode.attrs || [], nameOnlyMarkerIdx = function(nodeAttrs) {
                for (let i = 0; i < nodeAttrs.length; i++) if (isNameOnlyAttributeMarker(nodeAttrs[i])) return i;
                return nodeAttrs.length;
            }(nodeAttrs);
            let skipToNextSelector = !1;
            for (let i = 0; i < selector.length; i++) {
                const current = selector[i];
                if ("number" != typeof current) {
                    if (!skipToNextSelector) if (4 & mode) {
                        if (mode = 2 | 1 & mode, "" !== current && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || "" === current && 1 === selector.length) {
                            if (isPositive(mode)) return !1;
                            skipToNextSelector = !0;
                        }
                    } else {
                        const selectorAttrValue = 8 & mode ? current : selector[++i];
                        if (8 & mode && tNode.classes) {
                            if (!isCssClassMatching(getInitialStylingValue(tNode.classes), selectorAttrValue)) {
                                if (isPositive(mode)) return !1;
                                skipToNextSelector = !0;
                            }
                            continue;
                        }
                        const attrIndexInNode = findAttrIndexInNode(8 & mode ? "class" : current, nodeAttrs, 0 == tNode.type && tNode.tagName !== NG_TEMPLATE_SELECTOR, isProjectionMode);
                        if (-1 === attrIndexInNode) {
                            if (isPositive(mode)) return !1;
                            skipToNextSelector = !0;
                            continue;
                        }
                        if ("" !== selectorAttrValue) {
                            let nodeAttrValue;
                            nodeAttrValue = attrIndexInNode > nameOnlyMarkerIdx ? "" : nodeAttrs[attrIndexInNode + 1].toLowerCase();
                            const compareAgainstClassName = 8 & mode ? nodeAttrValue : null;
                            if (compareAgainstClassName && !isCssClassMatching(compareAgainstClassName, selectorAttrValue) || 2 & mode && selectorAttrValue !== nodeAttrValue) {
                                if (isPositive(mode)) return !1;
                                skipToNextSelector = !0;
                            }
                        }
                    }
                } else {
                    if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) return !1;
                    if (skipToNextSelector && isPositive(current)) continue;
                    skipToNextSelector = !1, mode = current | 1 & mode;
                }
            }
            return isPositive(mode) || skipToNextSelector;
        }
        function isPositive(mode) {
            return 0 == (1 & mode);
        }
        function findAttrIndexInNode(name, attrs, isInlineTemplate, isProjectionMode) {
            if (null === attrs) return -1;
            let i = 0;
            if (isProjectionMode || !isInlineTemplate) {
                let bindingsMode = !1;
                for (;i < attrs.length; ) {
                    const maybeAttrName = attrs[i];
                    if (maybeAttrName === name) return i;
                    if (3 === maybeAttrName || 6 === maybeAttrName) bindingsMode = !0; else {
                        if (1 === maybeAttrName || 2 === maybeAttrName) {
                            let value = attrs[++i];
                            for (;"string" == typeof value; ) value = attrs[++i];
                            continue;
                        }
                        if (4 === maybeAttrName) break;
                        if (0 === maybeAttrName) {
                            i += 4;
                            continue;
                        }
                    }
                    i += bindingsMode ? 1 : 2;
                }
                return -1;
            }
            return function(attrs, name) {
                let i = attrs.indexOf(4);
                if (i > -1) for (i++; i < attrs.length; ) {
                    if (attrs[i] === name) return i;
                    i++;
                }
                return -1;
            }(attrs, name);
        }
        function isNodeMatchingSelectorList(tNode, selector, isProjectionMode = !1) {
            for (let i = 0; i < selector.length; i++) if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) return !0;
            return !1;
        }
        function isSelectorInSelectorList(selector, list) {
            selectorListLoop: for (let i = 0; i < list.length; i++) {
                const currentSelectorInList = list[i];
                if (selector.length === currentSelectorInList.length) {
                    for (let j = 0; j < selector.length; j++) if (selector[j] !== currentSelectorInList[j]) continue selectorListLoop;
                    return !0;
                }
            }
            return !1;
        }
        const _state = {
            element: null,
            directiveIndex: -1,
            sourceIndex: -1,
            classesBitMask: -1,
            classesIndex: -1,
            stylesBitMask: -1,
            stylesIndex: -1,
            lastDirectClassMap: null,
            lastDirectStyleMap: null
        }, BIT_MASK_START_VALUE = 0, INDEX_START_VALUE = 1;
        function getStylingState(element, directiveIndex) {
            return _state.element !== element ? (_state.element = element, _state.directiveIndex = directiveIndex, 
            _state.sourceIndex = directiveIndex === TEMPLATE_DIRECTIVE_INDEX ? 0 : 1, _state.classesBitMask = BIT_MASK_START_VALUE, 
            _state.classesIndex = INDEX_START_VALUE, _state.stylesBitMask = BIT_MASK_START_VALUE, 
            _state.stylesIndex = INDEX_START_VALUE, _state.lastDirectClassMap = null, _state.lastDirectStyleMap = null) : _state.directiveIndex !== directiveIndex && (_state.directiveIndex = directiveIndex, 
            _state.sourceIndex++), _state;
        }
        const VALUE_IS_EXTERNALLY_MODIFIED = {}, STYLING_INDEX_FOR_MAP_BINDING = 0;
        function updateClassViaContext(context, tNode, data, element, directiveIndex, prop, bindingIndex, value, forceUpdate, firstUpdatePass) {
            const isMapBased = !prop, state = getStylingState(element, directiveIndex), countIndex = isMapBased ? STYLING_INDEX_FOR_MAP_BINDING : state.classesIndex++;
            return !(!firstUpdatePass && value === NO_CHANGE || !updateBindingData(context, tNode, data, countIndex, state.sourceIndex, prop, bindingIndex, value, forceUpdate, !1, firstUpdatePass, !0) && !forceUpdate || (state.classesBitMask |= 1 << countIndex, 
            0));
        }
        function updateStyleViaContext(context, tNode, data, element, directiveIndex, prop, bindingIndex, value, sanitizer, forceUpdate, firstUpdatePass) {
            const isMapBased = !prop, state = getStylingState(element, directiveIndex), countIndex = isMapBased ? STYLING_INDEX_FOR_MAP_BINDING : state.stylesIndex++;
            if (firstUpdatePass || value !== NO_CHANGE) {
                const sanitizationRequired = !!isMapBased || !!sanitizer && sanitizer(prop, null, 1);
                if (updateBindingData(context, tNode, data, countIndex, state.sourceIndex, prop, bindingIndex, value, forceUpdate, sanitizationRequired, firstUpdatePass, !1) || forceUpdate) return state.stylesBitMask |= 1 << countIndex, 
                !0;
            }
            return !1;
        }
        function updateBindingData(context, tNode, data, counterIndex, sourceIndex, prop, bindingIndex, value, forceUpdate, sanitizationRequired, firstUpdatePass, isClassBased) {
            const hostBindingsMode = isHostStylingActive(sourceIndex), hostBindingsFlag = isClassBased ? 4096 : 131072;
            firstUpdatePass && registerBinding(context, tNode, counterIndex, sourceIndex, prop, bindingIndex, sanitizationRequired, isClassBased);
            const changed = forceUpdate || hasValueChanged(data[bindingIndex], value);
            return changed && (setValue(data, bindingIndex, value), hasConfig(tNode, hostBindingsFlag) && !hostBindingsMode && (!prop || !value) && function(context, tNode, data, prop, isClassBased) {
                const valuesCount = getValuesCount(context);
                if (null !== prop && hasConfig(tNode, isClassBased ? 4096 : 131072)) {
                    const itemsPerRow = 4 + valuesCount;
                    let i = 2, found = !1;
                    for (;i < context.length; ) {
                        if (getProp(context, i) === prop) {
                            found = !0;
                            break;
                        }
                        i += itemsPerRow;
                    }
                    if (found) {
                        const bindingsStart = i + 4, valuesEnd = bindingsStart + valuesCount - 1;
                        for (let i = bindingsStart + 1; i < valuesEnd; i++) {
                            const bindingIndex = context[i];
                            0 !== bindingIndex && setValue(data, bindingIndex, null);
                        }
                    }
                }
                if (hasConfig(tNode, isClassBased ? 512 : 16384)) {
                    const bindingsStart = 6, valuesEnd = bindingsStart + valuesCount - 1;
                    for (let i = bindingsStart + 1; i < valuesEnd; i++) {
                        const stylingMap = getValue(data, context[i]);
                        stylingMap && (stylingMap[0] = MAP_DIRTY_VALUE);
                    }
                }
            }(context, tNode, data, prop, isClassBased)), changed;
        }
        function registerBinding(context, tNode, countId, sourceIndex, prop, bindingValue, sanitizationRequired, isClassBased) {
            let found = !1;
            prop = prop || MAP_BASED_ENTRY_PROP_NAME;
            let totalSources = getTotalSources(context);
            for (;totalSources <= sourceIndex; ) addNewSourceColumn(context), totalSources++;
            const collisionFlag = isClassBased ? 8192 : 262144, isBindingIndexValue = "number" == typeof bindingValue, entriesPerRow = 4 + getValuesCount(context);
            let i = 2;
            for (;i < context.length; ) {
                const p = getProp(context, i);
                if (prop <= p) {
                    prop < p ? allocateNewContextEntry(context, i, prop, sanitizationRequired) : isBindingIndexValue && patchConfig(tNode, collisionFlag), 
                    addBindingIntoContext(context, i, bindingValue, countId, sourceIndex), found = !0;
                    break;
                }
                i += entriesPerRow;
            }
            found || (allocateNewContextEntry(context, context.length, prop, sanitizationRequired), 
            addBindingIntoContext(context, i, bindingValue, countId, sourceIndex));
        }
        function allocateNewContextEntry(context, index, prop, sanitizationRequired) {
            context.splice(index, 0, sanitizationRequired ? 1 : 0, DEFAULT_GUARD_MASK_VALUE, DEFAULT_GUARD_MASK_VALUE, prop), 
            index += 4;
            const totalBindingsPerEntry = getTotalSources(context);
            for (let i = 0; i < totalBindingsPerEntry; i++) context.splice(index, 0, DEFAULT_BINDING_INDEX), 
            index++;
            context.splice(index, 0, DEFAULT_BINDING_VALUE);
        }
        function addBindingIntoContext(context, index, bindingValue, bitIndex, sourceIndex) {
            if ("number" == typeof bindingValue) {
                const hostBindingsMode = isHostStylingActive(sourceIndex);
                context[index + 4 + sourceIndex] = bindingValue, function(context, index, maskValue, isHostBinding) {
                    context[index + (isHostBinding ? 2 : 1)] = maskValue;
                }(context, index, getGuardMask(context, index, hostBindingsMode) | 1 << bitIndex, hostBindingsMode);
            } else null !== bindingValue && null === getDefaultValue(context, index) && function(context, index, value) {
                context[index + 4 + getTotalSources(context)] = value;
            }(context, index, bindingValue);
        }
        function addNewSourceColumn(context) {
            const insertOffset = 4 + getValuesCount(context) - 1;
            let index = 2;
            for (;index < context.length; ) index += insertOffset, context.splice(index++, 0, DEFAULT_BINDING_INDEX), 
            index++;
            context[0]++;
        }
        function syncContextInitialStyling(context, tNode, isClassBased) {
            !function(context, tNode, initialStyling, isClassBased) {
                let hasInitialStyling = !1;
                for (let i = 1; i < initialStyling.length; i += 2) {
                    const value = getMapValue(initialStyling, i);
                    value && (registerBinding(context, tNode, -1, 0, getMapProp(initialStyling, i), value, !1, isClassBased), 
                    hasInitialStyling = !0);
                }
                hasInitialStyling && patchConfig(tNode, 256);
            }(context, tNode, getStylingMapArray(context), isClassBased);
        }
        function applyStylingViaContext(context, tNode, renderer, element, bindingData, bitMaskValue, applyStylingFn, sanitizer, hostBindingsMode, isClassBased) {
            const bitMask = !0 === (value = bitMaskValue) ? -1 : !1 === value ? 0 : value;
            var value;
            let stylingMapsSyncFn = null, applyAllValues = !1;
            hasConfig(tNode, isClassBased ? 512 : 16384) && (stylingMapsSyncFn = _activeStylingMapApplyFn, 
            applyAllValues = 0 != (bitMask & getGuardMask(context, 2, hostBindingsMode)));
            const valuesCount = getValuesCount(context);
            let totalBindingsToVisit = 1, mapsMode = applyAllValues ? 1 : 0;
            hostBindingsMode && (mapsMode |= 8, totalBindingsToVisit = valuesCount - 1);
            let i = function(context, tNode, isClassBased) {
                let startPosition = 2;
                return hasConfig(tNode, isClassBased ? 512 : 16384) && (startPosition += 4 + getValuesCount(context)), 
                startPosition;
            }(context, tNode, isClassBased);
            for (;i < context.length; ) {
                if (bitMask & getGuardMask(context, i, hostBindingsMode)) {
                    let valueApplied = !1;
                    const prop = getProp(context, i), defaultValue = getDefaultValue(context, i);
                    for (let j = 0; j < totalBindingsToVisit; j++) {
                        const bindingIndex = getBindingValue(context, i, j);
                        if (!valueApplied && 0 !== bindingIndex) {
                            const value = getValue(bindingData, bindingIndex);
                            isStylingValueDefined(value) && (hostBindingsMode && 0 === j || applyStylingFn(renderer, element, prop, sanitizer && isSanitizationRequired(context, i) ? sanitizer(prop, value, 2) : unwrapSafeValue(value), bindingIndex), 
                            valueApplied = !0);
                        }
                        if (stylingMapsSyncFn) {
                            let mode = mapsMode | (valueApplied ? 4 : 2);
                            hostBindingsMode && 0 === j && (mode |= 16);
                            const valueAppliedWithinMap = stylingMapsSyncFn(context, renderer, element, bindingData, j, applyStylingFn, sanitizer, mode, prop, defaultValue);
                            valueApplied = valueApplied || valueAppliedWithinMap;
                        }
                    }
                    valueApplied || applyStylingFn(renderer, element, prop, defaultValue);
                }
                i += 4 + valuesCount;
            }
            stylingMapsSyncFn && (hostBindingsMode && (mapsMode |= 16), stylingMapsSyncFn(context, renderer, element, bindingData, 0, applyStylingFn, sanitizer, mapsMode));
        }
        function writeStylingValueDirectly(renderer, element, value, isClassBased, initialValue) {
            let valueToApply;
            return isClassBased ? (valueToApply = "string" == typeof value ? value : function(obj) {
                let str = "";
                if (obj) for (let key in obj) obj[key] && (str += (str.length ? " " : "") + key);
                return str;
            }(value), null !== initialValue && (valueToApply = concatString(initialValue, valueToApply, " ")), 
            setClassName(renderer, element, valueToApply)) : (valueToApply = forceStylesAsString(value, !0), 
            null !== initialValue && (valueToApply = initialValue + ";" + valueToApply), setStyleAttr(renderer, element, valueToApply)), 
            valueToApply;
        }
        function applyStylingValue(renderer, element, prop, value, applyFn, bindingIndex, sanitizer) {
            let valueToApply = unwrapSafeValue(value);
            return !!isStylingValueDefined(valueToApply) && (applyFn(renderer, element, prop, valueToApply = sanitizer ? sanitizer(prop, value, 3) : valueToApply, bindingIndex), 
            !0);
        }
        function findAndApplyMapValue(renderer, element, applyFn, map, prop, bindingIndex, sanitizer) {
            for (let i = 1; i < map.length; i += 2) {
                const p = getMapProp(map, i);
                if (p === prop) {
                    let valueToApply = getMapValue(map, i);
                    return applyFn(renderer, element, prop, valueToApply = sanitizer ? sanitizer(prop, valueToApply, 3) : valueToApply, bindingIndex), 
                    !0;
                }
                if (p > prop) break;
            }
            return !1;
        }
        let _activeStylingMapApplyFn = null;
        const setStyle = (renderer, native, prop, value) => {
            if (null !== renderer) if (isStylingValueDefined(value)) if (value = value.toString(), 
            isProceduralRenderer(renderer)) renderer.setStyle(native, prop, value, RendererStyleFlags3.DashCase); else {
                const nativeStyle = native.style;
                null != nativeStyle && nativeStyle.setProperty(prop, value);
            } else if (isProceduralRenderer(renderer)) renderer.removeStyle(native, prop, RendererStyleFlags3.DashCase); else {
                const nativeStyle = native.style;
                null != nativeStyle && nativeStyle.removeProperty(prop);
            }
        }, setClass = (renderer, native, className, value) => {
            if (null !== renderer && "" !== className) if (value) if (isProceduralRenderer(renderer)) renderer.addClass(native, className); else {
                const classList = native.classList;
                null != classList && classList.add(className);
            } else if (isProceduralRenderer(renderer)) renderer.removeClass(native, className); else {
                const classList = native.classList;
                null != classList && classList.remove(className);
            }
        }, setClassName = (renderer, native, className) => {
            null !== renderer && (isProceduralRenderer(renderer) ? renderer.setAttribute(native, "class", className) : native.className = className);
        }, setStyleAttr = (renderer, native, value) => {
            null !== renderer && (isProceduralRenderer(renderer) ? renderer.setAttribute(native, "style", value) : native.setAttribute("style", value));
        };
        function renderStylingMap(renderer, element, stylingValues, isClassBased) {
            const stylingMapArr = getStylingMapArray(stylingValues);
            if (stylingMapArr) for (let i = 1; i < stylingMapArr.length; i += 2) {
                const prop = getMapProp(stylingMapArr, i), value = getMapValue(stylingMapArr, i);
                isClassBased ? setClass(renderer, element, prop, value, null) : setStyle(renderer, element, prop, value, null);
            }
        }
        function ɵɵadvance(delta) {
            selectIndexInternal(getLView(), getSelectedIndex() + delta, getCheckNoChangesMode());
        }
        function selectIndexInternal(lView, index, checkNoChangesMode) {
            if (hasActiveElementFlag(1) && executeElementExitFn(), !checkNoChangesMode) if (3 == (3 & lView[FLAGS])) {
                const preOrderCheckHooks = lView[TVIEW].preOrderCheckHooks;
                null !== preOrderCheckHooks && executeCheckHooks(lView, preOrderCheckHooks, index);
            } else {
                const preOrderHooks = lView[TVIEW].preOrderHooks;
                null !== preOrderHooks && executeInitAndCheckHooks(lView, preOrderHooks, 0, index);
            }
            setSelectedIndex(index);
        }
        const syncStylingMap = (context, renderer, element, data, sourceIndex, applyStylingFn, sanitizer, mode, targetProp, defaultValue) => {
            let targetPropValueWasApplied = !1;
            if (getValuesCount(context)) {
                let runTheSyncAlgorithm = !0;
                const loopUntilEnd = !targetProp;
                loopUntilEnd && 0 == (1 & mode) && (runTheSyncAlgorithm = !1, targetPropValueWasApplied = !0), 
                runTheSyncAlgorithm && (targetPropValueWasApplied = function innerSyncStylingMap(context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp, currentMapIndex, defaultValue) {
                    const mapsLimit = getValuesCount(context) - 1 - 1, recurseInnerMaps = currentMapIndex < mapsLimit && 0 != (8 & mode), checkValuesOnly = 0 != (16 & mode);
                    checkValuesOnly && (mode &= -17);
                    let targetPropValueWasApplied = !1;
                    if (currentMapIndex <= mapsLimit) {
                        let cursor = ((mapIndex = currentMapIndex) >= MAP_CURSORS.length && MAP_CURSORS.push(1), 
                        MAP_CURSORS[mapIndex]);
                        const bindingIndex = getBindingValue(context, 2, currentMapIndex), stylingMapArr = getValue(data, bindingIndex);
                        if (stylingMapArr) {
                            for (;cursor < stylingMapArr.length; ) {
                                const prop = getMapProp(stylingMapArr, cursor), iteratedTooFar = targetProp && prop > targetProp, isTargetPropMatched = !iteratedTooFar && prop === targetProp, value = getMapValue(stylingMapArr, cursor), valueIsDefined = isStylingValueDefined(value), innerMode = iteratedTooFar ? mode : resolveInnerMapMode(mode, valueIsDefined, isTargetPropMatched), innerProp = iteratedTooFar ? targetProp : prop;
                                let valueApplied = !!recurseInnerMaps && innerSyncStylingMap(context, renderer, element, data, applyStylingFn, sanitizer, innerMode, innerProp, currentMapIndex + 1, defaultValue);
                                if (iteratedTooFar) {
                                    targetPropValueWasApplied || (targetPropValueWasApplied = valueApplied);
                                    break;
                                }
                                if (!valueApplied && isValueAllowedToBeApplied(mode, isTargetPropMatched) && (valueApplied = !0, 
                                !checkValuesOnly)) {
                                    const bindingIndexToApply = isTargetPropMatched ? bindingIndex : null;
                                    let finalValue;
                                    applyStylingFn(renderer, element, prop, finalValue = isTargetPropMatched && !valueIsDefined ? defaultValue : sanitizer ? sanitizer(prop, value, 3) : value ? unwrapSafeValue(value) : null, bindingIndexToApply);
                                }
                                targetPropValueWasApplied = valueApplied && isTargetPropMatched, cursor += 2;
                            }
                            MAP_CURSORS[currentMapIndex] = cursor, !recurseInnerMaps || 1 !== stylingMapArr.length && targetProp || (targetPropValueWasApplied = innerSyncStylingMap(context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp, currentMapIndex + 1, defaultValue));
                        } else recurseInnerMaps && (targetPropValueWasApplied = innerSyncStylingMap(context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp, currentMapIndex + 1, defaultValue));
                    }
                    var mapIndex;
                    return targetPropValueWasApplied;
                }(context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp || null, sourceIndex, defaultValue || null)), 
                loopUntilEnd && function() {
                    for (let i = 0; i < MAP_CURSORS.length; i++) MAP_CURSORS[i] = 1;
                }();
            }
            return targetPropValueWasApplied;
        };
        function resolveInnerMapMode(currentMode, valueIsDefined, isTargetPropMatched) {
            let innerMode = currentMode;
            return !valueIsDefined && (isTargetPropMatched ? 2 & currentMode : 1 & currentMode) ? (innerMode |= 2, 
            innerMode &= -5) : (innerMode |= 4, innerMode &= -3), innerMode;
        }
        function isValueAllowedToBeApplied(mode, isTargetPropMatched) {
            let doApplyValue = 0 != (1 & mode);
            return doApplyValue ? 4 & mode && isTargetPropMatched && (doApplyValue = !1) : 2 & mode && (doApplyValue = isTargetPropMatched), 
            doApplyValue;
        }
        const MAP_CURSORS = [];
        function refreshContentQueries(tView, lView) {
            const contentQueries = tView.contentQueries;
            if (null !== contentQueries) for (let i = 0; i < contentQueries.length; i += 2) {
                const queryStartIdx = contentQueries[i], directiveDefIdx = contentQueries[i + 1];
                if (-1 !== directiveDefIdx) {
                    const directiveDef = tView.data[directiveDefIdx];
                    setCurrentQueryIndex(queryStartIdx), directiveDef.contentQueries(2, lView[directiveDefIdx], directiveDefIdx);
                }
            }
        }
        function elementCreate(name, renderer, namespace) {
            return isProceduralRenderer(renderer) ? renderer.createElement(name, namespace) : null === namespace ? renderer.createElement(name) : renderer.createElementNS(namespace, name);
        }
        function createLView(parentLView, tView, context, flags, host, tHostNode, rendererFactory, renderer, sanitizer, injector) {
            const lView = tView.blueprint.slice();
            return lView[HOST] = host, lView[FLAGS] = 140 | flags, resetPreOrderHookFlags(lView), 
            lView[PARENT] = lView[DECLARATION_VIEW] = parentLView, lView[CONTEXT] = context, 
            lView[RENDERER_FACTORY] = rendererFactory || parentLView && parentLView[RENDERER_FACTORY], 
            lView[RENDERER] = renderer || parentLView && parentLView[RENDERER], lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] || null, 
            lView[INJECTOR$1] = injector || parentLView && parentLView[INJECTOR$1] || null, 
            lView[T_HOST] = tHostNode, lView;
        }
        function getOrCreateTNode(tView, tHostNode, index, type, name, attrs) {
            const adjustedIndex = index + HEADER_OFFSET, tNode = tView.data[adjustedIndex] || function(tView, tHostNode, adjustedIndex, type, name, attrs) {
                const previousOrParentTNode = getPreviousOrParentTNode(), isParent = getIsParent(), parent = isParent ? previousOrParentTNode : previousOrParentTNode && previousOrParentTNode.parent, tNode = tView.data[adjustedIndex] = createTNode(0, parent && parent !== tHostNode ? parent : null, type, adjustedIndex, name, attrs);
                return null === tView.firstChild && (tView.firstChild = tNode), previousOrParentTNode && (!isParent || null != previousOrParentTNode.child || null === tNode.parent && 2 !== previousOrParentTNode.type ? isParent || (previousOrParentTNode.next = tNode) : previousOrParentTNode.child = tNode), 
                tNode;
            }(tView, tHostNode, adjustedIndex, type, name, attrs);
            return setPreviousOrParentTNode(tNode, !0), tNode;
        }
        function renderView(lView, tView, context) {
            enterView(lView, lView[T_HOST]);
            try {
                const viewQuery = tView.viewQuery;
                null !== viewQuery && executeViewQueryFn(1, viewQuery, context);
                const templateFn = tView.template;
                null !== templateFn && executeTemplate(lView, templateFn, 1, context), tView.firstCreatePass && (tView.firstCreatePass = !1), 
                tView.staticContentQueries && refreshContentQueries(tView, lView), tView.staticViewQueries && executeViewQueryFn(2, tView.viewQuery, context);
                const components = tView.components;
                null !== components && function(hostLView, components) {
                    for (let i = 0; i < components.length; i++) renderComponent(hostLView, components[i]);
                }(lView, components);
            } finally {
                lView[FLAGS] &= -5, leaveView();
            }
        }
        function refreshView(lView, tView, templateFn, context) {
            enterView(lView, lView[T_HOST]);
            const flags = lView[FLAGS];
            try {
                resetPreOrderHookFlags(lView), setBindingIndex(tView.bindingStartIndex), null !== templateFn && executeTemplate(lView, templateFn, 2, context);
                const checkNoChangesMode = getCheckNoChangesMode(), hooksInitPhaseCompleted = 3 == (3 & flags);
                if (!checkNoChangesMode) if (hooksInitPhaseCompleted) {
                    const preOrderCheckHooks = tView.preOrderCheckHooks;
                    null !== preOrderCheckHooks && executeCheckHooks(lView, preOrderCheckHooks, null);
                } else {
                    const preOrderHooks = tView.preOrderHooks;
                    null !== preOrderHooks && executeInitAndCheckHooks(lView, preOrderHooks, 0, null), 
                    incrementInitPhaseFlags(lView, 0);
                }
                if (function(lView) {
                    let viewOrContainer = lView[CHILD_HEAD];
                    for (;null !== viewOrContainer; ) {
                        if (isLContainer(viewOrContainer) && -1 === viewOrContainer[ACTIVE_INDEX]) {
                            for (let i = CONTAINER_HEADER_OFFSET; i < viewOrContainer.length; i++) {
                                const embeddedLView = viewOrContainer[i], embeddedTView = embeddedLView[TVIEW];
                                refreshView(embeddedLView, embeddedTView, embeddedTView.template, embeddedLView[CONTEXT]);
                            }
                            const movedViews = viewOrContainer[MOVED_VIEWS];
                            if (null !== movedViews) {
                                const declaredComponentLView = findComponentView(lView);
                                for (let i = 0; i < movedViews.length; i++) {
                                    const movedLView = movedViews[i];
                                    let parentLView = movedLView[PARENT];
                                    for (;isLContainer(parentLView); ) parentLView = parentLView[PARENT];
                                    const insertedComponentLView = findComponentView(parentLView);
                                    if (16 != (16 & insertedComponentLView[FLAGS]) && insertedComponentLView !== declaredComponentLView) {
                                        const movedTView = movedLView[TVIEW];
                                        refreshView(movedLView, movedTView, movedTView.template, movedLView[CONTEXT]);
                                    }
                                }
                            }
                        }
                        viewOrContainer = viewOrContainer[NEXT];
                    }
                }(lView), null !== tView.contentQueries && refreshContentQueries(tView, lView), 
                !checkNoChangesMode) if (hooksInitPhaseCompleted) {
                    const contentCheckHooks = tView.contentCheckHooks;
                    null !== contentCheckHooks && executeCheckHooks(lView, contentCheckHooks);
                } else {
                    const contentHooks = tView.contentHooks;
                    null !== contentHooks && executeInitAndCheckHooks(lView, contentHooks, 1), incrementInitPhaseFlags(lView, 1);
                }
                !function(tView, lView) {
                    const selectedIndex = getSelectedIndex();
                    try {
                        if (null !== tView.expandoInstructions) {
                            let bindingRootIndex = setBindingIndex(tView.expandoStartIndex);
                            setBindingRoot(bindingRootIndex);
                            let currentDirectiveIndex = -1, currentElementIndex = -1;
                            for (let i = 0; i < tView.expandoInstructions.length; i++) {
                                const instruction = tView.expandoInstructions[i];
                                if ("number" == typeof instruction) {
                                    if (instruction <= 0) {
                                        setActiveHostElement(currentElementIndex = -instruction);
                                        const providerCount = tView.expandoInstructions[++i];
                                        currentDirectiveIndex = bindingRootIndex += INJECTOR_BLOOM_PARENT_SIZE + providerCount;
                                    } else bindingRootIndex += instruction;
                                    setBindingRoot(bindingRootIndex);
                                } else null !== instruction && (incrementActiveDirectiveId(), setBindingIndex(bindingRootIndex), 
                                instruction(2, unwrapRNode(lView[currentDirectiveIndex]), currentElementIndex)), 
                                currentDirectiveIndex++;
                            }
                        }
                    } finally {
                        setActiveHostElement(selectedIndex);
                    }
                }(tView, lView);
                const components = tView.components;
                null !== components && function(hostLView, components) {
                    for (let i = 0; i < components.length; i++) refreshComponent(hostLView, components[i]);
                }(lView, components);
                const viewQuery = tView.viewQuery;
                if (null !== viewQuery && executeViewQueryFn(2, viewQuery, context), !checkNoChangesMode) if (hooksInitPhaseCompleted) {
                    const viewCheckHooks = tView.viewCheckHooks;
                    null !== viewCheckHooks && executeCheckHooks(lView, viewCheckHooks);
                } else {
                    const viewHooks = tView.viewHooks;
                    null !== viewHooks && executeInitAndCheckHooks(lView, viewHooks, 2), incrementInitPhaseFlags(lView, 2);
                }
            } finally {
                !0 === tView.firstUpdatePass && (tView.firstUpdatePass = !1), lView[FLAGS] &= -73, 
                hasActiveElementFlag(1) && executeElementExitFn(), leaveView();
            }
        }
        function renderComponentOrTemplate(hostView, templateFn, context) {
            const rendererFactory = hostView[RENDERER_FACTORY], normalExecutionPath = !getCheckNoChangesMode(), creationModeIsActive = isCreationMode(hostView);
            try {
                normalExecutionPath && !creationModeIsActive && rendererFactory.begin && rendererFactory.begin();
                const tView = hostView[TVIEW];
                creationModeIsActive && renderView(hostView, tView, context), refreshView(hostView, tView, templateFn, context);
            } finally {
                normalExecutionPath && !creationModeIsActive && rendererFactory.end && rendererFactory.end();
            }
        }
        function executeTemplate(lView, templateFn, rf, context) {
            const prevSelectedIndex = getSelectedIndex();
            try {
                setActiveHostElement(null), 2 & rf && lView.length > HEADER_OFFSET && selectIndexInternal(lView, 0, getCheckNoChangesMode()), 
                templateFn(rf, context);
            } finally {
                hasActiveElementFlag(1) && executeElementExitFn(), setSelectedIndex(prevSelectedIndex);
            }
        }
        function executeContentQueries(tView, tNode, lView) {
            if (isContentQueryHost(tNode)) {
                const end = tNode.directiveEnd;
                for (let directiveIndex = tNode.directiveStart; directiveIndex < end; directiveIndex++) {
                    const def = tView.data[directiveIndex];
                    def.contentQueries && def.contentQueries(1, lView[directiveIndex], directiveIndex);
                }
            }
        }
        function createDirectivesInstances(tView, lView, tNode) {
            getBindingsEnabled() && (function(tView, lView, tNode, native) {
                const start = tNode.directiveStart, end = tNode.directiveEnd;
                tView.firstCreatePass || getOrCreateNodeInjectorForNode(tNode, lView), attachPatchData(native, lView);
                const initialInputs = tNode.initialInputs;
                for (let i = start; i < end; i++) {
                    const def = tView.data[i], isComponent = isComponentDef(def);
                    isComponent && addComponentLogic(lView, tNode, def);
                    const directive = getNodeInjectable(tView.data, lView, i, tNode);
                    attachPatchData(directive, lView), null !== initialInputs && setInputsFromAttrs(0, i - start, directive, def, 0, initialInputs), 
                    isComponent && (getComponentLViewByIndex(tNode.index, lView)[CONTEXT] = directive);
                }
            }(tView, lView, tNode, getNativeByTNode(tNode, lView)), 128 == (128 & tNode.flags) && function(tView, viewData, tNode) {
                const start = tNode.directiveStart, end = tNode.directiveEnd, expando = tView.expandoInstructions, firstCreatePass = tView.firstCreatePass, elementIndex = tNode.index - HEADER_OFFSET;
                try {
                    setActiveHostElement(elementIndex);
                    for (let i = start; i < end; i++) {
                        const def = tView.data[i], directive = viewData[i];
                        def.hostBindings ? (incrementActiveDirectiveId(), invokeHostBindingsInCreationMode(def, expando, directive, tNode, firstCreatePass)) : firstCreatePass && expando.push(null);
                    }
                } finally {
                    setActiveHostElement(null);
                }
            }(tView, lView, tNode));
        }
        function saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {
            const localNames = tNode.localNames;
            if (localNames) {
                let localIndex = tNode.index + 1;
                for (let i = 0; i < localNames.length; i += 2) {
                    const index = localNames[i + 1], value = -1 === index ? localRefExtractor(tNode, viewData) : viewData[index];
                    viewData[localIndex++] = value;
                }
            }
        }
        function getOrCreateTComponentView(def) {
            return def.tView || (def.tView = createTView(0, -1, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts));
        }
        function createTView(type, viewIndex, templateFn, decls, vars, directives, pipes, viewQuery, schemas, consts) {
            const bindingStartIndex = HEADER_OFFSET + decls, initialViewLength = bindingStartIndex + vars, blueprint = function(bindingStartIndex, initialViewLength) {
                const blueprint = [];
                for (let i = 0; i < initialViewLength; i++) blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);
                return (blueprint);
            }(bindingStartIndex, initialViewLength);
            return blueprint[TVIEW] = {
                id: viewIndex,
                blueprint: blueprint,
                template: templateFn,
                queries: null,
                viewQuery: viewQuery,
                node: null,
                data: blueprint.slice().fill(null, bindingStartIndex),
                bindingStartIndex: bindingStartIndex,
                expandoStartIndex: initialViewLength,
                expandoInstructions: null,
                firstCreatePass: !0,
                firstUpdatePass: !0,
                staticViewQueries: !1,
                staticContentQueries: !1,
                preOrderHooks: null,
                preOrderCheckHooks: null,
                contentHooks: null,
                contentCheckHooks: null,
                viewHooks: null,
                viewCheckHooks: null,
                destroyHooks: null,
                cleanup: null,
                contentQueries: null,
                components: null,
                directiveRegistry: "function" == typeof directives ? directives() : directives,
                pipeRegistry: "function" == typeof pipes ? pipes() : pipes,
                firstChild: null,
                schemas: schemas,
                consts: consts
            };
        }
        function createTNode(tView, tParent, type, adjustedIndex, tagName, attrs) {
            return {
                type: type,
                index: adjustedIndex,
                injectorIndex: tParent ? tParent.injectorIndex : -1,
                directiveStart: -1,
                directiveEnd: -1,
                propertyBindings: null,
                flags: 0,
                providerIndexes: 0,
                tagName: tagName,
                attrs: attrs,
                localNames: null,
                initialInputs: void 0,
                inputs: void 0,
                outputs: void 0,
                tViews: null,
                next: null,
                projectionNext: null,
                child: null,
                parent: tParent,
                projection: null,
                styles: null,
                classes: null
            };
        }
        function generatePropertyAliases(inputAliasMap, directiveDefIdx, propStore) {
            for (let publicName in inputAliasMap) if (inputAliasMap.hasOwnProperty(publicName)) {
                const internalName = inputAliasMap[publicName];
                (propStore = null === propStore ? {} : propStore).hasOwnProperty(publicName) ? propStore[publicName].push(directiveDefIdx, publicName, internalName) : propStore[publicName] = [ directiveDefIdx, publicName, internalName ];
            }
            return propStore;
        }
        function elementPropertyInternal(lView, index, propName, value, sanitizer, nativeOnly, loadRendererFn) {
            const element = getNativeByIndex(index, lView), tNode = getTNode(index, lView);
            let dataValue, inputData = tNode.inputs;
            if (!nativeOnly && null != inputData && (dataValue = inputData[propName])) setInputsForProperty(lView, dataValue, value), 
            isComponentHost(tNode) && function(lView, viewIndex) {
                const childComponentLView = getComponentLViewByIndex(viewIndex, lView);
                16 & childComponentLView[FLAGS] || (childComponentLView[FLAGS] |= 64);
            }(lView, index + HEADER_OFFSET); else if (3 === tNode.type) {
                propName = "class" === (name = propName) ? "className" : "for" === name ? "htmlFor" : "formaction" === name ? "formAction" : "innerHtml" === name ? "innerHTML" : "readonly" === name ? "readOnly" : "tabindex" === name ? "tabIndex" : name;
                const renderer = loadRendererFn ? loadRendererFn(tNode, lView) : lView[RENDERER];
                value = null != sanitizer ? sanitizer(value, tNode.tagName || "", propName) : value, 
                isProceduralRenderer(renderer) ? renderer.setProperty(element, propName, value) : isAnimationProp(propName) || (element.setProperty ? element.setProperty(propName, value) : element[propName] = value);
            }
            var name;
        }
        function resolveDirectives(tView, lView, tNode, localRefs) {
            if (!getBindingsEnabled()) return !1;
            const directives = function(tView, viewData, tNode) {
                const registry = tView.directiveRegistry;
                let matches = null;
                if (registry) for (let i = 0; i < registry.length; i++) {
                    const def = registry[i];
                    isNodeMatchingSelectorList(tNode, def.selectors, !1) && (matches || (matches = []), 
                    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, viewData), tView, def.type), 
                    isComponentDef(def) ? (2 & tNode.flags && throwMultipleComponentError(tNode), markAsComponentHost(tView, tNode), 
                    matches.unshift(def)) : matches.push(def));
                }
                return matches;
            }(tView, lView, tNode), exportsMap = null === localRefs ? null : {
                "": -1
            };
            let hasDirectives = !1;
            if (null !== directives) {
                hasDirectives = !0, initNodeFlags(tNode, tView.data.length, directives.length);
                for (let i = 0; i < directives.length; i++) {
                    const def = directives[i];
                    def.providersResolver && def.providersResolver(def);
                }
                generateExpandoInstructionBlock(tView, tNode, directives.length);
                const initialPreOrderHooksLength = tView.preOrderHooks && tView.preOrderHooks.length || 0, initialPreOrderCheckHooksLength = tView.preOrderCheckHooks && tView.preOrderCheckHooks.length || 0, nodeIndex = tNode.index - HEADER_OFFSET;
                for (let i = 0; i < directives.length; i++) {
                    const def = directives[i], directiveDefIdx = tView.data.length;
                    baseResolveDirective(tView, lView, def), saveNameToExportMap(tView.data.length - 1, def, exportsMap), 
                    null !== def.contentQueries && (tNode.flags |= 8), null !== def.hostBindings && (tNode.flags |= 128), 
                    registerPreOrderHooks(directiveDefIdx, def, tView, nodeIndex, initialPreOrderHooksLength, initialPreOrderCheckHooksLength);
                }
                !function(tView, tNode) {
                    const end = tNode.directiveEnd, defs = tView.data, tNodeAttrs = tNode.attrs, inputsFromAttrs = [];
                    let inputsStore = null, outputsStore = null;
                    for (let i = tNode.directiveStart; i < end; i++) {
                        const directiveDef = defs[i], directiveInputs = directiveDef.inputs;
                        inputsFromAttrs.push(null !== tNodeAttrs ? generateInitialInputs(directiveInputs, tNodeAttrs) : null), 
                        inputsStore = generatePropertyAliases(directiveInputs, i, inputsStore), outputsStore = generatePropertyAliases(directiveDef.outputs, i, outputsStore);
                    }
                    null !== inputsStore && ((inputsStore.hasOwnProperty("class") || inputsStore.hasOwnProperty("className")) && (tNode.flags |= 16), 
                    inputsStore.hasOwnProperty("style") && (tNode.flags |= 32)), tNode.initialInputs = inputsFromAttrs, 
                    tNode.inputs = inputsStore, tNode.outputs = outputsStore;
                }(tView, tNode);
            }
            return exportsMap && function(tNode, localRefs, exportsMap) {
                if (localRefs) {
                    const localNames = tNode.localNames = [];
                    for (let i = 0; i < localRefs.length; i += 2) {
                        const index = exportsMap[localRefs[i + 1]];
                        if (null == index) throw new Error(`Export of name '${localRefs[i + 1]}' not found!`);
                        localNames.push(localRefs[i], index);
                    }
                }
            }(tNode, localRefs, exportsMap), hasDirectives;
        }
        function invokeHostBindingsInCreationMode(def, expando, directive, tNode, firstCreatePass) {
            const previousExpandoLength = expando.length;
            setCurrentDirectiveDef(def), def.hostBindings(1, directive, tNode.index - HEADER_OFFSET), 
            setCurrentDirectiveDef(null), previousExpandoLength === expando.length && firstCreatePass && expando.push(def.hostBindings);
        }
        function generateExpandoInstructionBlock(tView, tNode, directiveCount) {
            const elementIndex = -(tNode.index - HEADER_OFFSET), providerCount = tView.data.length - (65535 & tNode.providerIndexes);
            (tView.expandoInstructions || (tView.expandoInstructions = [])).push(elementIndex, providerCount, directiveCount);
        }
        function markAsComponentHost(tView, hostTNode) {
            hostTNode.flags |= 2, (tView.components || (tView.components = [])).push(hostTNode.index);
        }
        function saveNameToExportMap(index, def, exportsMap) {
            if (exportsMap) {
                if (def.exportAs) for (let i = 0; i < def.exportAs.length; i++) exportsMap[def.exportAs[i]] = index;
                def.template && (exportsMap[""] = index);
            }
        }
        function initNodeFlags(tNode, index, numberOfDirectives) {
            tNode.flags |= 1, tNode.directiveStart = index, tNode.directiveEnd = index + numberOfDirectives, 
            tNode.providerIndexes = index;
        }
        function baseResolveDirective(tView, viewData, def) {
            tView.data.push(def);
            const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type)), nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), null);
            tView.blueprint.push(nodeInjectorFactory), viewData.push(nodeInjectorFactory);
        }
        function addComponentLogic(lView, hostTNode, def) {
            const native = getNativeByTNode(hostTNode, lView), tView = getOrCreateTComponentView(def), rendererFactory = lView[RENDERER_FACTORY], componentView = addToViewTree(lView, createLView(lView, tView, null, def.onPush ? 64 : 16, native, hostTNode, rendererFactory, rendererFactory.createRenderer(native, def)));
            lView[hostTNode.index] = componentView;
        }
        function setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {
            const initialInputs = initialInputData[directiveIndex];
            if (null !== initialInputs) {
                const setInput = def.setInput;
                for (let i = 0; i < initialInputs.length; ) {
                    const publicName = initialInputs[i++], privateName = initialInputs[i++], value = initialInputs[i++];
                    null !== setInput ? def.setInput(instance, value, publicName, privateName) : instance[privateName] = value;
                }
            }
        }
        function generateInitialInputs(inputs, attrs) {
            let inputsToStore = null, i = 0;
            for (;i < attrs.length; ) {
                const attrName = attrs[i];
                if (0 !== attrName) if (5 !== attrName) {
                    if ("number" == typeof attrName) break;
                    inputs.hasOwnProperty(attrName) && (null === inputsToStore && (inputsToStore = []), 
                    inputsToStore.push(attrName, inputs[attrName], attrs[i + 1])), i += 2;
                } else i += 2; else i += 4;
            }
            return inputsToStore;
        }
        function createLContainer(hostNative, currentView, native, tNode) {
            return new Array(hostNative, !0, -1, currentView, null, null, tNode, native, null);
        }
        function refreshComponent(hostLView, componentHostIdx) {
            const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
            if (128 == (128 & componentView[FLAGS]) && 80 & componentView[FLAGS]) {
                const tView = componentView[TVIEW];
                refreshView(componentView, tView, tView.template, componentView[CONTEXT]);
            }
        }
        function renderComponent(hostLView, componentHostIdx) {
            const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
            !function(componentView) {
                const componentTView = componentView[TVIEW];
                for (let i = componentView.length; i < componentTView.blueprint.length; i++) componentView.push(componentTView.blueprint[i]);
            }(componentView), renderView(componentView, componentView[TVIEW], componentView[CONTEXT]);
        }
        function addToViewTree(lView, lViewOrLContainer) {
            return lView[CHILD_HEAD] ? lView[CHILD_TAIL][NEXT] = lViewOrLContainer : lView[CHILD_HEAD] = lViewOrLContainer, 
            lView[CHILD_TAIL] = lViewOrLContainer, lViewOrLContainer;
        }
        function markViewDirty(lView) {
            for (;lView; ) {
                lView[FLAGS] |= 64;
                const parent = getLViewParent(lView);
                if (isRootView(lView) && !parent) return lView;
                lView = parent;
            }
            return null;
        }
        function detectChangesInternal(view, context) {
            const rendererFactory = view[RENDERER_FACTORY];
            rendererFactory.begin && rendererFactory.begin();
            try {
                const tView = view[TVIEW];
                refreshView(view, tView, tView.template, context);
            } catch (error) {
                throw handleError(view, error), error;
            } finally {
                rendererFactory.end && rendererFactory.end();
            }
        }
        function detectChangesInRootView(lView) {
            !function(rootContext) {
                for (let i = 0; i < rootContext.components.length; i++) {
                    const rootComponent = rootContext.components[i], lView = readPatchedLView(rootComponent);
                    renderComponentOrTemplate(lView, lView[TVIEW].template, rootComponent);
                }
            }(lView[CONTEXT]);
        }
        function executeViewQueryFn(flags, viewQueryFn, component) {
            setCurrentQueryIndex(0), viewQueryFn(flags, component);
        }
        const CLEAN_PROMISE = (() => Promise.resolve(null))();
        function getCleanup(view) {
            return view[CLEANUP] || (view[CLEANUP] = []);
        }
        function getTViewCleanup(view) {
            return view[TVIEW].cleanup || (view[TVIEW].cleanup = []);
        }
        function loadComponentRenderer(tNode, lView) {
            return lView[tNode.index][RENDERER];
        }
        function handleError(lView, error) {
            const injector = lView[INJECTOR$1], errorHandler = injector ? injector.get(ErrorHandler, null) : null;
            errorHandler && errorHandler.handleError(error);
        }
        function setInputsForProperty(lView, inputs, value) {
            const tView = lView[TVIEW];
            for (let i = 0; i < inputs.length; ) {
                const index = inputs[i++], publicName = inputs[i++], privateName = inputs[i++], instance = lView[index], def = tView.data[index];
                def.setInput ? def.setInput(instance, value, publicName, privateName) : instance[privateName] = value;
            }
        }
        function textBindingInternal(lView, index, value) {
            const element = getNativeByIndex(index, lView), renderer = lView[RENDERER];
            isProceduralRenderer(renderer) ? renderer.setValue(element, value) : element.textContent = value;
        }
        function renderInitialStyling(renderer, native, tNode, append) {
            null !== tNode.classes && (append ? renderStylingMap(renderer, native, tNode.classes, !0) : writeStylingValueDirectly(renderer, native, getInitialStylingValue(tNode.classes), !0, null)), 
            null !== tNode.styles && (append ? renderStylingMap(renderer, native, tNode.styles, !1) : writeStylingValueDirectly(renderer, native, getInitialStylingValue(tNode.styles), !1, null));
        }
        function getLContainer(tNode, embeddedView) {
            const container = embeddedView[PARENT];
            return -1 === tNode.index ? isLContainer(container) ? container : null : container;
        }
        function getContainerRenderParent(tViewNode, view) {
            const container = getLContainer(tViewNode, view);
            return container ? nativeParentNode(view[RENDERER], container[NATIVE]) : null;
        }
        function applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {
            if (null != lNodeToHandle) {
                let lContainer, isComponent = !1;
                isLContainer(lNodeToHandle) ? lContainer = lNodeToHandle : isLView(lNodeToHandle) && (isComponent = !0, 
                lNodeToHandle = lNodeToHandle[HOST]);
                const rNode = unwrapRNode(lNodeToHandle);
                0 === action && null !== parent ? null == beforeNode ? nativeAppendChild(renderer, parent, rNode) : nativeInsertBefore(renderer, parent, rNode, beforeNode || null) : 1 === action && null !== parent ? nativeInsertBefore(renderer, parent, rNode, beforeNode || null) : 2 === action ? function(renderer, rNode, isHostElement) {
                    const nativeParent = nativeParentNode(renderer, rNode);
                    nativeParent && function(renderer, parent, child, isHostElement) {
                        isProceduralRenderer(renderer) ? renderer.removeChild(parent, child, isHostElement) : parent.removeChild(child);
                    }(renderer, nativeParent, rNode, isHostElement);
                }(renderer, rNode, isComponent) : 3 === action && renderer.destroyNode(rNode), null != lContainer && function(renderer, action, lContainer, renderParent, beforeNode) {
                    const anchor = lContainer[NATIVE];
                    anchor !== unwrapRNode(lContainer) && applyToElementOrContainer(action, renderer, renderParent, anchor, beforeNode);
                    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) applyView(renderer, action, lContainer[i], renderParent, anchor);
                }(renderer, action, lContainer, parent, beforeNode);
            }
        }
        function addRemoveViewFromContainer(lView, insertMode, beforeNode) {
            const renderParent = getContainerRenderParent(lView[TVIEW].node, lView);
            renderParent && applyView(lView[RENDERER], insertMode ? 1 : 2, lView, renderParent, beforeNode);
        }
        function detachMovedView(declarationContainer, lView) {
            const movedViews = declarationContainer[MOVED_VIEWS], declaredViewIndex = movedViews.indexOf(lView);
            movedViews.splice(declaredViewIndex, 1);
        }
        function detachView(lContainer, removeIndex) {
            if (lContainer.length <= CONTAINER_HEADER_OFFSET) return;
            const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex, viewToDetach = lContainer[indexInContainer];
            if (viewToDetach) {
                const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];
                null !== declarationLContainer && declarationLContainer !== lContainer && detachMovedView(declarationLContainer, viewToDetach), 
                removeIndex > 0 && (lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT]);
                const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);
                addRemoveViewFromContainer(viewToDetach, !1, null);
                const lQueries = removedLView[QUERIES];
                null !== lQueries && lQueries.detachView(removedLView[TVIEW]), viewToDetach[PARENT] = null, 
                viewToDetach[NEXT] = null, viewToDetach[FLAGS] &= -129;
            }
            return viewToDetach;
        }
        function destroyLView(lView) {
            if (!(256 & lView[FLAGS])) {
                const renderer = lView[RENDERER];
                isProceduralRenderer(renderer) && renderer.destroyNode && applyView(renderer, 3, lView, null, null), 
                function(rootView) {
                    let lViewOrLContainer = rootView[CHILD_HEAD];
                    if (!lViewOrLContainer) return cleanUpView(rootView);
                    for (;lViewOrLContainer; ) {
                        let next = null;
                        if (isLView(lViewOrLContainer)) next = lViewOrLContainer[CHILD_HEAD]; else {
                            const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];
                            firstView && (next = firstView);
                        }
                        if (!next) {
                            for (;lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView; ) cleanUpView(lViewOrLContainer), 
                            lViewOrLContainer = getParentState(lViewOrLContainer, rootView);
                            cleanUpView(lViewOrLContainer || rootView), next = lViewOrLContainer && lViewOrLContainer[NEXT];
                        }
                        lViewOrLContainer = next;
                    }
                }(lView);
            }
        }
        function getParentState(lViewOrLContainer, rootView) {
            let tNode;
            return isLView(lViewOrLContainer) && (tNode = lViewOrLContainer[T_HOST]) && 2 === tNode.type ? getLContainer(tNode, lViewOrLContainer) : lViewOrLContainer[PARENT] === rootView ? null : lViewOrLContainer[PARENT];
        }
        function cleanUpView(view) {
            if (isLView(view) && !(256 & view[FLAGS])) {
                view[FLAGS] &= -129, view[FLAGS] |= 256, function(view) {
                    const tView = view[TVIEW];
                    let destroyHooks;
                    if (null != tView && null != (destroyHooks = tView.destroyHooks)) for (let i = 0; i < destroyHooks.length; i += 2) {
                        const context = view[destroyHooks[i]];
                        context instanceof NodeInjectorFactory || destroyHooks[i + 1].call(context);
                    }
                }(view), function(lView) {
                    const tCleanup = lView[TVIEW].cleanup;
                    if (null !== tCleanup) {
                        const lCleanup = lView[CLEANUP];
                        for (let i = 0; i < tCleanup.length - 1; i += 2) if ("string" == typeof tCleanup[i]) {
                            const idxOrTargetGetter = tCleanup[i + 1], target = "function" == typeof idxOrTargetGetter ? idxOrTargetGetter(lView) : unwrapRNode(lView[idxOrTargetGetter]), listener = lCleanup[tCleanup[i + 2]], useCaptureOrSubIdx = tCleanup[i + 3];
                            "boolean" == typeof useCaptureOrSubIdx ? target.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx) : useCaptureOrSubIdx >= 0 ? lCleanup[useCaptureOrSubIdx]() : lCleanup[-useCaptureOrSubIdx].unsubscribe(), 
                            i += 2;
                        } else tCleanup[i].call(lCleanup[tCleanup[i + 1]]);
                        lView[CLEANUP] = null;
                    }
                }(view);
                const hostTNode = view[T_HOST];
                hostTNode && 3 === hostTNode.type && isProceduralRenderer(view[RENDERER]) && view[RENDERER].destroy();
                const declarationContainer = view[DECLARATION_LCONTAINER];
                if (null !== declarationContainer && isLContainer(view[PARENT])) {
                    declarationContainer !== view[PARENT] && detachMovedView(declarationContainer, view);
                    const lQueries = view[QUERIES];
                    null !== lQueries && lQueries.detachView(view[TVIEW]);
                }
            }
        }
        function getRenderParent(tNode, currentView) {
            if (isRootView(currentView)) return nativeParentNode(currentView[RENDERER], getNativeByTNode(tNode, currentView));
            let parentTNode = tNode.parent;
            for (;null != parentTNode && (4 === parentTNode.type || 5 === parentTNode.type); ) parentTNode = (tNode = parentTNode).parent;
            if (null == parentTNode) {
                const hostTNode = currentView[T_HOST];
                return 2 === hostTNode.type ? getContainerRenderParent(hostTNode, currentView) : currentView[HOST];
            }
            if (tNode && 5 === tNode.type && 4 & tNode.flags) return getNativeByTNode(tNode, currentView).parentNode;
            if (2 & parentTNode.flags) {
                const tData = currentView[TVIEW].data, encapsulation = tData[tData[parentTNode.index].directiveStart].encapsulation;
                if (encapsulation !== ViewEncapsulation$1.ShadowDom && encapsulation !== ViewEncapsulation$1.Native) return null;
            }
            return (getNativeByTNode(parentTNode, currentView));
        }
        function nativeInsertBefore(renderer, parent, child, beforeNode) {
            isProceduralRenderer(renderer) ? renderer.insertBefore(parent, child, beforeNode) : parent.insertBefore(child, beforeNode, !0);
        }
        function nativeAppendChild(renderer, parent, child) {
            isProceduralRenderer(renderer) ? renderer.appendChild(parent, child) : parent.appendChild(child);
        }
        function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode) {
            null !== beforeNode ? nativeInsertBefore(renderer, parent, child, beforeNode) : nativeAppendChild(renderer, parent, child);
        }
        function nativeParentNode(renderer, node) {
            return isProceduralRenderer(renderer) ? renderer.parentNode(node) : node.parentNode;
        }
        function getNativeAnchorNode(parentTNode, lView) {
            if (2 === parentTNode.type) {
                const lContainer = getLContainer(parentTNode, lView);
                return null === lContainer ? null : getBeforeNodeForView(lContainer.indexOf(lView, CONTAINER_HEADER_OFFSET) - CONTAINER_HEADER_OFFSET, lContainer);
            }
            return 4 === parentTNode.type || 5 === parentTNode.type ? getNativeByTNode(parentTNode, lView) : null;
        }
        function appendChild(childEl, childTNode, currentView) {
            const renderParent = getRenderParent(childTNode, currentView);
            if (null != renderParent) {
                const renderer = currentView[RENDERER], anchorNode = getNativeAnchorNode(childTNode.parent || currentView[T_HOST], currentView);
                if (Array.isArray(childEl)) for (let i = 0; i < childEl.length; i++) nativeAppendOrInsertBefore(renderer, renderParent, childEl[i], anchorNode); else nativeAppendOrInsertBefore(renderer, renderParent, childEl, anchorNode);
            }
        }
        function getBeforeNodeForView(viewIndexInContainer, lContainer) {
            const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;
            if (nextViewIndex < lContainer.length) {
                const lView = lContainer[nextViewIndex], firstTNodeOfView = lView[TVIEW].firstChild;
                if (null !== firstTNodeOfView) return function getFirstNativeNode(lView, tNode) {
                    if (null !== tNode) {
                        const tNodeType = tNode.type;
                        if (3 === tNodeType) return getNativeByTNode(tNode, lView);
                        if (0 === tNodeType) return getBeforeNodeForView(-1, lView[tNode.index]);
                        if (4 === tNodeType || 5 === tNodeType) {
                            const elIcuContainerChild = tNode.child;
                            return null !== elIcuContainerChild ? getFirstNativeNode(lView, elIcuContainerChild) : getNativeByTNode(tNode, lView);
                        }
                        {
                            const componentView = findComponentView(lView), componentHost = componentView[T_HOST], parentView = getLViewParent(componentView), firstProjectedTNode = componentHost.projection[tNode.projection];
                            return null != firstProjectedTNode ? getFirstNativeNode(parentView, firstProjectedTNode) : getFirstNativeNode(lView, tNode.next);
                        }
                    }
                    return null;
                }(lView, firstTNodeOfView);
            }
            return lContainer[NATIVE];
        }
        function applyNodes(renderer, action, tNode, lView, renderParent, beforeNode, isProjection) {
            for (;null != tNode; ) {
                const rawSlotValue = lView[tNode.index], tNodeType = tNode.type;
                isProjection && 0 === action && (rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView), 
                tNode.flags |= 4), 64 != (64 & tNode.flags) && (4 === tNodeType || 5 === tNodeType ? (applyNodes(renderer, action, tNode.child, lView, renderParent, beforeNode, !1), 
                applyToElementOrContainer(action, renderer, renderParent, rawSlotValue, beforeNode)) : 1 === tNodeType ? applyProjectionRecursive(renderer, action, lView, tNode, renderParent, beforeNode) : applyToElementOrContainer(action, renderer, renderParent, rawSlotValue, beforeNode)), 
                tNode = isProjection ? tNode.projectionNext : tNode.next;
            }
        }
        function applyView(renderer, action, lView, renderParent, beforeNode) {
            applyNodes(renderer, action, lView[TVIEW].node.child, lView, renderParent, beforeNode, !1);
        }
        function applyProjectionRecursive(renderer, action, lView, tProjectionNode, renderParent, beforeNode) {
            const componentLView = findComponentView(lView), nodeToProjectOrRNodes = componentLView[T_HOST].projection[tProjectionNode.projection];
            if (Array.isArray(nodeToProjectOrRNodes)) for (let i = 0; i < nodeToProjectOrRNodes.length; i++) applyToElementOrContainer(action, renderer, renderParent, nodeToProjectOrRNodes[i], beforeNode); else applyNodes(renderer, action, nodeToProjectOrRNodes, componentLView[PARENT], renderParent, beforeNode, !0);
        }
        class ViewRef {
            constructor(_lView, _cdRefInjectingView) {
                this._lView = _lView, this._cdRefInjectingView = _cdRefInjectingView, this._appRef = null, 
                this._viewContainerRef = null, this._tViewNode = null;
            }
            get rootNodes() {
                return null == this._lView[HOST] ? function collectNativeNodes(lView, tNode, result, isProjection = !1) {
                    for (;null !== tNode; ) {
                        const lNode = lView[tNode.index];
                        if (null !== lNode && result.push(unwrapRNode(lNode)), isLContainer(lNode)) for (let i = CONTAINER_HEADER_OFFSET; i < lNode.length; i++) {
                            const lViewInAContainer = lNode[i], lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;
                            null !== lViewFirstChildTNode && collectNativeNodes(lViewInAContainer, lViewFirstChildTNode, result);
                        }
                        const tNodeType = tNode.type;
                        if (4 === tNodeType || 5 === tNodeType) collectNativeNodes(lView, tNode.child, result); else if (1 === tNodeType) {
                            const componentView = findComponentView(lView), componentHost = componentView[T_HOST], parentView = getLViewParent(componentView);
                            let firstProjectedNode = componentHost.projection[tNode.projection];
                            null !== firstProjectedNode && null !== parentView && collectNativeNodes(parentView, firstProjectedNode, result, !0);
                        }
                        tNode = isProjection ? tNode.projectionNext : tNode.next;
                    }
                    return result;
                }(this._lView, this._lView[T_HOST].child, []) : [];
            }
            get context() {
                return this._lView[CONTEXT];
            }
            get destroyed() {
                return 256 == (256 & this._lView[FLAGS]);
            }
            destroy() {
                if (this._appRef) this._appRef.detachView(this); else if (this._viewContainerRef) {
                    const index = this._viewContainerRef.indexOf(this);
                    index > -1 && this._viewContainerRef.detach(index), this._viewContainerRef = null;
                }
                destroyLView(this._lView);
            }
            onDestroy(callback) {
                var view, cleanupFn;
                cleanupFn = callback, getCleanup(view = this._lView).push(cleanupFn), view[TVIEW].firstCreatePass && getTViewCleanup(view).push(view[CLEANUP].length - 1, null);
            }
            markForCheck() {
                markViewDirty(this._cdRefInjectingView || this._lView);
            }
            detach() {
                this._lView[FLAGS] &= -129;
            }
            reattach() {
                this._lView[FLAGS] |= 128;
            }
            detectChanges() {
                detectChangesInternal(this._lView, this.context);
            }
            checkNoChanges() {
                !function(view, context) {
                    setCheckNoChangesMode(!0);
                    try {
                        detectChangesInternal(view, context);
                    } finally {
                        setCheckNoChangesMode(!1);
                    }
                }(this._lView, this.context);
            }
            attachToViewContainerRef(vcRef) {
                if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!");
                this._viewContainerRef = vcRef;
            }
            detachFromAppRef() {
                var lView;
                this._appRef = null, applyView((lView = this._lView)[RENDERER], 2, lView, null, null);
            }
            attachToAppRef(appRef) {
                if (this._viewContainerRef) throw new Error("This view is already attached to a ViewContainer!");
                this._appRef = appRef;
            }
        }
        class RootViewRef extends ViewRef {
            constructor(_view) {
                super(_view), this._view = _view;
            }
            detectChanges() {
                detectChangesInRootView(this._view);
            }
            checkNoChanges() {
                !function(lView) {
                    setCheckNoChangesMode(!0);
                    try {
                        detectChangesInRootView(lView);
                    } finally {
                        setCheckNoChangesMode(!1);
                    }
                }(this._view);
            }
            get context() {
                return null;
            }
        }
        let R3ElementRef, R3TemplateRef, R3ViewContainerRef;
        function createElementRef(ElementRefToken, tNode, view) {
            return R3ElementRef || (R3ElementRef = class extends ElementRefToken {}), new R3ElementRef(getNativeByTNode(tNode, view));
        }
        function createTemplateRef(TemplateRefToken, ElementRefToken, hostTNode, hostView) {
            return R3TemplateRef || (R3TemplateRef = class extends TemplateRefToken {
                constructor(_declarationView, _declarationTContainer, elementRef) {
                    super(), this._declarationView = _declarationView, this._declarationTContainer = _declarationTContainer, 
                    this.elementRef = elementRef;
                }
                createEmbeddedView(context) {
                    const embeddedTView = this._declarationTContainer.tViews, lView = createLView(this._declarationView, embeddedTView, context, 16, null, embeddedTView.node);
                    lView[DECLARATION_LCONTAINER] = this._declarationView[this._declarationTContainer.index];
                    const declarationViewLQueries = this._declarationView[QUERIES];
                    null !== declarationViewLQueries && (lView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView)), 
                    renderView(lView, embeddedTView, context);
                    const viewRef = new ViewRef(lView);
                    return viewRef._tViewNode = lView[T_HOST], viewRef;
                }
            }), 0 === hostTNode.type ? new R3TemplateRef(hostView, hostTNode, createElementRef(ElementRefToken, hostTNode, hostView)) : null;
        }
        function createContainerRef(ViewContainerRefToken, ElementRefToken, hostTNode, hostView) {
            let lContainer;
            R3ViewContainerRef || (R3ViewContainerRef = class extends ViewContainerRefToken {
                constructor(_lContainer, _hostTNode, _hostView) {
                    super(), this._lContainer = _lContainer, this._hostTNode = _hostTNode, this._hostView = _hostView;
                }
                get element() {
                    return createElementRef(ElementRefToken, this._hostTNode, this._hostView);
                }
                get injector() {
                    return new NodeInjector(this._hostTNode, this._hostView);
                }
                get parentInjector() {
                    const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostView), parentView = getParentInjectorView(parentLocation, this._hostView), parentTNode = function(location, startView, startTNode) {
                        if (startTNode.parent && -1 !== startTNode.parent.injectorIndex) {
                            const injectorIndex = startTNode.parent.injectorIndex;
                            let parentTNode = startTNode.parent;
                            for (;null != parentTNode.parent && injectorIndex == parentTNode.injectorIndex; ) parentTNode = parentTNode.parent;
                            return parentTNode;
                        }
                        let viewOffset = getParentInjectorViewOffset(location), parentView = startView, parentTNode = startView[T_HOST];
                        for (;viewOffset > 1; ) parentTNode = (parentView = parentView[DECLARATION_VIEW])[T_HOST], 
                        viewOffset--;
                        return parentTNode;
                    }(parentLocation, this._hostView, this._hostTNode);
                    return hasParentInjector(parentLocation) && null != parentTNode ? new NodeInjector(parentTNode, parentView) : new NodeInjector(null, this._hostView);
                }
                clear() {
                    for (;this.length > 0; ) this.remove(this.length - 1);
                }
                get(index) {
                    return null !== this._lContainer[VIEW_REFS] && this._lContainer[VIEW_REFS][index] || null;
                }
                get length() {
                    return this._lContainer.length - CONTAINER_HEADER_OFFSET;
                }
                createEmbeddedView(templateRef, context, index) {
                    const viewRef = templateRef.createEmbeddedView(context || {});
                    return this.insert(viewRef, index), viewRef;
                }
                createComponent(componentFactory, index, injector, projectableNodes, ngModuleRef) {
                    const contextInjector = injector || this.parentInjector;
                    if (!ngModuleRef && null == componentFactory.ngModule && contextInjector) {
                        const result = contextInjector.get(NgModuleRef, null);
                        result && (ngModuleRef = result);
                    }
                    const componentRef = componentFactory.create(contextInjector, projectableNodes, void 0, ngModuleRef);
                    return this.insert(componentRef.hostView, index), componentRef;
                }
                insert(viewRef, index) {
                    if (viewRef.destroyed) throw new Error("Cannot insert a destroyed View in a ViewContainer!");
                    this.allocateContainerIfNeeded();
                    const lView = viewRef._lView, adjustedIdx = this._adjustIndex(index);
                    return isLContainer(lView[PARENT]) ? this.move(viewRef, adjustedIdx) : (function(lView, lContainer, index) {
                        const indexInContainer = CONTAINER_HEADER_OFFSET + index, containerLength = lContainer.length;
                        index > 0 && (lContainer[indexInContainer - 1][NEXT] = lView), index < containerLength - CONTAINER_HEADER_OFFSET ? (lView[NEXT] = lContainer[indexInContainer], 
                        addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView)) : (lContainer.push(lView), 
                        lView[NEXT] = null), lView[PARENT] = lContainer;
                        const declarationLContainer = lView[DECLARATION_LCONTAINER];
                        null !== declarationLContainer && lContainer !== declarationLContainer && function(declarationContainer, lView) {
                            const movedViews = declarationContainer[MOVED_VIEWS];
                            null === movedViews ? declarationContainer[MOVED_VIEWS] = [ lView ] : movedViews.push(lView);
                        }(declarationLContainer, lView);
                        const lQueries = lView[QUERIES];
                        null !== lQueries && lQueries.insertView(lView[TVIEW]), lView[FLAGS] |= 128;
                    }(lView, this._lContainer, adjustedIdx), addRemoveViewFromContainer(lView, !0, getBeforeNodeForView(adjustedIdx, this._lContainer)), 
                    viewRef.attachToViewContainerRef(this), addToArray(this._lContainer[VIEW_REFS], adjustedIdx, viewRef), 
                    viewRef);
                }
                move(viewRef, newIndex) {
                    if (viewRef.destroyed) throw new Error("Cannot move a destroyed View in a ViewContainer!");
                    const index = this.indexOf(viewRef);
                    return -1 !== index && this.detach(index), this.insert(viewRef, newIndex), viewRef;
                }
                indexOf(viewRef) {
                    return null !== this._lContainer[VIEW_REFS] ? this._lContainer[VIEW_REFS].indexOf(viewRef) : 0;
                }
                remove(index) {
                    this.allocateContainerIfNeeded();
                    const adjustedIdx = this._adjustIndex(index, -1);
                    (function(lContainer, removeIndex) {
                        const detachedView = detachView(lContainer, removeIndex);
                        detachedView && destroyLView(detachedView);
                    })(this._lContainer, adjustedIdx), removeFromArray(this._lContainer[VIEW_REFS], adjustedIdx);
                }
                detach(index) {
                    this.allocateContainerIfNeeded();
                    const adjustedIdx = this._adjustIndex(index, -1), view = detachView(this._lContainer, adjustedIdx);
                    return view && null != removeFromArray(this._lContainer[VIEW_REFS], adjustedIdx) ? new ViewRef(view) : null;
                }
                _adjustIndex(index, shift = 0) {
                    return null == index ? this.length + shift : index;
                }
                allocateContainerIfNeeded() {
                    null === this._lContainer[VIEW_REFS] && (this._lContainer[VIEW_REFS] = []);
                }
            });
            const slotValue = hostView[hostTNode.index];
            if (isLContainer(slotValue)) (lContainer = slotValue)[ACTIVE_INDEX] = -1; else {
                let commentNode;
                if (commentNode = 4 === hostTNode.type ? unwrapRNode(slotValue) : hostView[RENDERER].createComment(""), 
                isRootView(hostView)) {
                    const renderer = hostView[RENDERER], hostNative = getNativeByTNode(hostTNode, hostView);
                    nativeInsertBefore(renderer, nativeParentNode(renderer, hostNative), commentNode, function(renderer, node) {
                        return isProceduralRenderer(renderer) ? renderer.nextSibling(node) : node.nextSibling;
                    }(renderer, hostNative));
                } else appendChild(commentNode, hostTNode, hostView);
                hostView[hostTNode.index] = lContainer = createLContainer(slotValue, hostView, commentNode, hostTNode), 
                addToViewTree(hostView, lContainer);
            }
            return new R3ViewContainerRef(lContainer, hostTNode, hostView);
        }
        let ChangeDetectorRef = (() => {
            class ChangeDetectorRef {}
            return ChangeDetectorRef.__NG_ELEMENT_ID__ = () => SWITCH_CHANGE_DETECTOR_REF_FACTORY(), 
            ChangeDetectorRef;
        })();
        const SWITCH_CHANGE_DETECTOR_REF_FACTORY = function(isPipe = !1) {
            return function(tNode, lView, isPipe) {
                if (!isPipe && isComponentHost(tNode)) {
                    const componentView = getComponentLViewByIndex(tNode.index, lView);
                    return new ViewRef(componentView, componentView);
                }
                if (3 === tNode.type || 0 === tNode.type || 4 === tNode.type) {
                    const hostComponentView = findComponentView(lView);
                    return new ViewRef(hostComponentView, lView);
                }
                return (null);
            }(getPreviousOrParentTNode(), getLView(), isPipe);
        }, INJECTOR_SCOPE = new InjectionToken("Set Injector scope."), NOT_YET = {}, CIRCULAR = {}, EMPTY_ARRAY$2 = [];
        let NULL_INJECTOR = void 0;
        function getNullInjector() {
            return void 0 === NULL_INJECTOR && (NULL_INJECTOR = new NullInjector), NULL_INJECTOR;
        }
        function createInjector(defType, parent = null, additionalProviders = null, name) {
            return parent = parent || getNullInjector(), new R3Injector(defType, additionalProviders, parent, name);
        }
        class R3Injector {
            constructor(def, additionalProviders, parent, source = null) {
                this.parent = parent, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, 
                this._destroyed = !1;
                const dedupStack = [];
                additionalProviders && deepForEach(additionalProviders, provider => this.processProvider(provider, def, additionalProviders)), 
                deepForEach([ def ], injectorDef => this.processInjectorType(injectorDef, [], dedupStack)), 
                this.records.set(INJECTOR, makeRecord(void 0, this));
                const record = this.records.get(INJECTOR_SCOPE);
                this.scope = null != record ? record.value : null, this.injectorDefTypes.forEach(defType => this.get(defType)), 
                this.source = source || ("object" == typeof def ? null : stringify(def));
            }
            get destroyed() {
                return this._destroyed;
            }
            destroy() {
                this.assertNotDestroyed(), this._destroyed = !0;
                try {
                    this.onDestroy.forEach(service => service.ngOnDestroy());
                } finally {
                    this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear();
                }
            }
            get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {
                this.assertNotDestroyed();
                const previousInjector = setCurrentInjector(this);
                try {
                    if (!(flags & InjectFlags.SkipSelf)) {
                        let record = this.records.get(token);
                        if (void 0 === record) {
                            const def = ("function" == typeof (value = token) || "object" == typeof value && value instanceof InjectionToken) && getInjectableDef(token);
                            record = def && this.injectableDefInScope(def) ? makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET) : null, 
                            this.records.set(token, record);
                        }
                        if (null != record) return this.hydrate(token, record);
                    }
                    return (flags & InjectFlags.Self ? getNullInjector() : this.parent).get(token, notFoundValue = flags & InjectFlags.Optional && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue);
                } catch (e) {
                    if ("NullInjectorError" === e.name) {
                        if ((e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || []).unshift(stringify(token)), 
                        previousInjector) throw e;
                        return function(e, token, injectorErrorName, source) {
                            const tokenPath = e[NG_TEMP_TOKEN_PATH];
                            throw token[SOURCE] && tokenPath.unshift(token[SOURCE]), e.message = function(text, obj, injectorErrorName, source = null) {
                                text = text && "\n" === text.charAt(0) && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;
                                let context = stringify(obj);
                                if (Array.isArray(obj)) context = obj.map(stringify).join(" -> "); else if ("object" == typeof obj) {
                                    let parts = [];
                                    for (let key in obj) if (obj.hasOwnProperty(key)) {
                                        let value = obj[key];
                                        parts.push(key + ":" + ("string" == typeof value ? JSON.stringify(value) : stringify(value)));
                                    }
                                    context = `{${parts.join(", ")}}`;
                                }
                                return `${injectorErrorName}${source ? "(" + source + ")" : ""}[${context}]: ${text.replace(NEW_LINE, "\n  ")}`;
                            }("\n" + e.message, tokenPath, injectorErrorName, source), e[NG_TOKEN_PATH] = tokenPath, 
                            e[NG_TEMP_TOKEN_PATH] = null, e;
                        }(e, token, "R3InjectorError", this.source);
                    }
                    throw e;
                } finally {
                    setCurrentInjector(previousInjector);
                }
                var value;
            }
            toString() {
                const tokens = [];
                return this.records.forEach((v, token) => tokens.push(stringify(token))), `R3Injector[${tokens.join(", ")}]`;
            }
            assertNotDestroyed() {
                if (this._destroyed) throw new Error("Injector has already been destroyed.");
            }
            processInjectorType(defOrWrappedDef, parents, dedupStack) {
                if (!(defOrWrappedDef = resolveForwardRef(defOrWrappedDef))) return !1;
                let def = getInjectorDef(defOrWrappedDef);
                const ngModule = null == def && defOrWrappedDef.ngModule || void 0, defType = void 0 === ngModule ? defOrWrappedDef : ngModule, isDuplicate = -1 !== dedupStack.indexOf(defType);
                if (void 0 !== ngModule && (def = getInjectorDef(ngModule)), null == def) return !1;
                if (this.injectorDefTypes.add(defType), this.records.set(defType, makeRecord(def.factory, NOT_YET)), 
                null != def.imports && !isDuplicate) {
                    let importTypesWithProviders;
                    dedupStack.push(defType);
                    try {
                        deepForEach(def.imports, imported => {
                            this.processInjectorType(imported, parents, dedupStack) && (void 0 === importTypesWithProviders && (importTypesWithProviders = []), 
                            importTypesWithProviders.push(imported));
                        });
                    } finally {}
                    if (void 0 !== importTypesWithProviders) for (let i = 0; i < importTypesWithProviders.length; i++) {
                        const {ngModule: ngModule, providers: providers} = importTypesWithProviders[i];
                        deepForEach(providers, provider => this.processProvider(provider, ngModule, providers || EMPTY_ARRAY$2));
                    }
                }
                const defProviders = def.providers;
                if (null != defProviders && !isDuplicate) {
                    const injectorType = defOrWrappedDef;
                    deepForEach(defProviders, provider => this.processProvider(provider, injectorType, defProviders));
                }
                return void 0 !== ngModule && void 0 !== defOrWrappedDef.providers;
            }
            processProvider(provider, ngModuleType, providers) {
                let token = isTypeProvider(provider = resolveForwardRef(provider)) ? provider : resolveForwardRef(provider && provider.provide);
                const record = function(provider, ngModuleType, providers) {
                    return isValueProvider(provider) ? makeRecord(void 0, provider.useValue) : makeRecord(providerToFactory(provider, ngModuleType, providers), NOT_YET);
                }(provider, ngModuleType, providers);
                if (isTypeProvider(provider) || !0 !== provider.multi) {
                    const existing = this.records.get(token);
                    existing && void 0 !== existing.multi && throwMixedMultiProviderError();
                } else {
                    let multiRecord = this.records.get(token);
                    multiRecord ? void 0 === multiRecord.multi && throwMixedMultiProviderError() : ((multiRecord = makeRecord(void 0, NOT_YET, !0)).factory = () => injectArgs(multiRecord.multi), 
                    this.records.set(token, multiRecord)), token = provider, multiRecord.multi.push(provider);
                }
                this.records.set(token, record);
            }
            hydrate(token, record) {
                var value;
                return record.value === CIRCULAR ? function(token) {
                    throw new Error(`Cannot instantiate cyclic dependency! ${token}`);
                }(stringify(token)) : record.value === NOT_YET && (record.value = CIRCULAR, record.value = record.factory()), 
                "object" == typeof record.value && record.value && null !== (value = record.value) && "object" == typeof value && "function" == typeof value.ngOnDestroy && this.onDestroy.add(record.value), 
                record.value;
            }
            injectableDefInScope(def) {
                return !!def.providedIn && ("string" == typeof def.providedIn ? "any" === def.providedIn || def.providedIn === this.scope : this.injectorDefTypes.has(def.providedIn));
            }
        }
        function injectableDefOrInjectorDefFactory(token) {
            const injectableDef = getInjectableDef(token), factory = null !== injectableDef ? injectableDef.factory : getFactoryDef(token);
            if (null !== factory) return factory;
            const injectorDef = getInjectorDef(token);
            if (null !== injectorDef) return injectorDef.factory;
            if (token instanceof InjectionToken) throw new Error(`Token ${stringify(token)} is missing a ɵprov definition.`);
            if (token instanceof Function) return function(token) {
                const paramLength = token.length;
                if (paramLength > 0) {
                    const args = newArray(paramLength, "?");
                    throw new Error(`Can't resolve all parameters for ${stringify(token)}: (${args.join(", ")}).`);
                }
                const inheritedInjectableDef = function(type) {
                    const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF]);
                    return def ? (console.warn(`DEPRECATED: DI is instantiating a token "${type.name}" that inherits its @Injectable decorator but does not provide one itself.\n` + `This will become an error in v10. Please add @Injectable() to the "${type.name}" class.`), 
                    def) : null;
                }(token);
                return null !== inheritedInjectableDef ? () => inheritedInjectableDef.factory(token) : () => new token;
            }(token);
            throw new Error("unreachable");
        }
        function providerToFactory(provider, ngModuleType, providers) {
            let factory = void 0;
            if (isTypeProvider(provider)) return injectableDefOrInjectorDefFactory(resolveForwardRef(provider));
            if (isValueProvider(provider)) factory = () => resolveForwardRef(provider.useValue); else if ((value = provider) && value.useExisting) factory = () => ɵɵinject(resolveForwardRef(provider.useExisting)); else if (function(value) {
                return !(!value || !value.useFactory);
            }(provider)) factory = () => provider.useFactory(...injectArgs(provider.deps || [])); else {
                const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
                if (classRef || function(ngModuleType, providers, provider) {
                    let ngModuleDetail = "";
                    throw ngModuleType && providers && (ngModuleDetail = ` - only instances of Provider and Type are allowed, got: [${providers.map(v => v == provider ? "?" + provider + "?" : "...").join(", ")}]`), 
                    new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}'` + ngModuleDetail);
                }(ngModuleType, providers, provider), !function(value) {
                    return !!value.deps;
                }(provider)) return injectableDefOrInjectorDefFactory(classRef);
                factory = () => new classRef(...injectArgs(provider.deps));
            }
            var value;
            return factory;
        }
        function makeRecord(factory, value, multi = !1) {
            return {
                factory: factory,
                value: value,
                multi: multi ? [] : void 0
            };
        }
        function isValueProvider(value) {
            return null !== value && "object" == typeof value && USE_VALUE in value;
        }
        function isTypeProvider(value) {
            return "function" == typeof value;
        }
        const INJECTOR_IMPL = function(providers, parent, name) {
            return createInjector({
                name: name
            }, parent, providers, name);
        };
        let Injector = (() => {
            class Injector {
                static create(options, parent) {
                    return Array.isArray(options) ? INJECTOR_IMPL(options, parent, "") : INJECTOR_IMPL(options.providers, options.parent, options.name || "");
                }
            }
            return Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND, Injector.NULL = new NullInjector, 
            Injector.ɵprov = ɵɵdefineInjectable({
                token: Injector,
                providedIn: "any",
                factory: () => ɵɵinject(INJECTOR)
            }), Injector.__NG_ELEMENT_ID__ = -1, Injector;
        })();
        const ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken("AnalyzeForEntryComponents");
        let componentResourceResolutionQueue = new Map;
        const componentDefPendingResolution = new Set;
        function unwrapResponse(response) {
            return "string" == typeof response ? response : response.text();
        }
        function ɵɵallocHostVars(count) {
            const lView = getLView(), tView = lView[TVIEW];
            tView.firstCreatePass && (function(tView, def, hostVars) {
                const expando = tView.expandoInstructions, length = expando.length;
                length >= 2 && expando[length - 2] === def.hostBindings ? expando[length - 1] = expando[length - 1] + hostVars : expando.push(def.hostBindings, hostVars);
            }(tView, instructionState.lFrame.currentDirectiveDef, count), function(tView, lView, totalHostVars) {
                for (let i = 0; i < totalHostVars; i++) lView.push(NO_CHANGE), tView.blueprint.push(NO_CHANGE), 
                tView.data.push(null);
            }(tView, lView, count));
        }
        let _symbolIterator = null;
        function getSymbolIterator() {
            if (!_symbolIterator) {
                const Symbol = _global.Symbol;
                if (Symbol && Symbol.iterator) _symbolIterator = Symbol.iterator; else {
                    const keys = Object.getOwnPropertyNames(Map.prototype);
                    for (let i = 0; i < keys.length; ++i) {
                        const key = keys[i];
                        "entries" !== key && "size" !== key && Map.prototype[key] === Map.prototype.entries && (_symbolIterator = key);
                    }
                }
            }
            return _symbolIterator;
        }
        function looseIdentical(a, b) {
            return a === b || "number" == typeof a && "number" == typeof b && isNaN(a) && isNaN(b);
        }
        class WrappedValue {
            constructor(value) {
                this.wrapped = value;
            }
            static wrap(value) {
                return new WrappedValue(value);
            }
            static unwrap(value) {
                return WrappedValue.isWrapped(value) ? value.wrapped : value;
            }
            static isWrapped(value) {
                return value instanceof WrappedValue;
            }
        }
        function isListLikeIterable$1(obj) {
            return !!isJsObject$1(obj) && (Array.isArray(obj) || !(obj instanceof Map) && getSymbolIterator() in obj);
        }
        function isJsObject$1(o) {
            return null !== o && ("function" == typeof o || "object" == typeof o);
        }
        function updateBinding(lView, bindingIndex, value) {
            return lView[bindingIndex] = value;
        }
        function getBinding(lView, bindingIndex) {
            return lView[bindingIndex];
        }
        function bindingUpdated(lView, bindingIndex, value) {
            return !Object.is(lView[bindingIndex], value) && (lView[bindingIndex] = value, !0);
        }
        function bindingUpdated2(lView, bindingIndex, exp1, exp2) {
            const different = bindingUpdated(lView, bindingIndex, exp1);
            return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
        }
        function ɵɵattribute(name, value, sanitizer, namespace) {
            const lView = getLView();
            return bindingUpdated(lView, nextBindingIndex(), value) && function(index, name, value, lView, sanitizer, namespace) {
                const element = getNativeByIndex(index, lView), renderer = lView[RENDERER];
                if (null == value) isProceduralRenderer(renderer) ? renderer.removeAttribute(element, name, namespace) : element.removeAttribute(name); else {
                    const tNode = getTNode(index, lView), strValue = null == sanitizer ? renderStringify(value) : sanitizer(value, tNode.tagName || "", name);
                    isProceduralRenderer(renderer) ? renderer.setAttribute(element, name, strValue, namespace) : namespace ? element.setAttributeNS(namespace, name, strValue) : element.setAttribute(name, strValue);
                }
            }(getSelectedIndex(), name, value, lView, sanitizer, namespace), ɵɵattribute;
        }
        function interpolation1(lView, prefix, v0, suffix) {
            return bindingUpdated(lView, nextBindingIndex(), v0) ? prefix + renderStringify(v0) + suffix : NO_CHANGE;
        }
        function ɵɵtemplate(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
            const lView = getLView(), tView = lView[TVIEW], tViewConsts = tView.consts, tContainerNode = function(lView, nodeIndex, tagName, attrs) {
                const adjustedIndex = nodeIndex + HEADER_OFFSET, comment = lView[adjustedIndex] = lView[RENDERER].createComment(""), tNode = getOrCreateTNode(lView[TVIEW], lView[T_HOST], nodeIndex, 0, tagName, attrs), lContainer = lView[adjustedIndex] = createLContainer(comment, lView, comment, tNode);
                return appendChild(comment, tNode, lView), attachPatchData(comment, lView), addToViewTree(lView, lContainer), 
                tNode;
            }(lView, index, tagName || null, getConstant(tViewConsts, attrsIndex)), localRefs = getConstant(tViewConsts, localRefsIndex);
            if (tView.firstCreatePass) {
                resolveDirectives(tView, lView, tContainerNode, localRefs), registerPostOrderHooks(tView, tContainerNode);
                const embeddedTView = tContainerNode.tViews = createTView(0, -1, templateFn, decls, vars, tView.directiveRegistry, tView.pipeRegistry, null, tView.schemas, tViewConsts), embeddedTViewNode = createTNode(0, null, 2, -1, null, null);
                embeddedTViewNode.injectorIndex = tContainerNode.injectorIndex, embeddedTView.node = embeddedTViewNode, 
                null !== tView.queries && (tView.queries.template(tView, tContainerNode), embeddedTView.queries = tView.queries.embeddedTView(tContainerNode));
            }
            isDirectiveHost(tContainerNode) && createDirectivesInstances(tView, lView, tContainerNode), 
            null != localRefs && saveResolvedLocalsInData(lView, tContainerNode, localRefExtractor), 
            setIsNotParent();
        }
        function ɵɵreference(index) {
            return load(instructionState.lFrame.contextLView, index);
        }
        function ɵɵdirectiveInject(token, flags = InjectFlags.Default) {
            token = resolveForwardRef(token);
            const lView = getLView();
            return null == lView ? ɵɵinject(token, flags) : getOrCreateInjectable(getPreviousOrParentTNode(), lView, token, flags);
        }
        function ɵɵinjectAttribute(attrNameToInject) {
            return function(tNode, attrNameToInject) {
                if ("class" === attrNameToInject) return getInitialStylingValue(tNode.classes);
                if ("style" === attrNameToInject) return getInitialStylingValue(tNode.styles);
                const attrs = tNode.attrs;
                if (attrs) {
                    const attrsLength = attrs.length;
                    let i = 0;
                    for (;i < attrsLength; ) {
                        const value = attrs[i];
                        if (isNameOnlyAttributeMarker(value)) break;
                        if (0 === value) i += 2; else if ("number" == typeof value) for (i++; i < attrsLength && "string" == typeof attrs[i]; ) i++; else {
                            if (value === attrNameToInject) return attrs[i + 1];
                            i += 2;
                        }
                    }
                }
                return null;
            }(getPreviousOrParentTNode(), attrNameToInject);
        }
        function ɵɵinvalidFactory() {
            throw new Error("invalid");
        }
        function ɵɵstyleSanitizer(sanitizer) {
            setCurrentStyleSanitizer(sanitizer);
        }
        function ɵɵstyleProp(prop, value, suffix) {
            !function(elementIndex, prop, value, suffix) {
                const bindingIndex = nextBindingIndex(), lView = getLView(), tNode = getTNode(elementIndex, lView), firstUpdatePass = lView[TVIEW].firstUpdatePass;
                firstUpdatePass && (patchConfig(tNode, 32768), patchHostStylingFlag(tNode, isHostStyling(), !1)), 
                stylingProp(tNode, firstUpdatePass, lView, bindingIndex, prop, function(value, suffix) {
                    if (value === NO_CHANGE) return value;
                    let resolvedValue = null;
                    return null !== value && (resolvedValue = suffix ? renderStringify(value) + suffix : value), 
                    resolvedValue;
                }(value, suffix), !1);
            }(getSelectedIndex(), prop, value, suffix);
        }
        function ɵɵclassProp(className, value) {
            const bindingIndex = nextBindingIndex(), lView = getLView(), tNode = getTNode(getSelectedIndex(), lView), firstUpdatePass = lView[TVIEW].firstUpdatePass;
            firstUpdatePass && (patchConfig(tNode, 1024), patchHostStylingFlag(tNode, isHostStyling(), !0)), 
            stylingProp(tNode, firstUpdatePass, lView, bindingIndex, className, value, !0);
        }
        function stylingProp(tNode, firstUpdatePass, lView, bindingIndex, prop, value, isClassBased) {
            let updated = !1;
            const native = getNativeByTNode(tNode, lView), context = isClassBased ? getClassesContext(tNode) : getStylesContext(tNode), sanitizer = isClassBased ? null : getCurrentStyleSanitizer();
            if (allowDirectStyling(tNode, isClassBased, firstUpdatePass)) {
                const sanitizerToUse = isClassBased ? null : sanitizer;
                updated = function(renderer, context, tNode, element, data, bindingIndex, prop, value, isClassBased, sanitizer) {
                    let applied = !1;
                    if (hasValueChanged(data[bindingIndex], value)) {
                        setValue(data, bindingIndex, value);
                        const applyFn = isClassBased ? setClass : setStyle, mapBindingsFlag = isClassBased ? 512 : 16384;
                        if (!(applied = applyStylingValue(renderer, element, prop, value, applyFn, bindingIndex, sanitizer)) && hasConfig(tNode, mapBindingsFlag)) {
                            const state = getStylingState(element, TEMPLATE_DIRECTIVE_INDEX), map = isClassBased ? state.lastDirectClassMap : state.lastDirectStyleMap;
                            applied = !!map && findAndApplyMapValue(renderer, element, applyFn, map, prop, bindingIndex, sanitizer);
                        }
                        if (!applied && hasConfig(tNode, 256)) {
                            const map = getStylingMapArray(context);
                            applied = !!map && findAndApplyMapValue(renderer, element, applyFn, map, prop, bindingIndex);
                        }
                        applied || applyFn(renderer, element, prop, null, bindingIndex);
                    }
                    return applied;
                }(getRenderer(tNode, lView), context, tNode, native, lView, bindingIndex, prop, value, isClassBased, sanitizerToUse), 
                sanitizerToUse && setElementExitFn(stylingApply);
            } else {
                const directiveIndex = getActiveDirectiveId();
                updated = isClassBased ? updateClassViaContext(context, tNode, lView, native, directiveIndex, prop, bindingIndex, value, !1, firstUpdatePass) : updateStyleViaContext(context, tNode, lView, native, directiveIndex, prop, bindingIndex, value, sanitizer, !1, firstUpdatePass), 
                setElementExitFn(stylingApply);
            }
            return updated;
        }
        function ɵɵstyleMap(styles) {
            const index = getSelectedIndex(), lView = getLView(), tNode = getTNode(index, lView), firstUpdatePass = lView[TVIEW].firstUpdatePass, context = getStylesContext(tNode), hasDirectiveInput = hasStyleInput(tNode), bindingIndex = incrementBindingIndex(2);
            !isHostStyling() && hasDirectiveInput && styles !== NO_CHANGE && (updateDirectiveInputValue(context, lView, tNode, bindingIndex, styles, !1, firstUpdatePass), 
            styles = NO_CHANGE), firstUpdatePass && (patchConfig(tNode, 16384), patchHostStylingFlag(tNode, isHostStyling(), !1)), 
            stylingMap(context, tNode, firstUpdatePass, lView, bindingIndex, styles, !1, hasDirectiveInput);
        }
        function ɵɵclassMap(classes) {
            classMapInternal(getSelectedIndex(), classes);
        }
        function classMapInternal(elementIndex, classes) {
            const lView = getLView(), tNode = getTNode(elementIndex, lView), firstUpdatePass = lView[TVIEW].firstUpdatePass, context = getClassesContext(tNode), hasDirectiveInput = hasClassInput(tNode), bindingIndex = incrementBindingIndex(2);
            !isHostStyling() && hasDirectiveInput && classes !== NO_CHANGE && (updateDirectiveInputValue(context, lView, tNode, bindingIndex, classes, !0, firstUpdatePass), 
            classes = NO_CHANGE), firstUpdatePass && (patchConfig(tNode, 512), patchHostStylingFlag(tNode, isHostStyling(), !0)), 
            stylingMap(context, tNode, firstUpdatePass, lView, bindingIndex, classes, !0, hasDirectiveInput);
        }
        function stylingMap(context, tNode, firstUpdatePass, lView, bindingIndex, value, isClassBased, hasDirectiveInput) {
            const directiveIndex = getActiveDirectiveId(), native = getNativeByTNode(tNode, lView), oldValue = getValue(lView, bindingIndex), sanitizer = getCurrentStyleSanitizer(), valueHasChanged = hasValueChanged(oldValue, value);
            if (allowDirectStyling(tNode, isClassBased, firstUpdatePass)) {
                const sanitizerToUse = isClassBased ? null : sanitizer;
                (function(renderer, context, tNode, element, data, bindingIndex, value, isClassBased, sanitizer, forceUpdate, bindingValueContainsInitial) {
                    const oldValue = getValue(data, bindingIndex);
                    if (forceUpdate || hasValueChanged(oldValue, value)) {
                        const hasInitial = hasConfig(tNode, 256), initialValue = hasInitial && !bindingValueContainsInitial ? getInitialStylingValue(context) : null;
                        setValue(data, bindingIndex, value);
                        const cachedValueIndex = bindingIndex + 1;
                        let cachedValue = getValue(data, cachedValueIndex);
                        cachedValue === NO_CHANGE && (cachedValue = initialValue), cachedValue = "string" != typeof cachedValue ? "" : cachedValue;
                        let writeToAttrDirectly = !hasConfig(tNode, isClassBased ? 1024 : 32768);
                        if (writeToAttrDirectly && function(element, cachedValue, isClassBased) {
                            return "undefined" === _global.Node || cachedValue === VALUE_IS_EXTERNALLY_MODIFIED || ((isClassBased ? element.className : element.style && element.style.cssText) || "") !== (cachedValue || "");
                        }(element, cachedValue, isClassBased) && (writeToAttrDirectly = !1, oldValue !== VALUE_IS_EXTERNALLY_MODIFIED && (function(renderer, element, values, isClassBased) {
                            let arr;
                            var value;
                            value = values, arr = Array.isArray(value) && "string" == typeof value[1] ? values : normalizeIntoStylingMap(null, values, !isClassBased);
                            const applyFn = isClassBased ? setClass : setStyle;
                            for (let i = 1; i < arr.length; i += 2) getMapValue(arr, i) && applyFn(renderer, element, getMapProp(arr, i), !1);
                        }(renderer, element, oldValue, isClassBased), setValue(data, cachedValueIndex, VALUE_IS_EXTERNALLY_MODIFIED))), 
                        writeToAttrDirectly) setValue(data, cachedValueIndex, writeStylingValueDirectly(renderer, element, value, isClassBased, hasInitial && !bindingValueContainsInitial ? getInitialStylingValue(context) : null) || null); else {
                            const applyFn = isClassBased ? setClass : setStyle, map = normalizeIntoStylingMap(oldValue, value, !isClassBased), initialStyles = hasInitial ? getStylingMapArray(context) : null;
                            for (let i = 1; i < map.length; i += 2) {
                                const prop = getMapProp(map, i);
                                let applied = applyStylingValue(renderer, element, prop, getMapValue(map, i), applyFn, bindingIndex, sanitizer);
                                !applied && initialStyles && (applied = findAndApplyMapValue(renderer, element, applyFn, initialStyles, prop, bindingIndex, sanitizer)), 
                                applied || applyFn(renderer, element, prop, null, bindingIndex);
                            }
                            const state = getStylingState(element, TEMPLATE_DIRECTIVE_INDEX);
                            isClassBased ? state.lastDirectClassMap = map : state.lastDirectStyleMap = map;
                        }
                    }
                })(getRenderer(tNode, lView), context, tNode, native, lView, bindingIndex, value, isClassBased, sanitizerToUse, valueHasChanged, hasDirectiveInput), 
                sanitizerToUse && setElementExitFn(stylingApply);
            } else {
                const stylingMapArr = value === NO_CHANGE ? NO_CHANGE : normalizeIntoStylingMap(oldValue, value, !isClassBased);
                _activeStylingMapApplyFn = syncStylingMap, isClassBased ? updateClassViaContext(context, tNode, lView, native, directiveIndex, null, bindingIndex, stylingMapArr, valueHasChanged, firstUpdatePass) : updateStyleViaContext(context, tNode, lView, native, directiveIndex, null, bindingIndex, stylingMapArr, sanitizer, valueHasChanged, firstUpdatePass), 
                setElementExitFn(stylingApply);
            }
        }
        function updateDirectiveInputValue(context, lView, tNode, bindingIndex, newValue, isClassBased, firstUpdatePass) {
            if (hasValueChanged(getValue(lView, bindingIndex), newValue)) {
                if (isStylingValueDefined(newValue) || !firstUpdatePass) {
                    const inputName = isClassBased ? selectClassBasedInputName(tNode.inputs) : "style";
                    setInputsForProperty(lView, tNode.inputs[inputName], function(initialValue, bindingValue, isClassBased) {
                        let value = bindingValue;
                        var classes;
                        return initialValue.length && (value = isClassBased ? concatString(initialValue, ((classes = bindingValue) && "string" != typeof classes && (classes = Object.keys(classes).join(" ")), 
                        classes || "")) : concatString(initialValue, forceStylesAsString(bindingValue, !0), ";")), 
                        value;
                    }(getInitialStylingValue(context), newValue, isClassBased)), setElementExitFn(stylingApply);
                }
                setValue(lView, bindingIndex, newValue);
            }
        }
        function stylingApply() {
            const lView = getLView(), tView = lView[TVIEW], tNode = getTNode(getSelectedIndex(), lView), native = getNativeByTNode(tNode, lView), directiveIndex = getActiveDirectiveId(), renderer = getRenderer(tNode, lView), sanitizer = getCurrentStyleSanitizer();
            (function(renderer, data, tNode, classesContext, stylesContext, element, directiveIndex, styleSanitizer, firstUpdatePass) {
                const state = getStylingState(element, directiveIndex), hostBindingsMode = isHostStylingActive(state.sourceIndex);
                stylesContext && (firstUpdatePass && syncContextInitialStyling(stylesContext, tNode, !1), 
                0 !== state.stylesBitMask && applyStylingViaContext(stylesContext, tNode, renderer, element, data, state.stylesBitMask, setStyle, styleSanitizer, hostBindingsMode, !1)), 
                classesContext && (firstUpdatePass && syncContextInitialStyling(classesContext, tNode, !0), 
                0 !== state.classesBitMask && applyStylingViaContext(classesContext, tNode, renderer, element, data, state.classesBitMask, setClass, null, hostBindingsMode, !0)), 
                _state.element = null;
            })(renderer, lView, tNode, isStylingContext(tNode.classes) ? tNode.classes : null, isStylingContext(tNode.styles) ? tNode.styles : null, native, directiveIndex, sanitizer, tView.firstUpdatePass), 
            setCurrentStyleSanitizer(null);
        }
        function getRenderer(tNode, lView) {
            return 3 === tNode.type ? lView[RENDERER] : null;
        }
        function registerInitialStylingOnTNode(tNode, attrs, startIndex) {
            let hasAdditionalInitialStyling = !1, styles = getStylingMapArray(tNode.styles), classes = getStylingMapArray(tNode.classes), mode = -1;
            for (let i = startIndex; i < attrs.length; i++) {
                const attr = attrs[i];
                if ("number" == typeof attr) mode = attr; else if (1 == mode) addItemToStylingMap(classes = classes || allocStylingMapArray(null), attr, !0), 
                hasAdditionalInitialStyling = !0; else if (2 == mode) {
                    const value = attrs[++i];
                    addItemToStylingMap(styles = styles || allocStylingMapArray(null), attr, value), 
                    hasAdditionalInitialStyling = !0;
                }
            }
            return classes && classes.length > 1 && (tNode.classes || (tNode.classes = classes), 
            updateRawValueOnContext(tNode.classes, stylingMapToString(classes, !0))), styles && styles.length > 1 && (tNode.styles || (tNode.styles = styles), 
            updateRawValueOnContext(tNode.styles, stylingMapToString(styles, !1))), hasAdditionalInitialStyling && (tNode.flags |= 256), 
            hasAdditionalInitialStyling;
        }
        function updateRawValueOnContext(context, value) {
            getStylingMapArray(context)[0] = value;
        }
        function getStylesContext(tNode) {
            return getContext(tNode, !1);
        }
        function getClassesContext(tNode) {
            return getContext(tNode, !0);
        }
        function getContext(tNode, isClassBased) {
            let context = isClassBased ? tNode.classes : tNode.styles;
            var initialStyling;
            return isStylingContext(context) || (isDirectiveHost(tNode), initialStyling = (initialStyling = context) || allocStylingMapArray(null), 
            context = [ DEFAULT_TOTAL_SOURCES, initialStyling ], isClassBased ? tNode.classes = context : tNode.styles = context), 
            context;
        }
        function isHostStyling() {
            return isHostStylingActive(getActiveDirectiveId());
        }
        function patchHostStylingFlag(tNode, hostBindingsMode, isClassBased) {
            patchConfig(tNode, hostBindingsMode ? isClassBased ? 4096 : 131072 : isClassBased ? 2048 : 65536);
        }
        function ɵɵelementStart(index, name, attrsIndex, localRefsIndex) {
            const lView = getLView(), tView = lView[TVIEW], tViewConsts = tView.consts, attrs = getConstant(tViewConsts, attrsIndex), localRefs = getConstant(tViewConsts, localRefsIndex), renderer = lView[RENDERER], native = lView[index + HEADER_OFFSET] = elementCreate(name, renderer, instructionState.lFrame.currentNamespace), tNode = getOrCreateTNode(tView, lView[T_HOST], index, 3, name, attrs);
            if (null != attrs) {
                const lastAttrIndex = setUpAttributes(renderer, native, attrs);
                tView.firstCreatePass && registerInitialStylingOnTNode(tNode, attrs, lastAttrIndex);
            }
            256 == (256 & tNode.flags) && renderInitialStyling(renderer, native, tNode, !1), 
            appendChild(native, tNode, lView), 0 === instructionState.lFrame.elementDepthCount && attachPatchData(native, lView), 
            instructionState.lFrame.elementDepthCount++, tView.firstCreatePass && (resolveDirectives(tView, lView, tNode, localRefs), 
            null !== tView.queries && tView.queries.elementStart(tView, tNode)), isDirectiveHost(tNode) && (createDirectivesInstances(tView, lView, tNode), 
            executeContentQueries(tView, tNode, lView)), null != localRefs && saveResolvedLocalsInData(lView, tNode);
        }
        function ɵɵelementEnd() {
            let previousOrParentTNode = getPreviousOrParentTNode();
            getIsParent() ? setIsNotParent() : setPreviousOrParentTNode(previousOrParentTNode = previousOrParentTNode.parent, !1);
            const tNode = previousOrParentTNode, lView = getLView(), tView = lView[TVIEW];
            if (instructionState.lFrame.elementDepthCount--, tView.firstCreatePass && (registerPostOrderHooks(tView, previousOrParentTNode), 
            isContentQueryHost(previousOrParentTNode) && tView.queries.elementEnd(previousOrParentTNode)), 
            hasClassInput(tNode)) {
                const inputName = selectClassBasedInputName(tNode.inputs);
                setDirectiveStylingInput(tNode.classes, lView, tNode.inputs[inputName]);
            }
            hasStyleInput(tNode) && setDirectiveStylingInput(tNode.styles, lView, tNode.inputs.style);
        }
        function ɵɵelement(index, name, attrsIndex, localRefsIndex) {
            ɵɵelementStart(index, name, attrsIndex, localRefsIndex), ɵɵelementEnd();
        }
        function ɵɵelementHostAttrs(attrs) {
            const hostElementIndex = getSelectedIndex(), lView = getLView(), tView = lView[TVIEW], tNode = getTNode(hostElementIndex, lView);
            if (3 === tNode.type) {
                const native = getNativeByTNode(tNode, lView), lastAttrIndex = setUpAttributes(lView[RENDERER], native, attrs);
                tView.firstCreatePass && registerInitialStylingOnTNode(tNode, attrs, lastAttrIndex) && renderInitialStyling(lView[RENDERER], native, tNode, !0);
            }
        }
        function setDirectiveStylingInput(context, lView, stylingInputs) {
            setInputsForProperty(lView, stylingInputs, context && getInitialStylingValue(context) || null);
        }
        function ɵɵelementContainerStart(index, attrsIndex, localRefsIndex) {
            const lView = getLView(), tView = lView[TVIEW], renderer = lView[RENDERER], tViewConsts = tView.consts, attrs = getConstant(tViewConsts, attrsIndex), localRefs = getConstant(tViewConsts, localRefsIndex), native = lView[index + HEADER_OFFSET] = renderer.createComment(""), tNode = getOrCreateTNode(tView, lView[T_HOST], index, 4, "ng-container", attrs);
            attrs && tView.firstCreatePass && registerInitialStylingOnTNode(tNode, attrs, 0), 
            appendChild(native, tNode, lView), attachPatchData(native, lView), tView.firstCreatePass && (resolveDirectives(tView, lView, tNode, localRefs), 
            tView.queries && tView.queries.elementStart(tView, tNode)), isDirectiveHost(tNode) && (createDirectivesInstances(tView, lView, tNode), 
            executeContentQueries(tView, tNode, lView)), null != localRefs && saveResolvedLocalsInData(lView, tNode);
        }
        function ɵɵelementContainerEnd() {
            let previousOrParentTNode = getPreviousOrParentTNode();
            const tView = getLView()[TVIEW];
            getIsParent() ? setIsNotParent() : setPreviousOrParentTNode(previousOrParentTNode = previousOrParentTNode.parent, !1), 
            tView.firstCreatePass && (registerPostOrderHooks(tView, previousOrParentTNode), 
            isContentQueryHost(previousOrParentTNode) && tView.queries.elementEnd(previousOrParentTNode));
        }
        function ɵɵgetCurrentView() {
            return getLView();
        }
        function isPromise(obj) {
            return !!obj && "function" == typeof obj.then;
        }
        function isObservable(obj) {
            return !!obj && "function" == typeof obj.subscribe;
        }
        function ɵɵlistener(eventName, listenerFn, useCapture = !1, eventTargetResolver) {
            const lView = getLView(), tNode = getPreviousOrParentTNode();
            listenerInternal(lView, lView[RENDERER], tNode, eventName, listenerFn, useCapture, eventTargetResolver);
        }
        function ɵɵcomponentHostSyntheticListener(eventName, listenerFn, useCapture = !1, eventTargetResolver) {
            const lView = getLView(), tNode = getPreviousOrParentTNode();
            listenerInternal(lView, loadComponentRenderer(tNode, lView), tNode, eventName, listenerFn, useCapture, eventTargetResolver);
        }
        function listenerInternal(lView, renderer, tNode, eventName, listenerFn, useCapture = !1, eventTargetResolver) {
            const tView = lView[TVIEW], isTNodeDirectiveHost = isDirectiveHost(tNode), tCleanup = tView.firstCreatePass && (tView.cleanup || (tView.cleanup = []));
            let processOutputs = !0;
            if (3 === tNode.type) {
                const native = getNativeByTNode(tNode, lView), resolved = eventTargetResolver ? eventTargetResolver(native) : EMPTY_OBJ, target = resolved.target || native, lCleanup = getCleanup(lView), lCleanupIndex = lCleanup.length, idxOrTargetGetter = eventTargetResolver ? _lView => eventTargetResolver(unwrapRNode(_lView[tNode.index])).target : tNode.index;
                if (isProceduralRenderer(renderer)) {
                    let existingListener = null;
                    if (!eventTargetResolver && isTNodeDirectiveHost && (existingListener = function(lView, eventName, tNodeIdx) {
                        const tCleanup = lView[TVIEW].cleanup;
                        if (null != tCleanup) for (let i = 0; i < tCleanup.length - 1; i += 2) {
                            const cleanupEventName = tCleanup[i];
                            if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {
                                const lCleanup = lView[CLEANUP], listenerIdxInLCleanup = tCleanup[i + 2];
                                return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;
                            }
                            "string" == typeof cleanupEventName && (i += 2);
                        }
                        return null;
                    }(lView, eventName, tNode.index)), null !== existingListener) (existingListener.__ngLastListenerFn__ || existingListener).__ngNextListenerFn__ = listenerFn, 
                    existingListener.__ngLastListenerFn__ = listenerFn, processOutputs = !1; else {
                        listenerFn = wrapListener(tNode, lView, listenerFn, !1);
                        const cleanupFn = renderer.listen(resolved.name || target, eventName, listenerFn);
                        lCleanup.push(listenerFn, cleanupFn), tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);
                    }
                } else listenerFn = wrapListener(tNode, lView, listenerFn, !0), target.addEventListener(eventName, listenerFn, useCapture), 
                lCleanup.push(listenerFn), tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, useCapture);
            }
            const outputs = tNode.outputs;
            let props;
            if (processOutputs && null != outputs && (props = outputs[eventName])) {
                const propsLength = props.length;
                if (propsLength) {
                    const lCleanup = getCleanup(lView);
                    for (let i = 0; i < propsLength; i += 3) {
                        const subscription = lView[props[i]][props[i + 2]].subscribe(listenerFn), idx = lCleanup.length;
                        lCleanup.push(listenerFn, subscription), tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));
                    }
                }
            }
        }
        function executeListenerWithErrorHandling(lView, tNode, listenerFn, e) {
            try {
                return !1 !== listenerFn(e);
            } catch (error) {
                return handleError(lView, error), !1;
            }
        }
        function wrapListener(tNode, lView, listenerFn, wrapWithPreventDefault) {
            return function wrapListenerIn_markDirtyAndPreventDefault(e) {
                if (e === Function) return listenerFn;
                const startView = 2 & tNode.flags ? getComponentLViewByIndex(tNode.index, lView) : lView;
                0 == (32 & lView[FLAGS]) && markViewDirty(startView);
                let result = executeListenerWithErrorHandling(lView, 0, listenerFn, e), nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;
                for (;nextListenerFn; ) result = executeListenerWithErrorHandling(lView, 0, nextListenerFn, e) && result, 
                nextListenerFn = nextListenerFn.__ngNextListenerFn__;
                return wrapWithPreventDefault && !1 === result && (e.preventDefault(), e.returnValue = !1), 
                result;
            };
        }
        function ɵɵnextContext(level = 1) {
            return function(level = 1) {
                return instructionState.lFrame.contextLView = function(nestingLevel, currentView) {
                    for (;nestingLevel > 0; ) currentView = currentView[DECLARATION_VIEW], nestingLevel--;
                    return currentView;
                }(level, instructionState.lFrame.contextLView), instructionState.lFrame.contextLView[CONTEXT];
            }(level);
        }
        function matchingProjectionSlotIndex(tNode, projectionSlots) {
            let wildcardNgContentIndex = null;
            const ngProjectAsAttrVal = function(tNode) {
                const nodeAttrs = tNode.attrs;
                if (null != nodeAttrs) {
                    const ngProjectAsAttrIdx = nodeAttrs.indexOf(5);
                    if (0 == (1 & ngProjectAsAttrIdx)) return nodeAttrs[ngProjectAsAttrIdx + 1];
                }
                return null;
            }(tNode);
            for (let i = 0; i < projectionSlots.length; i++) {
                const slotValue = projectionSlots[i];
                if ("*" !== slotValue) {
                    if (null === ngProjectAsAttrVal ? isNodeMatchingSelectorList(tNode, slotValue, !0) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) return i;
                } else wildcardNgContentIndex = i;
            }
            return wildcardNgContentIndex;
        }
        function ɵɵprojectionDef(projectionSlots) {
            const componentNode = findComponentView(getLView())[T_HOST];
            if (!componentNode.projection) {
                const projectionHeads = componentNode.projection = newArray(projectionSlots ? projectionSlots.length : 1, null), tails = projectionHeads.slice();
                let componentChild = componentNode.child;
                for (;null !== componentChild; ) {
                    const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;
                    null !== slotIndex && (tails[slotIndex] ? tails[slotIndex].projectionNext = componentChild : projectionHeads[slotIndex] = componentChild, 
                    tails[slotIndex] = componentChild), componentChild = componentChild.next;
                }
            }
        }
        let delayProjection = !1;
        function ɵɵprojection(nodeIndex, selectorIndex = 0, attrs) {
            const lView = getLView(), tProjectionNode = getOrCreateTNode(lView[TVIEW], lView[T_HOST], nodeIndex, 1, null, attrs || null);
            null === tProjectionNode.projection && (tProjectionNode.projection = selectorIndex), 
            setIsNotParent(), delayProjection || function(lView, tProjectionNode) {
                applyProjectionRecursive(lView[RENDERER], 0, lView, tProjectionNode, getRenderParent(tProjectionNode, lView), getNativeAnchorNode(tProjectionNode.parent || lView[T_HOST], lView));
            }(lView, tProjectionNode);
        }
        function ɵɵproperty(propName, value, sanitizer) {
            const lView = getLView();
            return bindingUpdated(lView, nextBindingIndex(), value) && elementPropertyInternal(lView, getSelectedIndex(), propName, value, sanitizer), 
            ɵɵproperty;
        }
        function ɵɵpropertyInterpolate(propName, v0, sanitizer) {
            return ɵɵpropertyInterpolate1(propName, "", v0, "", sanitizer), ɵɵpropertyInterpolate;
        }
        function ɵɵpropertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {
            const lView = getLView(), interpolatedValue = interpolation1(lView, prefix, v0, suffix);
            return interpolatedValue !== NO_CHANGE && elementPropertyInternal(lView, getSelectedIndex(), propName, interpolatedValue, sanitizer), 
            ɵɵpropertyInterpolate1;
        }
        function ɵɵtext(index, value = "") {
            const lView = getLView(), textNative = lView[index + HEADER_OFFSET] = function(value, renderer) {
                return isProceduralRenderer(renderer) ? renderer.createText(value) : renderer.createTextNode(value);
            }(value, lView[RENDERER]), tNode = getOrCreateTNode(lView[TVIEW], lView[T_HOST], index, 3, null, null);
            setIsNotParent(), appendChild(textNative, tNode, lView);
        }
        function ɵɵtextInterpolate(v0) {
            return ɵɵtextInterpolate1("", v0, ""), ɵɵtextInterpolate;
        }
        function ɵɵtextInterpolate1(prefix, v0, suffix) {
            const lView = getLView(), interpolated = interpolation1(lView, prefix, v0, suffix);
            return interpolated !== NO_CHANGE && textBindingInternal(lView, getSelectedIndex(), interpolated), 
            ɵɵtextInterpolate1;
        }
        function ɵɵtextInterpolate2(prefix, v0, i0, v1, suffix) {
            const lView = getLView(), interpolated = function(lView, prefix, v0, i0, v1, suffix) {
                const different = bindingUpdated2(lView, getBindingIndex(), v0, v1);
                return incrementBindingIndex(2), different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;
            }(lView, prefix, v0, i0, v1, suffix);
            return interpolated !== NO_CHANGE && textBindingInternal(lView, getSelectedIndex(), interpolated), 
            ɵɵtextInterpolate2;
        }
        function ɵɵclassMapInterpolate1(prefix, v0, suffix) {
            const interpolatedValue = interpolation1(getLView(), prefix, v0, suffix);
            classMapInternal(getSelectedIndex(), interpolatedValue);
        }
        function ɵɵhostProperty(propName, value, sanitizer) {
            const lView = getLView();
            return bindingUpdated(lView, nextBindingIndex(), value) && elementPropertyInternal(lView, getSelectedIndex(), propName, value, sanitizer, !0), 
            ɵɵhostProperty;
        }
        function ɵɵupdateSyntheticHostBinding(propName, value, sanitizer) {
            const lView = getLView();
            return bindingUpdated(lView, nextBindingIndex(), value) && elementPropertyInternal(lView, getSelectedIndex(), propName, value, sanitizer, !0, loadComponentRenderer), 
            ɵɵupdateSyntheticHostBinding;
        }
        function getComponent(element) {
            if (!(element instanceof Node)) throw new Error("Expecting instance of DOM Node");
            const context = loadLContext(element, !1);
            return null === context ? null : (void 0 === context.component && (context.component = function(nodeIndex, lView) {
                const tNode = lView[TVIEW].data[nodeIndex];
                return 2 & tNode.flags ? lView[tNode.directiveStart] : null;
            }(context.nodeIndex, context.lView)), context.component);
        }
        function loadLContext(target, throwOnNotFound = !0) {
            const context = function(target) {
                let mpValue = readPatchedData(target);
                if (mpValue) {
                    if (Array.isArray(mpValue)) {
                        const lView = mpValue;
                        let nodeIndex, component = void 0, directives = void 0;
                        if ((instance = target) && instance.constructor && instance.constructor.ɵcmp) {
                            if (-1 == (nodeIndex = function(lView, componentInstance) {
                                const componentIndices = lView[TVIEW].components;
                                if (componentIndices) for (let i = 0; i < componentIndices.length; i++) {
                                    const elementComponentIndex = componentIndices[i];
                                    if (getComponentLViewByIndex(elementComponentIndex, lView)[CONTEXT] === componentInstance) return elementComponentIndex;
                                } else if (getComponentLViewByIndex(HEADER_OFFSET, lView)[CONTEXT] === componentInstance) return HEADER_OFFSET;
                                return -1;
                            }(lView, target))) throw new Error("The provided component was not found in the application");
                            component = target;
                        } else if (function(instance) {
                            return instance && instance.constructor && instance.constructor.ɵdir;
                        }(target)) {
                            if (-1 == (nodeIndex = function(lView, directiveInstance) {
                                let tNode = lView[TVIEW].firstChild;
                                for (;tNode; ) {
                                    const directiveIndexEnd = tNode.directiveEnd;
                                    for (let i = tNode.directiveStart; i < directiveIndexEnd; i++) if (lView[i] === directiveInstance) return tNode.index;
                                    tNode = traverseNextElement(tNode);
                                }
                                return -1;
                            }(lView, target))) throw new Error("The provided directive was not found in the application");
                            directives = function(nodeIndex, lView, includeComponents) {
                                const tNode = lView[TVIEW].data[nodeIndex];
                                let directiveStartIndex = tNode.directiveStart;
                                return 0 == directiveStartIndex ? EMPTY_ARRAY : (2 & tNode.flags && directiveStartIndex++, 
                                lView.slice(directiveStartIndex, tNode.directiveEnd));
                            }(nodeIndex, lView);
                        } else if (-1 == (nodeIndex = findViaNativeElement(lView, target))) return null;
                        const native = unwrapRNode(lView[nodeIndex]), existingCtx = readPatchedData(native), context = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);
                        if (component && void 0 === context.component && (context.component = component, 
                        attachPatchData(context.component, context)), directives && void 0 === context.directives) {
                            context.directives = directives;
                            for (let i = 0; i < directives.length; i++) attachPatchData(directives[i], context);
                        }
                        attachPatchData(context.native, context), mpValue = context;
                    }
                } else {
                    const rElement = target;
                    let parent = rElement;
                    for (;parent = parent.parentNode; ) {
                        const parentContext = readPatchedData(parent);
                        if (parentContext) {
                            let lView;
                            if (!(lView = Array.isArray(parentContext) ? parentContext : parentContext.lView)) return null;
                            const index = findViaNativeElement(lView, rElement);
                            if (index >= 0) {
                                const native = unwrapRNode(lView[index]), context = createLContext(lView, index, native);
                                attachPatchData(native, context), mpValue = context;
                                break;
                            }
                        }
                    }
                }
                var instance;
                return (mpValue || null);
            }(target);
            if (!context && throwOnNotFound) throw new Error("Invalid ng target");
            return context;
        }
        function isBrowserEvents(listener) {
            return "boolean" == typeof listener.useCapture;
        }
        function sortListeners(a, b) {
            return a.name == b.name ? 0 : a.name < b.name ? -1 : 1;
        }
        function LifecycleHooksFeature(component, def) {
            const rootTView = readPatchedLView(component)[TVIEW], dirIndex = rootTView.data.length - 1;
            registerPreOrderHooks(dirIndex, def, rootTView, -1, -1, -1), registerPostOrderHooks(rootTView, {
                directiveStart: dirIndex,
                directiveEnd: dirIndex + 1
            });
        }
        function ɵɵInheritDefinitionFeature(definition) {
            let superType = Object.getPrototypeOf(definition.type.prototype).constructor;
            for (;superType; ) {
                let superDef = void 0;
                if (isComponentDef(definition)) superDef = superType.ɵcmp || superType.ɵdir; else {
                    if (superType.ɵcmp) throw new Error("Directives cannot inherit Components");
                    superDef = superType.ɵdir;
                }
                if (superDef) {
                    const writeableDef = definition;
                    writeableDef.inputs = maybeUnwrapEmpty(definition.inputs), writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs), 
                    writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);
                    const superHostBindings = superDef.hostBindings;
                    superHostBindings && inheritHostBindings(definition, superHostBindings);
                    const superViewQuery = superDef.viewQuery, superContentQueries = superDef.contentQueries;
                    superViewQuery && inheritViewQuery(definition, superViewQuery), superContentQueries && inheritContentQueries(definition, superContentQueries), 
                    fillProperties(definition.inputs, superDef.inputs), fillProperties(definition.declaredInputs, superDef.declaredInputs), 
                    fillProperties(definition.outputs, superDef.outputs), definition.afterContentChecked = definition.afterContentChecked || superDef.afterContentChecked, 
                    definition.afterContentInit = definition.afterContentInit || superDef.afterContentInit, 
                    definition.afterViewChecked = definition.afterViewChecked || superDef.afterViewChecked, 
                    definition.afterViewInit = definition.afterViewInit || superDef.afterViewInit, definition.doCheck = definition.doCheck || superDef.doCheck, 
                    definition.onDestroy = definition.onDestroy || superDef.onDestroy, definition.onInit = definition.onInit || superDef.onInit;
                    const features = superDef.features;
                    if (features) for (let i = 0; i < features.length; i++) {
                        const feature = features[i];
                        feature && feature.ngInherit && feature(definition);
                    }
                }
                superType = Object.getPrototypeOf(superType);
            }
        }
        function maybeUnwrapEmpty(value) {
            return value === EMPTY_OBJ ? {} : value === EMPTY_ARRAY ? [] : value;
        }
        function inheritViewQuery(definition, superViewQuery) {
            const prevViewQuery = definition.viewQuery;
            definition.viewQuery = prevViewQuery ? (rf, ctx) => {
                superViewQuery(rf, ctx), prevViewQuery(rf, ctx);
            } : superViewQuery;
        }
        function inheritContentQueries(definition, superContentQueries) {
            const prevContentQueries = definition.contentQueries;
            definition.contentQueries = prevContentQueries ? (rf, ctx, directiveIndex) => {
                superContentQueries(rf, ctx, directiveIndex), prevContentQueries(rf, ctx, directiveIndex);
            } : superContentQueries;
        }
        function inheritHostBindings(definition, superHostBindings) {
            const prevHostBindings = definition.hostBindings;
            superHostBindings !== prevHostBindings && (definition.hostBindings = prevHostBindings ? (rf, ctx, elementIndex) => {
                superHostBindings(rf, ctx, elementIndex), prevHostBindings(rf, ctx, elementIndex);
            } : superHostBindings);
        }
        class SimpleChange {
            constructor(previousValue, currentValue, firstChange) {
                this.previousValue = previousValue, this.currentValue = currentValue, this.firstChange = firstChange;
            }
            isFirstChange() {
                return this.firstChange;
            }
        }
        function ɵɵNgOnChangesFeature() {
            return NgOnChangesFeatureImpl.ngInherit = !0, NgOnChangesFeatureImpl;
        }
        function NgOnChangesFeatureImpl(definition) {
            definition.type.prototype.ngOnChanges && (definition.setInput = ngOnChangesSetInput, 
            definition.onChanges = function() {
                const simpleChangesStore = getSimpleChangesStore(this), current = simpleChangesStore && simpleChangesStore.current;
                if (current) {
                    const previous = simpleChangesStore.previous;
                    if (previous === EMPTY_OBJ) simpleChangesStore.previous = current; else for (let key in current) previous[key] = current[key];
                    simpleChangesStore.current = null, this.ngOnChanges(current);
                }
            });
        }
        function ngOnChangesSetInput(instance, value, publicName, privateName) {
            const simpleChangesStore = getSimpleChangesStore(instance) || function(instance, store) {
                return instance[SIMPLE_CHANGES_STORE] = store;
            }(instance, {
                previous: EMPTY_OBJ,
                current: null
            }), current = simpleChangesStore.current || (simpleChangesStore.current = {}), previous = simpleChangesStore.previous, declaredName = this.declaredInputs[publicName], previousChange = previous[declaredName];
            current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ), 
            instance[privateName] = value;
        }
        const SIMPLE_CHANGES_STORE = "__ngSimpleChanges__";
        function getSimpleChangesStore(instance) {
            return instance[SIMPLE_CHANGES_STORE] || null;
        }
        function resolveProvider$1(provider, tInjectables, lInjectablesBlueprint, isComponent, isViewProvider) {
            if (provider = resolveForwardRef(provider), Array.isArray(provider)) for (let i = 0; i < provider.length; i++) resolveProvider$1(provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider); else {
                const lView = getLView(), tView = lView[TVIEW];
                let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide), providerFactory = providerToFactory(provider);
                const tNode = getPreviousOrParentTNode(), beginIndex = 65535 & tNode.providerIndexes, endIndex = tNode.directiveStart, cptViewProvidersCount = tNode.providerIndexes >> 16;
                if (provider.useClass || isTypeProvider(provider)) {
                    const ngOnDestroy = (provider.useClass || provider).prototype.ngOnDestroy;
                    ngOnDestroy && (tView.destroyHooks || (tView.destroyHooks = [])).push(tInjectables.length, ngOnDestroy);
                }
                if (isTypeProvider(provider) || !provider.multi) {
                    const factory = new NodeInjectorFactory(providerFactory, isViewProvider, ɵɵdirectiveInject), existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);
                    -1 == existingFactoryIndex ? (diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token), 
                    tInjectables.push(token), tNode.directiveStart++, tNode.directiveEnd++, isViewProvider && (tNode.providerIndexes += 65536), 
                    lInjectablesBlueprint.push(factory), lView.push(factory)) : (lInjectablesBlueprint[existingFactoryIndex] = factory, 
                    lView[existingFactoryIndex] = factory);
                } else {
                    const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex), existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount), doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex], doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];
                    if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {
                        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
                        const factory = function(factoryFn, index, isViewProvider, isComponent, f) {
                            const factory = new NodeInjectorFactory(factoryFn, isViewProvider, ɵɵdirectiveInject);
                            return factory.multi = [], factory.index = index, factory.componentProviders = 0, 
                            multiFactoryAdd(factory, f, isComponent && !isViewProvider), factory;
                        }(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory);
                        !isViewProvider && doesViewProvidersFactoryExist && (lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory), 
                        tInjectables.push(token), tNode.directiveStart++, tNode.directiveEnd++, isViewProvider && (tNode.providerIndexes += 65536), 
                        lInjectablesBlueprint.push(factory), lView.push(factory);
                    } else multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent);
                    !isViewProvider && isComponent && doesViewProvidersFactoryExist && lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;
                }
            }
        }
        function multiFactoryAdd(multiFactory, factory, isComponentProvider) {
            multiFactory.multi.push(factory), isComponentProvider && multiFactory.componentProviders++;
        }
        function indexOf(item, arr, begin, end) {
            for (let i = begin; i < end; i++) if (arr[i] === item) return i;
            return -1;
        }
        function multiProvidersFactoryResolver(_, tData, lData, tNode) {
            return multiResolve(this.multi, []);
        }
        function multiViewProvidersFactoryResolver(_, tData, lData, tNode) {
            const factories = this.multi;
            let result;
            if (this.providerFactory) {
                const componentCount = this.providerFactory.componentProviders, multiProviders = getNodeInjectable(tData, lData, this.providerFactory.index, tNode);
                multiResolve(factories, result = multiProviders.slice(0, componentCount));
                for (let i = componentCount; i < multiProviders.length; i++) result.push(multiProviders[i]);
            } else multiResolve(factories, result = []);
            return result;
        }
        function multiResolve(factories, result) {
            for (let i = 0; i < factories.length; i++) result.push((0, factories[i])());
            return result;
        }
        function ɵɵProvidersFeature(providers, viewProviders = []) {
            return definition => {
                definition.providersResolver = (def, processProvidersFn) => (function(def, providers, viewProviders) {
                    const tView = getLView()[TVIEW];
                    if (tView.firstCreatePass) {
                        const isComponent = isComponentDef(def);
                        resolveProvider$1(viewProviders, tView.data, tView.blueprint, isComponent, !0), 
                        resolveProvider$1(providers, tView.data, tView.blueprint, isComponent, !1);
                    }
                })(def, processProvidersFn ? processProvidersFn(providers) : providers, viewProviders);
            };
        }
        class ComponentRef {}
        class ComponentFactory {}
        const ERROR_COMPONENT = "ngComponent";
        class _NullComponentFactoryResolver {
            resolveComponentFactory(component) {
                throw function(component) {
                    const error = Error(`No component factory found for ${stringify(component)}. Did you add it to @NgModule.entryComponents?`);
                    return error[ERROR_COMPONENT] = component, error;
                }(component);
            }
        }
        let ComponentFactoryResolver = (() => {
            class ComponentFactoryResolver {}
            return ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver, ComponentFactoryResolver;
        })(), ElementRef = (() => {
            class ElementRef {
                constructor(nativeElement) {
                    this.nativeElement = nativeElement;
                }
            }
            return ElementRef.__NG_ELEMENT_ID__ = () => SWITCH_ELEMENT_REF_FACTORY(ElementRef), 
            ElementRef;
        })();
        const SWITCH_ELEMENT_REF_FACTORY = function(ElementRefToken) {
            return createElementRef(ElementRefToken, getPreviousOrParentTNode(), getLView());
        };
        class RendererFactory2 {}
        const RendererStyleFlags2 = function() {
            var RendererStyleFlags2 = {
                Important: 1,
                DashCase: 2
            };
            return RendererStyleFlags2[RendererStyleFlags2.Important] = "Important", RendererStyleFlags2[RendererStyleFlags2.DashCase] = "DashCase", 
            RendererStyleFlags2;
        }();
        let Renderer2 = (() => {
            class Renderer2 {}
            return Renderer2.__NG_ELEMENT_ID__ = () => SWITCH_RENDERER2_FACTORY(), Renderer2;
        })();
        const SWITCH_RENDERER2_FACTORY = function() {
            const lView = getLView(), nodeAtIndex = getComponentLViewByIndex(getPreviousOrParentTNode().index, lView);
            return function(view) {
                const renderer = view[RENDERER];
                if (isProceduralRenderer(renderer)) return renderer;
                throw new Error("Cannot inject Renderer2 when the application uses Renderer3!");
            }(isLView(nodeAtIndex) ? nodeAtIndex : lView);
        };
        let Sanitizer = (() => {
            class Sanitizer {}
            return Sanitizer.ɵprov = ɵɵdefineInjectable({
                token: Sanitizer,
                providedIn: "root",
                factory: () => null
            }), Sanitizer;
        })();
        class Version {
            constructor(full) {
                this.full = full, this.major = full.split(".")[0], this.minor = full.split(".")[1], 
                this.patch = full.split(".").slice(2).join(".");
            }
        }
        const VERSION = new Version("9.0.0-rc.2");
        class DefaultIterableDifferFactory {
            constructor() {}
            supports(obj) {
                return isListLikeIterable$1(obj);
            }
            create(trackByFn) {
                return new DefaultIterableDiffer(trackByFn);
            }
        }
        const trackByIdentity = (index, item) => item;
        class DefaultIterableDiffer {
            constructor(trackByFn) {
                this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, 
                this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, 
                this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, 
                this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = trackByFn || trackByIdentity;
            }
            forEachItem(fn) {
                let record;
                for (record = this._itHead; null !== record; record = record._next) fn(record);
            }
            forEachOperation(fn) {
                let nextIt = this._itHead, nextRemove = this._removalsHead, addRemoveOffset = 0, moveOffsets = null;
                for (;nextIt || nextRemove; ) {
                    const record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove, adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets), currentIndex = record.currentIndex;
                    if (record === nextRemove) addRemoveOffset--, nextRemove = nextRemove._nextRemoved; else if (nextIt = nextIt._next, 
                    null == record.previousIndex) addRemoveOffset++; else {
                        moveOffsets || (moveOffsets = []);
                        const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset, localCurrentIndex = currentIndex - addRemoveOffset;
                        if (localMovePreviousIndex != localCurrentIndex) {
                            for (let i = 0; i < localMovePreviousIndex; i++) {
                                const offset = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0, index = offset + i;
                                localCurrentIndex <= index && index < localMovePreviousIndex && (moveOffsets[i] = offset + 1);
                            }
                            moveOffsets[record.previousIndex] = localCurrentIndex - localMovePreviousIndex;
                        }
                    }
                    adjPreviousIndex !== currentIndex && fn(record, adjPreviousIndex, currentIndex);
                }
            }
            forEachPreviousItem(fn) {
                let record;
                for (record = this._previousItHead; null !== record; record = record._nextPrevious) fn(record);
            }
            forEachAddedItem(fn) {
                let record;
                for (record = this._additionsHead; null !== record; record = record._nextAdded) fn(record);
            }
            forEachMovedItem(fn) {
                let record;
                for (record = this._movesHead; null !== record; record = record._nextMoved) fn(record);
            }
            forEachRemovedItem(fn) {
                let record;
                for (record = this._removalsHead; null !== record; record = record._nextRemoved) fn(record);
            }
            forEachIdentityChange(fn) {
                let record;
                for (record = this._identityChangesHead; null !== record; record = record._nextIdentityChange) fn(record);
            }
            diff(collection) {
                if (null == collection && (collection = []), !isListLikeIterable$1(collection)) throw new Error(`Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`);
                return this.check(collection) ? this : null;
            }
            onDestroy() {}
            check(collection) {
                this._reset();
                let index, item, itemTrackBy, record = this._itHead, mayBeDirty = !1;
                if (Array.isArray(collection)) {
                    this.length = collection.length;
                    for (let index = 0; index < this.length; index++) itemTrackBy = this._trackByFn(index, item = collection[index]), 
                    null !== record && looseIdentical(record.trackById, itemTrackBy) ? (mayBeDirty && (record = this._verifyReinsertion(record, item, itemTrackBy, index)), 
                    looseIdentical(record.item, item) || this._addIdentityChange(record, item)) : (record = this._mismatch(record, item, itemTrackBy, index), 
                    mayBeDirty = !0), record = record._next;
                } else index = 0, function(obj, fn) {
                    if (Array.isArray(obj)) for (let i = 0; i < obj.length; i++) fn(obj[i]); else {
                        const iterator = obj[getSymbolIterator()]();
                        let item;
                        for (;!(item = iterator.next()).done; ) fn(item.value);
                    }
                }(collection, item => {
                    itemTrackBy = this._trackByFn(index, item), null !== record && looseIdentical(record.trackById, itemTrackBy) ? (mayBeDirty && (record = this._verifyReinsertion(record, item, itemTrackBy, index)), 
                    looseIdentical(record.item, item) || this._addIdentityChange(record, item)) : (record = this._mismatch(record, item, itemTrackBy, index), 
                    mayBeDirty = !0), record = record._next, index++;
                }), this.length = index;
                return this._truncate(record), this.collection = collection, this.isDirty;
            }
            get isDirty() {
                return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead;
            }
            _reset() {
                if (this.isDirty) {
                    let record, nextRecord;
                    for (record = this._previousItHead = this._itHead; null !== record; record = record._next) record._nextPrevious = record._next;
                    for (record = this._additionsHead; null !== record; record = record._nextAdded) record.previousIndex = record.currentIndex;
                    for (this._additionsHead = this._additionsTail = null, record = this._movesHead; null !== record; record = nextRecord) record.previousIndex = record.currentIndex, 
                    nextRecord = record._nextMoved;
                    this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, 
                    this._identityChangesHead = this._identityChangesTail = null;
                }
            }
            _mismatch(record, item, itemTrackBy, index) {
                let previousRecord;
                return null === record ? previousRecord = this._itTail : (previousRecord = record._prev, 
                this._remove(record)), null !== (record = null === this._linkedRecords ? null : this._linkedRecords.get(itemTrackBy, index)) ? (looseIdentical(record.item, item) || this._addIdentityChange(record, item), 
                this._moveAfter(record, previousRecord, index)) : null !== (record = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(itemTrackBy, null)) ? (looseIdentical(record.item, item) || this._addIdentityChange(record, item), 
                this._reinsertAfter(record, previousRecord, index)) : record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index), 
                record;
            }
            _verifyReinsertion(record, item, itemTrackBy, index) {
                let reinsertRecord = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(itemTrackBy, null);
                return null !== reinsertRecord ? record = this._reinsertAfter(reinsertRecord, record._prev, index) : record.currentIndex != index && (record.currentIndex = index, 
                this._addToMoves(record, index)), record;
            }
            _truncate(record) {
                for (;null !== record; ) {
                    const nextRecord = record._next;
                    this._addToRemovals(this._unlink(record)), record = nextRecord;
                }
                null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), 
                null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), 
                null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null);
            }
            _reinsertAfter(record, prevRecord, index) {
                null !== this._unlinkedRecords && this._unlinkedRecords.remove(record);
                const prev = record._prevRemoved, next = record._nextRemoved;
                return null === prev ? this._removalsHead = next : prev._nextRemoved = next, null === next ? this._removalsTail = prev : next._prevRemoved = prev, 
                this._insertAfter(record, prevRecord, index), this._addToMoves(record, index), record;
            }
            _moveAfter(record, prevRecord, index) {
                return this._unlink(record), this._insertAfter(record, prevRecord, index), this._addToMoves(record, index), 
                record;
            }
            _addAfter(record, prevRecord, index) {
                return this._insertAfter(record, prevRecord, index), this._additionsTail = null === this._additionsTail ? this._additionsHead = record : this._additionsTail._nextAdded = record, 
                record;
            }
            _insertAfter(record, prevRecord, index) {
                const next = null === prevRecord ? this._itHead : prevRecord._next;
                return record._next = next, record._prev = prevRecord, null === next ? this._itTail = record : next._prev = record, 
                null === prevRecord ? this._itHead = record : prevRecord._next = record, null === this._linkedRecords && (this._linkedRecords = new _DuplicateMap), 
                this._linkedRecords.put(record), record.currentIndex = index, record;
            }
            _remove(record) {
                return this._addToRemovals(this._unlink(record));
            }
            _unlink(record) {
                null !== this._linkedRecords && this._linkedRecords.remove(record);
                const prev = record._prev, next = record._next;
                return null === prev ? this._itHead = next : prev._next = next, null === next ? this._itTail = prev : next._prev = prev, 
                record;
            }
            _addToMoves(record, toIndex) {
                return record.previousIndex === toIndex ? record : (this._movesTail = null === this._movesTail ? this._movesHead = record : this._movesTail._nextMoved = record, 
                record);
            }
            _addToRemovals(record) {
                return null === this._unlinkedRecords && (this._unlinkedRecords = new _DuplicateMap), 
                this._unlinkedRecords.put(record), record.currentIndex = null, record._nextRemoved = null, 
                null === this._removalsTail ? (this._removalsTail = this._removalsHead = record, 
                record._prevRemoved = null) : (record._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = record), 
                record;
            }
            _addIdentityChange(record, item) {
                return record.item = item, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = record : this._identityChangesTail._nextIdentityChange = record, 
                record;
            }
        }
        class IterableChangeRecord_ {
            constructor(item, trackById) {
                this.item = item, this.trackById = trackById, this.currentIndex = null, this.previousIndex = null, 
                this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, 
                this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, 
                this._nextMoved = null, this._nextIdentityChange = null;
            }
        }
        class _DuplicateItemRecordList {
            constructor() {
                this._head = null, this._tail = null;
            }
            add(record) {
                null === this._head ? (this._head = this._tail = record, record._nextDup = null, 
                record._prevDup = null) : (this._tail._nextDup = record, record._prevDup = this._tail, 
                record._nextDup = null, this._tail = record);
            }
            get(trackById, atOrAfterIndex) {
                let record;
                for (record = this._head; null !== record; record = record._nextDup) if ((null === atOrAfterIndex || atOrAfterIndex <= record.currentIndex) && looseIdentical(record.trackById, trackById)) return record;
                return null;
            }
            remove(record) {
                const prev = record._prevDup, next = record._nextDup;
                return null === prev ? this._head = next : prev._nextDup = next, null === next ? this._tail = prev : next._prevDup = prev, 
                null === this._head;
            }
        }
        class _DuplicateMap {
            constructor() {
                this.map = new Map;
            }
            put(record) {
                const key = record.trackById;
                let duplicates = this.map.get(key);
                duplicates || (duplicates = new _DuplicateItemRecordList, this.map.set(key, duplicates)), 
                duplicates.add(record);
            }
            get(trackById, atOrAfterIndex) {
                const recordList = this.map.get(trackById);
                return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
            }
            remove(record) {
                const key = record.trackById;
                return this.map.get(key).remove(record) && this.map.delete(key), record;
            }
            get isEmpty() {
                return 0 === this.map.size;
            }
            clear() {
                this.map.clear();
            }
        }
        function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
            const previousIndex = item.previousIndex;
            if (null === previousIndex) return previousIndex;
            let moveOffset = 0;
            return moveOffsets && previousIndex < moveOffsets.length && (moveOffset = moveOffsets[previousIndex]), 
            previousIndex + addRemoveOffset + moveOffset;
        }
        class DefaultKeyValueDifferFactory {
            constructor() {}
            supports(obj) {
                return obj instanceof Map || isJsObject$1(obj);
            }
            create() {
                return new DefaultKeyValueDiffer;
            }
        }
        class DefaultKeyValueDiffer {
            constructor() {
                this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, 
                this._changesHead = null, this._changesTail = null, this._additionsHead = null, 
                this._additionsTail = null, this._removalsHead = null, this._removalsTail = null;
            }
            get isDirty() {
                return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead;
            }
            forEachItem(fn) {
                let record;
                for (record = this._mapHead; null !== record; record = record._next) fn(record);
            }
            forEachPreviousItem(fn) {
                let record;
                for (record = this._previousMapHead; null !== record; record = record._nextPrevious) fn(record);
            }
            forEachChangedItem(fn) {
                let record;
                for (record = this._changesHead; null !== record; record = record._nextChanged) fn(record);
            }
            forEachAddedItem(fn) {
                let record;
                for (record = this._additionsHead; null !== record; record = record._nextAdded) fn(record);
            }
            forEachRemovedItem(fn) {
                let record;
                for (record = this._removalsHead; null !== record; record = record._nextRemoved) fn(record);
            }
            diff(map) {
                if (map) {
                    if (!(map instanceof Map || isJsObject$1(map))) throw new Error(`Error trying to diff '${stringify(map)}'. Only maps and objects are allowed`);
                } else map = new Map;
                return this.check(map) ? this : null;
            }
            onDestroy() {}
            check(map) {
                this._reset();
                let insertBefore = this._mapHead;
                if (this._appendAfter = null, this._forEach(map, (value, key) => {
                    if (insertBefore && insertBefore.key === key) this._maybeAddToChanges(insertBefore, value), 
                    this._appendAfter = insertBefore, insertBefore = insertBefore._next; else {
                        const record = this._getOrCreateRecordForKey(key, value);
                        insertBefore = this._insertBeforeOrAppend(insertBefore, record);
                    }
                }), insertBefore) {
                    insertBefore._prev && (insertBefore._prev._next = null), this._removalsHead = insertBefore;
                    for (let record = insertBefore; null !== record; record = record._nextRemoved) record === this._mapHead && (this._mapHead = null), 
                    this._records.delete(record.key), record._nextRemoved = record._next, record.previousValue = record.currentValue, 
                    record.currentValue = null, record._prev = null, record._next = null;
                }
                return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), 
                this.isDirty;
            }
            _insertBeforeOrAppend(before, record) {
                if (before) {
                    const prev = before._prev;
                    return record._next = before, record._prev = prev, before._prev = record, prev && (prev._next = record), 
                    before === this._mapHead && (this._mapHead = record), this._appendAfter = before, 
                    before;
                }
                return this._appendAfter ? (this._appendAfter._next = record, record._prev = this._appendAfter) : this._mapHead = record, 
                this._appendAfter = record, null;
            }
            _getOrCreateRecordForKey(key, value) {
                if (this._records.has(key)) {
                    const record = this._records.get(key);
                    this._maybeAddToChanges(record, value);
                    const prev = record._prev, next = record._next;
                    return prev && (prev._next = next), next && (next._prev = prev), record._next = null, 
                    record._prev = null, record;
                }
                const record = new KeyValueChangeRecord_(key);
                return this._records.set(key, record), record.currentValue = value, this._addToAdditions(record), 
                record;
            }
            _reset() {
                if (this.isDirty) {
                    let record;
                    for (this._previousMapHead = this._mapHead, record = this._previousMapHead; null !== record; record = record._next) record._nextPrevious = record._next;
                    for (record = this._changesHead; null !== record; record = record._nextChanged) record.previousValue = record.currentValue;
                    for (record = this._additionsHead; null != record; record = record._nextAdded) record.previousValue = record.currentValue;
                    this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, 
                    this._removalsHead = null;
                }
            }
            _maybeAddToChanges(record, newValue) {
                looseIdentical(newValue, record.currentValue) || (record.previousValue = record.currentValue, 
                record.currentValue = newValue, this._addToChanges(record));
            }
            _addToAdditions(record) {
                null === this._additionsHead ? this._additionsHead = this._additionsTail = record : (this._additionsTail._nextAdded = record, 
                this._additionsTail = record);
            }
            _addToChanges(record) {
                null === this._changesHead ? this._changesHead = this._changesTail = record : (this._changesTail._nextChanged = record, 
                this._changesTail = record);
            }
            _forEach(obj, fn) {
                obj instanceof Map ? obj.forEach(fn) : Object.keys(obj).forEach(k => fn(obj[k], k));
            }
        }
        class KeyValueChangeRecord_ {
            constructor(key) {
                this.key = key, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, 
                this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, 
                this._nextChanged = null;
            }
        }
        let IterableDiffers = (() => {
            class IterableDiffers {
                constructor(factories) {
                    this.factories = factories;
                }
                static create(factories, parent) {
                    if (null != parent) {
                        const copied = parent.factories.slice();
                        factories = factories.concat(copied);
                    }
                    return new IterableDiffers(factories);
                }
                static extend(factories) {
                    return {
                        provide: IterableDiffers,
                        useFactory: parent => {
                            if (!parent) throw new Error("Cannot extend IterableDiffers without a parent injector");
                            return IterableDiffers.create(factories, parent);
                        },
                        deps: [ [ IterableDiffers, new SkipSelf, new Optional ] ]
                    };
                }
                find(iterable) {
                    const factory = this.factories.find(f => f.supports(iterable));
                    if (null != factory) return factory;
                    throw new Error(`Cannot find a differ supporting object '${iterable}' of type '${type = iterable, 
                    type.name || typeof type}'`);
                    var type;
                }
            }
            return IterableDiffers.ɵprov = ɵɵdefineInjectable({
                token: IterableDiffers,
                providedIn: "root",
                factory: () => new IterableDiffers([ new DefaultIterableDifferFactory ])
            }), IterableDiffers;
        })(), KeyValueDiffers = (() => {
            class KeyValueDiffers {
                constructor(factories) {
                    this.factories = factories;
                }
                static create(factories, parent) {
                    if (parent) {
                        const copied = parent.factories.slice();
                        factories = factories.concat(copied);
                    }
                    return new KeyValueDiffers(factories);
                }
                static extend(factories) {
                    return {
                        provide: KeyValueDiffers,
                        useFactory: parent => {
                            if (!parent) throw new Error("Cannot extend KeyValueDiffers without a parent injector");
                            return KeyValueDiffers.create(factories, parent);
                        },
                        deps: [ [ KeyValueDiffers, new SkipSelf, new Optional ] ]
                    };
                }
                find(kv) {
                    const factory = this.factories.find(f => f.supports(kv));
                    if (factory) return factory;
                    throw new Error(`Cannot find a differ supporting object '${kv}'`);
                }
            }
            return KeyValueDiffers.ɵprov = ɵɵdefineInjectable({
                token: KeyValueDiffers,
                providedIn: "root",
                factory: () => new KeyValueDiffers([ new DefaultKeyValueDifferFactory ])
            }), KeyValueDiffers;
        })();
        const keyValDiff = [ new DefaultKeyValueDifferFactory ], defaultIterableDiffers = new IterableDiffers([ new DefaultIterableDifferFactory ]), defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
        let TemplateRef = (() => {
            class TemplateRef {}
            return TemplateRef.__NG_ELEMENT_ID__ = () => SWITCH_TEMPLATE_REF_FACTORY(TemplateRef, ElementRef), 
            TemplateRef;
        })();
        const SWITCH_TEMPLATE_REF_FACTORY = function(TemplateRefToken, ElementRefToken) {
            return createTemplateRef(TemplateRefToken, ElementRefToken, getPreviousOrParentTNode(), getLView());
        };
        let ViewContainerRef = (() => {
            class ViewContainerRef {}
            return ViewContainerRef.__NG_ELEMENT_ID__ = () => SWITCH_VIEW_CONTAINER_REF_FACTORY(ViewContainerRef, ElementRef), 
            ViewContainerRef;
        })();
        const SWITCH_VIEW_CONTAINER_REF_FACTORY = function(ViewContainerRefToken, ElementRefToken) {
            return createContainerRef(ViewContainerRefToken, ElementRefToken, getPreviousOrParentTNode(), getLView());
        }, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
        function toRefArray(map) {
            const array = [];
            for (let nonMinified in map) map.hasOwnProperty(nonMinified) && array.push({
                propName: map[nonMinified],
                templateName: nonMinified
            });
            return array;
        }
        const SCHEDULER = new InjectionToken("SCHEDULER_TOKEN", {
            providedIn: "root",
            factory: () => defaultScheduler
        });
        class ComponentFactory$1 extends ComponentFactory {
            constructor(componentDef, ngModule) {
                super(), this.componentDef = componentDef, this.ngModule = ngModule, this.componentType = componentDef.type, 
                this.selector = componentDef.selectors[0][0] || "div", this.ngContentSelectors = componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [], 
                this.isBoundToModule = !!ngModule;
            }
            get inputs() {
                return toRefArray(this.componentDef.inputs);
            }
            get outputs() {
                return toRefArray(this.componentDef.outputs);
            }
            create(injector, projectableNodes, rootSelectorOrNode, ngModule) {
                const rootViewInjector = (ngModule = ngModule || this.ngModule) ? function(rootViewInjector, moduleInjector) {
                    return {
                        get: (token, notFoundValue, flags) => {
                            const value = rootViewInjector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);
                            return value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ? value : moduleInjector.get(token, notFoundValue, flags);
                        }
                    };
                }(injector, ngModule.injector) : injector, rendererFactory = rootViewInjector.get(RendererFactory2, domRendererFactory3), sanitizer = rootViewInjector.get(Sanitizer, null), hostRNode = rootSelectorOrNode ? function(rendererFactory, elementOrSelector, encapsulation) {
                    const renderer = rendererFactory.createRenderer(null, null);
                    if (isProceduralRenderer(renderer)) return renderer.selectRootElement(elementOrSelector, encapsulation === ViewEncapsulation$1.ShadowDom);
                    let rElement = "string" == typeof elementOrSelector ? renderer.querySelector(elementOrSelector) : elementOrSelector;
                    return rElement.textContent = "", rElement;
                }(rendererFactory, rootSelectorOrNode, this.componentDef.encapsulation) : elementCreate(this.selector, rendererFactory.createRenderer(null, this.componentDef), null), rootFlags = this.componentDef.onPush ? 576 : 528, isIsolated = "string" == typeof rootSelectorOrNode && /^#root-ng-internal-isolated-\d+/.test(rootSelectorOrNode), rootContext = {
                    components: [],
                    scheduler: defaultScheduler,
                    clean: CLEAN_PROMISE,
                    playerHandler: null,
                    flags: 0
                }, renderer = rendererFactory.createRenderer(hostRNode, this.componentDef);
                rootSelectorOrNode && hostRNode && (isProceduralRenderer(renderer) ? renderer.setAttribute(hostRNode, "ng-version", VERSION.full) : hostRNode.setAttribute("ng-version", VERSION.full));
                const rootTView = createTView(0, -1, null, 1, 0, null, null, null, null, null), rootLView = createLView(null, rootTView, rootContext, rootFlags, null, null, rendererFactory, renderer, sanitizer, rootViewInjector);
                let component, tElementNode;
                enterView(rootLView, null);
                try {
                    const componentView = function(rNode, def, rootView, rendererFactory, renderer, sanitizer) {
                        const tView = rootView[TVIEW];
                        rootView[0 + HEADER_OFFSET] = rNode;
                        const tNode = getOrCreateTNode(tView, null, 0, 3, null, null), componentView = createLView(rootView, getOrCreateTComponentView(def), null, def.onPush ? 64 : 16, rootView[HEADER_OFFSET], tNode, rendererFactory, renderer, void 0);
                        return tView.firstCreatePass && (diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), tView, def.type), 
                        markAsComponentHost(tView, tNode), initNodeFlags(tNode, rootView.length, 1)), addToViewTree(rootView, componentView), 
                        rootView[HEADER_OFFSET] = componentView;
                    }(hostRNode, this.componentDef, rootLView, rendererFactory, renderer);
                    tElementNode = getTNode(0, rootLView), projectableNodes && (tElementNode.projection = projectableNodes.map(nodesforSlot => Array.from(nodesforSlot))), 
                    component = function(componentView, componentDef, rootView, rootContext, hostFeatures) {
                        const tView = rootView[TVIEW], component = function(tView, lView, def) {
                            const rootTNode = getPreviousOrParentTNode();
                            tView.firstCreatePass && (def.providersResolver && def.providersResolver(def), generateExpandoInstructionBlock(tView, rootTNode, 1), 
                            baseResolveDirective(tView, lView, def));
                            const directive = getNodeInjectable(tView.data, lView, lView.length - 1, rootTNode);
                            attachPatchData(directive, lView);
                            const native = getNativeByTNode(rootTNode, lView);
                            return native && attachPatchData(native, lView), directive;
                        }(tView, rootView, componentDef);
                        rootContext.components.push(component), componentView[CONTEXT] = component, hostFeatures && hostFeatures.forEach(feature => feature(component, componentDef)), 
                        componentDef.contentQueries && componentDef.contentQueries(1, component, rootView.length - 1);
                        const rootTNode = getPreviousOrParentTNode();
                        return tView.firstCreatePass && componentDef.hostBindings && (setActiveHostElement(rootTNode.index - HEADER_OFFSET), 
                        incrementActiveDirectiveId(), invokeHostBindingsInCreationMode(componentDef, tView.expandoInstructions, component, rootTNode, tView.firstCreatePass), 
                        setActiveHostElement(null)), component;
                    }(componentView, this.componentDef, rootLView, rootContext, [ LifecycleHooksFeature ]), 
                    renderView(rootLView, rootTView, null);
                } finally {
                    leaveView();
                }
                const componentRef = new ComponentRef$1(this.componentType, component, createElementRef(ElementRef, tElementNode, rootLView), rootLView, tElementNode);
                return rootSelectorOrNode && !isIsolated || (componentRef.hostView._tViewNode.child = tElementNode), 
                componentRef;
            }
        }
        class ComponentRef$1 extends ComponentRef {
            constructor(componentType, instance, location, _rootLView, _tNode) {
                super(), this.location = location, this._rootLView = _rootLView, this._tNode = _tNode, 
                this.destroyCbs = [], this.instance = instance, this.hostView = this.changeDetectorRef = new RootViewRef(_rootLView), 
                this.hostView._tViewNode = function(tView, tParentNode, index, lView) {
                    let tNode = tView.node;
                    return null == tNode && (tView.node = tNode = createTNode(0, null, 2, -1, null, null)), 
                    lView[T_HOST] = tNode;
                }(_rootLView[TVIEW], 0, 0, _rootLView), this.componentType = componentType;
            }
            get injector() {
                return new NodeInjector(this._tNode, this._rootLView);
            }
            destroy() {
                this.destroyCbs && (this.destroyCbs.forEach(fn => fn()), this.destroyCbs = null, 
                !this.hostView.destroyed && this.hostView.destroy());
            }
            onDestroy(callback) {
                this.destroyCbs && this.destroyCbs.push(callback);
            }
        }
        const u = void 0;
        var localeEn = [ "en", [ [ "a", "p" ], [ "AM", "PM" ], u ], [ [ "AM", "PM" ], u, u ], [ [ "S", "M", "T", "W", "T", "F", "S" ], [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ] ], u, [ [ "J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D" ], [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ] ], u, [ [ "B", "A" ], [ "BC", "AD" ], [ "Before Christ", "Anno Domini" ] ], 0, [ 6, 0 ], [ "M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y" ], [ "h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz" ], [ "{1}, {0}", u, "{1} 'at' {0}", u ], [ ".", ",", ";", "%", "+", "-", "E", "×", "‰", "∞", "NaN", ":" ], [ "#,##0.###", "#,##0%", "¤#,##0.00", "#E0" ], "$", "US Dollar", {}, function(n) {
            let i = Math.floor(Math.abs(n)), v = n.toString().replace(/^[^.]*\.?/, "").length;
            return 1 === i && 0 === v ? 1 : 5;
        } ];
        let LOCALE_DATA = {};
        function registerLocaleData(data, localeId, extraData) {
            "string" != typeof localeId && (extraData = localeId, localeId = data[LocaleDataIndex.LocaleId]), 
            localeId = localeId.toLowerCase().replace(/_/g, "-"), LOCALE_DATA[localeId] = data, 
            extraData && (LOCALE_DATA[localeId][LocaleDataIndex.ExtraData] = extraData);
        }
        function findLocaleData(locale) {
            const normalizedLocale = function(locale) {
                return locale.toLowerCase().replace(/_/g, "-");
            }(locale);
            let match = getLocaleData(normalizedLocale);
            if (match) return match;
            const parentLocale = normalizedLocale.split("-")[0];
            if (match = getLocaleData(parentLocale)) return match;
            if ("en" === parentLocale) return localeEn;
            throw new Error(`Missing locale data for the locale "${locale}".`);
        }
        function getLocalePluralCase(locale) {
            return findLocaleData(locale)[LocaleDataIndex.PluralCase];
        }
        function getLocaleData(normalizedLocale) {
            return normalizedLocale in LOCALE_DATA || (LOCALE_DATA[normalizedLocale] = _global.ng && _global.ng.common && _global.ng.common.locales && _global.ng.common.locales[normalizedLocale]), 
            LOCALE_DATA[normalizedLocale];
        }
        const LocaleDataIndex = function() {
            var LocaleDataIndex = {
                LocaleId: 0,
                DayPeriodsFormat: 1,
                DayPeriodsStandalone: 2,
                DaysFormat: 3,
                DaysStandalone: 4,
                MonthsFormat: 5,
                MonthsStandalone: 6,
                Eras: 7,
                FirstDayOfWeek: 8,
                WeekendRange: 9,
                DateFormat: 10,
                TimeFormat: 11,
                DateTimeFormat: 12,
                NumberSymbols: 13,
                NumberFormats: 14,
                CurrencySymbol: 15,
                CurrencyName: 16,
                Currencies: 17,
                PluralCase: 18,
                ExtraData: 19
            };
            return LocaleDataIndex[LocaleDataIndex.LocaleId] = "LocaleId", LocaleDataIndex[LocaleDataIndex.DayPeriodsFormat] = "DayPeriodsFormat", 
            LocaleDataIndex[LocaleDataIndex.DayPeriodsStandalone] = "DayPeriodsStandalone", 
            LocaleDataIndex[LocaleDataIndex.DaysFormat] = "DaysFormat", LocaleDataIndex[LocaleDataIndex.DaysStandalone] = "DaysStandalone", 
            LocaleDataIndex[LocaleDataIndex.MonthsFormat] = "MonthsFormat", LocaleDataIndex[LocaleDataIndex.MonthsStandalone] = "MonthsStandalone", 
            LocaleDataIndex[LocaleDataIndex.Eras] = "Eras", LocaleDataIndex[LocaleDataIndex.FirstDayOfWeek] = "FirstDayOfWeek", 
            LocaleDataIndex[LocaleDataIndex.WeekendRange] = "WeekendRange", LocaleDataIndex[LocaleDataIndex.DateFormat] = "DateFormat", 
            LocaleDataIndex[LocaleDataIndex.TimeFormat] = "TimeFormat", LocaleDataIndex[LocaleDataIndex.DateTimeFormat] = "DateTimeFormat", 
            LocaleDataIndex[LocaleDataIndex.NumberSymbols] = "NumberSymbols", LocaleDataIndex[LocaleDataIndex.NumberFormats] = "NumberFormats", 
            LocaleDataIndex[LocaleDataIndex.CurrencySymbol] = "CurrencySymbol", LocaleDataIndex[LocaleDataIndex.CurrencyName] = "CurrencyName", 
            LocaleDataIndex[LocaleDataIndex.Currencies] = "Currencies", LocaleDataIndex[LocaleDataIndex.PluralCase] = "PluralCase", 
            LocaleDataIndex[LocaleDataIndex.ExtraData] = "ExtraData", LocaleDataIndex;
        }(), DEFAULT_LOCALE_ID = "en-US";
        let LOCALE_ID = DEFAULT_LOCALE_ID;
        function setLocaleId(localeId) {
            var msg;
            msg = "Expected localeId to be defined", null == localeId && function(msg) {
                throw new Error(`ASSERTION ERROR: ${msg}`);
            }(msg), "string" == typeof localeId && (LOCALE_ID = localeId.toLowerCase().replace(/_/g, "-"));
        }
        const modules = new Map, COMPONENT_FACTORY_RESOLVER = {
            provide: ComponentFactoryResolver,
            useClass: class extends ComponentFactoryResolver {
                constructor(ngModule) {
                    super(), this.ngModule = ngModule;
                }
                resolveComponentFactory(component) {
                    const componentDef = getComponentDef(component);
                    return new ComponentFactory$1(componentDef, this.ngModule);
                }
            },
            deps: [ NgModuleRef ]
        };
        class NgModuleRef$1 extends NgModuleRef {
            constructor(ngModuleType, _parent) {
                super(), this._parent = _parent, this._bootstrapComponents = [], this.injector = this, 
                this.destroyCbs = [];
                const ngModuleDef = getNgModuleDef(ngModuleType), ngLocaleIdDef = ngModuleType[NG_LOC_ID_DEF] || null;
                ngLocaleIdDef && setLocaleId(ngLocaleIdDef), this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap), 
                this._r3Injector = createInjector(ngModuleType, _parent, [ {
                    provide: NgModuleRef,
                    useValue: this
                }, COMPONENT_FACTORY_RESOLVER ], stringify(ngModuleType)), this.instance = this.get(ngModuleType);
            }
            get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, injectFlags = InjectFlags.Default) {
                return token === Injector || token === NgModuleRef || token === INJECTOR ? this : this._r3Injector.get(token, notFoundValue, injectFlags);
            }
            get componentFactoryResolver() {
                return this.get(ComponentFactoryResolver);
            }
            destroy() {
                const injector = this._r3Injector;
                !injector.destroyed && injector.destroy(), this.destroyCbs.forEach(fn => fn()), 
                this.destroyCbs = null;
            }
            onDestroy(callback) {
                this.destroyCbs.push(callback);
            }
        }
        class NgModuleFactory$1 extends NgModuleFactory {
            constructor(moduleType) {
                super(), this.moduleType = moduleType, null !== getNgModuleDef(moduleType) && function registerNgModuleType(ngModuleType) {
                    if (null !== ngModuleType.ɵmod.id) {
                        const id = ngModuleType.ɵmod.id;
                        (function(id, type, incoming) {
                            if (type && type !== incoming) throw new Error(`Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);
                        })(id, modules.get(id), ngModuleType), modules.set(id, ngModuleType);
                    }
                    let imports = ngModuleType.ɵmod.imports;
                    imports instanceof Function && (imports = imports()), imports && imports.forEach(i => registerNgModuleType(i));
                }(moduleType);
            }
            create(parentInjector) {
                return new NgModuleRef$1(this.moduleType, parentInjector);
            }
        }
        function ɵɵpureFunction1(slotOffset, pureFn, exp, thisArg) {
            const lView = getLView(), bindingIndex = getBindingRoot() + slotOffset;
            return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getBinding(lView, bindingIndex + 1);
        }
        function ɵɵpureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {
            const bindingIndex = getBindingRoot() + slotOffset, lView = getLView();
            return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getBinding(lView, bindingIndex + 2);
        }
        function ɵɵpipe(index, pipeName) {
            const tView = getLView()[TVIEW];
            let pipeDef;
            const adjustedIndex = index + HEADER_OFFSET;
            tView.firstCreatePass ? (pipeDef = function(name, registry) {
                if (registry) for (let i = registry.length - 1; i >= 0; i--) {
                    const pipeDef = registry[i];
                    if (name === pipeDef.name) return pipeDef;
                }
                throw new Error(`The pipe '${name}' could not be found!`);
            }(pipeName, tView.pipeRegistry), tView.data[adjustedIndex] = pipeDef, pipeDef.onDestroy && (tView.destroyHooks || (tView.destroyHooks = [])).push(adjustedIndex, pipeDef.onDestroy)) : pipeDef = tView.data[adjustedIndex];
            const pipeInstance = (pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type)))();
            return function(index, value) {
                const lView = getLView(), tView = lView[TVIEW], adjustedIndex = index + HEADER_OFFSET;
                adjustedIndex >= tView.data.length && (tView.data[adjustedIndex] = null, tView.blueprint[adjustedIndex] = null), 
                lView[adjustedIndex] = value;
            }(index, pipeInstance), pipeInstance;
        }
        function ɵɵpipeBind1(index, slotOffset, v1) {
            const lView = getLView(), pipeInstance = load(lView, index);
            return function(lView, newValue) {
                return WrappedValue.isWrapped(newValue) && (newValue = WrappedValue.unwrap(newValue), 
                lView[getBindingIndex()] = NO_CHANGE), newValue;
            }(lView, function(lView, index) {
                return lView[TVIEW].data[index + HEADER_OFFSET].pure;
            }(lView, index) ? ɵɵpureFunction1(slotOffset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1));
        }
        class EventEmitter extends rxjs__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(isAsync = !1) {
                super(), this.__isAsync = isAsync;
            }
            emit(value) {
                super.next(value);
            }
            subscribe(generatorOrNext, error, complete) {
                let schedulerFn, errorFn = err => null, completeFn = () => null;
                generatorOrNext && "object" == typeof generatorOrNext ? (schedulerFn = this.__isAsync ? value => {
                    setTimeout(() => generatorOrNext.next(value));
                } : value => {
                    generatorOrNext.next(value);
                }, generatorOrNext.error && (errorFn = this.__isAsync ? err => {
                    setTimeout(() => generatorOrNext.error(err));
                } : err => {
                    generatorOrNext.error(err);
                }), generatorOrNext.complete && (completeFn = this.__isAsync ? () => {
                    setTimeout(() => generatorOrNext.complete());
                } : () => {
                    generatorOrNext.complete();
                })) : (schedulerFn = this.__isAsync ? value => {
                    setTimeout(() => generatorOrNext(value));
                } : value => {
                    generatorOrNext(value);
                }, error && (errorFn = this.__isAsync ? err => {
                    setTimeout(() => error(err));
                } : err => {
                    error(err);
                }), complete && (completeFn = this.__isAsync ? () => {
                    setTimeout(() => complete());
                } : () => {
                    complete();
                }));
                const sink = super.subscribe(schedulerFn, errorFn, completeFn);
                return generatorOrNext instanceof rxjs__WEBPACK_IMPORTED_MODULE_1__.a && generatorOrNext.add(sink), 
                sink;
            }
        }
        function symbolIterator() {
            return this._results[getSymbolIterator()]();
        }
        class QueryList {
            constructor() {
                this.dirty = !0, this._results = [], this.changes = new EventEmitter, this.length = 0;
                const symbol = getSymbolIterator(), proto = QueryList.prototype;
                proto[symbol] || (proto[symbol] = symbolIterator);
            }
            map(fn) {
                return this._results.map(fn);
            }
            filter(fn) {
                return this._results.filter(fn);
            }
            find(fn) {
                return this._results.find(fn);
            }
            reduce(fn, init) {
                return this._results.reduce(fn, init);
            }
            forEach(fn) {
                this._results.forEach(fn);
            }
            some(fn) {
                return this._results.some(fn);
            }
            toArray() {
                return this._results.slice();
            }
            toString() {
                return this._results.toString();
            }
            reset(resultsTree) {
                this._results = function flatten(list, dst) {
                    void 0 === dst && (dst = list);
                    for (let i = 0; i < list.length; i++) {
                        let item = list[i];
                        Array.isArray(item) ? (dst === list && (dst = list.slice(0, i)), flatten(item, dst)) : dst !== list && dst.push(item);
                    }
                    return dst;
                }(resultsTree), this.dirty = !1, this.length = this._results.length, this.last = this._results[this.length - 1], 
                this.first = this._results[0];
            }
            notifyOnChanges() {
                this.changes.emit(this);
            }
            setDirty() {
                this.dirty = !0;
            }
            destroy() {
                this.changes.complete(), this.changes.unsubscribe();
            }
        }
        class LQuery_ {
            constructor(queryList) {
                this.queryList = queryList, this.matches = null;
            }
            clone() {
                return new LQuery_(this.queryList);
            }
            setDirty() {
                this.queryList.setDirty();
            }
        }
        class LQueries_ {
            constructor(queries = []) {
                this.queries = queries;
            }
            createEmbeddedView(tView) {
                const tQueries = tView.queries;
                if (null !== tQueries) {
                    const noOfInheritedQueries = null !== tView.contentQueries ? tView.contentQueries[0] : tQueries.length, viewLQueries = [];
                    for (let i = 0; i < noOfInheritedQueries; i++) {
                        const tQuery = tQueries.getByIndex(i);
                        viewLQueries.push(this.queries[tQuery.indexInDeclarationView].clone());
                    }
                    return new LQueries_(viewLQueries);
                }
                return null;
            }
            insertView(tView) {
                this.dirtyQueriesWithMatches(tView);
            }
            detachView(tView) {
                this.dirtyQueriesWithMatches(tView);
            }
            dirtyQueriesWithMatches(tView) {
                for (let i = 0; i < this.queries.length; i++) null !== getTQuery(tView, i).matches && this.queries[i].setDirty();
            }
        }
        class TQueryMetadata_ {
            constructor(predicate, descendants, isStatic, read = null) {
                this.predicate = predicate, this.descendants = descendants, this.isStatic = isStatic, 
                this.read = read;
            }
        }
        class TQueries_ {
            constructor(queries = []) {
                this.queries = queries;
            }
            elementStart(tView, tNode) {
                for (let i = 0; i < this.queries.length; i++) this.queries[i].elementStart(tView, tNode);
            }
            elementEnd(tNode) {
                for (let i = 0; i < this.queries.length; i++) this.queries[i].elementEnd(tNode);
            }
            embeddedTView(tNode) {
                let queriesForTemplateRef = null;
                for (let i = 0; i < this.length; i++) {
                    const childQueryIndex = null !== queriesForTemplateRef ? queriesForTemplateRef.length : 0, tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);
                    tqueryClone && (tqueryClone.indexInDeclarationView = i, null !== queriesForTemplateRef ? queriesForTemplateRef.push(tqueryClone) : queriesForTemplateRef = [ tqueryClone ]);
                }
                return null !== queriesForTemplateRef ? new TQueries_(queriesForTemplateRef) : null;
            }
            template(tView, tNode) {
                for (let i = 0; i < this.queries.length; i++) this.queries[i].template(tView, tNode);
            }
            getByIndex(index) {
                return this.queries[index];
            }
            get length() {
                return this.queries.length;
            }
            track(tquery) {
                this.queries.push(tquery);
            }
        }
        class TQuery_ {
            constructor(metadata, nodeIndex = -1) {
                this.metadata = metadata, this.matches = null, this.indexInDeclarationView = -1, 
                this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = nodeIndex;
            }
            elementStart(tView, tNode) {
                this.isApplyingToNode(tNode) && this.matchTNode(tView, tNode);
            }
            elementEnd(tNode) {
                this._declarationNodeIndex === tNode.index && (this._appliesToNextNode = !1);
            }
            template(tView, tNode) {
                this.elementStart(tView, tNode);
            }
            embeddedTView(tNode, childQueryIndex) {
                return this.isApplyingToNode(tNode) ? (this.crossesNgTemplate = !0, this.addMatch(-tNode.index, childQueryIndex), 
                new TQuery_(this.metadata)) : null;
            }
            isApplyingToNode(tNode) {
                return this._appliesToNextNode && !1 === this.metadata.descendants ? this._declarationNodeIndex === (tNode.parent ? tNode.parent.index : -1) : this._appliesToNextNode;
            }
            matchTNode(tView, tNode) {
                if (Array.isArray(this.metadata.predicate)) {
                    const localNames = this.metadata.predicate;
                    for (let i = 0; i < localNames.length; i++) this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, localNames[i]));
                } else {
                    const typePredicate = this.metadata.predicate;
                    typePredicate === TemplateRef ? 0 === tNode.type && this.matchTNodeWithReadOption(tView, tNode, -1) : this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, typePredicate, !1, !1));
                }
            }
            matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {
                if (null !== nodeMatchIdx) {
                    const read = this.metadata.read;
                    if (null !== read) if (read === ElementRef || read === ViewContainerRef || read === TemplateRef && 0 === tNode.type) this.addMatch(tNode.index, -2); else {
                        const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, !1, !1);
                        null !== directiveOrProviderIdx && this.addMatch(tNode.index, directiveOrProviderIdx);
                    } else this.addMatch(tNode.index, nodeMatchIdx);
                }
            }
            addMatch(tNodeIdx, matchIdx) {
                null === this.matches ? this.matches = [ tNodeIdx, matchIdx ] : this.matches.push(tNodeIdx, matchIdx);
            }
        }
        function getIdxOfMatchingSelector(tNode, selector) {
            const localNames = tNode.localNames;
            if (null !== localNames) for (let i = 0; i < localNames.length; i += 2) if (localNames[i] === selector) return localNames[i + 1];
            return null;
        }
        function createResultForNode(lView, tNode, matchingIdx, read) {
            return -1 === matchingIdx ? function(tNode, currentView) {
                return 3 === tNode.type || 4 === tNode.type ? createElementRef(ElementRef, tNode, currentView) : 0 === tNode.type ? createTemplateRef(TemplateRef, ElementRef, tNode, currentView) : null;
            }(tNode, lView) : -2 === matchingIdx ? function(lView, tNode, read) {
                return read === ElementRef ? createElementRef(ElementRef, tNode, lView) : read === TemplateRef ? createTemplateRef(TemplateRef, ElementRef, tNode, lView) : read === ViewContainerRef ? createContainerRef(ViewContainerRef, ElementRef, tNode, lView) : void 0;
            }(lView, tNode, read) : getNodeInjectable(lView[TVIEW].data, lView, matchingIdx, tNode);
        }
        function materializeViewResults(lView, tQuery, queryIndex) {
            const lQuery = lView[QUERIES].queries[queryIndex];
            if (null === lQuery.matches) {
                const tViewData = lView[TVIEW].data, tQueryMatches = tQuery.matches, result = [];
                for (let i = 0; i < tQueryMatches.length; i += 2) {
                    const matchedNodeIdx = tQueryMatches[i];
                    result.push(matchedNodeIdx < 0 ? null : createResultForNode(lView, tViewData[matchedNodeIdx], tQueryMatches[i + 1], tQuery.metadata.read));
                }
                lQuery.matches = result;
            }
            return lQuery.matches;
        }
        function ɵɵqueryRefresh(queryList) {
            const lView = getLView(), queryIndex = getCurrentQueryIndex();
            setCurrentQueryIndex(queryIndex + 1);
            const tQuery = getTQuery(lView[TVIEW], queryIndex);
            if (queryList.dirty && isCreationMode(lView) === tQuery.metadata.isStatic) {
                if (null === tQuery.matches) queryList.reset([]); else {
                    const result = tQuery.crossesNgTemplate ? function collectQueryResults(lView, queryIndex, result) {
                        const tQuery = lView[TVIEW].queries.getByIndex(queryIndex), tQueryMatches = tQuery.matches;
                        if (null !== tQueryMatches) {
                            const lViewResults = materializeViewResults(lView, tQuery, queryIndex);
                            for (let i = 0; i < tQueryMatches.length; i += 2) {
                                const tNodeIdx = tQueryMatches[i];
                                if (tNodeIdx > 0) result.push(lViewResults[i / 2]); else {
                                    const childQueryIndex = tQueryMatches[i + 1], declarationLContainer = lView[-tNodeIdx];
                                    for (let i = CONTAINER_HEADER_OFFSET; i < declarationLContainer.length; i++) {
                                        const embeddedLView = declarationLContainer[i];
                                        embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT] && collectQueryResults(embeddedLView, childQueryIndex, result);
                                    }
                                    if (null !== declarationLContainer[MOVED_VIEWS]) {
                                        const embeddedLViews = declarationLContainer[MOVED_VIEWS];
                                        for (let i = 0; i < embeddedLViews.length; i++) collectQueryResults(embeddedLViews[i], childQueryIndex, result);
                                    }
                                }
                            }
                        }
                        return result;
                    }(lView, queryIndex, []) : materializeViewResults(lView, tQuery, queryIndex);
                    queryList.reset(result), queryList.notifyOnChanges();
                }
                return !0;
            }
            return !1;
        }
        function ɵɵstaticViewQuery(predicate, descend, read) {
            viewQueryInternal(getLView(), predicate, descend, read, !0);
        }
        function ɵɵviewQuery(predicate, descend, read) {
            viewQueryInternal(getLView(), predicate, descend, read, !1);
        }
        function viewQueryInternal(lView, predicate, descend, read, isStatic) {
            const tView = lView[TVIEW];
            tView.firstCreatePass && (createTQuery(tView, new TQueryMetadata_(predicate, descend, isStatic, read), -1), 
            isStatic && (tView.staticViewQueries = !0)), createLQuery(lView);
        }
        function ɵɵcontentQuery(directiveIndex, predicate, descend, read) {
            contentQueryInternal(getLView(), predicate, descend, read, !1, getPreviousOrParentTNode(), directiveIndex);
        }
        function ɵɵstaticContentQuery(directiveIndex, predicate, descend, read) {
            contentQueryInternal(getLView(), predicate, descend, read, !0, getPreviousOrParentTNode(), directiveIndex);
        }
        function contentQueryInternal(lView, predicate, descend, read, isStatic, tNode, directiveIndex) {
            const tView = lView[TVIEW];
            tView.firstCreatePass && (createTQuery(tView, new TQueryMetadata_(predicate, descend, isStatic, read), tNode.index), 
            function(tView, directiveIndex) {
                const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);
                directiveIndex !== (tView.contentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1) && tViewContentQueries.push(tView.queries.length - 1, directiveIndex);
            }(tView, directiveIndex), isStatic && (tView.staticContentQueries = !0)), createLQuery(lView);
        }
        function ɵɵloadQuery() {
            return lView = getLView(), queryIndex = getCurrentQueryIndex(), lView[QUERIES].queries[queryIndex].queryList;
            var lView, queryIndex;
        }
        function createLQuery(lView) {
            const queryList = new QueryList;
            !function(lView, context, cleanupFn) {
                const lCleanup = getCleanup(lView);
                lCleanup.push(context), lView[TVIEW].firstCreatePass && getTViewCleanup(lView).push(cleanupFn, lCleanup.length - 1);
            }(lView, queryList, queryList.destroy), null === lView[QUERIES] && (lView[QUERIES] = new LQueries_), 
            lView[QUERIES].queries.push(new LQuery_(queryList));
        }
        function createTQuery(tView, metadata, nodeIndex) {
            null === tView.queries && (tView.queries = new TQueries_), tView.queries.track(new TQuery_(metadata, nodeIndex));
        }
        function getTQuery(tView, index) {
            return tView.queries.getByIndex(index);
        }
        function ɵɵtemplateRefExtractor(tNode, currentView) {
            return createTemplateRef(TemplateRef, ElementRef, tNode, currentView);
        }
        const APP_INITIALIZER = new InjectionToken("Application Initializer");
        let ApplicationInitStatus = (() => {
            class ApplicationInitStatus {
                constructor(appInits) {
                    this.appInits = appInits, this.initialized = !1, this.done = !1, this.donePromise = new Promise((res, rej) => {
                        this.resolve = res, this.reject = rej;
                    });
                }
                runInitializers() {
                    if (this.initialized) return;
                    const asyncInitPromises = [], complete = () => {
                        this.done = !0, this.resolve();
                    };
                    if (this.appInits) for (let i = 0; i < this.appInits.length; i++) {
                        const initResult = this.appInits[i]();
                        isPromise(initResult) && asyncInitPromises.push(initResult);
                    }
                    Promise.all(asyncInitPromises).then(() => {
                        complete();
                    }).catch(e => {
                        this.reject(e);
                    }), 0 === asyncInitPromises.length && complete(), this.initialized = !0;
                }
            }
            return ApplicationInitStatus.ɵfac = function(t) {
                return new (t || ApplicationInitStatus)(ɵɵinject(APP_INITIALIZER, 8));
            }, ApplicationInitStatus.ɵprov = ɵɵdefineInjectable({
                token: ApplicationInitStatus,
                factory: function(t) {
                    return ApplicationInitStatus.ɵfac(t);
                },
                providedIn: null
            }), ApplicationInitStatus;
        })();
        const APP_ID = new InjectionToken("AppId"), APP_ID_RANDOM_PROVIDER = {
            provide: APP_ID,
            useFactory: function() {
                return `${_randomChar()}${_randomChar()}${_randomChar()}`;
            },
            deps: []
        };
        function _randomChar() {
            return String.fromCharCode(97 + Math.floor(25 * Math.random()));
        }
        const PLATFORM_INITIALIZER = new InjectionToken("Platform Initializer"), PLATFORM_ID = new InjectionToken("Platform ID"), APP_BOOTSTRAP_LISTENER = new InjectionToken("appBootstrapListener");
        let Console = (() => {
            class Console {
                log(message) {
                    console.log(message);
                }
                warn(message) {
                    console.warn(message);
                }
            }
            return Console.ɵfac = function(t) {
                return new (t || Console);
            }, Console.ɵprov = ɵɵdefineInjectable({
                token: Console,
                factory: function(t) {
                    return Console.ɵfac(t);
                },
                providedIn: null
            }), Console;
        })();
        const LOCALE_ID$1 = new InjectionToken("LocaleId"), ivyEnabled = !0;
        class ModuleWithComponentFactories {
            constructor(ngModuleFactory, componentFactories) {
                this.ngModuleFactory = ngModuleFactory, this.componentFactories = componentFactories;
            }
        }
        const Compiler_compileModuleSync__POST_R3__ = function(moduleType) {
            return new NgModuleFactory$1(moduleType);
        }, Compiler_compileModuleSync = Compiler_compileModuleSync__POST_R3__, Compiler_compileModuleAsync = function(moduleType) {
            return Promise.resolve(Compiler_compileModuleSync__POST_R3__(moduleType));
        }, Compiler_compileModuleAndAllComponentsSync__POST_R3__ = function(moduleType) {
            const ngModuleFactory = Compiler_compileModuleSync__POST_R3__(moduleType), componentFactories = maybeUnwrapFn(getNgModuleDef(moduleType).declarations).reduce((factories, declaration) => {
                const componentDef = getComponentDef(declaration);
                return componentDef && factories.push(new ComponentFactory$1(componentDef)), factories;
            }, []);
            return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
        }, Compiler_compileModuleAndAllComponentsSync = Compiler_compileModuleAndAllComponentsSync__POST_R3__, Compiler_compileModuleAndAllComponentsAsync = function(moduleType) {
            return Promise.resolve(Compiler_compileModuleAndAllComponentsSync__POST_R3__(moduleType));
        };
        let Compiler = (() => {
            class Compiler {
                constructor() {
                    this.compileModuleSync = Compiler_compileModuleSync, this.compileModuleAsync = Compiler_compileModuleAsync, 
                    this.compileModuleAndAllComponentsSync = Compiler_compileModuleAndAllComponentsSync, 
                    this.compileModuleAndAllComponentsAsync = Compiler_compileModuleAndAllComponentsAsync;
                }
                clearCache() {}
                clearCacheFor(type) {}
                getModuleId(moduleType) {}
            }
            return Compiler.ɵfac = function(t) {
                return new (t || Compiler);
            }, Compiler.ɵprov = ɵɵdefineInjectable({
                token: Compiler,
                factory: function(t) {
                    return Compiler.ɵfac(t);
                },
                providedIn: null
            }), Compiler;
        })();
        const COMPILER_OPTIONS = new InjectionToken("compilerOptions");
        let trace, events;
        function detectWTF() {
            const wtf = _global.wtf;
            return !(!wtf || !(trace = wtf.trace) || (events = trace.events, 0));
        }
        const wtfEnabled = detectWTF();
        function noopScope(arg0, arg1) {
            return null;
        }
        const wtfCreateScope = wtfEnabled ? function(signature, flags = null) {
            return events.createScope(signature, flags);
        } : (signature, flags) => noopScope, wtfLeave = wtfEnabled ? function(scope, returnValue) {
            return trace.leaveScope(scope, returnValue), returnValue;
        } : (s, r) => r, promise = (() => Promise.resolve(0))();
        function scheduleMicroTask(fn) {
            "undefined" == typeof Zone ? promise.then(() => {
                fn && fn.apply(null, null);
            }) : Zone.current.scheduleMicroTask("scheduleMicrotask", fn);
        }
        class NgZone {
            constructor({enableLongStackTrace: enableLongStackTrace = !1, shouldCoalesceEventChangeDetection: shouldCoalesceEventChangeDetection = !1}) {
                if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, 
                this.onUnstable = new EventEmitter(!1), this.onMicrotaskEmpty = new EventEmitter(!1), 
                this.onStable = new EventEmitter(!1), this.onError = new EventEmitter(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js");
                Zone.assertZonePatched(), this._nesting = 0, this._outer = this._inner = Zone.current, 
                Zone.wtfZoneSpec && (this._inner = this._inner.fork(Zone.wtfZoneSpec)), Zone.TaskTrackingZoneSpec && (this._inner = this._inner.fork(new Zone.TaskTrackingZoneSpec)), 
                enableLongStackTrace && Zone.longStackTraceZoneSpec && (this._inner = this._inner.fork(Zone.longStackTraceZoneSpec)), 
                this.shouldCoalesceEventChangeDetection = shouldCoalesceEventChangeDetection, this.lastRequestAnimationFrameId = -1, 
                this.nativeRequestAnimationFrame = function() {
                    let nativeRequestAnimationFrame = _global.requestAnimationFrame, nativeCancelAnimationFrame = _global.cancelAnimationFrame;
                    if ("undefined" != typeof Zone && nativeRequestAnimationFrame && nativeCancelAnimationFrame) {
                        const unpatchedRequestAnimationFrame = nativeRequestAnimationFrame[Zone.__symbol__("OriginalDelegate")];
                        unpatchedRequestAnimationFrame && (nativeRequestAnimationFrame = unpatchedRequestAnimationFrame);
                        const unpatchedCancelAnimationFrame = nativeCancelAnimationFrame[Zone.__symbol__("OriginalDelegate")];
                        unpatchedCancelAnimationFrame && (nativeCancelAnimationFrame = unpatchedCancelAnimationFrame);
                    }
                    return {
                        nativeRequestAnimationFrame: nativeRequestAnimationFrame,
                        nativeCancelAnimationFrame: nativeCancelAnimationFrame
                    };
                }().nativeRequestAnimationFrame, function(zone) {
                    const maybeDelayChangeDetection = !!zone.shouldCoalesceEventChangeDetection && zone.nativeRequestAnimationFrame && (() => {
                        !function(zone) {
                            -1 === zone.lastRequestAnimationFrameId && (zone.lastRequestAnimationFrameId = zone.nativeRequestAnimationFrame.call(_global, () => {
                                zone.lastRequestAnimationFrameId = -1, updateMicroTaskStatus(zone), checkStable(zone);
                            }), updateMicroTaskStatus(zone));
                        }(zone);
                    });
                    zone._inner = zone._inner.fork({
                        name: "angular",
                        properties: {
                            isAngularZone: !0,
                            maybeDelayChangeDetection: maybeDelayChangeDetection
                        },
                        onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
                            try {
                                return onEnter(zone), delegate.invokeTask(target, task, applyThis, applyArgs);
                            } finally {
                                maybeDelayChangeDetection && "eventTask" === task.type && maybeDelayChangeDetection(), 
                                onLeave(zone);
                            }
                        },
                        onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
                            try {
                                return onEnter(zone), delegate.invoke(target, callback, applyThis, applyArgs, source);
                            } finally {
                                onLeave(zone);
                            }
                        },
                        onHasTask: (delegate, current, target, hasTaskState) => {
                            delegate.hasTask(target, hasTaskState), current === target && ("microTask" == hasTaskState.change ? (zone._hasPendingMicrotasks = hasTaskState.microTask, 
                            updateMicroTaskStatus(zone), checkStable(zone)) : "macroTask" == hasTaskState.change && (zone.hasPendingMacrotasks = hasTaskState.macroTask));
                        },
                        onHandleError: (delegate, current, target, error) => (delegate.handleError(target, error), 
                        zone.runOutsideAngular(() => zone.onError.emit(error)), !1)
                    });
                }(this);
            }
            static isInAngularZone() {
                return !0 === Zone.current.get("isAngularZone");
            }
            static assertInAngularZone() {
                if (!NgZone.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!");
            }
            static assertNotInAngularZone() {
                if (NgZone.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!");
            }
            run(fn, applyThis, applyArgs) {
                return this._inner.run(fn, applyThis, applyArgs);
            }
            runTask(fn, applyThis, applyArgs, name) {
                const zone = this._inner, task = zone.scheduleEventTask("NgZoneEvent: " + name, fn, EMPTY_PAYLOAD, noop$1, noop$1);
                try {
                    return zone.runTask(task, applyThis, applyArgs);
                } finally {
                    zone.cancelTask(task);
                }
            }
            runGuarded(fn, applyThis, applyArgs) {
                return this._inner.runGuarded(fn, applyThis, applyArgs);
            }
            runOutsideAngular(fn) {
                return this._outer.run(fn);
            }
        }
        function noop$1() {}
        const EMPTY_PAYLOAD = {};
        function checkStable(zone) {
            if (0 == zone._nesting && !zone.hasPendingMicrotasks && !zone.isStable) try {
                zone._nesting++, zone.onMicrotaskEmpty.emit(null);
            } finally {
                if (zone._nesting--, !zone.hasPendingMicrotasks) try {
                    zone.runOutsideAngular(() => zone.onStable.emit(null));
                } finally {
                    zone.isStable = !0;
                }
            }
        }
        function updateMicroTaskStatus(zone) {
            zone.hasPendingMicrotasks = !!(zone._hasPendingMicrotasks || zone.shouldCoalesceEventChangeDetection && -1 !== zone.lastRequestAnimationFrameId);
        }
        function onEnter(zone) {
            zone._nesting++, zone.isStable && (zone.isStable = !1, zone.onUnstable.emit(null));
        }
        function onLeave(zone) {
            zone._nesting--, checkStable(zone);
        }
        class NoopNgZone {
            constructor() {
                this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, 
                this.onUnstable = new EventEmitter, this.onMicrotaskEmpty = new EventEmitter, this.onStable = new EventEmitter, 
                this.onError = new EventEmitter;
            }
            run(fn, applyThis, applyArgs) {
                return fn.apply(applyThis, applyArgs);
            }
            runGuarded(fn, applyThis, applyArgs) {
                return fn.apply(applyThis, applyArgs);
            }
            runOutsideAngular(fn) {
                return fn();
            }
            runTask(fn, applyThis, applyArgs, name) {
                return fn.apply(applyThis, applyArgs);
            }
        }
        let Testability = (() => {
            class Testability {
                constructor(_ngZone) {
                    this._ngZone = _ngZone, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, 
                    this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), 
                    _ngZone.run(() => {
                        this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone");
                    });
                }
                _watchAngularEvents() {
                    this._ngZone.onUnstable.subscribe({
                        next: () => {
                            this._didWork = !0, this._isZoneStable = !1;
                        }
                    }), this._ngZone.runOutsideAngular(() => {
                        this._ngZone.onStable.subscribe({
                            next: () => {
                                NgZone.assertNotInAngularZone(), scheduleMicroTask(() => {
                                    this._isZoneStable = !0, this._runCallbacksIfReady();
                                });
                            }
                        });
                    });
                }
                increasePendingRequestCount() {
                    return this._pendingCount += 1, this._didWork = !0, this._pendingCount;
                }
                decreasePendingRequestCount() {
                    if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero");
                    return this._runCallbacksIfReady(), this._pendingCount;
                }
                isStable() {
                    return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks;
                }
                _runCallbacksIfReady() {
                    if (this.isStable()) scheduleMicroTask(() => {
                        for (;0 !== this._callbacks.length; ) {
                            let cb = this._callbacks.pop();
                            clearTimeout(cb.timeoutId), cb.doneCb(this._didWork);
                        }
                        this._didWork = !1;
                    }); else {
                        let pending = this.getPendingTasks();
                        this._callbacks = this._callbacks.filter(cb => !cb.updateCb || !cb.updateCb(pending) || (clearTimeout(cb.timeoutId), 
                        !1)), this._didWork = !0;
                    }
                }
                getPendingTasks() {
                    return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(t => ({
                        source: t.source,
                        creationLocation: t.creationLocation,
                        data: t.data
                    })) : [];
                }
                addCallback(cb, timeout, updateCb) {
                    let timeoutId = -1;
                    timeout && timeout > 0 && (timeoutId = setTimeout(() => {
                        this._callbacks = this._callbacks.filter(cb => cb.timeoutId !== timeoutId), cb(this._didWork, this.getPendingTasks());
                    }, timeout)), this._callbacks.push({
                        doneCb: cb,
                        timeoutId: timeoutId,
                        updateCb: updateCb
                    });
                }
                whenStable(doneCb, timeout, updateCb) {
                    if (updateCb && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');
                    this.addCallback(doneCb, timeout, updateCb), this._runCallbacksIfReady();
                }
                getPendingRequestCount() {
                    return this._pendingCount;
                }
                findProviders(using, provider, exactMatch) {
                    return [];
                }
            }
            return Testability.ɵfac = function(t) {
                return new (t || Testability)(ɵɵinject(NgZone));
            }, Testability.ɵprov = ɵɵdefineInjectable({
                token: Testability,
                factory: function(t) {
                    return Testability.ɵfac(t);
                },
                providedIn: null
            }), Testability;
        })(), TestabilityRegistry = (() => {
            class TestabilityRegistry {
                constructor() {
                    this._applications = new Map, _testabilityGetter.addToWindow(this);
                }
                registerApplication(token, testability) {
                    this._applications.set(token, testability);
                }
                unregisterApplication(token) {
                    this._applications.delete(token);
                }
                unregisterAllApplications() {
                    this._applications.clear();
                }
                getTestability(elem) {
                    return this._applications.get(elem) || null;
                }
                getAllTestabilities() {
                    return Array.from(this._applications.values());
                }
                getAllRootElements() {
                    return Array.from(this._applications.keys());
                }
                findTestabilityInTree(elem, findInAncestors = !0) {
                    return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
                }
            }
            return TestabilityRegistry.ɵfac = function(t) {
                return new (t || TestabilityRegistry);
            }, TestabilityRegistry.ɵprov = ɵɵdefineInjectable({
                token: TestabilityRegistry,
                factory: function(t) {
                    return TestabilityRegistry.ɵfac(t);
                },
                providedIn: null
            }), TestabilityRegistry;
        })();
        class _NoopGetTestability {
            addToWindow(registry) {}
            findTestabilityInTree(registry, elem, findInAncestors) {
                return null;
            }
        }
        function setTestabilityGetter(getter) {
            _testabilityGetter = getter;
        }
        let _platform, _testabilityGetter = new _NoopGetTestability, compileNgModuleFactory = function(injector, options, moduleType) {
            const moduleFactory = new NgModuleFactory$1(moduleType);
            if (0 === componentResourceResolutionQueue.size) return Promise.resolve(moduleFactory);
            const compilerProviders = function(parts) {
                const result = [];
                return parts.forEach(part => part && result.push(...part)), result;
            }(injector.get(COMPILER_OPTIONS, []).concat(options).map(o => o.providers));
            if (0 === compilerProviders.length) return Promise.resolve(moduleFactory);
            const compiler = function() {
                const globalNg = _global.ng;
                if (!globalNg || !globalNg.ɵcompilerFacade) throw new Error("Angular JIT compilation failed: '@angular/compiler' not loaded!\n  - JIT compilation is discouraged for production use-cases! Consider AOT mode instead.\n  - Did you bootstrap using '@angular/platform-browser-dynamic' or '@angular/platform-server'?\n  - Alternatively provide the compiler with 'import \"@angular/compiler\";' before bootstrapping.");
                return globalNg.ɵcompilerFacade;
            }(), resourceLoader = Injector.create({
                providers: compilerProviders
            }).get(compiler.ResourceLoader);
            return function(resourceResolver) {
                const componentResolved = [], urlMap = new Map;
                function cachedResourceResolve(url) {
                    let promise = urlMap.get(url);
                    if (!promise) {
                        const resp = resourceResolver(url);
                        urlMap.set(url, promise = resp.then(unwrapResponse));
                    }
                    return promise;
                }
                return componentResourceResolutionQueue.forEach((component, type) => {
                    const promises = [];
                    component.templateUrl && promises.push(cachedResourceResolve(component.templateUrl).then(template => {
                        component.template = template;
                    }));
                    const styleUrls = component.styleUrls, styles = component.styles || (component.styles = []), styleOffset = component.styles.length;
                    styleUrls && styleUrls.forEach((styleUrl, index) => {
                        styles.push(""), promises.push(cachedResourceResolve(styleUrl).then(style => {
                            styles[styleOffset + index] = style, styleUrls.splice(styleUrls.indexOf(styleUrl), 1), 
                            0 == styleUrls.length && (component.styleUrls = void 0);
                        }));
                    });
                    const fullyResolved = Promise.all(promises).then(() => (function(type) {
                        componentDefPendingResolution.delete(type);
                    })(type));
                    componentResolved.push(fullyResolved);
                }), componentResourceResolutionQueue = new Map, Promise.all(componentResolved).then(() => void 0);
            }(url => Promise.resolve(resourceLoader.get(url))).then(() => moduleFactory);
        }, publishDefaultGlobalUtils$1 = function() {}, isBoundToModule = function(cf) {
            return cf.isBoundToModule;
        };
        const ALLOW_MULTIPLE_PLATFORMS = new InjectionToken("AllowMultipleToken");
        class NgProbeToken {
            constructor(name, token) {
                this.name = name, this.token = token;
            }
        }
        function createPlatformFactory(parentPlatformFactory, name, providers = []) {
            const desc = `Platform: ${name}`, marker = new InjectionToken(desc);
            return (extraProviders = []) => {
                let platform = getPlatform();
                if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, !1)) if (parentPlatformFactory) parentPlatformFactory(providers.concat(extraProviders).concat({
                    provide: marker,
                    useValue: !0
                })); else {
                    const injectedProviders = providers.concat(extraProviders).concat({
                        provide: marker,
                        useValue: !0
                    }, {
                        provide: INJECTOR_SCOPE,
                        useValue: "platform"
                    });
                    !function(injector) {
                        if (_platform && !_platform.destroyed && !_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one.");
                        publishDefaultGlobalUtils$1(), _platform = injector.get(PlatformRef);
                        const inits = injector.get(PLATFORM_INITIALIZER, null);
                        inits && inits.forEach(init => init());
                    }(Injector.create({
                        providers: injectedProviders,
                        name: desc
                    }));
                }
                return function(requiredToken) {
                    const platform = getPlatform();
                    if (!platform) throw new Error("No platform exists!");
                    if (!platform.injector.get(requiredToken, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first.");
                    return platform;
                }(marker);
            };
        }
        function getPlatform() {
            return _platform && !_platform.destroyed ? _platform : null;
        }
        let PlatformRef = (() => {
            class PlatformRef {
                constructor(_injector) {
                    this._injector = _injector, this._modules = [], this._destroyListeners = [], this._destroyed = !1;
                }
                bootstrapModuleFactory(moduleFactory, options) {
                    const ngZone = (ngZoneEventCoalescing = options && options.ngZoneEventCoalescing || !1, 
                    "noop" === (ngZoneOption = options ? options.ngZone : void 0) ? new NoopNgZone : ("zone.js" === ngZoneOption ? void 0 : ngZoneOption) || new NgZone({
                        enableLongStackTrace: isDevMode(),
                        shouldCoalesceEventChangeDetection: ngZoneEventCoalescing
                    })), providers = [ {
                        provide: NgZone,
                        useValue: ngZone
                    } ];
                    var ngZoneOption, ngZoneEventCoalescing;
                    return ngZone.run(() => {
                        const ngZoneInjector = Injector.create({
                            providers: providers,
                            parent: this.injector,
                            name: moduleFactory.moduleType.name
                        }), moduleRef = moduleFactory.create(ngZoneInjector), exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
                        if (!exceptionHandler) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");
                        return ivyEnabled && setLocaleId(moduleRef.injector.get(LOCALE_ID$1, DEFAULT_LOCALE_ID) || DEFAULT_LOCALE_ID), 
                        moduleRef.onDestroy(() => remove(this._modules, moduleRef)), ngZone.runOutsideAngular(() => ngZone.onError.subscribe({
                            next: error => {
                                exceptionHandler.handleError(error);
                            }
                        })), function(errorHandler, ngZone, callback) {
                            try {
                                const result = callback();
                                return isPromise(result) ? result.catch(e => {
                                    throw ngZone.runOutsideAngular(() => errorHandler.handleError(e)), e;
                                }) : result;
                            } catch (e) {
                                throw ngZone.runOutsideAngular(() => errorHandler.handleError(e)), e;
                            }
                        }(exceptionHandler, ngZone, () => {
                            const initStatus = moduleRef.injector.get(ApplicationInitStatus);
                            return initStatus.runInitializers(), initStatus.donePromise.then(() => (this._moduleDoBootstrap(moduleRef), 
                            moduleRef));
                        });
                    });
                }
                bootstrapModule(moduleType, compilerOptions = []) {
                    const options = optionsReducer({}, compilerOptions);
                    return compileNgModuleFactory(this.injector, options, moduleType).then(moduleFactory => this.bootstrapModuleFactory(moduleFactory, options));
                }
                _moduleDoBootstrap(moduleRef) {
                    const appRef = moduleRef.injector.get(ApplicationRef);
                    if (moduleRef._bootstrapComponents.length > 0) moduleRef._bootstrapComponents.forEach(f => appRef.bootstrap(f)); else {
                        if (!moduleRef.instance.ngDoBootstrap) throw new Error(`The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. ` + "Please define one of these.");
                        moduleRef.instance.ngDoBootstrap(appRef);
                    }
                    this._modules.push(moduleRef);
                }
                onDestroy(callback) {
                    this._destroyListeners.push(callback);
                }
                get injector() {
                    return this._injector;
                }
                destroy() {
                    if (this._destroyed) throw new Error("The platform has already been destroyed!");
                    this._modules.slice().forEach(module => module.destroy()), this._destroyListeners.forEach(listener => listener()), 
                    this._destroyed = !0;
                }
                get destroyed() {
                    return this._destroyed;
                }
            }
            return PlatformRef.ɵfac = function(t) {
                return new (t || PlatformRef)(ɵɵinject(Injector));
            }, PlatformRef.ɵprov = ɵɵdefineInjectable({
                token: PlatformRef,
                factory: function(t) {
                    return PlatformRef.ɵfac(t);
                },
                providedIn: null
            }), PlatformRef;
        })();
        function optionsReducer(dst, objs) {
            return Array.isArray(objs) ? objs.reduce(optionsReducer, dst) : Object.assign(Object.assign({}, dst), objs);
        }
        let ApplicationRef = (() => {
            class ApplicationRef {
                constructor(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus) {
                    this._zone = _zone, this._console = _console, this._injector = _injector, this._exceptionHandler = _exceptionHandler, 
                    this._componentFactoryResolver = _componentFactoryResolver, this._initStatus = _initStatus, 
                    this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._enforceNoNewChanges = !1, 
                    this._stable = !0, this.componentTypes = [], this.components = [], this._enforceNoNewChanges = isDevMode(), 
                    this._zone.onMicrotaskEmpty.subscribe({
                        next: () => {
                            this._zone.run(() => {
                                this.tick();
                            });
                        }
                    });
                    const isCurrentlyStable = new rxjs__WEBPACK_IMPORTED_MODULE_2__.a(observer => {
                        this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, 
                        this._zone.runOutsideAngular(() => {
                            observer.next(this._stable), observer.complete();
                        });
                    }), isStable = new rxjs__WEBPACK_IMPORTED_MODULE_2__.a(observer => {
                        let stableSub;
                        this._zone.runOutsideAngular(() => {
                            stableSub = this._zone.onStable.subscribe(() => {
                                NgZone.assertNotInAngularZone(), scheduleMicroTask(() => {
                                    this._stable || this._zone.hasPendingMacrotasks || this._zone.hasPendingMicrotasks || (this._stable = !0, 
                                    observer.next(!0));
                                });
                            });
                        });
                        const unstableSub = this._zone.onUnstable.subscribe(() => {
                            NgZone.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => {
                                observer.next(!1);
                            }));
                        });
                        return (() => {
                            stableSub.unsubscribe(), unstableSub.unsubscribe();
                        });
                    });
                    this.isStable = Object(rxjs__WEBPACK_IMPORTED_MODULE_3__.a)(isCurrentlyStable, isStable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)()));
                }
                bootstrap(componentOrFactory, rootSelectorOrNode) {
                    if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");
                    let componentFactory;
                    componentFactory = componentOrFactory instanceof ComponentFactory ? componentOrFactory : this._componentFactoryResolver.resolveComponentFactory(componentOrFactory), 
                    this.componentTypes.push(componentFactory.componentType);
                    const ngModule = isBoundToModule(componentFactory) ? void 0 : this._injector.get(NgModuleRef), compRef = componentFactory.create(Injector.NULL, [], rootSelectorOrNode || componentFactory.selector, ngModule);
                    compRef.onDestroy(() => {
                        this._unloadComponent(compRef);
                    });
                    const testability = compRef.injector.get(Testability, null);
                    return testability && compRef.injector.get(TestabilityRegistry).registerApplication(compRef.location.nativeElement, testability), 
                    this._loadComponent(compRef), isDevMode() && this._console.log("Angular is running in the development mode. Call enableProdMode() to enable the production mode."), 
                    compRef;
                }
                tick() {
                    if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively");
                    const scope = ApplicationRef._tickScope();
                    try {
                        this._runningTick = !0;
                        for (let view of this._views) view.detectChanges();
                        if (this._enforceNoNewChanges) for (let view of this._views) view.checkNoChanges();
                    } catch (e) {
                        this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(e));
                    } finally {
                        this._runningTick = !1, wtfLeave(scope);
                    }
                }
                attachView(viewRef) {
                    const view = viewRef;
                    this._views.push(view), view.attachToAppRef(this);
                }
                detachView(viewRef) {
                    const view = viewRef;
                    remove(this._views, view), view.detachFromAppRef();
                }
                _loadComponent(componentRef) {
                    this.attachView(componentRef.hostView), this.tick(), this.components.push(componentRef), 
                    this._injector.get(APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners).forEach(listener => listener(componentRef));
                }
                _unloadComponent(componentRef) {
                    this.detachView(componentRef.hostView), remove(this.components, componentRef);
                }
                ngOnDestroy() {
                    this._views.slice().forEach(view => view.destroy());
                }
                get viewCount() {
                    return this._views.length;
                }
            }
            return ApplicationRef.ɵfac = function(t) {
                return new (t || ApplicationRef)(ɵɵinject(NgZone), ɵɵinject(Console), ɵɵinject(Injector), ɵɵinject(ErrorHandler), ɵɵinject(ComponentFactoryResolver), ɵɵinject(ApplicationInitStatus));
            }, ApplicationRef.ɵprov = ɵɵdefineInjectable({
                token: ApplicationRef,
                factory: function(t) {
                    return ApplicationRef.ɵfac(t);
                },
                providedIn: null
            }), ApplicationRef._tickScope = wtfCreateScope("ApplicationRef#tick()"), ApplicationRef;
        })();
        function remove(list, el) {
            const index = list.indexOf(el);
            index > -1 && list.splice(index, 1);
        }
        class NgModuleFactoryLoader {}
        const _SEPARATOR = "#", FACTORY_CLASS_SUFFIX = "NgFactory";
        class SystemJsNgModuleLoaderConfig {}
        const DEFAULT_CONFIG = {
            factoryPathPrefix: "",
            factoryPathSuffix: ".ngfactory"
        };
        let SystemJsNgModuleLoader = (() => {
            class SystemJsNgModuleLoader {
                constructor(_compiler, config) {
                    this._compiler = _compiler, this._config = config || DEFAULT_CONFIG;
                }
                load(path) {
                    return !ivyEnabled && this._compiler instanceof Compiler ? this.loadFactory(path) : this.loadAndCompile(path);
                }
                loadAndCompile(path) {
                    let [module, exportName] = path.split(_SEPARATOR);
                    return void 0 === exportName && (exportName = "default"), __webpack_require__("zn8P")(module).then(module => module[exportName]).then(type => checkNotEmpty(type, module, exportName)).then(type => this._compiler.compileModuleAsync(type));
                }
                loadFactory(path) {
                    let [module, exportName] = path.split(_SEPARATOR), factoryClassSuffix = FACTORY_CLASS_SUFFIX;
                    return void 0 === exportName && (exportName = "default", factoryClassSuffix = ""), 
                    __webpack_require__("zn8P")(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix).then(module => module[exportName + factoryClassSuffix]).then(factory => checkNotEmpty(factory, module, exportName));
                }
            }
            return SystemJsNgModuleLoader.ɵfac = function(t) {
                return new (t || SystemJsNgModuleLoader)(ɵɵinject(Compiler), ɵɵinject(SystemJsNgModuleLoaderConfig, 8));
            }, SystemJsNgModuleLoader.ɵprov = ɵɵdefineInjectable({
                token: SystemJsNgModuleLoader,
                factory: function(t) {
                    return SystemJsNgModuleLoader.ɵfac(t);
                },
                providedIn: null
            }), SystemJsNgModuleLoader;
        })();
        function checkNotEmpty(value, modulePath, exportName) {
            if (!value) throw new Error(`Cannot find '${exportName}' in '${modulePath}'`);
            return value;
        }
        class DebugNode__POST_R3__ {
            constructor(nativeNode) {
                this.nativeNode = nativeNode;
            }
            get parent() {
                const parent = this.nativeNode.parentNode;
                return parent ? new DebugElement__POST_R3__(parent) : null;
            }
            get injector() {
                return function(target) {
                    const context = loadLContext(target, !1);
                    return null === context ? Injector.NULL : new NodeInjector(context.lView[TVIEW].data[context.nodeIndex], context.lView);
                }(this.nativeNode);
            }
            get componentInstance() {
                const nativeElement = this.nativeNode;
                return nativeElement && (getComponent(nativeElement) || function(element) {
                    const context = loadLContext(element, !1);
                    if (null === context) return null;
                    let parent, lView = context.lView;
                    for (;null === lView[HOST] && (parent = getLViewParent(lView)); ) lView = parent;
                    return 512 & lView[FLAGS] ? null : lView[CONTEXT];
                }(nativeElement));
            }
            get context() {
                return getComponent(this.nativeNode) || function(element) {
                    if (!(element instanceof Node)) throw new Error("Expecting instance of DOM Node");
                    const context = loadLContext(element, !1);
                    return null === context ? null : context.lView[CONTEXT];
                }(this.nativeNode);
            }
            get listeners() {
                return function(element) {
                    if (!(element instanceof Node)) throw new Error("Expecting instance of DOM Node");
                    const lContext = loadLContext(element, !1);
                    if (null === lContext) return [];
                    const lView = lContext.lView, lCleanup = lView[CLEANUP], tCleanup = lView[TVIEW].cleanup, listeners = [];
                    if (tCleanup && lCleanup) for (let i = 0; i < tCleanup.length; ) {
                        const firstParam = tCleanup[i++], secondParam = tCleanup[i++];
                        if ("string" == typeof firstParam) {
                            const name = firstParam, listenerElement = unwrapRNode(lView[secondParam]), callback = lCleanup[tCleanup[i++]], useCaptureOrIndx = tCleanup[i++], useCapture = "boolean" == typeof useCaptureOrIndx ? useCaptureOrIndx : !(useCaptureOrIndx >= 0) && null;
                            element == listenerElement && listeners.push({
                                element: element,
                                name: name,
                                callback: callback,
                                useCapture: useCapture
                            });
                        }
                    }
                    return listeners.sort(sortListeners), listeners;
                }(this.nativeNode).filter(isBrowserEvents);
            }
            get references() {
                return function(target) {
                    const context = loadLContext(target, !1);
                    return null === context ? {} : (void 0 === context.localRefs && (context.localRefs = function(lView, nodeIndex) {
                        const tNode = lView[TVIEW].data[nodeIndex];
                        if (tNode && tNode.localNames) {
                            const result = {};
                            let localIndex = tNode.index + 1;
                            for (let i = 0; i < tNode.localNames.length; i += 2) result[tNode.localNames[i]] = lView[localIndex], 
                            localIndex++;
                            return result;
                        }
                        return null;
                    }(context.lView, context.nodeIndex)), context.localRefs || {});
                }(this.nativeNode);
            }
            get providerTokens() {
                return function(element) {
                    const context = loadLContext(element, !1);
                    if (null === context) return [];
                    const tView = context.lView[TVIEW], tNode = tView.data[context.nodeIndex], providerTokens = [], endIndex = tNode.directiveEnd;
                    for (let i = 65535 & tNode.providerIndexes; i < endIndex; i++) {
                        let value = tView.data[i];
                        void 0 !== (obj = value).type && void 0 !== obj.template && void 0 !== obj.declaredInputs && (value = value.type), 
                        providerTokens.push(value);
                    }
                    var obj;
                    return providerTokens;
                }(this.nativeNode);
            }
        }
        class DebugElement__POST_R3__ extends DebugNode__POST_R3__ {
            constructor(nativeNode) {
                super(nativeNode);
            }
            get nativeElement() {
                return this.nativeNode.nodeType == Node.ELEMENT_NODE ? this.nativeNode : null;
            }
            get name() {
                try {
                    const context = loadLContext(this.nativeNode);
                    return context.lView[TVIEW].data[context.nodeIndex].tagName;
                } catch (e) {
                    return this.nativeNode.nodeName;
                }
            }
            get properties() {
                const context = loadLContext(this.nativeNode, !1);
                if (null == context) return {};
                const lView = context.lView, tData = lView[TVIEW].data, properties = function(tNode, lView, tData) {
                    const properties = {};
                    let bindingIndexes = tNode.propertyBindings;
                    if (null !== bindingIndexes) for (let i = 0; i < bindingIndexes.length; i++) {
                        const bindingIndex = bindingIndexes[i], metadataParts = tData[bindingIndex].split(INTERPOLATION_DELIMITER), propertyName = metadataParts[0];
                        if (metadataParts.length > 1) {
                            let value = metadataParts[1];
                            for (let j = 1; j < metadataParts.length - 1; j++) value += renderStringify(lView[bindingIndex + j - 1]) + metadataParts[j + 1];
                            properties[propertyName] = value;
                        } else properties[propertyName] = lView[bindingIndex];
                    }
                    return properties;
                }(tData[context.nodeIndex], lView, tData), className = function(debugElement) {
                    const classes = debugElement.classes;
                    let output = "";
                    for (const className of Object.keys(classes)) classes[className] && (output = output ? output + ` ${className}` : className);
                    return output;
                }(this);
                return className && (properties.className = properties.className ? properties.className + ` ${className}` : className), 
                properties;
            }
            get attributes() {
                const attributes = {}, element = this.nativeElement;
                if (!element) return attributes;
                const context = loadLContext(element, !1);
                if (null == context) return {};
                const tNodeAttrs = context.lView[TVIEW].data[context.nodeIndex].attrs, lowercaseTNodeAttrs = [];
                if (tNodeAttrs) {
                    let i = 0;
                    for (;i < tNodeAttrs.length; ) {
                        const attrName = tNodeAttrs[i];
                        if ("string" != typeof attrName) break;
                        attributes[attrName] = tNodeAttrs[i + 1], lowercaseTNodeAttrs.push(attrName.toLowerCase()), 
                        i += 2;
                    }
                }
                const eAttrs = element.attributes;
                for (let i = 0; i < eAttrs.length; i++) {
                    const attr = eAttrs[i];
                    -1 === lowercaseTNodeAttrs.indexOf(attr.name) && (attributes[attr.name] = attr.value);
                }
                return attributes;
            }
            get styles() {
                return this.nativeElement && this.nativeElement.style ? this.nativeElement.style : {};
            }
            get classes() {
                if (!this._classesProxy) {
                    const element = this.nativeElement;
                    this._classesProxy = function(handler) {
                        const g = _global;
                        if (!g.Proxy) throw new Error("Proxy is not supported in this browser");
                        return new g.Proxy({}, handler);
                    }({
                        get: (target, prop) => !!element && element.classList.contains(prop),
                        set: (target, prop, value) => !!element && element.classList.toggle(prop, !!value),
                        ownKeys: () => element ? Array.from(element.classList).sort() : [],
                        getOwnPropertyDescriptor: k => ({
                            enumerable: !0,
                            configurable: !0
                        })
                    });
                }
                return this._classesProxy;
            }
            get childNodes() {
                const childNodes = this.nativeNode.childNodes, children = [];
                for (let i = 0; i < childNodes.length; i++) children.push(getDebugNode__POST_R3__(childNodes[i]));
                return children;
            }
            get children() {
                const nativeElement = this.nativeElement;
                if (!nativeElement) return [];
                const childNodes = nativeElement.children, children = [];
                for (let i = 0; i < childNodes.length; i++) children.push(getDebugNode__POST_R3__(childNodes[i]));
                return children;
            }
            query(predicate) {
                return this.queryAll(predicate)[0] || null;
            }
            queryAll(predicate) {
                const matches = [];
                return _queryAllR3(this, predicate, matches, !0), matches;
            }
            queryAllNodes(predicate) {
                const matches = [];
                return _queryAllR3(this, predicate, matches, !1), matches;
            }
            triggerEventHandler(eventName, eventObj) {
                const node = this.nativeNode, invokedListeners = [];
                this.listeners.forEach(listener => {
                    if (listener.name === eventName) {
                        const callback = listener.callback;
                        callback(eventObj), invokedListeners.push(callback);
                    }
                }), "function" == typeof node.eventListeners && node.eventListeners(eventName).forEach(listener => {
                    const unwrappedListener = listener(Function);
                    return -1 === invokedListeners.indexOf(unwrappedListener) && unwrappedListener(eventObj);
                });
            }
        }
        function _queryAllR3(parentElement, predicate, matches, elementsOnly) {
            const context = loadLContext(parentElement.nativeNode);
            _queryNodeChildrenR3(context.lView[TVIEW].data[context.nodeIndex], context.lView, predicate, matches, elementsOnly, parentElement.nativeNode);
        }
        function _queryNodeChildrenR3(tNode, lView, predicate, matches, elementsOnly, rootNativeNode) {
            const nativeNode = getNativeByTNodeOrNull(tNode, lView);
            if (3 === tNode.type || 4 === tNode.type) {
                if (_addQueryMatchR3(nativeNode, predicate, matches, elementsOnly, rootNativeNode), 
                isComponentHost(tNode)) {
                    const componentView = getComponentLViewByIndex(tNode.index, lView);
                    componentView && componentView[TVIEW].firstChild && _queryNodeChildrenR3(componentView[TVIEW].firstChild, componentView, predicate, matches, elementsOnly, rootNativeNode);
                } else tNode.child && _queryNodeChildrenR3(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode), 
                nativeNode && function _queryNativeNodeDescendants(parentNode, predicate, matches, elementsOnly) {
                    const nodes = parentNode.childNodes, length = nodes.length;
                    for (let i = 0; i < length; i++) {
                        const node = nodes[i], debugNode = getDebugNode$1(node);
                        debugNode && (elementsOnly && debugNode instanceof DebugElement__POST_R3__ && predicate(debugNode) && -1 === matches.indexOf(debugNode) ? matches.push(debugNode) : !elementsOnly && predicate(debugNode) && -1 === matches.indexOf(debugNode) && matches.push(debugNode), 
                        _queryNativeNodeDescendants(node, predicate, matches, elementsOnly));
                    }
                }(nativeNode, predicate, matches, elementsOnly);
                const nodeOrContainer = lView[tNode.index];
                isLContainer(nodeOrContainer) && _queryNodeChildrenInContainerR3(nodeOrContainer, predicate, matches, elementsOnly, rootNativeNode);
            } else if (0 === tNode.type) {
                const lContainer = lView[tNode.index];
                _addQueryMatchR3(lContainer[NATIVE], predicate, matches, elementsOnly, rootNativeNode), 
                _queryNodeChildrenInContainerR3(lContainer, predicate, matches, elementsOnly, rootNativeNode);
            } else if (1 === tNode.type) {
                const componentView = findComponentView(lView), head = componentView[T_HOST].projection[tNode.projection];
                if (Array.isArray(head)) for (let nativeNode of head) _addQueryMatchR3(nativeNode, predicate, matches, elementsOnly, rootNativeNode); else if (head) {
                    const nextLView = componentView[PARENT];
                    _queryNodeChildrenR3(nextLView[TVIEW].data[head.index], nextLView, predicate, matches, elementsOnly, rootNativeNode);
                }
            } else tNode.child && _queryNodeChildrenR3(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
            if (rootNativeNode !== nativeNode) {
                const nextTNode = 4 & tNode.flags ? tNode.projectionNext : tNode.next;
                nextTNode && _queryNodeChildrenR3(nextTNode, lView, predicate, matches, elementsOnly, rootNativeNode);
            }
        }
        function _queryNodeChildrenInContainerR3(lContainer, predicate, matches, elementsOnly, rootNativeNode) {
            for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
                const childView = lContainer[i];
                _queryNodeChildrenR3(childView[TVIEW].node, childView, predicate, matches, elementsOnly, rootNativeNode);
            }
        }
        function _addQueryMatchR3(nativeNode, predicate, matches, elementsOnly, rootNativeNode) {
            if (rootNativeNode !== nativeNode) {
                const debugNode = getDebugNode$1(nativeNode);
                if (!debugNode) return;
                elementsOnly && debugNode instanceof DebugElement__POST_R3__ && predicate(debugNode) && -1 === matches.indexOf(debugNode) ? matches.push(debugNode) : !elementsOnly && predicate(debugNode) && -1 === matches.indexOf(debugNode) && matches.push(debugNode);
            }
        }
        const NG_DEBUG_PROPERTY = "__ng_debug__";
        function getDebugNode__POST_R3__(nativeNode) {
            return nativeNode instanceof Node ? (nativeNode.hasOwnProperty(NG_DEBUG_PROPERTY) || (nativeNode[NG_DEBUG_PROPERTY] = nativeNode.nodeType == Node.ELEMENT_NODE ? new DebugElement__POST_R3__(nativeNode) : new DebugNode__POST_R3__(nativeNode)), 
            nativeNode[NG_DEBUG_PROPERTY]) : null;
        }
        const getDebugNode$1 = getDebugNode__POST_R3__, platformCore = createPlatformFactory(null, "core", [ {
            provide: PLATFORM_ID,
            useValue: "unknown"
        }, {
            provide: PlatformRef,
            deps: [ Injector ]
        }, {
            provide: TestabilityRegistry,
            deps: []
        }, {
            provide: Console,
            deps: []
        } ]), APPLICATION_MODULE_PROVIDERS = [ {
            provide: ApplicationRef,
            useClass: ApplicationRef,
            deps: [ NgZone, Console, Injector, ErrorHandler, ComponentFactoryResolver, ApplicationInitStatus ]
        }, {
            provide: SCHEDULER,
            deps: [ NgZone ],
            useFactory: function(ngZone) {
                let queue = [];
                return ngZone.onStable.subscribe(() => {
                    for (;queue.length; ) queue.pop()();
                }), function(fn) {
                    queue.push(fn);
                };
            }
        }, {
            provide: ApplicationInitStatus,
            useClass: ApplicationInitStatus,
            deps: [ [ new Optional, APP_INITIALIZER ] ]
        }, {
            provide: Compiler,
            useClass: Compiler,
            deps: []
        }, APP_ID_RANDOM_PROVIDER, {
            provide: IterableDiffers,
            useFactory: function() {
                return defaultIterableDiffers;
            },
            deps: []
        }, {
            provide: KeyValueDiffers,
            useFactory: function() {
                return defaultKeyValueDiffers;
            },
            deps: []
        }, {
            provide: LOCALE_ID$1,
            useFactory: function(locale) {
                return locale = locale || ivyEnabled && "undefined" != typeof $localize && $localize.locale || DEFAULT_LOCALE_ID, 
                ivyEnabled && setLocaleId(locale), locale;
            },
            deps: [ [ new Inject(LOCALE_ID$1), new Optional, new SkipSelf ] ]
        } ];
        let ApplicationModule = (() => {
            class ApplicationModule {
                constructor(appRef) {}
            }
            return ApplicationModule.ɵmod = ɵɵdefineNgModule({
                type: ApplicationModule
            }), ApplicationModule.ɵinj = ɵɵdefineInjector({
                factory: function(t) {
                    return new (t || ApplicationModule)(ɵɵinject(ApplicationRef));
                },
                providers: APPLICATION_MODULE_PROVIDERS
            }), ApplicationModule;
        })();
    },
    g5Zp: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var common = __webpack_require__("ofXK"), code_component = __webpack_require__("6CTB"), core = __webpack_require__("fXoL"), animations = __webpack_require__("R1ws"), fesm2015_core = __webpack_require__("FKr1");
        const _c11 = [ 1, "mat-card" ], _c12 = [ "*", [ [ "mat-card-footer" ] ] ], _c13 = [ "*", "mat-card-footer" ];
        let card_MatCard = (() => {
            class MatCard {
                constructor(_animationMode) {
                    this._animationMode = _animationMode;
                }
            }
            return MatCard.ɵfac = function(t) {
                return new (t || MatCard)(core.Pb(animations.a, 8));
            }, MatCard.ɵcmp = core.Jb({
                type: MatCard,
                selectors: [ [ "mat-card" ] ],
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (core.Bb(1), core.Ub(_c11)), 2 & rf && core.Fb("_mat-animation-noopable", "NoopAnimations" === ctx._animationMode);
                },
                exportAs: [ "matCard" ],
                ngContentSelectors: _c13,
                decls: 2,
                vars: 0,
                template: function(rf, ctx) {
                    1 & rf && (core.kc(_c12), core.jc(0), core.jc(1, 1));
                },
                styles: [ ".mat-card{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:block;position:relative;padding:16px;border-radius:4px}._mat-animation-noopable.mat-card{transition:none;animation:none}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}@media(-ms-high-contrast: active){.mat-card{outline:solid 1px}}.mat-card-actions,.mat-card-subtitle,.mat-card-content{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button,.mat-card-actions .mat-stroked-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px}@media(max-width: 599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card>:first-child,.mat-card-content>:first-child{margin-top:0}.mat-card>:last-child:not(.mat-card-footer),.mat-card-content>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions .mat-button:first-child,.mat-card-actions .mat-raised-button:first-child,.mat-card-actions .mat-stroked-button:first-child{margin-left:0;margin-right:0}.mat-card-title:not(:first-child),.mat-card-subtitle:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}/*# sourceMappingURL=card.css.map */\n" ],
                encapsulation: 2,
                changeDetection: 0
            }), MatCard;
        })(), card_MatCardModule = (() => {
            class MatCardModule {}
            return MatCardModule.ɵmod = core.Nb({
                type: MatCardModule
            }), MatCardModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || MatCardModule);
                },
                imports: [ [ fesm2015_core.b ], fesm2015_core.b ]
            }), MatCardModule;
        })();
        var observers = __webpack_require__("GU7r"), portal = __webpack_require__("+rOU"), a11y = __webpack_require__("u47x"), Subject = __webpack_require__("XNiG"), Subscription = __webpack_require__("quSY"), merge = __webpack_require__("VRyK"), fromEvent = __webpack_require__("xgIS"), of = __webpack_require__("LRne"), timer = __webpack_require__("PqYM"), bidi = __webpack_require__("cH1L"), fesm2015_animations = __webpack_require__("R0Ic"), startWith = __webpack_require__("JX91"), distinctUntilChanged = __webpack_require__("/uUt"), takeUntil = __webpack_require__("1G5W"), coercion = __webpack_require__("8LU1"), scrolling = __webpack_require__("vxfF"), fesm2015_platform = __webpack_require__("nLfN"), keycodes = __webpack_require__("FtGj");
        const tabs_c0 = [ 1, "mat-ink-bar" ];
        function MatTab_ng_template_0_Template(rf, ctx) {
            1 & rf && core.jc(0);
        }
        const tabs_c1 = [ "*" ], tabs_c2 = [ 1, "mat-tab-body" ];
        function MatTabBody_ng_template_2_Template(rf, ctx) {}
        const tabs_c3 = function(a0) {
            return {
                animationDuration: a0
            };
        }, tabs_c4 = function(a0, a1) {
            return {
                value: a0,
                params: a1
            };
        }, tabs_c5 = [ "tabBodyWrapper" ], tabs_c6 = [ "tabHeader" ], tabs_c7 = [ 1, "mat-tab-group" ];
        function MatTabGroup_div_2_ng_template_2_ng_template_0_Template(rf, ctx) {}
        function MatTabGroup_div_2_ng_template_2_Template(rf, ctx) {
            if (1 & rf && core.Cc(0, MatTabGroup_div_2_ng_template_2_ng_template_0_Template, 0, 0, "ng-template", 9), 
            2 & rf) {
                const tab_r22 = core.gc().$implicit;
                core.lc("cdkPortalOutlet", tab_r22.templateLabel);
            }
        }
        function MatTabGroup_div_2_ng_template_3_Template(rf, ctx) {
            if (1 & rf && core.Ec(0), 2 & rf) {
                const tab_r22 = core.gc().$implicit;
                core.Fc(tab_r22.textLabel);
            }
        }
        function MatTabGroup_div_2_Template(rf, ctx) {
            if (1 & rf) {
                const _r30 = core.Wb();
                core.Vb(0, "div", 6), core.cc("click", (function($event) {
                    core.uc(_r30);
                    const tab_r22 = ctx.$implicit, i_r23 = ctx.index, ctx_r29 = core.gc(), _r18 = core.rc(1);
                    return ctx_r29._handleClick(tab_r22, _r18, i_r23);
                })), core.Vb(1, "div", 7), core.Cc(2, MatTabGroup_div_2_ng_template_2_Template, 1, 1, "ng-template", 8), 
                core.Cc(3, MatTabGroup_div_2_ng_template_3_Template, 1, 1, "ng-template", 8), core.Tb(), 
                core.Tb();
            }
            if (2 & rf) {
                const tab_r22 = ctx.$implicit, i_r23 = ctx.index, ctx_r19 = core.gc();
                core.Fb("mat-tab-label-active", ctx_r19.selectedIndex == i_r23), core.lc("id", ctx_r19._getTabLabelId(i_r23))("disabled", tab_r22.disabled)("matRippleDisabled", tab_r22.disabled || ctx_r19.disableRipple), 
                core.Cb("tabIndex", ctx_r19._getTabIndex(tab_r22, i_r23))("aria-posinset", i_r23 + 1)("aria-setsize", ctx_r19._tabs.length)("aria-controls", ctx_r19._getTabContentId(i_r23))("aria-selected", ctx_r19.selectedIndex == i_r23)("aria-label", tab_r22.ariaLabel || null)("aria-labelledby", !tab_r22.ariaLabel && tab_r22.ariaLabelledby ? tab_r22.ariaLabelledby : null), 
                core.Ab(2), core.lc("ngIf", tab_r22.templateLabel), core.Ab(1), core.lc("ngIf", !tab_r22.templateLabel);
            }
        }
        function MatTabGroup_mat_tab_body_5_Template(rf, ctx) {
            if (1 & rf) {
                const _r34 = core.Wb();
                core.Vb(0, "mat-tab-body", 10), core.cc("_onCentered", (function($event) {
                    return core.uc(_r34), core.gc()._removeTabBodyWrapperHeight();
                })), core.cc("_onCentering", (function($event) {
                    return core.uc(_r34), core.gc()._setTabBodyWrapperHeight($event);
                })), core.Tb();
            }
            if (2 & rf) {
                const tab_r31 = ctx.$implicit, i_r32 = ctx.index, ctx_r21 = core.gc();
                core.Fb("mat-tab-body-active", ctx_r21.selectedIndex == i_r32), core.lc("id", ctx_r21._getTabContentId(i_r32))("content", tab_r31.content)("position", tab_r31.position)("origin", tab_r31.origin)("animationDuration", ctx_r21.animationDuration), 
                core.Cb("aria-labelledby", ctx_r21._getTabLabelId(i_r32));
            }
        }
        const tabs_c8 = [ "tabListContainer" ], tabs_c9 = [ "tabList" ], tabs_c10 = [ "nextPaginator" ], tabs_c11 = [ "previousPaginator" ], tabs_c12 = [ 1, "mat-tab-header" ], _MAT_INK_BAR_POSITIONER = new core.p("MatInkBarPositioner", {
            providedIn: "root",
            factory: function() {
                return element => ({
                    left: element ? (element.offsetLeft || 0) + "px" : "0",
                    width: element ? (element.offsetWidth || 0) + "px" : "0"
                });
            }
        });
        let tabs_MatInkBar = (() => {
            class MatInkBar {
                constructor(_elementRef, _ngZone, _inkBarPositioner, _animationMode) {
                    this._elementRef = _elementRef, this._ngZone = _ngZone, this._inkBarPositioner = _inkBarPositioner, 
                    this._animationMode = _animationMode;
                }
                alignToElement(element) {
                    this.show(), "undefined" != typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => {
                        requestAnimationFrame(() => this._setStyles(element));
                    }) : this._setStyles(element);
                }
                show() {
                    this._elementRef.nativeElement.style.visibility = "visible";
                }
                hide() {
                    this._elementRef.nativeElement.style.visibility = "hidden";
                }
                _setStyles(element) {
                    const positions = this._inkBarPositioner(element), inkBar = this._elementRef.nativeElement;
                    inkBar.style.left = positions.left, inkBar.style.width = positions.width;
                }
            }
            return MatInkBar.ɵfac = function(t) {
                return new (t || MatInkBar)(core.Pb(core.k), core.Pb(core.y), core.Pb(_MAT_INK_BAR_POSITIONER), core.Pb(animations.a, 8));
            }, MatInkBar.ɵdir = core.Kb({
                type: MatInkBar,
                selectors: [ [ "mat-ink-bar" ] ],
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (core.Bb(1), core.Ub(tabs_c0)), 2 & rf && core.Fb("_mat-animation-noopable", "NoopAnimations" === ctx._animationMode);
                }
            }), MatInkBar;
        })(), tabs_MatTabContent = (() => {
            class MatTabContent {
                constructor(template) {
                    this.template = template;
                }
            }
            return MatTabContent.ɵfac = function(t) {
                return new (t || MatTabContent)(core.Pb(core.L));
            }, MatTabContent.ɵdir = core.Kb({
                type: MatTabContent,
                selectors: [ [ "", "matTabContent", "" ] ]
            }), MatTabContent;
        })(), tabs_MatTabLabel = (() => {
            class MatTabLabel extends portal.b {}
            return MatTabLabel.ɵfac = function(t) {
                return ɵMatTabLabel_BaseFactory(t || MatTabLabel);
            }, MatTabLabel.ɵdir = core.Kb({
                type: MatTabLabel,
                selectors: [ [ "", "mat-tab-label", "" ], [ "", "matTabLabel", "" ] ],
                features: [ core.xb ]
            }), MatTabLabel;
        })();
        const ɵMatTabLabel_BaseFactory = core.Xb(tabs_MatTabLabel);
        class MatTabBase {}
        const _MatTabMixinBase = Object(fesm2015_core.h)(MatTabBase);
        let tabs_MatTab = (() => {
            class MatTab extends _MatTabMixinBase {
                constructor(_viewContainerRef) {
                    super(), this._viewContainerRef = _viewContainerRef, this.textLabel = "", this._contentPortal = null, 
                    this._stateChanges = new Subject.a, this.position = null, this.origin = null, this.isActive = !1;
                }
                get content() {
                    return this._contentPortal;
                }
                ngOnChanges(changes) {
                    (changes.hasOwnProperty("textLabel") || changes.hasOwnProperty("disabled")) && this._stateChanges.next();
                }
                ngOnDestroy() {
                    this._stateChanges.complete();
                }
                ngOnInit() {
                    this._contentPortal = new portal.i(this._explicitContent || this._implicitContent, this._viewContainerRef);
                }
            }
            return MatTab.ɵfac = function(t) {
                return new (t || MatTab)(core.Pb(core.O));
            }, MatTab.ɵcmp = core.Jb({
                type: MatTab,
                selectors: [ [ "mat-tab" ] ],
                contentQueries: function(rf, ctx, dirIndex) {
                    var _t;
                    1 & rf && (core.Hb(dirIndex, tabs_MatTabLabel, !0), core.xc(dirIndex, tabs_MatTabContent, !0, core.L)), 
                    2 & rf && (core.qc(_t = core.dc()) && (ctx.templateLabel = _t.first), core.qc(_t = core.dc()) && (ctx._explicitContent = _t.first));
                },
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && core.yc(core.L, !0), 2 & rf && core.qc(_t = core.dc()) && (ctx._implicitContent = _t.first);
                },
                inputs: {
                    disabled: "disabled",
                    textLabel: [ "label", "textLabel" ],
                    ariaLabel: [ "aria-label", "ariaLabel" ],
                    ariaLabelledby: [ "aria-labelledby", "ariaLabelledby" ]
                },
                exportAs: [ "matTab" ],
                features: [ core.xb, core.yb() ],
                ngContentSelectors: tabs_c1,
                decls: 1,
                vars: 0,
                template: function(rf, ctx) {
                    1 & rf && (core.kc(), core.Cc(0, MatTab_ng_template_0_Template, 1, 0, "ng-template"));
                },
                encapsulation: 2,
                changeDetection: 0
            }), MatTab;
        })();
        const matTabsAnimations = {
            translateTab: Object(fesm2015_animations.j)("translateTab", [ Object(fesm2015_animations.g)("center, void, left-origin-center, right-origin-center", Object(fesm2015_animations.h)({
                transform: "none"
            })), Object(fesm2015_animations.g)("left", Object(fesm2015_animations.h)({
                transform: "translate3d(-100%, 0, 0)",
                minHeight: "1px"
            })), Object(fesm2015_animations.g)("right", Object(fesm2015_animations.h)({
                transform: "translate3d(100%, 0, 0)",
                minHeight: "1px"
            })), Object(fesm2015_animations.i)("* => left, * => right, left => center, right => center", Object(fesm2015_animations.e)("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)")), Object(fesm2015_animations.i)("void => left-origin-center", [ Object(fesm2015_animations.h)({
                transform: "translate3d(-100%, 0, 0)"
            }), Object(fesm2015_animations.e)("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)") ]), Object(fesm2015_animations.i)("void => right-origin-center", [ Object(fesm2015_animations.h)({
                transform: "translate3d(100%, 0, 0)"
            }), Object(fesm2015_animations.e)("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)") ]) ])
        };
        let tabs_MatTabBodyPortal = (() => {
            class MatTabBodyPortal extends portal.c {
                constructor(componentFactoryResolver, viewContainerRef, _host) {
                    super(componentFactoryResolver, viewContainerRef), this._host = _host, this._centeringSub = Subscription.a.EMPTY, 
                    this._leavingSub = Subscription.a.EMPTY;
                }
                ngOnInit() {
                    super.ngOnInit(), this._centeringSub = this._host._beforeCentering.pipe(Object(startWith.a)(this._host._isCenterPosition(this._host._position))).subscribe(isCentering => {
                        isCentering && !this.hasAttached() && this.attach(this._host._content);
                    }), this._leavingSub = this._host._afterLeavingCenter.subscribe(() => {
                        this.detach();
                    });
                }
                ngOnDestroy() {
                    super.ngOnDestroy(), this._centeringSub.unsubscribe(), this._leavingSub.unsubscribe();
                }
            }
            return MatTabBodyPortal.ɵfac = function(t) {
                return new (t || MatTabBodyPortal)(core.Pb(core.j), core.Pb(core.O), core.Pb(Object(core.T)(() => tabs_MatTabBody)));
            }, MatTabBodyPortal.ɵdir = core.Kb({
                type: MatTabBodyPortal,
                selectors: [ [ "", "matTabBodyHost", "" ] ],
                features: [ core.xb ]
            }), MatTabBodyPortal;
        })(), tabs_MatTabBodyBase = (() => {
            class _MatTabBodyBase {
                constructor(_elementRef, _dir, changeDetectorRef) {
                    this._elementRef = _elementRef, this._dir = _dir, this._dirChangeSubscription = Subscription.a.EMPTY, 
                    this._translateTabComplete = new Subject.a, this._onCentering = new core.m, this._beforeCentering = new core.m, 
                    this._afterLeavingCenter = new core.m, this._onCentered = new core.m(!0), this.animationDuration = "500ms", 
                    _dir && (this._dirChangeSubscription = _dir.change.subscribe(dir => {
                        this._computePositionAnimationState(dir), changeDetectorRef.markForCheck();
                    })), this._translateTabComplete.pipe(Object(distinctUntilChanged.a)((x, y) => x.fromState === y.fromState && x.toState === y.toState)).subscribe(event => {
                        this._isCenterPosition(event.toState) && this._isCenterPosition(this._position) && this._onCentered.emit(), 
                        this._isCenterPosition(event.fromState) && !this._isCenterPosition(this._position) && this._afterLeavingCenter.emit();
                    });
                }
                set position(position) {
                    this._positionIndex = position, this._computePositionAnimationState();
                }
                ngOnInit() {
                    "center" == this._position && null != this.origin && (this._position = this._computePositionFromOrigin());
                }
                ngOnDestroy() {
                    this._dirChangeSubscription.unsubscribe(), this._translateTabComplete.complete();
                }
                _onTranslateTabStarted(event) {
                    const isCentering = this._isCenterPosition(event.toState);
                    this._beforeCentering.emit(isCentering), isCentering && this._onCentering.emit(this._elementRef.nativeElement.clientHeight);
                }
                _getLayoutDirection() {
                    return this._dir && "rtl" === this._dir.value ? "rtl" : "ltr";
                }
                _isCenterPosition(position) {
                    return "center" == position || "left-origin-center" == position || "right-origin-center" == position;
                }
                _computePositionAnimationState(dir = this._getLayoutDirection()) {
                    this._position = this._positionIndex < 0 ? "ltr" == dir ? "left" : "right" : this._positionIndex > 0 ? "ltr" == dir ? "right" : "left" : "center";
                }
                _computePositionFromOrigin() {
                    const dir = this._getLayoutDirection();
                    return "ltr" == dir && this.origin <= 0 || "rtl" == dir && this.origin > 0 ? "left-origin-center" : "right-origin-center";
                }
            }
            return _MatTabBodyBase.ɵfac = function(t) {
                return new (t || _MatTabBodyBase)(core.Pb(core.k), core.Pb(bidi.b, 8), core.Pb(core.h));
            }, _MatTabBodyBase.ɵdir = core.Kb({
                type: _MatTabBodyBase,
                selectors: [ [ "do-not-use-abstract-mat-tab-body-base" ] ],
                inputs: {
                    animationDuration: "animationDuration",
                    position: "position",
                    _content: [ "content", "_content" ],
                    origin: "origin"
                },
                outputs: {
                    _onCentering: "_onCentering",
                    _beforeCentering: "_beforeCentering",
                    _afterLeavingCenter: "_afterLeavingCenter",
                    _onCentered: "_onCentered"
                }
            }), _MatTabBodyBase;
        })(), tabs_MatTabBody = (() => {
            class MatTabBody extends tabs_MatTabBodyBase {
                constructor(elementRef, dir, changeDetectorRef) {
                    super(elementRef, dir, changeDetectorRef);
                }
            }
            return MatTabBody.ɵfac = function(t) {
                return new (t || MatTabBody)(core.Pb(core.k), core.Pb(bidi.b, 8), core.Pb(core.h));
            }, MatTabBody.ɵcmp = core.Jb({
                type: MatTabBody,
                selectors: [ [ "mat-tab-body" ] ],
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && core.Jc(portal.f, !0), 2 & rf && core.qc(_t = core.dc()) && (ctx._portalHost = _t.first);
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && core.Ub(tabs_c2);
                },
                features: [ core.xb ],
                decls: 3,
                vars: 6,
                consts: [ [ 1, "mat-tab-body-content" ], [ "content", "" ], [ "matTabBodyHost", "" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.Vb(0, "div", 0, 1), core.cc("@translateTab.start", (function($event) {
                        return ctx._onTranslateTabStarted($event);
                    })), core.cc("@translateTab.done", (function($event) {
                        return ctx._translateTabComplete.next($event);
                    })), core.Cc(2, MatTabBody_ng_template_2_Template, 0, 0, "ng-template", 2), core.Tb()), 
                    2 & rf && core.lc("@translateTab", core.pc(3, tabs_c4, ctx._position, core.oc(1, tabs_c3, ctx.animationDuration)));
                },
                directives: [ tabs_MatTabBodyPortal ],
                styles: [ ".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}/*# sourceMappingURL=tab-body.css.map */\n" ],
                encapsulation: 2,
                data: {
                    animation: [ matTabsAnimations.translateTab ]
                },
                changeDetection: 0
            }), MatTabBody;
        })(), nextId = 0;
        class MatTabChangeEvent {}
        const MAT_TABS_CONFIG = new core.p("MAT_TABS_CONFIG");
        class MatTabGroupMixinBase {
            constructor(_elementRef) {
                this._elementRef = _elementRef;
            }
        }
        const _MatTabGroupMixinBase = Object(fesm2015_core.f)(Object(fesm2015_core.g)(MatTabGroupMixinBase), "primary");
        let tabs_MatTabGroupBase = (() => {
            class _MatTabGroupBase extends _MatTabGroupMixinBase {
                constructor(elementRef, _changeDetectorRef, defaultConfig, _animationMode) {
                    super(elementRef), this._changeDetectorRef = _changeDetectorRef, this._animationMode = _animationMode, 
                    this._indexToSelect = 0, this._tabBodyWrapperHeight = 0, this._tabsSubscription = Subscription.a.EMPTY, 
                    this._tabLabelSubscription = Subscription.a.EMPTY, this._dynamicHeight = !1, this._selectedIndex = null, 
                    this.headerPosition = "above", this.selectedIndexChange = new core.m, this.focusChange = new core.m, 
                    this.animationDone = new core.m, this.selectedTabChange = new core.m(!0), this._groupId = nextId++, 
                    this.animationDuration = defaultConfig && defaultConfig.animationDuration ? defaultConfig.animationDuration : "500ms";
                }
                get dynamicHeight() {
                    return this._dynamicHeight;
                }
                set dynamicHeight(value) {
                    this._dynamicHeight = Object(coercion.b)(value);
                }
                get selectedIndex() {
                    return this._selectedIndex;
                }
                set selectedIndex(value) {
                    this._indexToSelect = Object(coercion.e)(value, null);
                }
                get animationDuration() {
                    return this._animationDuration;
                }
                set animationDuration(value) {
                    this._animationDuration = /^\d+$/.test(value) ? value + "ms" : value;
                }
                get backgroundColor() {
                    return this._backgroundColor;
                }
                set backgroundColor(value) {
                    const nativeElement = this._elementRef.nativeElement;
                    nativeElement.classList.remove(`mat-background-${this.backgroundColor}`), value && nativeElement.classList.add(`mat-background-${value}`), 
                    this._backgroundColor = value;
                }
                ngAfterContentChecked() {
                    const indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);
                    if (this._selectedIndex != indexToSelect) {
                        const isFirstRun = null == this._selectedIndex;
                        isFirstRun || this.selectedTabChange.emit(this._createChangeEvent(indexToSelect)), 
                        Promise.resolve().then(() => {
                            this._tabs.forEach((tab, index) => tab.isActive = index === indexToSelect), isFirstRun || this.selectedIndexChange.emit(indexToSelect);
                        });
                    }
                    this._tabs.forEach((tab, index) => {
                        tab.position = index - indexToSelect, null == this._selectedIndex || 0 != tab.position || tab.origin || (tab.origin = indexToSelect - this._selectedIndex);
                    }), this._selectedIndex !== indexToSelect && (this._selectedIndex = indexToSelect, 
                    this._changeDetectorRef.markForCheck());
                }
                ngAfterContentInit() {
                    this._subscribeToTabLabels(), this._tabsSubscription = this._tabs.changes.subscribe(() => {
                        if (this._clampTabIndex(this._indexToSelect) === this._selectedIndex) {
                            const tabs = this._tabs.toArray();
                            for (let i = 0; i < tabs.length; i++) if (tabs[i].isActive) {
                                this._indexToSelect = this._selectedIndex = i;
                                break;
                            }
                        }
                        this._subscribeToTabLabels(), this._changeDetectorRef.markForCheck();
                    });
                }
                ngOnDestroy() {
                    this._tabsSubscription.unsubscribe(), this._tabLabelSubscription.unsubscribe();
                }
                realignInkBar() {
                    this._tabHeader && this._tabHeader._alignInkBarToSelectedTab();
                }
                _focusChanged(index) {
                    this.focusChange.emit(this._createChangeEvent(index));
                }
                _createChangeEvent(index) {
                    const event = new MatTabChangeEvent;
                    return event.index = index, this._tabs && this._tabs.length && (event.tab = this._tabs.toArray()[index]), 
                    event;
                }
                _subscribeToTabLabels() {
                    this._tabLabelSubscription && this._tabLabelSubscription.unsubscribe(), this._tabLabelSubscription = Object(merge.a)(...this._tabs.map(tab => tab._stateChanges)).subscribe(() => this._changeDetectorRef.markForCheck());
                }
                _clampTabIndex(index) {
                    return Math.min(this._tabs.length - 1, Math.max(index || 0, 0));
                }
                _getTabLabelId(i) {
                    return `mat-tab-label-${this._groupId}-${i}`;
                }
                _getTabContentId(i) {
                    return `mat-tab-content-${this._groupId}-${i}`;
                }
                _setTabBodyWrapperHeight(tabHeight) {
                    if (!this._dynamicHeight || !this._tabBodyWrapperHeight) return;
                    const wrapper = this._tabBodyWrapper.nativeElement;
                    wrapper.style.height = this._tabBodyWrapperHeight + "px", this._tabBodyWrapper.nativeElement.offsetHeight && (wrapper.style.height = tabHeight + "px");
                }
                _removeTabBodyWrapperHeight() {
                    const wrapper = this._tabBodyWrapper.nativeElement;
                    this._tabBodyWrapperHeight = wrapper.clientHeight, wrapper.style.height = "", this.animationDone.emit();
                }
                _handleClick(tab, tabHeader, index) {
                    tab.disabled || (this.selectedIndex = tabHeader.focusIndex = index);
                }
                _getTabIndex(tab, idx) {
                    return tab.disabled ? null : this.selectedIndex === idx ? 0 : -1;
                }
            }
            return _MatTabGroupBase.ɵfac = function(t) {
                return new (t || _MatTabGroupBase)(core.Pb(core.k), core.Pb(core.h), core.Pb(MAT_TABS_CONFIG, 8), core.Pb(animations.a, 8));
            }, _MatTabGroupBase.ɵdir = core.Kb({
                type: _MatTabGroupBase,
                selectors: [ [ "do-not-use-abstract-mat-tab-group-base" ] ],
                inputs: {
                    headerPosition: "headerPosition",
                    animationDuration: "animationDuration",
                    dynamicHeight: "dynamicHeight",
                    selectedIndex: "selectedIndex",
                    backgroundColor: "backgroundColor"
                },
                outputs: {
                    selectedIndexChange: "selectedIndexChange",
                    focusChange: "focusChange",
                    animationDone: "animationDone",
                    selectedTabChange: "selectedTabChange"
                },
                features: [ core.xb ]
            }), _MatTabGroupBase;
        })(), tabs_MatTabGroup = (() => {
            class MatTabGroup extends tabs_MatTabGroupBase {
                constructor(elementRef, changeDetectorRef, defaultConfig, animationMode) {
                    super(elementRef, changeDetectorRef, defaultConfig, animationMode);
                }
            }
            return MatTabGroup.ɵfac = function(t) {
                return new (t || MatTabGroup)(core.Pb(core.k), core.Pb(core.h), core.Pb(MAT_TABS_CONFIG, 8), core.Pb(animations.a, 8));
            }, MatTabGroup.ɵcmp = core.Jb({
                type: MatTabGroup,
                selectors: [ [ "mat-tab-group" ] ],
                contentQueries: function(rf, ctx, dirIndex) {
                    var _t;
                    1 & rf && core.Hb(dirIndex, tabs_MatTab, !1), 2 & rf && core.qc(_t = core.dc()) && (ctx._tabs = _t);
                },
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && (core.Jc(tabs_c5, !0), core.Jc(tabs_c6, !0)), 2 & rf && (core.qc(_t = core.dc()) && (ctx._tabBodyWrapper = _t.first), 
                    core.qc(_t = core.dc()) && (ctx._tabHeader = _t.first));
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (core.Bb(2), core.Ub(tabs_c7)), 2 & rf && (core.Fb("mat-tab-group-dynamic-height", ctx.dynamicHeight), 
                    core.Fb("mat-tab-group-inverted-header", "below" === ctx.headerPosition));
                },
                inputs: {
                    color: "color",
                    disableRipple: "disableRipple"
                },
                exportAs: [ "matTabGroup" ],
                features: [ core.xb ],
                decls: 6,
                vars: 5,
                consts: [ [ 3, "selectedIndex", "disableRipple", "indexFocused", "selectFocusedIndex" ], [ "tabHeader", "" ], [ "class", "mat-tab-label", "role", "tab", "matTabLabelWrapper", "", "mat-ripple", "", "cdkMonitorElementFocus", "", 3, "id", "mat-tab-label-active", "disabled", "matRippleDisabled", "click", 4, "ngFor", "ngForOf" ], [ 1, "mat-tab-body-wrapper" ], [ "tabBodyWrapper", "" ], [ "role", "tabpanel", 3, "id", "mat-tab-body-active", "content", "position", "origin", "animationDuration", "_onCentered", "_onCentering", 4, "ngFor", "ngForOf" ], [ "role", "tab", "matTabLabelWrapper", "", "mat-ripple", "", "cdkMonitorElementFocus", "", 1, "mat-tab-label", 3, "id", "disabled", "matRippleDisabled", "click" ], [ 1, "mat-tab-label-content" ], [ 3, "ngIf" ], [ 3, "cdkPortalOutlet" ], [ "role", "tabpanel", 3, "id", "content", "position", "origin", "animationDuration", "_onCentered", "_onCentering" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.Vb(0, "mat-tab-header", 0, 1), core.cc("indexFocused", (function($event) {
                        return ctx._focusChanged($event);
                    })), core.cc("selectFocusedIndex", (function($event) {
                        return ctx.selectedIndex = $event;
                    })), core.Cc(2, MatTabGroup_div_2_Template, 4, 13, "div", 2), core.Tb(), core.Vb(3, "div", 3, 4), 
                    core.Cc(5, MatTabGroup_mat_tab_body_5_Template, 1, 7, "mat-tab-body", 5), core.Tb()), 
                    2 & rf && (core.lc("selectedIndex", ctx.selectedIndex)("disableRipple", ctx.disableRipple), 
                    core.Ab(2), core.lc("ngForOf", ctx._tabs), core.Ab(1), core.Fb("_mat-animation-noopable", "NoopAnimations" === ctx._animationMode), 
                    core.Ab(2), core.lc("ngForOf", ctx._tabs));
                },
                directives: function() {
                    return [ tabs_MatTabHeader, common.j, tabs_MatTabLabelWrapper, fesm2015_core.c, a11y.b, common.k, portal.c, tabs_MatTabBody ];
                },
                styles: [ ".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media(-ms-high-contrast: active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media(-ms-high-contrast: active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media(-ms-high-contrast: active){.mat-tab-label{opacity:1}}@media(max-width: 599px){.mat-tab-label{padding:0 12px}}@media(max-width: 959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height 500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-tab-body-wrapper{transition:none;animation:none}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}/*# sourceMappingURL=tab-group.css.map */\n" ],
                encapsulation: 2,
                changeDetection: 0
            }), MatTabGroup;
        })();
        class MatTabLabelWrapperBase {}
        const _MatTabLabelWrapperMixinBase = Object(fesm2015_core.h)(MatTabLabelWrapperBase);
        let tabs_MatTabLabelWrapper = (() => {
            class MatTabLabelWrapper extends _MatTabLabelWrapperMixinBase {
                constructor(elementRef) {
                    super(), this.elementRef = elementRef;
                }
                focus() {
                    this.elementRef.nativeElement.focus();
                }
                getOffsetLeft() {
                    return this.elementRef.nativeElement.offsetLeft;
                }
                getOffsetWidth() {
                    return this.elementRef.nativeElement.offsetWidth;
                }
            }
            return MatTabLabelWrapper.ɵfac = function(t) {
                return new (t || MatTabLabelWrapper)(core.Pb(core.k));
            }, MatTabLabelWrapper.ɵdir = core.Kb({
                type: MatTabLabelWrapper,
                selectors: [ [ "", "matTabLabelWrapper", "" ] ],
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && core.Bb(2), 2 & rf && (core.Cb("aria-disabled", !!ctx.disabled), core.Fb("mat-tab-disabled", ctx.disabled));
                },
                inputs: {
                    disabled: "disabled"
                },
                features: [ core.xb ]
            }), MatTabLabelWrapper;
        })();
        const passiveEventListenerOptions = Object(fesm2015_platform.e)({
            passive: !0
        }), EXAGGERATED_OVERSCROLL = 60, HEADER_SCROLL_DELAY = 650, HEADER_SCROLL_INTERVAL = 100;
        let tabs_MatPaginatedTabHeader = (() => {
            class MatPaginatedTabHeader {
                constructor(_elementRef, _changeDetectorRef, _viewportRuler, _dir, _ngZone, _platform, _animationMode) {
                    this._elementRef = _elementRef, this._changeDetectorRef = _changeDetectorRef, this._viewportRuler = _viewportRuler, 
                    this._dir = _dir, this._ngZone = _ngZone, this._platform = _platform, this._animationMode = _animationMode, 
                    this._scrollDistance = 0, this._selectedIndexChanged = !1, this._destroyed = new Subject.a, 
                    this._showPaginationControls = !1, this._disableScrollAfter = !0, this._disableScrollBefore = !0, 
                    this._stopScrolling = new Subject.a, this._selectedIndex = 0, this.selectFocusedIndex = new core.m, 
                    this.indexFocused = new core.m, _ngZone.runOutsideAngular(() => {
                        Object(fromEvent.a)(_elementRef.nativeElement, "mouseleave").pipe(Object(takeUntil.a)(this._destroyed)).subscribe(() => {
                            this._stopInterval();
                        });
                    });
                }
                get selectedIndex() {
                    return this._selectedIndex;
                }
                set selectedIndex(value) {
                    value = Object(coercion.e)(value), this._selectedIndex != value && (this._selectedIndexChanged = !0, 
                    this._selectedIndex = value, this._keyManager && this._keyManager.updateActiveItemIndex(value));
                }
                ngAfterViewInit() {
                    Object(fromEvent.a)(this._previousPaginator.nativeElement, "touchstart", passiveEventListenerOptions).pipe(Object(takeUntil.a)(this._destroyed)).subscribe(() => {
                        this._handlePaginatorPress("before");
                    }), Object(fromEvent.a)(this._nextPaginator.nativeElement, "touchstart", passiveEventListenerOptions).pipe(Object(takeUntil.a)(this._destroyed)).subscribe(() => {
                        this._handlePaginatorPress("after");
                    });
                }
                ngAfterContentInit() {
                    const dirChange = this._dir ? this._dir.change : Object(of.a)(null), resize = this._viewportRuler.change(150), realign = () => {
                        this.updatePagination(), this._alignInkBarToSelectedTab();
                    };
                    this._keyManager = new a11y.c(this._items).withHorizontalOrientation(this._getLayoutDirection()).withWrap(), 
                    this._keyManager.updateActiveItem(0), "undefined" != typeof requestAnimationFrame ? requestAnimationFrame(realign) : realign(), 
                    Object(merge.a)(dirChange, resize, this._items.changes).pipe(Object(takeUntil.a)(this._destroyed)).subscribe(() => {
                        realign(), this._keyManager.withHorizontalOrientation(this._getLayoutDirection());
                    }), this._keyManager.change.pipe(Object(takeUntil.a)(this._destroyed)).subscribe(newFocusIndex => {
                        this.indexFocused.emit(newFocusIndex), this._setTabFocus(newFocusIndex);
                    });
                }
                ngAfterContentChecked() {
                    this._tabLabelCount != this._items.length && (this.updatePagination(), this._tabLabelCount = this._items.length, 
                    this._changeDetectorRef.markForCheck()), this._selectedIndexChanged && (this._scrollToLabel(this._selectedIndex), 
                    this._checkScrollingControls(), this._alignInkBarToSelectedTab(), this._selectedIndexChanged = !1, 
                    this._changeDetectorRef.markForCheck()), this._scrollDistanceChanged && (this._updateTabScrollPosition(), 
                    this._scrollDistanceChanged = !1, this._changeDetectorRef.markForCheck());
                }
                ngOnDestroy() {
                    this._destroyed.next(), this._destroyed.complete(), this._stopScrolling.complete();
                }
                _handleKeydown(event) {
                    if (!Object(keycodes.o)(event)) switch (event.keyCode) {
                      case keycodes.f:
                        this._keyManager.setFirstItemActive(), event.preventDefault();
                        break;

                      case keycodes.c:
                        this._keyManager.setLastItemActive(), event.preventDefault();
                        break;

                      case keycodes.d:
                      case keycodes.j:
                        this.selectFocusedIndex.emit(this.focusIndex), this._itemSelected(event);
                        break;

                      default:
                        this._keyManager.onKeydown(event);
                    }
                }
                _onContentChanges() {
                    const textContent = this._elementRef.nativeElement.textContent;
                    textContent !== this._currentTextContent && (this._currentTextContent = textContent || "", 
                    this._ngZone.run(() => {
                        this.updatePagination(), this._alignInkBarToSelectedTab(), this._changeDetectorRef.markForCheck();
                    }));
                }
                updatePagination() {
                    this._checkPaginationEnabled(), this._checkScrollingControls(), this._updateTabScrollPosition();
                }
                get focusIndex() {
                    return this._keyManager ? this._keyManager.activeItemIndex : 0;
                }
                set focusIndex(value) {
                    this._isValidIndex(value) && this.focusIndex !== value && this._keyManager && this._keyManager.setActiveItem(value);
                }
                _isValidIndex(index) {
                    if (!this._items) return !0;
                    const tab = this._items ? this._items.toArray()[index] : null;
                    return !!tab && !tab.disabled;
                }
                _setTabFocus(tabIndex) {
                    if (this._showPaginationControls && this._scrollToLabel(tabIndex), this._items && this._items.length) {
                        this._items.toArray()[tabIndex].focus();
                        const containerEl = this._tabListContainer.nativeElement, dir = this._getLayoutDirection();
                        containerEl.scrollLeft = "ltr" == dir ? 0 : containerEl.scrollWidth - containerEl.offsetWidth;
                    }
                }
                _getLayoutDirection() {
                    return this._dir && "rtl" === this._dir.value ? "rtl" : "ltr";
                }
                _updateTabScrollPosition() {
                    const scrollDistance = this.scrollDistance, platform = this._platform, translateX = "ltr" === this._getLayoutDirection() ? -scrollDistance : scrollDistance;
                    this._tabList.nativeElement.style.transform = `translateX(${Math.round(translateX)}px)`, 
                    platform && (platform.TRIDENT || platform.EDGE) && (this._tabListContainer.nativeElement.scrollLeft = 0);
                }
                get scrollDistance() {
                    return this._scrollDistance;
                }
                set scrollDistance(value) {
                    this._scrollTo(value);
                }
                _scrollHeader(direction) {
                    return this._scrollTo(this._scrollDistance + ("before" == direction ? -1 : 1) * this._tabListContainer.nativeElement.offsetWidth / 3);
                }
                _handlePaginatorClick(direction) {
                    this._stopInterval(), this._scrollHeader(direction);
                }
                _scrollToLabel(labelIndex) {
                    const selectedLabel = this._items ? this._items.toArray()[labelIndex] : null;
                    if (!selectedLabel) return;
                    const viewLength = this._tabListContainer.nativeElement.offsetWidth, {offsetLeft: offsetLeft, offsetWidth: offsetWidth} = selectedLabel.elementRef.nativeElement;
                    let labelBeforePos, labelAfterPos;
                    "ltr" == this._getLayoutDirection() ? labelAfterPos = (labelBeforePos = offsetLeft) + offsetWidth : labelBeforePos = (labelAfterPos = this._tabList.nativeElement.offsetWidth - offsetLeft) - offsetWidth;
                    const beforeVisiblePos = this.scrollDistance, afterVisiblePos = this.scrollDistance + viewLength;
                    labelBeforePos < beforeVisiblePos ? this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL : labelAfterPos > afterVisiblePos && (this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL);
                }
                _checkPaginationEnabled() {
                    const isEnabled = this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;
                    isEnabled || (this.scrollDistance = 0), isEnabled !== this._showPaginationControls && this._changeDetectorRef.markForCheck(), 
                    this._showPaginationControls = isEnabled;
                }
                _checkScrollingControls() {
                    this._disableScrollBefore = 0 == this.scrollDistance, this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance(), 
                    this._changeDetectorRef.markForCheck();
                }
                _getMaxScrollDistance() {
                    return this._tabList.nativeElement.scrollWidth - this._tabListContainer.nativeElement.offsetWidth || 0;
                }
                _alignInkBarToSelectedTab() {
                    const selectedItem = this._items && this._items.length ? this._items.toArray()[this.selectedIndex] : null, selectedLabelWrapper = selectedItem ? selectedItem.elementRef.nativeElement : null;
                    selectedLabelWrapper ? this._inkBar.alignToElement(selectedLabelWrapper) : this._inkBar.hide();
                }
                _stopInterval() {
                    this._stopScrolling.next();
                }
                _handlePaginatorPress(direction) {
                    this._stopInterval(), Object(timer.a)(HEADER_SCROLL_DELAY, HEADER_SCROLL_INTERVAL).pipe(Object(takeUntil.a)(Object(merge.a)(this._stopScrolling, this._destroyed))).subscribe(() => {
                        const {maxScrollDistance: maxScrollDistance, distance: distance} = this._scrollHeader(direction);
                        (0 === distance || distance >= maxScrollDistance) && this._stopInterval();
                    });
                }
                _scrollTo(position) {
                    const maxScrollDistance = this._getMaxScrollDistance();
                    return this._scrollDistance = Math.max(0, Math.min(maxScrollDistance, position)), 
                    this._scrollDistanceChanged = !0, this._checkScrollingControls(), {
                        maxScrollDistance: maxScrollDistance,
                        distance: this._scrollDistance
                    };
                }
            }
            return MatPaginatedTabHeader.ɵfac = function(t) {
                return new (t || MatPaginatedTabHeader)(core.Pb(core.k), core.Pb(core.h), core.Pb(scrolling.e), core.Pb(bidi.b, 8), core.Pb(core.y), core.Pb(fesm2015_platform.a), core.Pb(animations.a, 8));
            }, MatPaginatedTabHeader.ɵdir = core.Kb({
                type: MatPaginatedTabHeader,
                selectors: [ [ "do-not-use-abstract-mat-paginated-tab-header" ] ]
            }), MatPaginatedTabHeader;
        })(), tabs_MatTabHeaderBase = (() => {
            class _MatTabHeaderBase extends tabs_MatPaginatedTabHeader {
                constructor(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode) {
                    super(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode), 
                    this._disableRipple = !1;
                }
                get disableRipple() {
                    return this._disableRipple;
                }
                set disableRipple(value) {
                    this._disableRipple = Object(coercion.b)(value);
                }
                _itemSelected(event) {
                    event.preventDefault();
                }
            }
            return _MatTabHeaderBase.ɵfac = function(t) {
                return new (t || _MatTabHeaderBase)(core.Pb(core.k), core.Pb(core.h), core.Pb(scrolling.e), core.Pb(bidi.b, 8), core.Pb(core.y), core.Pb(fesm2015_platform.a), core.Pb(animations.a, 8));
            }, _MatTabHeaderBase.ɵdir = core.Kb({
                type: _MatTabHeaderBase,
                selectors: [ [ "do-not-use-abstract-mat-tab-header-base" ] ],
                inputs: {
                    disableRipple: "disableRipple"
                },
                features: [ core.xb ]
            }), _MatTabHeaderBase;
        })(), tabs_MatTabHeader = (() => {
            class MatTabHeader extends tabs_MatTabHeaderBase {
                constructor(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode) {
                    super(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode);
                }
            }
            return MatTabHeader.ɵfac = function(t) {
                return new (t || MatTabHeader)(core.Pb(core.k), core.Pb(core.h), core.Pb(scrolling.e), core.Pb(bidi.b, 8), core.Pb(core.y), core.Pb(fesm2015_platform.a), core.Pb(animations.a, 8));
            }, MatTabHeader.ɵcmp = core.Jb({
                type: MatTabHeader,
                selectors: [ [ "mat-tab-header" ] ],
                contentQueries: function(rf, ctx, dirIndex) {
                    var _t;
                    1 & rf && core.Hb(dirIndex, tabs_MatTabLabelWrapper, !1), 2 & rf && core.qc(_t = core.dc()) && (ctx._items = _t);
                },
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && (core.yc(tabs_MatInkBar, !0), core.yc(tabs_c8, !0), core.yc(tabs_c9, !0), 
                    core.Jc(tabs_c10, !0), core.Jc(tabs_c11, !0)), 2 & rf && (core.qc(_t = core.dc()) && (ctx._inkBar = _t.first), 
                    core.qc(_t = core.dc()) && (ctx._tabListContainer = _t.first), core.qc(_t = core.dc()) && (ctx._tabList = _t.first), 
                    core.qc(_t = core.dc()) && (ctx._nextPaginator = _t.first), core.qc(_t = core.dc()) && (ctx._previousPaginator = _t.first));
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (core.Bb(2), core.Ub(tabs_c12)), 2 & rf && (core.Fb("mat-tab-header-pagination-controls-enabled", ctx._showPaginationControls), 
                    core.Fb("mat-tab-header-rtl", "rtl" == ctx._getLayoutDirection()));
                },
                inputs: {
                    selectedIndex: "selectedIndex"
                },
                outputs: {
                    selectFocusedIndex: "selectFocusedIndex",
                    indexFocused: "indexFocused"
                },
                features: [ core.xb ],
                ngContentSelectors: tabs_c1,
                decls: 13,
                vars: 5,
                consts: [ [ "aria-hidden", "true", "mat-ripple", "", 1, "mat-tab-header-pagination", "mat-tab-header-pagination-before", "mat-elevation-z4", 3, "matRippleDisabled", "click", "mousedown", "touchend" ], [ "previousPaginator", "" ], [ 1, "mat-tab-header-pagination-chevron" ], [ 1, "mat-tab-label-container", 3, "keydown" ], [ "tabListContainer", "" ], [ "role", "tablist", 1, "mat-tab-list", 3, "cdkObserveContent" ], [ "tabList", "" ], [ 1, "mat-tab-labels" ], [ "aria-hidden", "true", "mat-ripple", "", 1, "mat-tab-header-pagination", "mat-tab-header-pagination-after", "mat-elevation-z4", 3, "matRippleDisabled", "mousedown", "click", "touchend" ], [ "nextPaginator", "" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.kc(), core.Vb(0, "div", 0, 1), core.cc("click", (function($event) {
                        return ctx._handlePaginatorClick("before");
                    })), core.cc("mousedown", (function($event) {
                        return ctx._handlePaginatorPress("before");
                    })), core.cc("touchend", (function($event) {
                        return ctx._stopInterval();
                    })), core.Qb(2, "div", 2), core.Tb(), core.Vb(3, "div", 3, 4), core.cc("keydown", (function($event) {
                        return ctx._handleKeydown($event);
                    })), core.Vb(5, "div", 5, 6), core.cc("cdkObserveContent", (function($event) {
                        return ctx._onContentChanges();
                    })), core.Vb(7, "div", 7), core.jc(8), core.Tb(), core.Qb(9, "mat-ink-bar"), core.Tb(), 
                    core.Tb(), core.Vb(10, "div", 8, 9), core.cc("mousedown", (function($event) {
                        return ctx._handlePaginatorPress("after");
                    })), core.cc("click", (function($event) {
                        return ctx._handlePaginatorClick("after");
                    })), core.cc("touchend", (function($event) {
                        return ctx._stopInterval();
                    })), core.Qb(12, "div", 2), core.Tb()), 2 & rf && (core.Fb("mat-tab-header-pagination-disabled", ctx._disableScrollBefore), 
                    core.lc("matRippleDisabled", ctx._disableScrollBefore || ctx.disableRipple), core.Ab(5), 
                    core.Fb("_mat-animation-noopable", "NoopAnimations" === ctx._animationMode), core.Ab(5), 
                    core.Fb("mat-tab-header-pagination-disabled", ctx._disableScrollAfter), core.lc("matRippleDisabled", ctx._disableScrollAfter || ctx.disableRipple));
                },
                directives: [ fesm2015_core.c, observers.a, tabs_MatInkBar ],
                styles: [ '.mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:"";height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media(-ms-high-contrast: active){.mat-ink-bar{outline:solid 2px;height:0}}.mat-tab-labels{display:flex}[mat-align-tabs=center] .mat-tab-labels{justify-content:center}[mat-align-tabs=end] .mat-tab-labels{justify-content:flex-end}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}._mat-animation-noopable.mat-tab-list{transition:none;animation:none}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media(-ms-high-contrast: active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media(-ms-high-contrast: active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media(-ms-high-contrast: active){.mat-tab-label{opacity:1}}@media(max-width: 599px){.mat-tab-label{min-width:72px}}/*# sourceMappingURL=tab-header.css.map */\n' ],
                encapsulation: 2,
                changeDetection: 0
            }), MatTabHeader;
        })(), tabs_MatTabsModule = (() => {
            class MatTabsModule {}
            return MatTabsModule.ɵmod = core.Nb({
                type: MatTabsModule
            }), MatTabsModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || MatTabsModule);
                },
                imports: [ [ common.c, fesm2015_core.b, portal.h, fesm2015_core.d, observers.c, a11y.a ], fesm2015_core.b ]
            }), MatTabsModule;
        })();
        const code_tabs_component_c0 = [ "content" ];
        function CodeTabsComponent_mat_tab_5_ng_template_1_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "span"), core.Ec(1), core.Tb()), 2 & rf) {
                const tab_r111 = core.gc().$implicit;
                core.Db(tab_r111.class), core.Ab(1), core.Fc(tab_r111.header);
            }
        }
        function CodeTabsComponent_mat_tab_5_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "mat-tab", 4), core.Cc(1, CodeTabsComponent_mat_tab_5_ng_template_1_Template, 2, 4, "ng-template", 5), 
            core.Qb(2, "aio-code", 6), core.Tb()), 2 & rf) {
                const tab_r111 = ctx.$implicit;
                core.Ab(2), core.Db(tab_r111.class), core.lc("language", tab_r111.language)("linenums", tab_r111.linenums)("path", tab_r111.path)("region", tab_r111.region)("header", tab_r111.header);
            }
        }
        const code_tabs_component_c1 = [ "*" ];
        let code_tabs_component_CodeTabsComponent = (() => {
            class CodeTabsComponent {
                ngOnInit() {
                    this.tabs = [];
                    const codeExamples = Array.from(this.content.nativeElement.querySelectorAll("code-pane"));
                    for (const tabContent of codeExamples) this.tabs.push(this.getTabInfo(tabContent));
                }
                ngAfterViewInit() {
                    this.codeComponents.toArray().forEach((codeComponent, i) => {
                        codeComponent.code = this.tabs[i].code;
                    });
                }
                getTabInfo(tabContent) {
                    return {
                        class: tabContent.getAttribute("class") || "",
                        code: tabContent.innerHTML,
                        path: tabContent.getAttribute("path") || "",
                        region: tabContent.getAttribute("region") || "",
                        header: tabContent.getAttribute("header") || void 0,
                        language: tabContent.getAttribute("language") || void 0,
                        linenums: tabContent.getAttribute("linenums") || this.linenums
                    };
                }
            }
            return CodeTabsComponent.ɵfac = function(t) {
                return new (t || CodeTabsComponent);
            }, CodeTabsComponent.ɵcmp = core.Jb({
                type: CodeTabsComponent,
                selectors: [ [ "code-tabs" ] ],
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && (core.yc(code_tabs_component_c0, !0), core.Jc(code_component.a, !0)), 
                    2 & rf && (core.qc(_t = core.dc()) && (ctx.content = _t.first), core.qc(_t = core.dc()) && (ctx.codeComponents = _t));
                },
                inputs: {
                    linenums: "linenums"
                },
                ngContentSelectors: code_tabs_component_c1,
                decls: 6,
                vars: 2,
                consts: [ [ 2, "display", "none" ], [ "content", "" ], [ 1, "code-tab-group", 3, "disableRipple" ], [ "style", "overflow-y: hidden;", 4, "ngFor", "ngForOf" ], [ 2, "overflow-y", "hidden" ], [ "mat-tab-label", "" ], [ 3, "language", "linenums", "path", "region", "header" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.kc(), core.Vb(0, "div", 0, 1), core.jc(2), core.Tb(), core.Vb(3, "mat-card"), 
                    core.Vb(4, "mat-tab-group", 2), core.Cc(5, CodeTabsComponent_mat_tab_5_Template, 3, 8, "mat-tab", 3), 
                    core.Tb(), core.Tb()), 2 & rf && (core.Ab(4), core.lc("disableRipple", !0), core.Ab(1), 
                    core.lc("ngForOf", ctx.tabs));
                },
                directives: [ card_MatCard, tabs_MatTabGroup, common.j, tabs_MatTab, tabs_MatTabLabel, code_component.a ],
                encapsulation: 2
            }), CodeTabsComponent;
        })();
        var code_module = __webpack_require__("V90o");
        __webpack_require__.d(__webpack_exports__, "CodeTabsModule", (function() {
            return code_tabs_module_CodeTabsModule;
        }));
        let code_tabs_module_CodeTabsModule = (() => {
            class CodeTabsModule {
                constructor() {
                    this.customElementComponent = code_tabs_component_CodeTabsComponent;
                }
            }
            return CodeTabsModule.ɵmod = core.Nb({
                type: CodeTabsModule
            }), CodeTabsModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || CodeTabsModule);
                },
                imports: [ [ common.c, card_MatCardModule, tabs_MatTabsModule, code_module.a ] ]
            }), CodeTabsModule;
        })();
    },
    gRHU: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return empty;
        }));
        var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("2fFW"), _util_hostReportError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("NJ4a");
        const empty = {
            closed: !0,
            next(value) {},
            error(err) {
                if (_config__WEBPACK_IMPORTED_MODULE_0__.a.useDeprecatedSynchronousErrorHandling) throw err;
                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_1__.a)(err);
            },
            complete() {}
        };
    },
    hqch: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return WebWorkerClient;
        }));
        var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("HDdC");
        class WebWorkerClient {
            constructor(worker, zone) {
                this.worker = worker, this.zone = zone, this.nextId = 0;
            }
            static create(worker, zone) {
                return new WebWorkerClient(worker, zone);
            }
            sendMessage(type, payload) {
                return new rxjs__WEBPACK_IMPORTED_MODULE_0__.a(subscriber => {
                    const id = this.nextId++, handleMessage = response => {
                        const {type: responseType, id: responseId, payload: responsePayload} = response.data;
                        type === responseType && id === responseId && this.zone.run(() => {
                            subscriber.next(responsePayload), subscriber.complete();
                        });
                    }, handleError = error => {
                        this.zone.run(() => subscriber.error(error));
                    };
                    return this.worker.addEventListener("message", handleMessage), this.worker.addEventListener("error", handleError), 
                    this.worker.postMessage({
                        type: type,
                        id: id,
                        payload: payload
                    }), () => {
                        this.worker.removeEventListener("message", handleMessage), this.worker.removeEventListener("error", handleError);
                    };
                });
            }
        }
    },
    "iL+y": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        var Subject = __webpack_require__("XNiG"), never = __webpack_require__("5yfJ"), concat = __webpack_require__("GyhO"), Observable = __webpack_require__("HDdC"), scheduler_async = __webpack_require__("D0XW"), isNumeric = __webpack_require__("Y7HM");
        function dispatch(state) {
            const {subscriber: subscriber, counter: counter, period: period} = state;
            subscriber.next(counter), this.schedule({
                subscriber: subscriber,
                counter: counter + 1,
                period: period
            }, period);
        }
        var takeUntil = __webpack_require__("1G5W"), first = __webpack_require__("SxV6"), tap = __webpack_require__("vkgz"), map = __webpack_require__("lJxs"), core = __webpack_require__("fXoL"), logger_service = __webpack_require__("vHPH"), service_worker = __webpack_require__("Jho9");
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return sw_updates_service_SwUpdatesService;
        }));
        let sw_updates_service_SwUpdatesService = (() => {
            class SwUpdatesService {
                constructor(appRef, logger, swu) {
                    if (this.logger = logger, this.swu = swu, this.checkInterval = 216e5, this.onDestroy = new Subject.a, 
                    !swu.isEnabled) return void (this.updateActivated = never.a.pipe(Object(takeUntil.a)(this.onDestroy)));
                    const appIsStable = appRef.isStable.pipe(Object(first.a)(v => v));
                    Object(concat.a)(appIsStable, function(period = 0, scheduler = scheduler_async.a) {
                        return (!Object(isNumeric.a)(period) || period < 0) && (period = 0), scheduler && "function" == typeof scheduler.schedule || (scheduler = scheduler_async.a), 
                        new Observable.a(subscriber => (subscriber.add(scheduler.schedule(dispatch, period, {
                            subscriber: subscriber,
                            counter: 0,
                            period: period
                        })), subscriber));
                    }(this.checkInterval)).pipe(Object(tap.a)(() => this.log("Checking for update...")), Object(takeUntil.a)(this.onDestroy)).subscribe(() => this.swu.checkForUpdate()), 
                    this.swu.available.pipe(Object(tap.a)(evt => this.log(`Update available: ${JSON.stringify(evt)}`)), Object(takeUntil.a)(this.onDestroy)).subscribe(() => this.swu.activateUpdate()), 
                    this.updateActivated = this.swu.activated.pipe(Object(tap.a)(evt => this.log(`Update activated: ${JSON.stringify(evt)}`)), Object(map.a)(evt => evt.current.hash), Object(takeUntil.a)(this.onDestroy));
                }
                ngOnDestroy() {
                    this.onDestroy.next();
                }
                log(message) {
                    const timestamp = (new Date).toISOString();
                    this.logger.log(`[SwUpdates - ${timestamp}]: ${message}`);
                }
            }
            return SwUpdatesService.ɵfac = function(t) {
                return new (t || SwUpdatesService)(core.Zb(core.g), core.Zb(logger_service.a), core.Zb(service_worker.b));
            }, SwUpdatesService.ɵprov = core.Lb({
                token: SwUpdatesService,
                factory: function(t) {
                    return SwUpdatesService.ɵfac(t);
                },
                providedIn: null
            }), SwUpdatesService;
        })();
    },
    itXk: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return combineLatest;
        }));
        var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("z+Ro"), _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("DH7j"), _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("l7GE"), _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("ZUHj"), _fromArray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("yCtX");
        const NONE = {};
        function combineLatest(...observables) {
            let resultSelector = null, scheduler = null;
            return Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__.a)(observables[observables.length - 1]) && (scheduler = observables.pop()), 
            "function" == typeof observables[observables.length - 1] && (resultSelector = observables.pop()), 
            1 === observables.length && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__.a)(observables[0]) && (observables = observables[0]), 
            Object(_fromArray__WEBPACK_IMPORTED_MODULE_4__.a)(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
        }
        class CombineLatestOperator {
            constructor(resultSelector) {
                this.resultSelector = resultSelector;
            }
            call(subscriber, source) {
                return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
            }
        }
        class CombineLatestSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__.a {
            constructor(destination, resultSelector) {
                super(destination), this.resultSelector = resultSelector, this.active = 0, this.values = [], 
                this.observables = [];
            }
            _next(observable) {
                this.values.push(NONE), this.observables.push(observable);
            }
            _complete() {
                const observables = this.observables, len = observables.length;
                if (0 === len) this.destination.complete(); else {
                    this.active = len, this.toRespond = len;
                    for (let i = 0; i < len; i++) {
                        const observable = observables[i];
                        this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__.a)(this, observable, observable, i));
                    }
                }
            }
            notifyComplete(unused) {
                0 == (this.active -= 1) && this.destination.complete();
            }
            notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                const values = this.values, toRespond = this.toRespond ? values[outerIndex] === NONE ? --this.toRespond : this.toRespond : 0;
                values[outerIndex] = innerValue, 0 === toRespond && (this.resultSelector ? this._tryResultSelector(values) : this.destination.next(values.slice()));
            }
            _tryResultSelector(values) {
                let result;
                try {
                    result = this.resultSelector.apply(this, values);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.next(result);
            }
        }
    },
    jZKg: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return scheduleArray;
        }));
        var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("HDdC"), _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("quSY");
        function scheduleArray(input, scheduler) {
            return new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(subscriber => {
                const sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__.a;
                let i = 0;
                return sub.add(scheduler.schedule((function() {
                    i !== input.length ? (subscriber.next(input[i++]), subscriber.closed || sub.add(this.schedule())) : subscriber.complete();
                }))), sub;
            });
        }
    },
    jhN1: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return BrowserModule;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return DomSanitizer;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return HammerGestureConfig;
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return Meta;
        })), __webpack_require__.d(__webpack_exports__, "e", (function() {
            return Title;
        })), __webpack_require__.d(__webpack_exports__, "f", (function() {
            return platformBrowser;
        })), __webpack_require__.d(__webpack_exports__, "g", (function() {
            return DomRendererFactory2;
        }));
        var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ofXK"), _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("fXoL");
        class GenericBrowserDomAdapter extends _angular_common__WEBPACK_IMPORTED_MODULE_0__.t {
            constructor() {
                super();
            }
            supportsDOMEvents() {
                return !0;
            }
        }
        class BrowserDomAdapter extends GenericBrowserDomAdapter {
            static makeCurrent() {
                Object(_angular_common__WEBPACK_IMPORTED_MODULE_0__.x)(new BrowserDomAdapter);
            }
            getProperty(el, name) {
                return el[name];
            }
            log(error) {
                window.console && window.console.log && window.console.log(error);
            }
            logGroup(error) {
                window.console && window.console.group && window.console.group(error);
            }
            logGroupEnd() {
                window.console && window.console.groupEnd && window.console.groupEnd();
            }
            onAndCancel(el, evt, listener) {
                return el.addEventListener(evt, listener, !1), () => {
                    el.removeEventListener(evt, listener, !1);
                };
            }
            dispatchEvent(el, evt) {
                el.dispatchEvent(evt);
            }
            remove(node) {
                return node.parentNode && node.parentNode.removeChild(node), node;
            }
            getValue(el) {
                return el.value;
            }
            createElement(tagName, doc) {
                return (doc = doc || this.getDefaultDocument()).createElement(tagName);
            }
            createHtmlDocument() {
                return document.implementation.createHTMLDocument("fakeTitle");
            }
            getDefaultDocument() {
                return document;
            }
            isElementNode(node) {
                return node.nodeType === Node.ELEMENT_NODE;
            }
            isShadowRoot(node) {
                return node instanceof DocumentFragment;
            }
            getGlobalEventTarget(doc, target) {
                return "window" === target ? window : "document" === target ? doc : "body" === target ? doc.body : null;
            }
            getHistory() {
                return window.history;
            }
            getLocation() {
                return window.location;
            }
            getBaseHref(doc) {
                const href = baseElement || (baseElement = document.querySelector("base")) ? baseElement.getAttribute("href") : null;
                return null == href ? null : (url = href, urlParsingNode || (urlParsingNode = document.createElement("a")), 
                urlParsingNode.setAttribute("href", url), "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname);
                var url;
            }
            resetBaseElement() {
                baseElement = null;
            }
            getUserAgent() {
                return window.navigator.userAgent;
            }
            performanceNow() {
                return window.performance && window.performance.now ? window.performance.now() : (new Date).getTime();
            }
            supportsCookies() {
                return !0;
            }
            getCookie(name) {
                return Object(_angular_common__WEBPACK_IMPORTED_MODULE_0__.w)(document.cookie, name);
            }
        }
        let urlParsingNode, baseElement = null;
        const TRANSITION_ID = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.p("TRANSITION_ID"), SERVER_TRANSITION_PROVIDERS = [ {
            provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.d,
            useFactory: function(transitionId, document, injector) {
                return () => {
                    injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_1__.e).donePromise.then(() => {
                        const dom = Object(_angular_common__WEBPACK_IMPORTED_MODULE_0__.v)();
                        Array.prototype.slice.apply(document.querySelectorAll("style[ng-transition]")).filter(el => el.getAttribute("ng-transition") === transitionId).forEach(el => dom.remove(el));
                    });
                };
            },
            deps: [ TRANSITION_ID, _angular_common__WEBPACK_IMPORTED_MODULE_0__.d, _angular_core__WEBPACK_IMPORTED_MODULE_1__.q ],
            multi: !0
        } ];
        class BrowserGetTestability {
            static init() {
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Y)(new BrowserGetTestability);
            }
            addToWindow(registry) {
                _angular_core__WEBPACK_IMPORTED_MODULE_1__.ob.getAngularTestability = (elem, findInAncestors = !0) => {
                    const testability = registry.findTestabilityInTree(elem, findInAncestors);
                    if (null == testability) throw new Error("Could not find testability for element.");
                    return testability;
                }, _angular_core__WEBPACK_IMPORTED_MODULE_1__.ob.getAllAngularTestabilities = () => registry.getAllTestabilities(), 
                _angular_core__WEBPACK_IMPORTED_MODULE_1__.ob.getAllAngularRootElements = () => registry.getAllRootElements(), 
                _angular_core__WEBPACK_IMPORTED_MODULE_1__.ob.frameworkStabilizers || (_angular_core__WEBPACK_IMPORTED_MODULE_1__.ob.frameworkStabilizers = []), 
                _angular_core__WEBPACK_IMPORTED_MODULE_1__.ob.frameworkStabilizers.push(callback => {
                    const testabilities = _angular_core__WEBPACK_IMPORTED_MODULE_1__.ob.getAllAngularTestabilities();
                    let count = testabilities.length, didWork = !1;
                    const decrement = function(didWork_) {
                        didWork = didWork || didWork_, 0 == --count && callback(didWork);
                    };
                    testabilities.forEach((function(testability) {
                        testability.whenStable(decrement);
                    }));
                });
            }
            findTestabilityInTree(registry, elem, findInAncestors) {
                if (null == elem) return null;
                const t = registry.getTestability(elem);
                return null != t ? t : findInAncestors ? Object(_angular_common__WEBPACK_IMPORTED_MODULE_0__.v)().isShadowRoot(elem) ? this.findTestabilityInTree(registry, elem.host, !0) : this.findTestabilityInTree(registry, elem.parentElement, !0) : null;
            }
        }
        const EVENT_MANAGER_PLUGINS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.p("EventManagerPlugins");
        let EventManager = (() => {
            class EventManager {
                constructor(plugins, _zone) {
                    this._zone = _zone, this._eventNameToPlugin = new Map, plugins.forEach(p => p.manager = this), 
                    this._plugins = plugins.slice().reverse();
                }
                addEventListener(element, eventName, handler) {
                    return this._findPluginFor(eventName).addEventListener(element, eventName, handler);
                }
                addGlobalEventListener(target, eventName, handler) {
                    return this._findPluginFor(eventName).addGlobalEventListener(target, eventName, handler);
                }
                getZone() {
                    return this._zone;
                }
                _findPluginFor(eventName) {
                    const plugin = this._eventNameToPlugin.get(eventName);
                    if (plugin) return plugin;
                    const plugins = this._plugins;
                    for (let i = 0; i < plugins.length; i++) {
                        const plugin = plugins[i];
                        if (plugin.supports(eventName)) return this._eventNameToPlugin.set(eventName, plugin), 
                        plugin;
                    }
                    throw new Error(`No event manager plugin found for event ${eventName}`);
                }
            }
            return EventManager.ɵfac = function(t) {
                return new (t || EventManager)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(EVENT_MANAGER_PLUGINS), _angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(_angular_core__WEBPACK_IMPORTED_MODULE_1__.y));
            }, EventManager.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb({
                token: EventManager,
                factory: function(t) {
                    return EventManager.ɵfac(t);
                },
                providedIn: null
            }), EventManager;
        })();
        class EventManagerPlugin {
            constructor(_doc) {
                this._doc = _doc;
            }
            addGlobalEventListener(element, eventName, handler) {
                const target = Object(_angular_common__WEBPACK_IMPORTED_MODULE_0__.v)().getGlobalEventTarget(this._doc, element);
                if (!target) throw new Error(`Unsupported event target ${target} for event ${eventName}`);
                return this.addEventListener(target, eventName, handler);
            }
        }
        let SharedStylesHost = (() => {
            class SharedStylesHost {
                constructor() {
                    this._stylesSet = new Set;
                }
                addStyles(styles) {
                    const additions = new Set;
                    styles.forEach(style => {
                        this._stylesSet.has(style) || (this._stylesSet.add(style), additions.add(style));
                    }), this.onStylesAdded(additions);
                }
                onStylesAdded(additions) {}
                getAllStyles() {
                    return Array.from(this._stylesSet);
                }
            }
            return SharedStylesHost.ɵfac = function(t) {
                return new (t || SharedStylesHost);
            }, SharedStylesHost.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb({
                token: SharedStylesHost,
                factory: function(t) {
                    return SharedStylesHost.ɵfac(t);
                },
                providedIn: null
            }), SharedStylesHost;
        })(), DomSharedStylesHost = (() => {
            class DomSharedStylesHost extends SharedStylesHost {
                constructor(_doc) {
                    super(), this._doc = _doc, this._hostNodes = new Set, this._styleNodes = new Set, 
                    this._hostNodes.add(_doc.head);
                }
                _addStylesToHost(styles, host) {
                    styles.forEach(style => {
                        const styleEl = this._doc.createElement("style");
                        styleEl.textContent = style, this._styleNodes.add(host.appendChild(styleEl));
                    });
                }
                addHost(hostNode) {
                    this._addStylesToHost(this._stylesSet, hostNode), this._hostNodes.add(hostNode);
                }
                removeHost(hostNode) {
                    this._hostNodes.delete(hostNode);
                }
                onStylesAdded(additions) {
                    this._hostNodes.forEach(hostNode => this._addStylesToHost(additions, hostNode));
                }
                ngOnDestroy() {
                    this._styleNodes.forEach(styleNode => Object(_angular_common__WEBPACK_IMPORTED_MODULE_0__.v)().remove(styleNode));
                }
            }
            return DomSharedStylesHost.ɵfac = function(t) {
                return new (t || DomSharedStylesHost)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(_angular_common__WEBPACK_IMPORTED_MODULE_0__.d));
            }, DomSharedStylesHost.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb({
                token: DomSharedStylesHost,
                factory: function(t) {
                    return DomSharedStylesHost.ɵfac(t);
                },
                providedIn: null
            }), DomSharedStylesHost;
        })();
        const NAMESPACE_URIS = {
            svg: "http://www.w3.org/2000/svg",
            xhtml: "http://www.w3.org/1999/xhtml",
            xlink: "http://www.w3.org/1999/xlink",
            xml: "http://www.w3.org/XML/1998/namespace",
            xmlns: "http://www.w3.org/2000/xmlns/"
        }, COMPONENT_REGEX = /%COMP%/g, NG_DEV_MODE = !1, HOST_ATTR = "_nghost-%COMP%", CONTENT_ATTR = "_ngcontent-%COMP%";
        function flattenStyles(compId, styles, target) {
            for (let i = 0; i < styles.length; i++) {
                let style = styles[i];
                Array.isArray(style) ? flattenStyles(compId, style, target) : (style = style.replace(COMPONENT_REGEX, compId), 
                target.push(style));
            }
            return target;
        }
        function decoratePreventDefault(eventHandler) {
            return event => {
                if (event === Function) return eventHandler;
                !1 === eventHandler(event) && (event.preventDefault(), event.returnValue = !1);
            };
        }
        let DomRendererFactory2 = (() => {
            class DomRendererFactory2 {
                constructor(eventManager, sharedStylesHost, appId) {
                    this.eventManager = eventManager, this.sharedStylesHost = sharedStylesHost, this.appId = appId, 
                    this.rendererByCompId = new Map, this.defaultRenderer = new DefaultDomRenderer2(eventManager);
                }
                createRenderer(element, type) {
                    if (!element || !type) return this.defaultRenderer;
                    switch (type.encapsulation) {
                      case _angular_core__WEBPACK_IMPORTED_MODULE_1__.P.Emulated:
                        {
                            let renderer = this.rendererByCompId.get(type.id);
                            return renderer || (renderer = new EmulatedEncapsulationDomRenderer2(this.eventManager, this.sharedStylesHost, type, this.appId), 
                            this.rendererByCompId.set(type.id, renderer)), renderer.applyToHost(element), renderer;
                        }

                      case _angular_core__WEBPACK_IMPORTED_MODULE_1__.P.Native:
                      case _angular_core__WEBPACK_IMPORTED_MODULE_1__.P.ShadowDom:
                        return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);

                      default:
                        if (!this.rendererByCompId.has(type.id)) {
                            const styles = flattenStyles(type.id, type.styles, []);
                            this.sharedStylesHost.addStyles(styles), this.rendererByCompId.set(type.id, this.defaultRenderer);
                        }
                        return this.defaultRenderer;
                    }
                }
                begin() {}
                end() {}
            }
            return DomRendererFactory2.ɵfac = function(t) {
                return new (t || DomRendererFactory2)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(EventManager), _angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(DomSharedStylesHost), _angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(_angular_core__WEBPACK_IMPORTED_MODULE_1__.c));
            }, DomRendererFactory2.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb({
                token: DomRendererFactory2,
                factory: function(t) {
                    return DomRendererFactory2.ɵfac(t);
                },
                providedIn: null
            }), DomRendererFactory2;
        })();
        class DefaultDomRenderer2 {
            constructor(eventManager) {
                this.eventManager = eventManager, this.data = Object.create(null);
            }
            destroy() {}
            createElement(name, namespace) {
                return namespace ? document.createElementNS(NAMESPACE_URIS[namespace] || namespace, name) : document.createElement(name);
            }
            createComment(value) {
                return document.createComment(value);
            }
            createText(value) {
                return document.createTextNode(value);
            }
            appendChild(parent, newChild) {
                parent.appendChild(newChild);
            }
            insertBefore(parent, newChild, refChild) {
                parent && parent.insertBefore(newChild, refChild);
            }
            removeChild(parent, oldChild) {
                parent && parent.removeChild(oldChild);
            }
            selectRootElement(selectorOrNode, preserveContent) {
                let el = "string" == typeof selectorOrNode ? document.querySelector(selectorOrNode) : selectorOrNode;
                if (!el) throw new Error(`The selector "${selectorOrNode}" did not match any elements`);
                return preserveContent || (el.textContent = ""), el;
            }
            parentNode(node) {
                return node.parentNode;
            }
            nextSibling(node) {
                return node.nextSibling;
            }
            setAttribute(el, name, value, namespace) {
                if (namespace) {
                    name = namespace + ":" + name;
                    const namespaceUri = NAMESPACE_URIS[namespace];
                    namespaceUri ? el.setAttributeNS(namespaceUri, name, value) : el.setAttribute(name, value);
                } else el.setAttribute(name, value);
            }
            removeAttribute(el, name, namespace) {
                if (namespace) {
                    const namespaceUri = NAMESPACE_URIS[namespace];
                    namespaceUri ? el.removeAttributeNS(namespaceUri, name) : el.removeAttribute(`${namespace}:${name}`);
                } else el.removeAttribute(name);
            }
            addClass(el, name) {
                el.classList.add(name);
            }
            removeClass(el, name) {
                el.classList.remove(name);
            }
            setStyle(el, style, value, flags) {
                flags & _angular_core__WEBPACK_IMPORTED_MODULE_1__.F.DashCase ? el.style.setProperty(style, value, flags & _angular_core__WEBPACK_IMPORTED_MODULE_1__.F.Important ? "important" : "") : el.style[style] = value;
            }
            removeStyle(el, style, flags) {
                flags & _angular_core__WEBPACK_IMPORTED_MODULE_1__.F.DashCase ? el.style.removeProperty(style) : el.style[style] = "";
            }
            setProperty(el, name, value) {
                NG_DEV_MODE && checkNoSyntheticProp(name, "property"), el[name] = value;
            }
            setValue(node, value) {
                node.nodeValue = value;
            }
            listen(target, event, callback) {
                return NG_DEV_MODE && checkNoSyntheticProp(event, "listener"), "string" == typeof target ? this.eventManager.addGlobalEventListener(target, event, decoratePreventDefault(callback)) : this.eventManager.addEventListener(target, event, decoratePreventDefault(callback));
            }
        }
        const AT_CHARCODE = (() => "@".charCodeAt(0))();
        function checkNoSyntheticProp(name, nameKind) {
            if (name.charCodeAt(0) === AT_CHARCODE) throw new Error(`Found the synthetic ${nameKind} ${name}. Please include either "BrowserAnimationsModule" or "NoopAnimationsModule" in your application.`);
        }
        class EmulatedEncapsulationDomRenderer2 extends DefaultDomRenderer2 {
            constructor(eventManager, sharedStylesHost, component, appId) {
                super(eventManager), this.component = component;
                const styles = flattenStyles(appId + "-" + component.id, component.styles, []);
                sharedStylesHost.addStyles(styles), this.contentAttr = CONTENT_ATTR.replace(COMPONENT_REGEX, appId + "-" + component.id), 
                this.hostAttr = HOST_ATTR.replace(COMPONENT_REGEX, appId + "-" + component.id);
            }
            applyToHost(element) {
                super.setAttribute(element, this.hostAttr, "");
            }
            createElement(parent, name) {
                const el = super.createElement(parent, name);
                return super.setAttribute(el, this.contentAttr, ""), el;
            }
        }
        class ShadowDomRenderer extends DefaultDomRenderer2 {
            constructor(eventManager, sharedStylesHost, hostEl, component) {
                super(eventManager), this.sharedStylesHost = sharedStylesHost, this.hostEl = hostEl, 
                this.component = component, this.shadowRoot = component.encapsulation === _angular_core__WEBPACK_IMPORTED_MODULE_1__.P.ShadowDom ? hostEl.attachShadow({
                    mode: "open"
                }) : hostEl.createShadowRoot(), this.sharedStylesHost.addHost(this.shadowRoot);
                const styles = flattenStyles(component.id, component.styles, []);
                for (let i = 0; i < styles.length; i++) {
                    const styleEl = document.createElement("style");
                    styleEl.textContent = styles[i], this.shadowRoot.appendChild(styleEl);
                }
            }
            nodeOrShadowRoot(node) {
                return node === this.hostEl ? this.shadowRoot : node;
            }
            destroy() {
                this.sharedStylesHost.removeHost(this.shadowRoot);
            }
            appendChild(parent, newChild) {
                return super.appendChild(this.nodeOrShadowRoot(parent), newChild);
            }
            insertBefore(parent, newChild, refChild) {
                return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);
            }
            removeChild(parent, oldChild) {
                return super.removeChild(this.nodeOrShadowRoot(parent), oldChild);
            }
            parentNode(node) {
                return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));
            }
        }
        let DomEventsPlugin = (() => {
            class DomEventsPlugin extends EventManagerPlugin {
                constructor(doc) {
                    super(doc);
                }
                supports(eventName) {
                    return !0;
                }
                addEventListener(element, eventName, handler) {
                    return element.addEventListener(eventName, handler, !1), () => this.removeEventListener(element, eventName, handler);
                }
                removeEventListener(target, eventName, callback) {
                    return target.removeEventListener(eventName, callback);
                }
            }
            return DomEventsPlugin.ɵfac = function(t) {
                return new (t || DomEventsPlugin)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(_angular_common__WEBPACK_IMPORTED_MODULE_0__.d));
            }, DomEventsPlugin.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb({
                token: DomEventsPlugin,
                factory: function(t) {
                    return DomEventsPlugin.ɵfac(t);
                },
                providedIn: null
            }), DomEventsPlugin;
        })(), HammerGestureConfig = (() => {
            class HammerGestureConfig {
                constructor() {
                    this.events = [], this.overrides = {};
                }
                buildHammer(element) {
                    const mc = new Hammer(element, this.options);
                    mc.get("pinch").set({
                        enable: !0
                    }), mc.get("rotate").set({
                        enable: !0
                    });
                    for (const eventName in this.overrides) mc.get(eventName).set(this.overrides[eventName]);
                    return mc;
                }
            }
            return HammerGestureConfig.ɵfac = function(t) {
                return new (t || HammerGestureConfig);
            }, HammerGestureConfig.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb({
                token: HammerGestureConfig,
                factory: function(t) {
                    return HammerGestureConfig.ɵfac(t);
                },
                providedIn: null
            }), HammerGestureConfig;
        })();
        const MODIFIER_KEYS = [ "alt", "control", "meta", "shift" ], DOM_KEY_LOCATION_NUMPAD = 3, _keyMap = {
            "\b": "Backspace",
            "\t": "Tab",
            "": "Delete",
            "": "Escape",
            Del: "Delete",
            Esc: "Escape",
            Left: "ArrowLeft",
            Right: "ArrowRight",
            Up: "ArrowUp",
            Down: "ArrowDown",
            Menu: "ContextMenu",
            Scroll: "ScrollLock",
            Win: "OS"
        }, _chromeNumKeyPadMap = {
            A: "1",
            B: "2",
            C: "3",
            D: "4",
            E: "5",
            F: "6",
            G: "7",
            H: "8",
            I: "9",
            J: "*",
            K: "+",
            M: "-",
            N: ".",
            O: "/",
            "`": "0",
            "": "NumLock"
        }, MODIFIER_KEY_GETTERS = {
            alt: event => event.altKey,
            control: event => event.ctrlKey,
            meta: event => event.metaKey,
            shift: event => event.shiftKey
        };
        let KeyEventsPlugin = (() => {
            class KeyEventsPlugin extends EventManagerPlugin {
                constructor(doc) {
                    super(doc);
                }
                supports(eventName) {
                    return null != KeyEventsPlugin.parseEventName(eventName);
                }
                addEventListener(element, eventName, handler) {
                    const parsedEvent = KeyEventsPlugin.parseEventName(eventName), outsideHandler = KeyEventsPlugin.eventCallback(parsedEvent.fullKey, handler, this.manager.getZone());
                    return this.manager.getZone().runOutsideAngular(() => Object(_angular_common__WEBPACK_IMPORTED_MODULE_0__.v)().onAndCancel(element, parsedEvent.domEventName, outsideHandler));
                }
                static parseEventName(eventName) {
                    const parts = eventName.toLowerCase().split("."), domEventName = parts.shift();
                    if (0 === parts.length || "keydown" !== domEventName && "keyup" !== domEventName) return null;
                    const key = KeyEventsPlugin._normalizeKey(parts.pop());
                    let fullKey = "";
                    if (MODIFIER_KEYS.forEach(modifierName => {
                        const index = parts.indexOf(modifierName);
                        index > -1 && (parts.splice(index, 1), fullKey += modifierName + ".");
                    }), fullKey += key, 0 != parts.length || 0 === key.length) return null;
                    const result = {};
                    return result.domEventName = domEventName, result.fullKey = fullKey, result;
                }
                static getEventFullKey(event) {
                    let fullKey = "", key = function(event) {
                        let key = event.key;
                        if (null == key) {
                            if (null == (key = event.keyIdentifier)) return "Unidentified";
                            key.startsWith("U+") && (key = String.fromCharCode(parseInt(key.substring(2), 16)), 
                            event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key) && (key = _chromeNumKeyPadMap[key]));
                        }
                        return _keyMap[key] || key;
                    }(event);
                    return " " === (key = key.toLowerCase()) ? key = "space" : "." === key && (key = "dot"), 
                    MODIFIER_KEYS.forEach(modifierName => {
                        modifierName != key && (0, MODIFIER_KEY_GETTERS[modifierName])(event) && (fullKey += modifierName + ".");
                    }), fullKey += key;
                }
                static eventCallback(fullKey, handler, zone) {
                    return event => {
                        KeyEventsPlugin.getEventFullKey(event) === fullKey && zone.runGuarded(() => handler(event));
                    };
                }
                static _normalizeKey(keyName) {
                    switch (keyName) {
                      case "esc":
                        return "escape";

                      default:
                        return keyName;
                    }
                }
            }
            return KeyEventsPlugin.ɵfac = function(t) {
                return new (t || KeyEventsPlugin)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(_angular_common__WEBPACK_IMPORTED_MODULE_0__.d));
            }, KeyEventsPlugin.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb({
                token: KeyEventsPlugin,
                factory: function(t) {
                    return KeyEventsPlugin.ɵfac(t);
                },
                providedIn: null
            }), KeyEventsPlugin;
        })(), DomSanitizer = (() => {
            class DomSanitizer {}
            return DomSanitizer.ɵfac = function(t) {
                return new (t || DomSanitizer);
            }, DomSanitizer.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb({
                token: DomSanitizer,
                factory: function(t) {
                    return t ? new (t || DomSanitizer) : _angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(DomSanitizerImpl);
                },
                providedIn: "root"
            }), DomSanitizer.ɵprov = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb)({
                factory: function() {
                    return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb)(DomSanitizerImpl);
                },
                token: DomSanitizer,
                providedIn: "root"
            }), DomSanitizer;
        })();
        function domSanitizerImplFactory(injector) {
            return new DomSanitizerImpl(injector.get(_angular_common__WEBPACK_IMPORTED_MODULE_0__.d));
        }
        let DomSanitizerImpl = (() => {
            class DomSanitizerImpl extends DomSanitizer {
                constructor(_doc) {
                    super(), this._doc = _doc;
                }
                sanitize(ctx, value) {
                    if (null == value) return null;
                    switch (ctx) {
                      case _angular_core__WEBPACK_IMPORTED_MODULE_1__.H.NONE:
                        return value;

                      case _angular_core__WEBPACK_IMPORTED_MODULE_1__.H.HTML:
                        return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.fb)(value, "HTML") ? Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.wb)(value) : Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.cb)(this._doc, String(value));

                      case _angular_core__WEBPACK_IMPORTED_MODULE_1__.H.STYLE:
                        return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.fb)(value, "Style") ? Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.wb)(value) : Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.db)(value);

                      case _angular_core__WEBPACK_IMPORTED_MODULE_1__.H.SCRIPT:
                        if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.fb)(value, "Script")) return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.wb)(value);
                        throw new Error("unsafe value used in a script context");

                      case _angular_core__WEBPACK_IMPORTED_MODULE_1__.H.URL:
                        return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.nb)(value), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.fb)(value, "URL") ? Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.wb)(value) : Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.eb)(String(value));

                      case _angular_core__WEBPACK_IMPORTED_MODULE_1__.H.RESOURCE_URL:
                        if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.fb)(value, "ResourceURL")) return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.wb)(value);
                        throw new Error("unsafe value used in a resource URL context (see http://g.co/ng/security#xss)");

                      default:
                        throw new Error(`Unexpected SecurityContext ${ctx} (see http://g.co/ng/security#xss)`);
                    }
                }
                bypassSecurityTrustHtml(value) {
                    return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.gb)(value);
                }
                bypassSecurityTrustStyle(value) {
                    return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.jb)(value);
                }
                bypassSecurityTrustScript(value) {
                    return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.ib)(value);
                }
                bypassSecurityTrustUrl(value) {
                    return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.kb)(value);
                }
                bypassSecurityTrustResourceUrl(value) {
                    return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.hb)(value);
                }
            }
            return DomSanitizerImpl.ɵfac = function(t) {
                return new (t || DomSanitizerImpl)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(_angular_common__WEBPACK_IMPORTED_MODULE_0__.d));
            }, DomSanitizerImpl.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb({
                token: DomSanitizerImpl,
                factory: function(t) {
                    return t ? new t : domSanitizerImplFactory(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(_angular_core__WEBPACK_IMPORTED_MODULE_1__.q));
                },
                providedIn: "root"
            }), DomSanitizerImpl.ɵprov = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb)({
                factory: function() {
                    return domSanitizerImplFactory(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.n));
                },
                token: DomSanitizerImpl,
                providedIn: "root"
            }), DomSanitizerImpl;
        })();
        const INTERNAL_BROWSER_PLATFORM_PROVIDERS = [ {
            provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.A,
            useValue: _angular_common__WEBPACK_IMPORTED_MODULE_0__.u
        }, {
            provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.B,
            useValue: function() {
                BrowserDomAdapter.makeCurrent(), BrowserGetTestability.init();
            },
            multi: !0
        }, {
            provide: _angular_common__WEBPACK_IMPORTED_MODULE_0__.d,
            useFactory: function() {
                return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.ub)(document), document;
            },
            deps: []
        } ], platformBrowser = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.R)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.X, "browser", INTERNAL_BROWSER_PLATFORM_PROVIDERS), BROWSER_MODULE_PROVIDERS = [ [], {
            provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ab,
            useValue: "root"
        }, {
            provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.l,
            useFactory: function() {
                return new _angular_core__WEBPACK_IMPORTED_MODULE_1__.l;
            },
            deps: []
        }, {
            provide: EVENT_MANAGER_PLUGINS,
            useClass: DomEventsPlugin,
            multi: !0,
            deps: [ _angular_common__WEBPACK_IMPORTED_MODULE_0__.d, _angular_core__WEBPACK_IMPORTED_MODULE_1__.y, _angular_core__WEBPACK_IMPORTED_MODULE_1__.A ]
        }, {
            provide: EVENT_MANAGER_PLUGINS,
            useClass: KeyEventsPlugin,
            multi: !0,
            deps: [ _angular_common__WEBPACK_IMPORTED_MODULE_0__.d ]
        }, [], {
            provide: DomRendererFactory2,
            useClass: DomRendererFactory2,
            deps: [ EventManager, DomSharedStylesHost, _angular_core__WEBPACK_IMPORTED_MODULE_1__.c ]
        }, {
            provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.E,
            useExisting: DomRendererFactory2
        }, {
            provide: SharedStylesHost,
            useExisting: DomSharedStylesHost
        }, {
            provide: DomSharedStylesHost,
            useClass: DomSharedStylesHost,
            deps: [ _angular_common__WEBPACK_IMPORTED_MODULE_0__.d ]
        }, {
            provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.M,
            useClass: _angular_core__WEBPACK_IMPORTED_MODULE_1__.M,
            deps: [ _angular_core__WEBPACK_IMPORTED_MODULE_1__.y ]
        }, {
            provide: EventManager,
            useClass: EventManager,
            deps: [ EVENT_MANAGER_PLUGINS, _angular_core__WEBPACK_IMPORTED_MODULE_1__.y ]
        }, [] ];
        let BrowserModule = (() => {
            class BrowserModule {
                constructor(parentModule) {
                    if (parentModule) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.");
                }
                static withServerTransition(params) {
                    return {
                        ngModule: BrowserModule,
                        providers: [ {
                            provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.c,
                            useValue: params.appId
                        }, {
                            provide: TRANSITION_ID,
                            useExisting: _angular_core__WEBPACK_IMPORTED_MODULE_1__.c
                        }, SERVER_TRANSITION_PROVIDERS ]
                    };
                }
            }
            return BrowserModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Nb({
                type: BrowserModule
            }), BrowserModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Mb({
                factory: function(t) {
                    return new (t || BrowserModule)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(BrowserModule, 12));
                },
                providers: BROWSER_MODULE_PROVIDERS,
                imports: [ _angular_common__WEBPACK_IMPORTED_MODULE_0__.c, _angular_core__WEBPACK_IMPORTED_MODULE_1__.f ]
            }), BrowserModule;
        })();
        function createMeta() {
            return new Meta(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb)(_angular_common__WEBPACK_IMPORTED_MODULE_0__.d));
        }
        let Meta = (() => {
            class Meta {
                constructor(_doc) {
                    this._doc = _doc, this._dom = Object(_angular_common__WEBPACK_IMPORTED_MODULE_0__.v)();
                }
                addTag(tag, forceCreation = !1) {
                    return tag ? this._getOrCreateElement(tag, forceCreation) : null;
                }
                addTags(tags, forceCreation = !1) {
                    return tags ? tags.reduce((result, tag) => (tag && result.push(this._getOrCreateElement(tag, forceCreation)), 
                    result), []) : [];
                }
                getTag(attrSelector) {
                    return attrSelector && this._doc.querySelector(`meta[${attrSelector}]`) || null;
                }
                getTags(attrSelector) {
                    if (!attrSelector) return [];
                    const list = this._doc.querySelectorAll(`meta[${attrSelector}]`);
                    return list ? [].slice.call(list) : [];
                }
                updateTag(tag, selector) {
                    if (!tag) return null;
                    selector = selector || this._parseSelector(tag);
                    const meta = this.getTag(selector);
                    return meta ? this._setMetaElementAttributes(tag, meta) : this._getOrCreateElement(tag, !0);
                }
                removeTag(attrSelector) {
                    this.removeTagElement(this.getTag(attrSelector));
                }
                removeTagElement(meta) {
                    meta && this._dom.remove(meta);
                }
                _getOrCreateElement(meta, forceCreation = !1) {
                    if (!forceCreation) {
                        const selector = this._parseSelector(meta), elem = this.getTag(selector);
                        if (elem && this._containsAttributes(meta, elem)) return elem;
                    }
                    const element = this._dom.createElement("meta");
                    return this._setMetaElementAttributes(meta, element), this._doc.getElementsByTagName("head")[0].appendChild(element), 
                    element;
                }
                _setMetaElementAttributes(tag, el) {
                    return Object.keys(tag).forEach(prop => el.setAttribute(prop, tag[prop])), el;
                }
                _parseSelector(tag) {
                    const attr = tag.name ? "name" : "property";
                    return `${attr}="${tag[attr]}"`;
                }
                _containsAttributes(tag, elem) {
                    return Object.keys(tag).every(key => elem.getAttribute(key) === tag[key]);
                }
            }
            return Meta.ɵfac = function(t) {
                return new (t || Meta)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(_angular_common__WEBPACK_IMPORTED_MODULE_0__.d));
            }, Meta.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb({
                token: Meta,
                factory: function(t) {
                    return t ? new t : createMeta();
                },
                providedIn: "root"
            }), Meta.ɵprov = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb)({
                factory: createMeta,
                token: Meta,
                providedIn: "root"
            }), Meta;
        })();
        function createTitle() {
            return new Title(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb)(_angular_common__WEBPACK_IMPORTED_MODULE_0__.d));
        }
        let Title = (() => {
            class Title {
                constructor(_doc) {
                    this._doc = _doc;
                }
                getTitle() {
                    return this._doc.title;
                }
                setTitle(newTitle) {
                    this._doc.title = newTitle || "";
                }
            }
            return Title.ɵfac = function(t) {
                return new (t || Title)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(_angular_common__WEBPACK_IMPORTED_MODULE_0__.d));
            }, Title.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb({
                token: Title,
                factory: function(t) {
                    return t ? new t : createTitle();
                },
                providedIn: "root"
            }), Title.ɵprov = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb)({
                factory: createTitle,
                token: Title,
                providedIn: "root"
            }), Title;
        })();
        "undefined" != typeof window && window;
    },
    jn67: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "e", (function() {
            return FILE_NOT_FOUND_ID;
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return FETCHING_ERROR_ID;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return CONTENT_URL_PREFIX;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return DOC_CONTENT_URL_PREFIX;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return DocumentService;
        }));
        var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("NHP+"), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("LRne"), rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("eIep"), rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("vkgz"), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("JIr8"), _angular_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("fXoL"), app_shared_logger_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("vHPH"), _angular_common_http__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("tk/3"), app_shared_location_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("/lUL");
        const FILE_NOT_FOUND_ID = "file-not-found", FETCHING_ERROR_ID = "fetching-error", CONTENT_URL_PREFIX = "generated/", DOC_CONTENT_URL_PREFIX = CONTENT_URL_PREFIX + "docs/", FETCHING_ERROR_CONTENTS = path => `\n  <div class="nf-container l-flex-wrap flex-center">\n    <div class="nf-icon material-icons">error_outline</div>\n    <div class="nf-response l-flex-wrap">\n      <h1 class="no-toc">Request for document failed.</h1>\n      <p>\n        We are unable to retrieve the "${path}" page at this time.\n        Please check your connection and try again later.\n      </p>\n    </div>\n  </div>\n`;
        let DocumentService = (() => {
            class DocumentService {
                constructor(logger, http, location) {
                    this.logger = logger, this.http = http, this.cache = new Map, this.currentDocument = location.currentPath.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(path => this.getDocument(path)));
                }
                getDocument(url) {
                    const id = url || "index";
                    return this.logger.log("getting document", id), this.cache.has(id) || this.cache.set(id, this.fetchDocument(id)), 
                    this.cache.get(id);
                }
                fetchDocument(id) {
                    const requestPath = `${DOC_CONTENT_URL_PREFIX}${id}.json`, subject = new rxjs__WEBPACK_IMPORTED_MODULE_0__.a;
                    return this.logger.log("fetching document from", requestPath), this.http.get(requestPath, {
                        responseType: "json"
                    }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(data => {
                        if (!data || "object" != typeof data) throw this.logger.log("received invalid data:", data), 
                        Error("Invalid data");
                    }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)(error => 404 === error.status ? this.getFileNotFoundDoc(id) : this.getErrorDoc(id, error))).subscribe(subject), 
                    subject.asObservable();
                }
                getFileNotFoundDoc(id) {
                    return id !== FILE_NOT_FOUND_ID ? (this.logger.error(new Error(`Document file not found at '${id}'`)), 
                    this.getDocument(FILE_NOT_FOUND_ID)) : Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)({
                        id: FILE_NOT_FOUND_ID,
                        contents: "Document not found"
                    });
                }
                getErrorDoc(id, error) {
                    return this.logger.error(new Error(`Error fetching document '${id}': (${error.message})`)), 
                    this.cache.delete(id), Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)({
                        id: FETCHING_ERROR_ID,
                        contents: FETCHING_ERROR_CONTENTS(id)
                    });
                }
            }
            return DocumentService.ɵfac = function(t) {
                return new (t || DocumentService)(_angular_core__WEBPACK_IMPORTED_MODULE_5__.Zb(app_shared_logger_service__WEBPACK_IMPORTED_MODULE_6__.a), _angular_core__WEBPACK_IMPORTED_MODULE_5__.Zb(_angular_common_http__WEBPACK_IMPORTED_MODULE_7__.a), _angular_core__WEBPACK_IMPORTED_MODULE_5__.Zb(app_shared_location_service__WEBPACK_IMPORTED_MODULE_8__.a));
            }, DocumentService.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_5__.Lb({
                token: DocumentService,
                factory: function(t) {
                    return DocumentService.ɵfac(t);
                },
                providedIn: null
            }), DocumentService;
        })();
    },
    jtHE: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        var Subject = __webpack_require__("XNiG"), AsyncAction = __webpack_require__("3N8a");
        class QueueAction_QueueAction extends AsyncAction.a {
            constructor(scheduler, work) {
                super(scheduler, work), this.scheduler = scheduler, this.work = work;
            }
            schedule(state, delay = 0) {
                return delay > 0 ? super.schedule(state, delay) : (this.delay = delay, this.state = state, 
                this.scheduler.flush(this), this);
            }
            execute(state, delay) {
                return delay > 0 || this.closed ? super.execute(state, delay) : this._execute(state, delay);
            }
            requestAsyncId(scheduler, id, delay = 0) {
                return null !== delay && delay > 0 || null === delay && this.delay > 0 ? super.requestAsyncId(scheduler, id, delay) : scheduler.flush(this);
            }
        }
        var AsyncScheduler = __webpack_require__("IjjT");
        class QueueScheduler_QueueScheduler extends AsyncScheduler.a {}
        const queue = new QueueScheduler_QueueScheduler(QueueAction_QueueAction);
        var Subscription = __webpack_require__("quSY"), observeOn = __webpack_require__("pxpQ"), ObjectUnsubscribedError = __webpack_require__("9ppp"), SubjectSubscription = __webpack_require__("Ylt2");
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return ReplaySubject_ReplaySubject;
        }));
        class ReplaySubject_ReplaySubject extends Subject.a {
            constructor(bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY, scheduler) {
                super(), this.scheduler = scheduler, this._events = [], this._infiniteTimeWindow = !1, 
                this._bufferSize = bufferSize < 1 ? 1 : bufferSize, this._windowTime = windowTime < 1 ? 1 : windowTime, 
                windowTime === Number.POSITIVE_INFINITY ? (this._infiniteTimeWindow = !0, this.next = this.nextInfiniteTimeWindow) : this.next = this.nextTimeWindow;
            }
            nextInfiniteTimeWindow(value) {
                const _events = this._events;
                _events.push(value), _events.length > this._bufferSize && _events.shift(), super.next(value);
            }
            nextTimeWindow(value) {
                this._events.push(new ReplayEvent(this._getNow(), value)), this._trimBufferThenGetEvents(), 
                super.next(value);
            }
            _subscribe(subscriber) {
                const _infiniteTimeWindow = this._infiniteTimeWindow, _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents(), scheduler = this.scheduler, len = _events.length;
                let subscription;
                if (this.closed) throw new ObjectUnsubscribedError.a;
                if (this.isStopped || this.hasError ? subscription = Subscription.a.EMPTY : (this.observers.push(subscriber), 
                subscription = new SubjectSubscription.a(this, subscriber)), scheduler && subscriber.add(subscriber = new observeOn.a(subscriber, scheduler)), 
                _infiniteTimeWindow) for (let i = 0; i < len && !subscriber.closed; i++) subscriber.next(_events[i]); else for (let i = 0; i < len && !subscriber.closed; i++) subscriber.next(_events[i].value);
                return this.hasError ? subscriber.error(this.thrownError) : this.isStopped && subscriber.complete(), 
                subscription;
            }
            _getNow() {
                return (this.scheduler || queue).now();
            }
            _trimBufferThenGetEvents() {
                const now = this._getNow(), _bufferSize = this._bufferSize, _windowTime = this._windowTime, _events = this._events, eventsCount = _events.length;
                let spliceCount = 0;
                for (;spliceCount < eventsCount && !(now - _events[spliceCount].time < _windowTime); ) spliceCount++;
                return eventsCount > _bufferSize && (spliceCount = Math.max(spliceCount, eventsCount - _bufferSize)), 
                spliceCount > 0 && _events.splice(0, spliceCount), _events;
            }
        }
        class ReplayEvent {
            constructor(time, value) {
                this.time = time, this.value = value;
            }
        }
    },
    kJWO: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return observable;
        }));
        const observable = (() => "function" == typeof Symbol && Symbol.observable || "@@observable")();
    },
    l7GE: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return OuterSubscriber;
        }));
        var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7o/Q");
        class OuterSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
            notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue);
            }
            notifyError(error, innerSub) {
                this.destination.error(error);
            }
            notifyComplete(innerSub) {
                this.destination.complete();
            }
        }
    },
    lJxs: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return map;
        }));
        var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7o/Q");
        function map(project, thisArg) {
            return function(source) {
                if ("function" != typeof project) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
                return source.lift(new MapOperator(project, thisArg));
            };
        }
        class MapOperator {
            constructor(project, thisArg) {
                this.project = project, this.thisArg = thisArg;
            }
            call(subscriber, source) {
                return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
            }
        }
        class MapSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(destination, project, thisArg) {
                super(destination), this.project = project, this.count = 0, this.thisArg = thisArg || this;
            }
            _next(value) {
                let result;
                try {
                    result = this.project.call(this.thisArg, value, this.count++);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.next(result);
            }
        }
    },
    m7ka: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var common = __webpack_require__("ofXK"), document_service = __webpack_require__("jn67"), core = __webpack_require__("fXoL");
        function getAttrValue(attrs, attr) {
            const key = "string" == typeof attr ? attr : attr.find(a => attrs.hasOwnProperty(a.toLowerCase()));
            return void 0 === key ? void 0 : attrs[key.toLowerCase()];
        }
        function boolFromValue(attrValue, def = !1) {
            return void 0 === attrValue ? def : "false" !== attrValue.trim();
        }
        const _c0 = [ "content" ];
        function LiveExampleComponent_span_4_p_3_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "p"), core.Ec(1, " You can also "), core.Vb(2, "a", 8), 
            core.Ec(3, "download this example"), core.Tb(), core.Ec(4, ". "), core.Tb()), 2 & rf) {
                const ctx_r118 = core.gc(2);
                core.Ab(2), core.lc("href", ctx_r118.zip, core.wc);
            }
        }
        function LiveExampleComponent_span_4_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "span"), core.Vb(1, "div", 5), core.Qb(2, "aio-embedded-stackblitz", 6), 
            core.Tb(), core.Cc(3, LiveExampleComponent_span_4_p_3_Template, 5, 1, "p", 7), core.Tb()), 
            2 & rf) {
                const ctx_r115 = core.gc();
                core.Ab(1), core.mc("title", ctx_r115.title), core.Ab(1), core.lc("src", ctx_r115.stackblitz), 
                core.Ab(1), core.lc("ngIf", ctx_r115.enableDownload);
            }
        }
        function LiveExampleComponent_span_5_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "span"), core.Vb(1, "a", 9), core.Ec(2), core.Tb(), core.Tb()), 
            2 & rf) {
                const ctx_r116 = core.gc();
                core.Ab(1), core.mc("title", ctx_r116.title), core.lc("href", ctx_r116.zip, core.wc), 
                core.Ab(1), core.Fc(ctx_r116.title);
            }
        }
        function LiveExampleComponent_span_6_span_3_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "span"), core.Ec(1, " / "), core.Vb(2, "a", 8), core.Ec(3, "download example"), 
            core.Tb(), core.Tb()), 2 & rf) {
                const ctx_r119 = core.gc(2);
                core.Ab(2), core.lc("href", ctx_r119.zip, core.wc);
            }
        }
        function LiveExampleComponent_span_6_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "span"), core.Vb(1, "a", 10), core.Ec(2), core.Tb(), core.Cc(3, LiveExampleComponent_span_6_span_3_Template, 4, 1, "span", 7), 
            core.Tb()), 2 & rf) {
                const ctx_r117 = core.gc();
                core.Ab(1), core.mc("title", ctx_r117.title), core.lc("href", ctx_r117.stackblitz, core.wc), 
                core.Ab(1), core.Fc(ctx_r117.title), core.Ab(1), core.lc("ngIf", ctx_r117.enableDownload);
            }
        }
        const _c1 = [ "*" ], _c2 = [ "iframe" ], LIVE_EXAMPLE_BASE = document_service.a + "live-examples/", ZIP_BASE = document_service.a + "zips/";
        let live_example_component_LiveExampleComponent = (() => {
            class LiveExampleComponent {
                constructor(elementRef, location) {
                    const attrs = function(el) {
                        const attrs = el instanceof core.k ? el.nativeElement.attributes : el.attributes, attrMap = {};
                        for (const attr of attrs) attrMap[attr.name.toLowerCase()] = attr.value;
                        return attrMap;
                    }(elementRef), exampleDir = this.getExampleDir(attrs, location.path(!1)), stackblitzName = this.getStackblitzName(attrs);
                    this.mode = this.getMode(attrs), this.enableDownload = this.getEnableDownload(attrs), 
                    this.stackblitz = this.getStackblitz(exampleDir, stackblitzName, "embedded" === this.mode), 
                    this.zip = this.getZip(exampleDir, stackblitzName), this.title = this.getTitle(attrs);
                }
                ngAfterContentInit() {
                    const textContent = this.content.nativeElement.textContent.trim();
                    textContent && (this.title = textContent);
                }
                getEnableDownload(attrs) {
                    return !boolFromValue(getAttrValue(attrs, "noDownload"));
                }
                getExampleDir(attrs, path) {
                    let exampleDir = getAttrValue(attrs, "name");
                    if (!exampleDir) {
                        const match = path.match(/[^/?#]+(?=\/?(?:\?|#|$))/);
                        exampleDir = match ? match[0] : "index";
                    }
                    return exampleDir.trim();
                }
                getMode(attrs) {
                    const downloadOnly = boolFromValue(getAttrValue(attrs, "downloadOnly")), isEmbedded = boolFromValue(getAttrValue(attrs, "embedded"));
                    return downloadOnly ? "downloadOnly" : isEmbedded ? "embedded" : "default";
                }
                getStackblitz(exampleDir, stackblitzName, isEmbedded) {
                    return `${LIVE_EXAMPLE_BASE}${exampleDir}/${stackblitzName}stackblitz.html${isEmbedded ? "?ctl=1" : ""}`;
                }
                getStackblitzName(attrs) {
                    const attrValue = (getAttrValue(attrs, "stackblitz") || "").trim();
                    return attrValue && `${attrValue}.`;
                }
                getTitle(attrs) {
                    return (getAttrValue(attrs, "title") || "live example").trim();
                }
                getZip(exampleDir, stackblitzName) {
                    const zipName = exampleDir.split("/")[0];
                    return `${ZIP_BASE}${exampleDir}/${stackblitzName}${zipName}.zip`;
                }
            }
            return LiveExampleComponent.ɵfac = function(t) {
                return new (t || LiveExampleComponent)(core.Pb(core.k), core.Pb(common.g));
            }, LiveExampleComponent.ɵcmp = core.Jb({
                type: LiveExampleComponent,
                selectors: [ [ "live-example" ] ],
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && core.yc(_c0, !0), 2 & rf && core.qc(_t = core.dc()) && (ctx.content = _t.first);
                },
                ngContentSelectors: _c1,
                decls: 7,
                vars: 3,
                consts: [ [ 2, "display", "none" ], [ "content", "" ], [ 3, "ngSwitch" ], [ 4, "ngSwitchCase" ], [ 4, "ngSwitchDefault" ], [ 3, "title" ], [ 3, "src" ], [ 4, "ngIf" ], [ "download", "", "title", "Download example", 3, "href" ], [ "download", "", 3, "href", "title" ], [ "target", "_blank", 3, "href", "title" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.kc(), core.Vb(0, "span", 0, 1), core.jc(2), core.Tb(), core.Vb(3, "span", 2), 
                    core.Cc(4, LiveExampleComponent_span_4_Template, 4, 3, "span", 3), core.Cc(5, LiveExampleComponent_span_5_Template, 3, 3, "span", 3), 
                    core.Cc(6, LiveExampleComponent_span_6_Template, 4, 4, "span", 4), core.Tb()), 2 & rf && (core.Ab(3), 
                    core.lc("ngSwitch", ctx.mode), core.Ab(1), core.lc("ngSwitchCase", "embedded"), 
                    core.Ab(1), core.lc("ngSwitchCase", "downloadOnly"));
                },
                directives: function() {
                    return [ common.m, common.n, common.o, live_example_component_EmbeddedStackblitzComponent, common.k ];
                },
                encapsulation: 2
            }), LiveExampleComponent;
        })(), live_example_component_EmbeddedStackblitzComponent = (() => {
            class EmbeddedStackblitzComponent {
                ngAfterViewInit() {
                    this.iframe && (this.iframe.nativeElement.src = this.src);
                }
            }
            return EmbeddedStackblitzComponent.ɵfac = function(t) {
                return new (t || EmbeddedStackblitzComponent);
            }, EmbeddedStackblitzComponent.ɵcmp = core.Jb({
                type: EmbeddedStackblitzComponent,
                selectors: [ [ "aio-embedded-stackblitz" ] ],
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && core.yc(_c2, !0), 2 & rf && core.qc(_t = core.dc()) && (ctx.iframe = _t.first);
                },
                inputs: {
                    src: "src"
                },
                decls: 2,
                vars: 0,
                consts: [ [ "frameborder", "0", "width", "100%", "height", "100%" ], [ "iframe", "" ] ],
                template: function(rf, ctx) {
                    1 & rf && core.Qb(0, "iframe", 0, 1);
                },
                styles: [ "iframe[_ngcontent-%COMP%] { min-height: 400px; }" ]
            }), EmbeddedStackblitzComponent;
        })();
        __webpack_require__.d(__webpack_exports__, "LiveExampleModule", (function() {
            return live_example_module_LiveExampleModule;
        }));
        let live_example_module_LiveExampleModule = (() => {
            class LiveExampleModule {
                constructor() {
                    this.customElementComponent = live_example_component_LiveExampleComponent;
                }
            }
            return LiveExampleModule.ɵmod = core.Nb({
                type: LiveExampleModule
            }), LiveExampleModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || LiveExampleModule);
                },
                imports: [ [ common.c ] ]
            }), LiveExampleModule;
        })();
    },
    mCNh: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return pipe;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return pipeFromArray;
        }));
        var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("KqfI");
        function pipe(...fns) {
            return pipeFromArray(fns);
        }
        function pipeFromArray(fns) {
            return fns ? 1 === fns.length ? fns[0] : function(input) {
                return fns.reduce((prev, fn) => fn(prev), input);
            } : _noop__WEBPACK_IMPORTED_MODULE_0__.a;
        }
    },
    n6bG: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        function isFunction(x) {
            return "function" == typeof x;
        }
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return isFunction;
        }));
    },
    nLfN: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Platform;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return PlatformModule;
        })), __webpack_require__.d(__webpack_exports__, "e", (function() {
            return normalizePassiveListenerOptions;
        })), __webpack_require__.d(__webpack_exports__, "f", (function() {
            return supportsScrollBehavior;
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return getRtlScrollAxisType;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return RtlScrollAxisType;
        }));
        var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("fXoL"), _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("ofXK");
        let hasV8BreakIterator;
        try {
            hasV8BreakIterator = "undefined" != typeof Intl && Intl.v8BreakIterator;
        } catch (_a) {
            hasV8BreakIterator = !1;
        }
        let supportsPassiveEvents, Platform = (() => {
            class Platform {
                constructor(_platformId) {
                    this._platformId = _platformId, this.isBrowser = this._platformId ? Object(_angular_common__WEBPACK_IMPORTED_MODULE_1__.s)(this._platformId) : "object" == typeof document && !!document, 
                    this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), 
                    this.BLINK = this.isBrowser && !(!window.chrome && !hasV8BreakIterator) && "undefined" != typeof CSS && !this.EDGE && !this.TRIDENT, 
                    this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, 
                    this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), 
                    this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), 
                    this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, 
                    this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
                }
            }
            return Platform.ɵfac = function(t) {
                return new (t || Platform)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.A, 8));
            }, Platform.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb({
                token: Platform,
                factory: function(t) {
                    return Platform.ɵfac(t);
                },
                providedIn: "root"
            }), Platform.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb)({
                factory: function() {
                    return new Platform(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.A, 8));
                },
                token: Platform,
                providedIn: "root"
            }), Platform;
        })(), PlatformModule = (() => {
            class PlatformModule {}
            return PlatformModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Nb({
                type: PlatformModule
            }), PlatformModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Mb({
                factory: function(t) {
                    return new (t || PlatformModule);
                }
            }), PlatformModule;
        })();
        function normalizePassiveListenerOptions(options) {
            return function() {
                if (null == supportsPassiveEvents && "undefined" != typeof window) try {
                    window.addEventListener("test", null, Object.defineProperty({}, "passive", {
                        get: () => supportsPassiveEvents = !0
                    }));
                } finally {
                    supportsPassiveEvents = supportsPassiveEvents || !1;
                }
                return supportsPassiveEvents;
            }() ? options : !!options.capture;
        }
        const RtlScrollAxisType = function() {
            var RtlScrollAxisType = {
                NORMAL: 0,
                NEGATED: 1,
                INVERTED: 2
            };
            return RtlScrollAxisType[RtlScrollAxisType.NORMAL] = "NORMAL", RtlScrollAxisType[RtlScrollAxisType.NEGATED] = "NEGATED", 
            RtlScrollAxisType[RtlScrollAxisType.INVERTED] = "INVERTED", RtlScrollAxisType;
        }();
        let rtlScrollAxisType;
        function supportsScrollBehavior() {
            return !!("object" == typeof document && "scrollBehavior" in document.documentElement.style);
        }
        function getRtlScrollAxisType() {
            if ("object" != typeof document || !document) return RtlScrollAxisType.NORMAL;
            if (!rtlScrollAxisType) {
                const scrollContainer = document.createElement("div"), containerStyle = scrollContainer.style;
                scrollContainer.dir = "rtl", containerStyle.height = "1px", containerStyle.width = "1px", 
                containerStyle.overflow = "auto", containerStyle.visibility = "hidden", containerStyle.pointerEvents = "none", 
                containerStyle.position = "absolute";
                const content = document.createElement("div"), contentStyle = content.style;
                contentStyle.width = "2px", contentStyle.height = "1px", scrollContainer.appendChild(content), 
                document.body.appendChild(scrollContainer), rtlScrollAxisType = RtlScrollAxisType.NORMAL, 
                0 === scrollContainer.scrollLeft && (scrollContainer.scrollLeft = 1, rtlScrollAxisType = 0 === scrollContainer.scrollLeft ? RtlScrollAxisType.NEGATED : RtlScrollAxisType.INVERTED), 
                scrollContainer.parentNode.removeChild(scrollContainer);
            }
            return rtlScrollAxisType;
        }
    },
    nYR2: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return finalize;
        }));
        var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7o/Q"), _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("quSY");
        function finalize(callback) {
            return source => source.lift(new FinallyOperator(callback));
        }
        class FinallyOperator {
            constructor(callback) {
                this.callback = callback;
            }
            call(subscriber, source) {
                return source.subscribe(new FinallySubscriber(subscriber, this.callback));
            }
        }
        class FinallySubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(destination, callback) {
                super(destination), this.add(new _Subscription__WEBPACK_IMPORTED_MODULE_1__.a(callback));
            }
        }
    },
    ngJS: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return subscribeToArray;
        }));
        const subscribeToArray = array => subscriber => {
            for (let i = 0, len = array.length; i < len && !subscriber.closed; i++) subscriber.next(array[i]);
            subscriber.complete();
        };
    },
    oB13: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        var Subject = __webpack_require__("XNiG"), Observable = __webpack_require__("HDdC"), Subscription = (__webpack_require__("7o/Q"), 
        __webpack_require__("quSY")), refCount = __webpack_require__("x+ZX");
        class ConnectableObservable_ConnectableObservable extends Observable.a {
            constructor(source, subjectFactory) {
                super(), this.source = source, this.subjectFactory = subjectFactory, this._refCount = 0, 
                this._isComplete = !1;
            }
            _subscribe(subscriber) {
                return this.getSubject().subscribe(subscriber);
            }
            getSubject() {
                const subject = this._subject;
                return subject && !subject.isStopped || (this._subject = this.subjectFactory()), 
                this._subject;
            }
            connect() {
                let connection = this._connection;
                return connection || (this._isComplete = !1, (connection = this._connection = new Subscription.a).add(this.source.subscribe(new ConnectableObservable_ConnectableSubscriber(this.getSubject(), this))), 
                connection.closed && (this._connection = null, connection = Subscription.a.EMPTY)), 
                connection;
            }
            refCount() {
                return Object(refCount.a)()(this);
            }
        }
        const connectableObservableDescriptor = (() => {
            const connectableProto = ConnectableObservable_ConnectableObservable.prototype;
            return {
                operator: {
                    value: null
                },
                _refCount: {
                    value: 0,
                    writable: !0
                },
                _subject: {
                    value: null,
                    writable: !0
                },
                _connection: {
                    value: null,
                    writable: !0
                },
                _subscribe: {
                    value: connectableProto._subscribe
                },
                _isComplete: {
                    value: connectableProto._isComplete,
                    writable: !0
                },
                getSubject: {
                    value: connectableProto.getSubject
                },
                connect: {
                    value: connectableProto.connect
                },
                refCount: {
                    value: connectableProto.refCount
                }
            };
        })();
        class ConnectableObservable_ConnectableSubscriber extends Subject.b {
            constructor(destination, connectable) {
                super(destination), this.connectable = connectable;
            }
            _error(err) {
                this._unsubscribe(), super._error(err);
            }
            _complete() {
                this.connectable._isComplete = !0, this._unsubscribe(), super._complete();
            }
            _unsubscribe() {
                const connectable = this.connectable;
                if (connectable) {
                    this.connectable = null;
                    const connection = connectable._connection;
                    connectable._refCount = 0, connectable._subject = null, connectable._connection = null, 
                    connection && connection.unsubscribe();
                }
            }
        }
        function multicast(subjectOrSubjectFactory, selector) {
            return function(source) {
                let subjectFactory;
                if (subjectFactory = "function" == typeof subjectOrSubjectFactory ? subjectOrSubjectFactory : function() {
                    return subjectOrSubjectFactory;
                }, "function" == typeof selector) return source.lift(new MulticastOperator(subjectFactory, selector));
                const connectable = Object.create(source, connectableObservableDescriptor);
                return connectable.source = source, connectable.subjectFactory = subjectFactory, 
                connectable;
            };
        }
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return multicast;
        }));
        class MulticastOperator {
            constructor(subjectFactory, selector) {
                this.subjectFactory = subjectFactory, this.selector = selector;
            }
            call(subscriber, source) {
                const {selector: selector} = this, subject = this.subjectFactory(), subscription = selector(subject).subscribe(subscriber);
                return subscription.add(source.subscribe(subject)), subscription;
            }
        }
    },
    ofXK: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return APP_BASE_HREF;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return AsyncPipe;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return CommonModule;
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return DOCUMENT;
        })), __webpack_require__.d(__webpack_exports__, "e", (function() {
            return HashLocationStrategy;
        })), __webpack_require__.d(__webpack_exports__, "f", (function() {
            return LOCATION_INITIALIZED;
        })), __webpack_require__.d(__webpack_exports__, "g", (function() {
            return Location;
        })), __webpack_require__.d(__webpack_exports__, "h", (function() {
            return LocationStrategy;
        })), __webpack_require__.d(__webpack_exports__, "i", (function() {
            return NgClass;
        })), __webpack_require__.d(__webpack_exports__, "j", (function() {
            return NgForOf;
        })), __webpack_require__.d(__webpack_exports__, "k", (function() {
            return NgIf;
        })), __webpack_require__.d(__webpack_exports__, "l", (function() {
            return NgStyle;
        })), __webpack_require__.d(__webpack_exports__, "m", (function() {
            return NgSwitch;
        })), __webpack_require__.d(__webpack_exports__, "n", (function() {
            return NgSwitchCase;
        })), __webpack_require__.d(__webpack_exports__, "o", (function() {
            return NgSwitchDefault;
        })), __webpack_require__.d(__webpack_exports__, "p", (function() {
            return PathLocationStrategy;
        })), __webpack_require__.d(__webpack_exports__, "q", (function() {
            return PlatformLocation;
        })), __webpack_require__.d(__webpack_exports__, "r", (function() {
            return ViewportScroller;
        })), __webpack_require__.d(__webpack_exports__, "s", (function() {
            return isPlatformBrowser;
        })), __webpack_require__.d(__webpack_exports__, "t", (function() {
            return DomAdapter;
        })), __webpack_require__.d(__webpack_exports__, "u", (function() {
            return PLATFORM_BROWSER_ID;
        })), __webpack_require__.d(__webpack_exports__, "v", (function() {
            return getDOM;
        })), __webpack_require__.d(__webpack_exports__, "w", (function() {
            return parseCookieValue;
        })), __webpack_require__.d(__webpack_exports__, "x", (function() {
            return setRootDomAdapter;
        }));
        var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("fXoL");
        class StylingDiffer {
            constructor(_name, _options) {
                this._name = _name, this._options = _options, this.value = null, this._lastSetValue = null, 
                this._lastSetValueType = 0, this._lastSetValueIdentityChange = !1;
            }
            setValue(value) {
                if (Array.isArray(value)) this._lastSetValueType = 4; else if (value instanceof Set) this._lastSetValueType = 8; else if (value && "string" == typeof value) {
                    if (!(4 & this._options)) throw new Error(this._name + " string values are not allowed");
                    this._lastSetValueType = 1;
                } else this._lastSetValueType = value ? 2 : 0;
                this._lastSetValueIdentityChange = !0, this._lastSetValue = value || null;
            }
            hasValueChanged() {
                let valueHasChanged = this._lastSetValueIdentityChange;
                if (!(valueHasChanged || 14 & this._lastSetValueType)) return !1;
                let finalValue = null;
                const trimValues = !!(1 & this._options), parseOutUnits = !!(8 & this._options), allowSubKeys = !!(2 & this._options);
                switch (this._lastSetValueType) {
                  case 1:
                    const tokens = this._lastSetValue.split(/\s+/g);
                    16 & this._options ? (finalValue = {}, tokens.forEach((token, i) => finalValue[token] = !0)) : finalValue = tokens.reduce((str, token, i) => str + (i ? " " : "") + token);
                    break;

                  case 2:
                    const map = this._lastSetValue, keys = Object.keys(map);
                    valueHasChanged || (valueHasChanged = !this.value || function(keys, a, b) {
                        const newKeys = keys;
                        if (!arrayEqualsArray(Object.keys(a), newKeys)) return !0;
                        for (let i = 0; i < newKeys.length; i++) {
                            const key = newKeys[i];
                            if (a[key] !== b[key]) return !0;
                        }
                        return !1;
                    }(keys, this.value, map)), valueHasChanged && (finalValue = bulidMapFromValues(this._name, trimValues, parseOutUnits, allowSubKeys, map, keys));
                    break;

                  case 4:
                  case 8:
                    const values = Array.from(this._lastSetValue);
                    valueHasChanged || (valueHasChanged = !arrayEqualsArray(Object.keys(this.value), values)), 
                    valueHasChanged && (finalValue = bulidMapFromValues(this._name, trimValues, parseOutUnits, allowSubKeys, values));
                    break;

                  default:
                    finalValue = null;
                }
                return valueHasChanged && (this.value = finalValue), valueHasChanged;
            }
        }
        function bulidMapFromValues(errorPrefix, trim, parseOutUnits, allowSubKeys, values, keys) {
            const map = {};
            if (keys) for (let i = 0; i < keys.length; i++) {
                let key = keys[i];
                setMapValues(map, key = trim ? key.trim() : key, values[key], parseOutUnits, allowSubKeys);
            } else for (let i = 0; i < values.length; i++) {
                let value = values[i];
                assertValidValue(errorPrefix, value), setMapValues(map, value = trim ? value.trim() : value, !0, !1, allowSubKeys);
            }
            return map;
        }
        function assertValidValue(errorPrefix, value) {
            if ("string" != typeof value) throw new Error(`${errorPrefix} can only toggle CSS classes expressed as strings, got ${value}`);
        }
        function setMapValues(map, key, value, parseOutUnits, allowSubKeys) {
            if (allowSubKeys && key.indexOf(" ") > 0) {
                const innerKeys = key.split(/\s+/g);
                for (let j = 0; j < innerKeys.length; j++) setIndividualMapValue(map, innerKeys[j], value, parseOutUnits);
            } else setIndividualMapValue(map, key, value, parseOutUnits);
        }
        function setIndividualMapValue(map, key, value, parseOutUnits) {
            if (parseOutUnits) {
                const values = function(key, value) {
                    const index = key.indexOf(".");
                    if (index > 0) {
                        const unit = key.substr(index + 1);
                        key = key.substring(0, index), null != value && (value += unit);
                    }
                    return {
                        key: key,
                        value: value
                    };
                }(key, value);
                value = values.value, key = values.key;
            }
            map[key] = value;
        }
        function arrayEqualsArray(a, b) {
            if (a && b) {
                if (a.length !== b.length) return !1;
                for (let i = 0; i < a.length; i++) if (-1 === b.indexOf(a[i])) return !1;
                return !0;
            }
            return !1;
        }
        class NgClassImpl {}
        const NgClassImplProvider = {
            provide: NgClassImpl,
            useClass: (() => {
                class NgClassR3Impl {
                    constructor() {
                        this._value = null, this._ngClassDiffer = new StylingDiffer("NgClass", 23), this._classStringDiffer = null;
                    }
                    getValue() {
                        return this._value;
                    }
                    setClass(value) {
                        (value || this._classStringDiffer) && (this._classStringDiffer = this._classStringDiffer || new StylingDiffer("class", 20), 
                        this._classStringDiffer.setValue(value));
                    }
                    setNgClass(value) {
                        this._ngClassDiffer.setValue(value);
                    }
                    applyChanges() {
                        const classChanged = !!this._classStringDiffer && this._classStringDiffer.hasValueChanged(), ngClassChanged = this._ngClassDiffer.hasValueChanged();
                        if (classChanged || ngClassChanged) {
                            let value = this._ngClassDiffer.value;
                            if (this._classStringDiffer) {
                                let classValue = this._classStringDiffer.value;
                                classValue && (value = value ? Object.assign(Object.assign({}, classValue), value) : classValue);
                            }
                            this._value = value;
                        }
                    }
                }
                return NgClassR3Impl.ɵfac = function(t) {
                    return new (t || NgClassR3Impl);
                }, NgClassR3Impl.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb({
                    token: NgClassR3Impl,
                    factory: function(t) {
                        return NgClassR3Impl.ɵfac(t);
                    },
                    providedIn: null
                }), NgClassR3Impl;
            })()
        }, ngClassDirectiveDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Kb)({
            type: function() {},
            selectors: null,
            hostBindings: function(rf, ctx, elIndex) {
                1 & rf && Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Bb)(2), 2 & rf && Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Db)(ctx.getValue());
            }
        }), ngClassFactoryDef = function() {};
        let NgClassBase = (() => {
            class NgClassBase {
                constructor(_delegate) {
                    this._delegate = _delegate;
                }
                getValue() {
                    return this._delegate.getValue();
                }
            }
            return NgClassBase.ɵdir = ngClassDirectiveDef, NgClassBase.ɵfac = ngClassFactoryDef, 
            NgClassBase;
        })(), NgClass = (() => {
            class NgClass extends NgClassBase {
                constructor(delegate) {
                    super(delegate);
                }
                set klass(value) {
                    this._delegate.setClass(value);
                }
                set ngClass(value) {
                    this._delegate.setNgClass(value);
                }
                ngDoCheck() {
                    this._delegate.applyChanges();
                }
            }
            return NgClass.ɵfac = function(t) {
                return new (t || NgClass)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(NgClassImpl));
            }, NgClass.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Kb({
                type: NgClass,
                selectors: [ [ "", "ngClass", "" ] ],
                inputs: {
                    klass: [ "class", "klass" ],
                    ngClass: "ngClass"
                },
                features: [ _angular_core__WEBPACK_IMPORTED_MODULE_0__.zb([ NgClassImplProvider ]), _angular_core__WEBPACK_IMPORTED_MODULE_0__.xb ]
            }), NgClass;
        })();
        class NgStyleImpl {}
        const NgStyleImplProvider = {
            provide: NgStyleImpl,
            useClass: (() => {
                class NgStyleR3Impl {
                    constructor() {
                        this._differ = new StylingDiffer("NgStyle", 8), this._value = null;
                    }
                    getValue() {
                        return this._value;
                    }
                    setNgStyle(value) {
                        this._differ.setValue(value);
                    }
                    applyChanges() {
                        this._differ.hasValueChanged() && (this._value = this._differ.value);
                    }
                }
                return NgStyleR3Impl.ɵfac = function(t) {
                    return new (t || NgStyleR3Impl);
                }, NgStyleR3Impl.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb({
                    token: NgStyleR3Impl,
                    factory: function(t) {
                        return NgStyleR3Impl.ɵfac(t);
                    },
                    providedIn: null
                }), NgStyleR3Impl;
            })()
        }, ngStyleDirectiveDef__POST_R3__ = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Kb)({
            type: function() {},
            selectors: null,
            hostBindings: function(rf, ctx, elIndex) {
                1 & rf && Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Bb)(2), 2 & rf && Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.zc)(ctx.getValue());
            }
        }), ngStyleDirectiveDef = ngStyleDirectiveDef__POST_R3__, ngStyleFactoryDef = ngStyleDirectiveDef__POST_R3__;
        let NgStyleBase = (() => {
            class NgStyleBase {
                constructor(_delegate) {
                    this._delegate = _delegate;
                }
                getValue() {
                    return this._delegate.getValue();
                }
            }
            return NgStyleBase.ɵdir = ngStyleDirectiveDef, NgStyleBase.ɵfac = ngStyleFactoryDef, 
            NgStyleBase;
        })(), NgStyle = (() => {
            class NgStyle extends NgStyleBase {
                constructor(delegate) {
                    super(delegate);
                }
                set ngStyle(value) {
                    this._delegate.setNgStyle(value);
                }
                ngDoCheck() {
                    this._delegate.applyChanges();
                }
            }
            return NgStyle.ɵfac = function(t) {
                return new (t || NgStyle)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(NgStyleImpl));
            }, NgStyle.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Kb({
                type: NgStyle,
                selectors: [ [ "", "ngStyle", "" ] ],
                inputs: {
                    ngStyle: "ngStyle"
                },
                features: [ _angular_core__WEBPACK_IMPORTED_MODULE_0__.zb([ NgStyleImplProvider ]), _angular_core__WEBPACK_IMPORTED_MODULE_0__.xb ]
            }), NgStyle;
        })(), _DOM = null;
        function getDOM() {
            return _DOM;
        }
        function setRootDomAdapter(adapter) {
            _DOM || (_DOM = adapter);
        }
        class DomAdapter {}
        const DOCUMENT = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.p("DocumentToken");
        let PlatformLocation = (() => {
            class PlatformLocation {}
            return PlatformLocation.ɵfac = function(t) {
                return new (t || PlatformLocation);
            }, PlatformLocation.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb({
                token: PlatformLocation,
                factory: function() {
                    return useBrowserPlatformLocation();
                },
                providedIn: "platform"
            }), PlatformLocation.ɵprov = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb)({
                factory: useBrowserPlatformLocation,
                token: PlatformLocation,
                providedIn: "platform"
            }), PlatformLocation;
        })();
        function useBrowserPlatformLocation() {
            return Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb)(BrowserPlatformLocation);
        }
        const LOCATION_INITIALIZED = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.p("Location Initialized");
        let BrowserPlatformLocation = (() => {
            class BrowserPlatformLocation extends PlatformLocation {
                constructor(_doc) {
                    super(), this._doc = _doc, this._init();
                }
                _init() {
                    this.location = getDOM().getLocation(), this._history = getDOM().getHistory();
                }
                getBaseHrefFromDOM() {
                    return getDOM().getBaseHref(this._doc);
                }
                onPopState(fn) {
                    getDOM().getGlobalEventTarget(this._doc, "window").addEventListener("popstate", fn, !1);
                }
                onHashChange(fn) {
                    getDOM().getGlobalEventTarget(this._doc, "window").addEventListener("hashchange", fn, !1);
                }
                get href() {
                    return this.location.href;
                }
                get protocol() {
                    return this.location.protocol;
                }
                get hostname() {
                    return this.location.hostname;
                }
                get port() {
                    return this.location.port;
                }
                get pathname() {
                    return this.location.pathname;
                }
                get search() {
                    return this.location.search;
                }
                get hash() {
                    return this.location.hash;
                }
                set pathname(newPath) {
                    this.location.pathname = newPath;
                }
                pushState(state, title, url) {
                    supportsState() ? this._history.pushState(state, title, url) : this.location.hash = url;
                }
                replaceState(state, title, url) {
                    supportsState() ? this._history.replaceState(state, title, url) : this.location.hash = url;
                }
                forward() {
                    this._history.forward();
                }
                back() {
                    this._history.back();
                }
                getState() {
                    return this._history.state;
                }
            }
            return BrowserPlatformLocation.ɵfac = function(t) {
                return new (t || BrowserPlatformLocation)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb(DOCUMENT));
            }, BrowserPlatformLocation.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb({
                token: BrowserPlatformLocation,
                factory: function() {
                    return createBrowserPlatformLocation();
                },
                providedIn: "platform"
            }), BrowserPlatformLocation.ɵprov = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb)({
                factory: createBrowserPlatformLocation,
                token: BrowserPlatformLocation,
                providedIn: "platform"
            }), BrowserPlatformLocation;
        })();
        function supportsState() {
            return !!window.history.pushState;
        }
        function createBrowserPlatformLocation() {
            return new BrowserPlatformLocation(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb)(DOCUMENT));
        }
        function joinWithSlash(start, end) {
            if (0 == start.length) return end;
            if (0 == end.length) return start;
            let slashes = 0;
            return start.endsWith("/") && slashes++, end.startsWith("/") && slashes++, 2 == slashes ? start + end.substring(1) : 1 == slashes ? start + end : start + "/" + end;
        }
        function stripTrailingSlash(url) {
            const match = url.match(/#|\?|$/), pathEndIdx = match && match.index || url.length;
            return url.slice(0, pathEndIdx - ("/" === url[pathEndIdx - 1] ? 1 : 0)) + url.slice(pathEndIdx);
        }
        function normalizeQueryParams(params) {
            return params && "?" !== params[0] ? "?" + params : params;
        }
        let LocationStrategy = (() => {
            class LocationStrategy {}
            return LocationStrategy.ɵfac = function(t) {
                return new (t || LocationStrategy);
            }, LocationStrategy.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb({
                token: LocationStrategy,
                factory: function() {
                    return provideLocationStrategy();
                },
                providedIn: "root"
            }), LocationStrategy.ɵprov = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb)({
                factory: provideLocationStrategy,
                token: LocationStrategy,
                providedIn: "root"
            }), LocationStrategy;
        })();
        function provideLocationStrategy(platformLocation) {
            const location = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb)(DOCUMENT).location;
            return new PathLocationStrategy(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb)(PlatformLocation), location && location.origin || "");
        }
        const APP_BASE_HREF = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.p("appBaseHref");
        let PathLocationStrategy = (() => {
            class PathLocationStrategy extends LocationStrategy {
                constructor(_platformLocation, href) {
                    if (super(), this._platformLocation = _platformLocation, null == href && (href = this._platformLocation.getBaseHrefFromDOM()), 
                    null == href) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");
                    this._baseHref = href;
                }
                onPopState(fn) {
                    this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn);
                }
                getBaseHref() {
                    return this._baseHref;
                }
                prepareExternalUrl(internal) {
                    return joinWithSlash(this._baseHref, internal);
                }
                path(includeHash = !1) {
                    const pathname = this._platformLocation.pathname + normalizeQueryParams(this._platformLocation.search), hash = this._platformLocation.hash;
                    return hash && includeHash ? `${pathname}${hash}` : pathname;
                }
                pushState(state, title, url, queryParams) {
                    const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
                    this._platformLocation.pushState(state, title, externalUrl);
                }
                replaceState(state, title, url, queryParams) {
                    const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
                    this._platformLocation.replaceState(state, title, externalUrl);
                }
                forward() {
                    this._platformLocation.forward();
                }
                back() {
                    this._platformLocation.back();
                }
            }
            return PathLocationStrategy.ɵfac = function(t) {
                return new (t || PathLocationStrategy)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb(PlatformLocation), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb(APP_BASE_HREF, 8));
            }, PathLocationStrategy.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb({
                token: PathLocationStrategy,
                factory: function(t) {
                    return PathLocationStrategy.ɵfac(t);
                },
                providedIn: null
            }), PathLocationStrategy;
        })(), HashLocationStrategy = (() => {
            class HashLocationStrategy extends LocationStrategy {
                constructor(_platformLocation, _baseHref) {
                    super(), this._platformLocation = _platformLocation, this._baseHref = "", null != _baseHref && (this._baseHref = _baseHref);
                }
                onPopState(fn) {
                    this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn);
                }
                getBaseHref() {
                    return this._baseHref;
                }
                path(includeHash = !1) {
                    let path = this._platformLocation.hash;
                    return null == path && (path = "#"), path.length > 0 ? path.substring(1) : path;
                }
                prepareExternalUrl(internal) {
                    const url = joinWithSlash(this._baseHref, internal);
                    return url.length > 0 ? "#" + url : url;
                }
                pushState(state, title, path, queryParams) {
                    let url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams));
                    0 == url.length && (url = this._platformLocation.pathname), this._platformLocation.pushState(state, title, url);
                }
                replaceState(state, title, path, queryParams) {
                    let url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams));
                    0 == url.length && (url = this._platformLocation.pathname), this._platformLocation.replaceState(state, title, url);
                }
                forward() {
                    this._platformLocation.forward();
                }
                back() {
                    this._platformLocation.back();
                }
            }
            return HashLocationStrategy.ɵfac = function(t) {
                return new (t || HashLocationStrategy)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb(PlatformLocation), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb(APP_BASE_HREF, 8));
            }, HashLocationStrategy.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb({
                token: HashLocationStrategy,
                factory: function(t) {
                    return HashLocationStrategy.ɵfac(t);
                },
                providedIn: null
            }), HashLocationStrategy;
        })(), Location = (() => {
            class Location {
                constructor(platformStrategy, platformLocation) {
                    this._subject = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.m, this._urlChangeListeners = [], 
                    this._platformStrategy = platformStrategy;
                    const browserBaseHref = this._platformStrategy.getBaseHref();
                    this._platformLocation = platformLocation, this._baseHref = stripTrailingSlash(_stripIndexHtml(browserBaseHref)), 
                    this._platformStrategy.onPopState(ev => {
                        this._subject.emit({
                            url: this.path(!0),
                            pop: !0,
                            state: ev.state,
                            type: ev.type
                        });
                    });
                }
                path(includeHash = !1) {
                    return this.normalize(this._platformStrategy.path(includeHash));
                }
                getState() {
                    return this._platformLocation.getState();
                }
                isCurrentPathEqualTo(path, query = "") {
                    return this.path() == this.normalize(path + normalizeQueryParams(query));
                }
                normalize(url) {
                    return Location.stripTrailingSlash(function(baseHref, url) {
                        return baseHref && url.startsWith(baseHref) ? url.substring(baseHref.length) : url;
                    }(this._baseHref, _stripIndexHtml(url)));
                }
                prepareExternalUrl(url) {
                    return url && "/" !== url[0] && (url = "/" + url), this._platformStrategy.prepareExternalUrl(url);
                }
                go(path, query = "", state = null) {
                    this._platformStrategy.pushState(state, "", path, query), this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
                }
                replaceState(path, query = "", state = null) {
                    this._platformStrategy.replaceState(state, "", path, query), this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
                }
                forward() {
                    this._platformStrategy.forward();
                }
                back() {
                    this._platformStrategy.back();
                }
                onUrlChange(fn) {
                    this._urlChangeListeners.push(fn), this.subscribe(v => {
                        this._notifyUrlChangeListeners(v.url, v.state);
                    });
                }
                _notifyUrlChangeListeners(url = "", state) {
                    this._urlChangeListeners.forEach(fn => fn(url, state));
                }
                subscribe(onNext, onThrow, onReturn) {
                    return this._subject.subscribe({
                        next: onNext,
                        error: onThrow,
                        complete: onReturn
                    });
                }
            }
            return Location.ɵfac = function(t) {
                return new (t || Location)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb(LocationStrategy), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb(PlatformLocation));
            }, Location.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb({
                token: Location,
                factory: function() {
                    return createLocation();
                },
                providedIn: "root"
            }), Location.normalizeQueryParams = normalizeQueryParams, Location.joinWithSlash = joinWithSlash, 
            Location.stripTrailingSlash = stripTrailingSlash, Location.ɵprov = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb)({
                factory: createLocation,
                token: Location,
                providedIn: "root"
            }), Location;
        })();
        function createLocation() {
            return new Location(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb)(LocationStrategy), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb)(PlatformLocation));
        }
        function _stripIndexHtml(url) {
            return url.replace(/\/index.html$/, "");
        }
        const Plural = function() {
            var Plural = {
                Zero: 0,
                One: 1,
                Two: 2,
                Few: 3,
                Many: 4,
                Other: 5
            };
            return Plural[Plural.Zero] = "Zero", Plural[Plural.One] = "One", Plural[Plural.Two] = "Two", 
            Plural[Plural.Few] = "Few", Plural[Plural.Many] = "Many", Plural[Plural.Other] = "Other", 
            Plural;
        }(), getLocalePluralCase = _angular_core__WEBPACK_IMPORTED_MODULE_0__.mb;
        class NgLocalization {}
        let NgLocaleLocalization = (() => {
            class NgLocaleLocalization extends NgLocalization {
                constructor(locale) {
                    super(), this.locale = locale;
                }
                getPluralCategory(value, locale) {
                    switch (getLocalePluralCase(locale || this.locale)(value)) {
                      case Plural.Zero:
                        return "zero";

                      case Plural.One:
                        return "one";

                      case Plural.Two:
                        return "two";

                      case Plural.Few:
                        return "few";

                      case Plural.Many:
                        return "many";

                      default:
                        return "other";
                    }
                }
            }
            return NgLocaleLocalization.ɵfac = function(t) {
                return new (t || NgLocaleLocalization)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.t));
            }, NgLocaleLocalization.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb({
                token: NgLocaleLocalization,
                factory: function(t) {
                    return NgLocaleLocalization.ɵfac(t);
                },
                providedIn: null
            }), NgLocaleLocalization;
        })();
        function parseCookieValue(cookieStr, name) {
            name = encodeURIComponent(name);
            for (const cookie of cookieStr.split(";")) {
                const eqIndex = cookie.indexOf("="), [cookieName, cookieValue] = -1 == eqIndex ? [ cookie, "" ] : [ cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1) ];
                if (cookieName.trim() === name) return decodeURIComponent(cookieValue);
            }
            return null;
        }
        class NgForOfContext {
            constructor($implicit, ngForOf, index, count) {
                this.$implicit = $implicit, this.ngForOf = ngForOf, this.index = index, this.count = count;
            }
            get first() {
                return 0 === this.index;
            }
            get last() {
                return this.index === this.count - 1;
            }
            get even() {
                return this.index % 2 == 0;
            }
            get odd() {
                return !this.even;
            }
        }
        let NgForOf = (() => {
            class NgForOf {
                constructor(_viewContainer, _template, _differs) {
                    this._viewContainer = _viewContainer, this._template = _template, this._differs = _differs, 
                    this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null;
                }
                set ngForOf(ngForOf) {
                    this._ngForOf = ngForOf, this._ngForOfDirty = !0;
                }
                set ngForTrackBy(fn) {
                    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.W)() && null != fn && "function" != typeof fn && console && console.warn && console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}. ` + "See https://angular.io/docs/ts/latest/api/common/index/NgFor-directive.html#!#change-propagation for more information."), 
                    this._trackByFn = fn;
                }
                get ngForTrackBy() {
                    return this._trackByFn;
                }
                set ngForTemplate(value) {
                    value && (this._template = value);
                }
                ngDoCheck() {
                    if (this._ngForOfDirty) {
                        this._ngForOfDirty = !1;
                        const value = this._ngForOf;
                        if (!this._differ && value) try {
                            this._differ = this._differs.find(value).create(this.ngForTrackBy);
                        } catch (_a) {
                            throw new Error(`Cannot find a differ supporting object '${value}' of type '${type = value, 
                            type.name || typeof type}'. NgFor only supports binding to Iterables such as Arrays.`);
                        }
                    }
                    var type;
                    if (this._differ) {
                        const changes = this._differ.diff(this._ngForOf);
                        changes && this._applyChanges(changes);
                    }
                }
                _applyChanges(changes) {
                    const insertTuples = [];
                    changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
                        if (null == item.previousIndex) {
                            const view = this._viewContainer.createEmbeddedView(this._template, new NgForOfContext(null, this._ngForOf, -1, -1), null === currentIndex ? void 0 : currentIndex), tuple = new RecordViewTuple(item, view);
                            insertTuples.push(tuple);
                        } else if (null == currentIndex) this._viewContainer.remove(null === adjustedPreviousIndex ? void 0 : adjustedPreviousIndex); else if (null !== adjustedPreviousIndex) {
                            const view = this._viewContainer.get(adjustedPreviousIndex);
                            this._viewContainer.move(view, currentIndex);
                            const tuple = new RecordViewTuple(item, view);
                            insertTuples.push(tuple);
                        }
                    });
                    for (let i = 0; i < insertTuples.length; i++) this._perViewChange(insertTuples[i].view, insertTuples[i].record);
                    for (let i = 0, ilen = this._viewContainer.length; i < ilen; i++) {
                        const viewRef = this._viewContainer.get(i);
                        viewRef.context.index = i, viewRef.context.count = ilen, viewRef.context.ngForOf = this._ngForOf;
                    }
                    changes.forEachIdentityChange(record => {
                        this._viewContainer.get(record.currentIndex).context.$implicit = record.item;
                    });
                }
                _perViewChange(view, record) {
                    view.context.$implicit = record.item;
                }
                static ngTemplateContextGuard(dir, ctx) {
                    return !0;
                }
            }
            return NgForOf.ɵfac = function(t) {
                return new (t || NgForOf)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.O), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.L), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.r));
            }, NgForOf.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Kb({
                type: NgForOf,
                selectors: [ [ "", "ngFor", "", "ngForOf", "" ] ],
                inputs: {
                    ngForOf: "ngForOf",
                    ngForTrackBy: "ngForTrackBy",
                    ngForTemplate: "ngForTemplate"
                }
            }), NgForOf;
        })();
        class RecordViewTuple {
            constructor(record, view) {
                this.record = record, this.view = view;
            }
        }
        let NgIf = (() => {
            class NgIf {
                constructor(_viewContainer, templateRef) {
                    this._viewContainer = _viewContainer, this._context = new NgIfContext, this._thenTemplateRef = null, 
                    this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, 
                    this._thenTemplateRef = templateRef;
                }
                set ngIf(condition) {
                    this._context.$implicit = this._context.ngIf = condition, this._updateView();
                }
                set ngIfThen(templateRef) {
                    assertTemplate("ngIfThen", templateRef), this._thenTemplateRef = templateRef, this._thenViewRef = null, 
                    this._updateView();
                }
                set ngIfElse(templateRef) {
                    assertTemplate("ngIfElse", templateRef), this._elseTemplateRef = templateRef, this._elseViewRef = null, 
                    this._updateView();
                }
                _updateView() {
                    this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, 
                    this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), 
                    this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context)));
                }
            }
            return NgIf.ɵfac = function(t) {
                return new (t || NgIf)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.O), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.L));
            }, NgIf.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Kb({
                type: NgIf,
                selectors: [ [ "", "ngIf", "" ] ],
                inputs: {
                    ngIf: "ngIf",
                    ngIfThen: "ngIfThen",
                    ngIfElse: "ngIfElse"
                }
            }), NgIf;
        })();
        class NgIfContext {
            constructor() {
                this.$implicit = null, this.ngIf = null;
            }
        }
        function assertTemplate(property, templateRef) {
            if (templateRef && !templateRef.createEmbeddedView) throw new Error(`${property} must be a TemplateRef, but received '${Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.vb)(templateRef)}'.`);
        }
        class SwitchView {
            constructor(_viewContainerRef, _templateRef) {
                this._viewContainerRef = _viewContainerRef, this._templateRef = _templateRef, this._created = !1;
            }
            create() {
                this._created = !0, this._viewContainerRef.createEmbeddedView(this._templateRef);
            }
            destroy() {
                this._created = !1, this._viewContainerRef.clear();
            }
            enforceState(created) {
                created && !this._created ? this.create() : !created && this._created && this.destroy();
            }
        }
        let NgSwitch = (() => {
            class NgSwitch {
                constructor() {
                    this._defaultUsed = !1, this._caseCount = 0, this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1;
                }
                set ngSwitch(newValue) {
                    this._ngSwitch = newValue, 0 === this._caseCount && this._updateDefaultCases(!0);
                }
                _addCase() {
                    return this._caseCount++;
                }
                _addDefault(view) {
                    this._defaultViews || (this._defaultViews = []), this._defaultViews.push(view);
                }
                _matchCase(value) {
                    const matched = value == this._ngSwitch;
                    return this._lastCasesMatched = this._lastCasesMatched || matched, this._lastCaseCheckIndex++, 
                    this._lastCaseCheckIndex === this._caseCount && (this._updateDefaultCases(!this._lastCasesMatched), 
                    this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1), matched;
                }
                _updateDefaultCases(useDefault) {
                    if (this._defaultViews && useDefault !== this._defaultUsed) {
                        this._defaultUsed = useDefault;
                        for (let i = 0; i < this._defaultViews.length; i++) this._defaultViews[i].enforceState(useDefault);
                    }
                }
            }
            return NgSwitch.ɵfac = function(t) {
                return new (t || NgSwitch);
            }, NgSwitch.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Kb({
                type: NgSwitch,
                selectors: [ [ "", "ngSwitch", "" ] ],
                inputs: {
                    ngSwitch: "ngSwitch"
                }
            }), NgSwitch;
        })(), NgSwitchCase = (() => {
            class NgSwitchCase {
                constructor(viewContainer, templateRef, ngSwitch) {
                    this.ngSwitch = ngSwitch, ngSwitch._addCase(), this._view = new SwitchView(viewContainer, templateRef);
                }
                ngDoCheck() {
                    this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase));
                }
            }
            return NgSwitchCase.ɵfac = function(t) {
                return new (t || NgSwitchCase)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.O), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.L), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(NgSwitch, 1));
            }, NgSwitchCase.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Kb({
                type: NgSwitchCase,
                selectors: [ [ "", "ngSwitchCase", "" ] ],
                inputs: {
                    ngSwitchCase: "ngSwitchCase"
                }
            }), NgSwitchCase;
        })(), NgSwitchDefault = (() => {
            class NgSwitchDefault {
                constructor(viewContainer, templateRef, ngSwitch) {
                    ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));
                }
            }
            return NgSwitchDefault.ɵfac = function(t) {
                return new (t || NgSwitchDefault)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.O), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.L), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(NgSwitch, 1));
            }, NgSwitchDefault.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Kb({
                type: NgSwitchDefault,
                selectors: [ [ "", "ngSwitchDefault", "" ] ]
            }), NgSwitchDefault;
        })();
        class ObservableStrategy {
            createSubscription(async, updateLatestValue) {
                return async.subscribe({
                    next: updateLatestValue,
                    error: e => {
                        throw e;
                    }
                });
            }
            dispose(subscription) {
                subscription.unsubscribe();
            }
            onDestroy(subscription) {
                subscription.unsubscribe();
            }
        }
        class PromiseStrategy {
            createSubscription(async, updateLatestValue) {
                return async.then(updateLatestValue, e => {
                    throw e;
                });
            }
            dispose(subscription) {}
            onDestroy(subscription) {}
        }
        const _promiseStrategy = new PromiseStrategy, _observableStrategy = new ObservableStrategy;
        let AsyncPipe = (() => {
            class AsyncPipe {
                constructor(_ref) {
                    this._ref = _ref, this._latestValue = null, this._latestReturnedValue = null, this._subscription = null, 
                    this._obj = null, this._strategy = null;
                }
                ngOnDestroy() {
                    this._subscription && this._dispose();
                }
                transform(obj) {
                    return this._obj ? obj !== this._obj ? (this._dispose(), this.transform(obj)) : Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.sb)(this._latestValue, this._latestReturnedValue) ? this._latestReturnedValue : (this._latestReturnedValue = this._latestValue, 
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.Q.wrap(this._latestValue)) : (obj && this._subscribe(obj), 
                    this._latestReturnedValue = this._latestValue, this._latestValue);
                }
                _subscribe(obj) {
                    this._obj = obj, this._strategy = this._selectStrategy(obj), this._subscription = this._strategy.createSubscription(obj, value => this._updateLatestValue(obj, value));
                }
                _selectStrategy(obj) {
                    if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.rb)(obj)) return _promiseStrategy;
                    if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.qb)(obj)) return _observableStrategy;
                    throw type = AsyncPipe, Error(`InvalidPipeArgument: '${obj}' for pipe '${Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.vb)(type)}'`);
                    var type;
                }
                _dispose() {
                    this._strategy.dispose(this._subscription), this._latestValue = null, this._latestReturnedValue = null, 
                    this._subscription = null, this._obj = null;
                }
                _updateLatestValue(async, value) {
                    async === this._obj && (this._latestValue = value, this._ref.markForCheck());
                }
            }
            return AsyncPipe.ɵfac = function(t) {
                return new (t || AsyncPipe)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.h));
            }, AsyncPipe.ɵpipe = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ob({
                name: "async",
                type: AsyncPipe,
                pure: !1
            }), AsyncPipe;
        })(), CommonModule = (() => {
            class CommonModule {}
            return CommonModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Nb({
                type: CommonModule
            }), CommonModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Mb({
                factory: function(t) {
                    return new (t || CommonModule);
                },
                providers: [ {
                    provide: NgLocalization,
                    useClass: NgLocaleLocalization
                } ]
            }), CommonModule;
        })();
        const PLATFORM_BROWSER_ID = "browser";
        function isPlatformBrowser(platformId) {
            return platformId === PLATFORM_BROWSER_ID;
        }
        let ViewportScroller = (() => {
            class ViewportScroller {}
            return ViewportScroller.ɵprov = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb)({
                token: ViewportScroller,
                providedIn: "root",
                factory: () => new BrowserViewportScroller(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb)(DOCUMENT), window, Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.l))
            }), ViewportScroller;
        })();
        class BrowserViewportScroller {
            constructor(document, window, errorHandler) {
                this.document = document, this.window = window, this.errorHandler = errorHandler, 
                this.offset = () => [ 0, 0 ];
            }
            setOffset(offset) {
                this.offset = Array.isArray(offset) ? () => offset : offset;
            }
            getScrollPosition() {
                return this.supportScrollRestoration() ? [ this.window.scrollX, this.window.scrollY ] : [ 0, 0 ];
            }
            scrollToPosition(position) {
                this.supportScrollRestoration() && this.window.scrollTo(position[0], position[1]);
            }
            scrollToAnchor(anchor) {
                if (this.supportScrollRestoration()) {
                    anchor = this.window.CSS && this.window.CSS.escape ? this.window.CSS.escape(anchor) : anchor.replace(/(\"|\'\ |:|\.|\[|\]|,|=)/g, "\\$1");
                    try {
                        const elSelectedById = this.document.querySelector(`#${anchor}`);
                        if (elSelectedById) return void this.scrollToElement(elSelectedById);
                        const elSelectedByName = this.document.querySelector(`[name='${anchor}']`);
                        if (elSelectedByName) return void this.scrollToElement(elSelectedByName);
                    } catch (e) {
                        this.errorHandler.handleError(e);
                    }
                }
            }
            setHistoryScrollRestoration(scrollRestoration) {
                if (this.supportScrollRestoration()) {
                    const history = this.window.history;
                    history && history.scrollRestoration && (history.scrollRestoration = scrollRestoration);
                }
            }
            scrollToElement(el) {
                const rect = el.getBoundingClientRect(), left = rect.left + this.window.pageXOffset, top = rect.top + this.window.pageYOffset, offset = this.offset();
                this.window.scrollTo(left - offset[0], top - offset[1]);
            }
            supportScrollRestoration() {
                try {
                    return !!this.window && !!this.window.scrollTo;
                } catch (_a) {
                    return !1;
                }
            }
        }
    },
    pLZG: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return filter;
        }));
        var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7o/Q");
        function filter(predicate, thisArg) {
            return function(source) {
                return source.lift(new FilterOperator(predicate, thisArg));
            };
        }
        class FilterOperator {
            constructor(predicate, thisArg) {
                this.predicate = predicate, this.thisArg = thisArg;
            }
            call(subscriber, source) {
                return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
            }
        }
        class FilterSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(destination, predicate, thisArg) {
                super(destination), this.predicate = predicate, this.thisArg = thisArg, this.count = 0;
            }
            _next(value) {
                let result;
                try {
                    result = this.predicate.call(this.thisArg, value, this.count++);
                } catch (err) {
                    return void this.destination.error(err);
                }
                result && this.destination.next(value);
            }
        }
    },
    pxpQ: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "b", (function() {
            return observeOn;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return ObserveOnSubscriber;
        }));
        var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7o/Q"), _Notification__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("WMd4");
        function observeOn(scheduler, delay = 0) {
            return function(source) {
                return source.lift(new ObserveOnOperator(scheduler, delay));
            };
        }
        class ObserveOnOperator {
            constructor(scheduler, delay = 0) {
                this.scheduler = scheduler, this.delay = delay;
            }
            call(subscriber, source) {
                return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
            }
        }
        class ObserveOnSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(destination, scheduler, delay = 0) {
                super(destination), this.scheduler = scheduler, this.delay = delay;
            }
            static dispatch(arg) {
                const {notification: notification, destination: destination} = arg;
                notification.observe(destination), this.unsubscribe();
            }
            scheduleMessage(notification) {
                this.destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
            }
            _next(value) {
                this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_1__.a.createNext(value));
            }
            _error(err) {
                this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_1__.a.createError(err)), 
                this.unsubscribe();
            }
            _complete() {
                this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_1__.a.createComplete()), 
                this.unsubscribe();
            }
        }
        class ObserveOnMessage {
            constructor(notification, destination) {
                this.notification = notification, this.destination = destination;
            }
        }
    },
    qZ0a: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return publishLast;
        }));
        var _AsyncSubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("NHP+"), _multicast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("oB13");
        function publishLast() {
            return source => Object(_multicast__WEBPACK_IMPORTED_MODULE_1__.a)(new _AsyncSubject__WEBPACK_IMPORTED_MODULE_0__.a)(source);
        }
    },
    quSY: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        var isArray = __webpack_require__("DH7j"), isObject = __webpack_require__("XoHu"), isFunction = __webpack_require__("n6bG");
        const UnsubscriptionError = (() => {
            function UnsubscriptionErrorImpl(errors) {
                return Error.call(this), this.message = errors ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join("\n  ")}` : "", 
                this.name = "UnsubscriptionError", this.errors = errors, this;
            }
            return UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype), UnsubscriptionErrorImpl;
        })();
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Subscription_Subscription;
        }));
        let Subscription_Subscription = (() => {
            class Subscription {
                constructor(unsubscribe) {
                    this.closed = !1, this._parentOrParents = null, this._subscriptions = null, unsubscribe && (this._unsubscribe = unsubscribe);
                }
                unsubscribe() {
                    let errors;
                    if (this.closed) return;
                    let {_parentOrParents: _parentOrParents, _unsubscribe: _unsubscribe, _subscriptions: _subscriptions} = this;
                    if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, 
                    _parentOrParents instanceof Subscription) _parentOrParents.remove(this); else if (null !== _parentOrParents) for (let index = 0; index < _parentOrParents.length; ++index) _parentOrParents[index].remove(this);
                    if (Object(isFunction.a)(_unsubscribe)) try {
                        _unsubscribe.call(this);
                    } catch (e) {
                        errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [ e ];
                    }
                    if (Object(isArray.a)(_subscriptions)) {
                        let index = -1, len = _subscriptions.length;
                        for (;++index < len; ) {
                            const sub = _subscriptions[index];
                            if (Object(isObject.a)(sub)) try {
                                sub.unsubscribe();
                            } catch (e) {
                                errors = errors || [], e instanceof UnsubscriptionError ? errors = errors.concat(flattenUnsubscriptionErrors(e.errors)) : errors.push(e);
                            }
                        }
                    }
                    if (errors) throw new UnsubscriptionError(errors);
                }
                add(teardown) {
                    let subscription = teardown;
                    if (!teardown) return Subscription.EMPTY;
                    switch (typeof teardown) {
                      case "function":
                        subscription = new Subscription(teardown);

                      case "object":
                        if (subscription === this || subscription.closed || "function" != typeof subscription.unsubscribe) return subscription;
                        if (this.closed) return subscription.unsubscribe(), subscription;
                        if (!(subscription instanceof Subscription)) {
                            const tmp = subscription;
                            (subscription = new Subscription)._subscriptions = [ tmp ];
                        }
                        break;

                      default:
                        throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
                    }
                    let {_parentOrParents: _parentOrParents} = subscription;
                    if (null === _parentOrParents) subscription._parentOrParents = this; else if (_parentOrParents instanceof Subscription) {
                        if (_parentOrParents === this) return subscription;
                        subscription._parentOrParents = [ _parentOrParents, this ];
                    } else {
                        if (-1 !== _parentOrParents.indexOf(this)) return subscription;
                        _parentOrParents.push(this);
                    }
                    const subscriptions = this._subscriptions;
                    return null === subscriptions ? this._subscriptions = [ subscription ] : subscriptions.push(subscription), 
                    subscription;
                }
                remove(subscription) {
                    const subscriptions = this._subscriptions;
                    if (subscriptions) {
                        const subscriptionIndex = subscriptions.indexOf(subscription);
                        -1 !== subscriptionIndex && subscriptions.splice(subscriptionIndex, 1);
                    }
                }
            }
            return Subscription.EMPTY = function(empty) {
                return empty.closed = !0, empty;
            }(new Subscription), Subscription;
        })();
        function flattenUnsubscriptionErrors(errors) {
            return errors.reduce((errs, err) => errs.concat(err instanceof UnsubscriptionError ? err.errors : err), []);
        }
    },
    sVev: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return EmptyError;
        }));
        const EmptyError = (() => {
            function EmptyErrorImpl() {
                return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", 
                this;
            }
            return EmptyErrorImpl.prototype = Object.create(Error.prototype), EmptyErrorImpl;
        })();
    },
    "tk/3": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return HttpClient;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return HttpClientModule;
        }));
        var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("fXoL"), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("LRne"), rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("HDdC"), rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("bOdf"), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("pLZG"), rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("lJxs"), _angular_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("ofXK");
        class HttpHandler {}
        class HttpBackend {}
        class HttpHeaders {
            constructor(headers) {
                this.normalizedNames = new Map, this.lazyUpdate = null, headers ? this.lazyInit = "string" == typeof headers ? () => {
                    this.headers = new Map, headers.split("\n").forEach(line => {
                        const index = line.indexOf(":");
                        if (index > 0) {
                            const name = line.slice(0, index), key = name.toLowerCase(), value = line.slice(index + 1).trim();
                            this.maybeSetNormalizedName(name, key), this.headers.has(key) ? this.headers.get(key).push(value) : this.headers.set(key, [ value ]);
                        }
                    });
                } : () => {
                    this.headers = new Map, Object.keys(headers).forEach(name => {
                        let values = headers[name];
                        const key = name.toLowerCase();
                        "string" == typeof values && (values = [ values ]), values.length > 0 && (this.headers.set(key, values), 
                        this.maybeSetNormalizedName(name, key));
                    });
                } : this.headers = new Map;
            }
            has(name) {
                return this.init(), this.headers.has(name.toLowerCase());
            }
            get(name) {
                this.init();
                const values = this.headers.get(name.toLowerCase());
                return values && values.length > 0 ? values[0] : null;
            }
            keys() {
                return this.init(), Array.from(this.normalizedNames.values());
            }
            getAll(name) {
                return this.init(), this.headers.get(name.toLowerCase()) || null;
            }
            append(name, value) {
                return this.clone({
                    name: name,
                    value: value,
                    op: "a"
                });
            }
            set(name, value) {
                return this.clone({
                    name: name,
                    value: value,
                    op: "s"
                });
            }
            delete(name, value) {
                return this.clone({
                    name: name,
                    value: value,
                    op: "d"
                });
            }
            maybeSetNormalizedName(name, lcName) {
                this.normalizedNames.has(lcName) || this.normalizedNames.set(lcName, name);
            }
            init() {
                this.lazyInit && (this.lazyInit instanceof HttpHeaders ? this.copyFrom(this.lazyInit) : this.lazyInit(), 
                this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(update => this.applyUpdate(update)), 
                this.lazyUpdate = null));
            }
            copyFrom(other) {
                other.init(), Array.from(other.headers.keys()).forEach(key => {
                    this.headers.set(key, other.headers.get(key)), this.normalizedNames.set(key, other.normalizedNames.get(key));
                });
            }
            clone(update) {
                const clone = new HttpHeaders;
                return clone.lazyInit = this.lazyInit && this.lazyInit instanceof HttpHeaders ? this.lazyInit : this, 
                clone.lazyUpdate = (this.lazyUpdate || []).concat([ update ]), clone;
            }
            applyUpdate(update) {
                const key = update.name.toLowerCase();
                switch (update.op) {
                  case "a":
                  case "s":
                    let value = update.value;
                    if ("string" == typeof value && (value = [ value ]), 0 === value.length) return;
                    this.maybeSetNormalizedName(update.name, key);
                    const base = ("a" === update.op ? this.headers.get(key) : void 0) || [];
                    base.push(...value), this.headers.set(key, base);
                    break;

                  case "d":
                    const toDelete = update.value;
                    if (toDelete) {
                        let existing = this.headers.get(key);
                        if (!existing) return;
                        0 === (existing = existing.filter(value => -1 === toDelete.indexOf(value))).length ? (this.headers.delete(key), 
                        this.normalizedNames.delete(key)) : this.headers.set(key, existing);
                    } else this.headers.delete(key), this.normalizedNames.delete(key);
                }
            }
            forEach(fn) {
                this.init(), Array.from(this.normalizedNames.keys()).forEach(key => fn(this.normalizedNames.get(key), this.headers.get(key)));
            }
        }
        class HttpUrlEncodingCodec {
            encodeKey(key) {
                return standardEncoding(key);
            }
            encodeValue(value) {
                return standardEncoding(value);
            }
            decodeKey(key) {
                return decodeURIComponent(key);
            }
            decodeValue(value) {
                return decodeURIComponent(value);
            }
        }
        function standardEncoding(v) {
            return encodeURIComponent(v).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/gi, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%2B/gi, "+").replace(/%3D/gi, "=").replace(/%3F/gi, "?").replace(/%2F/gi, "/");
        }
        class HttpParams {
            constructor(options = {}) {
                if (this.updates = null, this.cloneFrom = null, this.encoder = options.encoder || new HttpUrlEncodingCodec, 
                options.fromString) {
                    if (options.fromObject) throw new Error("Cannot specify both fromString and fromObject.");
                    this.map = function(rawParams, codec) {
                        const map = new Map;
                        return rawParams.length > 0 && rawParams.split("&").forEach(param => {
                            const eqIdx = param.indexOf("="), [key, val] = -1 == eqIdx ? [ codec.decodeKey(param), "" ] : [ codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1)) ], list = map.get(key) || [];
                            list.push(val), map.set(key, list);
                        }), map;
                    }(options.fromString, this.encoder);
                } else options.fromObject ? (this.map = new Map, Object.keys(options.fromObject).forEach(key => {
                    const value = options.fromObject[key];
                    this.map.set(key, Array.isArray(value) ? value : [ value ]);
                })) : this.map = null;
            }
            has(param) {
                return this.init(), this.map.has(param);
            }
            get(param) {
                this.init();
                const res = this.map.get(param);
                return res ? res[0] : null;
            }
            getAll(param) {
                return this.init(), this.map.get(param) || null;
            }
            keys() {
                return this.init(), Array.from(this.map.keys());
            }
            append(param, value) {
                return this.clone({
                    param: param,
                    value: value,
                    op: "a"
                });
            }
            set(param, value) {
                return this.clone({
                    param: param,
                    value: value,
                    op: "s"
                });
            }
            delete(param, value) {
                return this.clone({
                    param: param,
                    value: value,
                    op: "d"
                });
            }
            toString() {
                return this.init(), this.keys().map(key => {
                    const eKey = this.encoder.encodeKey(key);
                    return (this.map.get(key).map(value => eKey + "=" + this.encoder.encodeValue(value)).join("&"));
                }).join("&");
            }
            clone(update) {
                const clone = new HttpParams({
                    encoder: this.encoder
                });
                return clone.cloneFrom = this.cloneFrom || this, clone.updates = (this.updates || []).concat([ update ]), 
                clone;
            }
            init() {
                null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), 
                this.cloneFrom.keys().forEach(key => this.map.set(key, this.cloneFrom.map.get(key))), 
                this.updates.forEach(update => {
                    switch (update.op) {
                      case "a":
                      case "s":
                        const base = ("a" === update.op ? this.map.get(update.param) : void 0) || [];
                        base.push(update.value), this.map.set(update.param, base);
                        break;

                      case "d":
                        if (void 0 === update.value) {
                            this.map.delete(update.param);
                            break;
                        }
                        {
                            let base = this.map.get(update.param) || [];
                            const idx = base.indexOf(update.value);
                            -1 !== idx && base.splice(idx, 1), base.length > 0 ? this.map.set(update.param, base) : this.map.delete(update.param);
                        }
                    }
                }), this.cloneFrom = this.updates = null);
            }
        }
        function isArrayBuffer(value) {
            return "undefined" != typeof ArrayBuffer && value instanceof ArrayBuffer;
        }
        function isBlob(value) {
            return "undefined" != typeof Blob && value instanceof Blob;
        }
        function isFormData(value) {
            return "undefined" != typeof FormData && value instanceof FormData;
        }
        class HttpRequest {
            constructor(method, url, third, fourth) {
                let options;
                if (this.url = url, this.body = null, this.reportProgress = !1, this.withCredentials = !1, 
                this.responseType = "json", this.method = method.toUpperCase(), function(method) {
                    switch (method) {
                      case "DELETE":
                      case "GET":
                      case "HEAD":
                      case "OPTIONS":
                      case "JSONP":
                        return !1;

                      default:
                        return !0;
                    }
                }(this.method) || fourth ? (this.body = void 0 !== third ? third : null, options = fourth) : options = third, 
                options && (this.reportProgress = !!options.reportProgress, this.withCredentials = !!options.withCredentials, 
                options.responseType && (this.responseType = options.responseType), options.headers && (this.headers = options.headers), 
                options.params && (this.params = options.params)), this.headers || (this.headers = new HttpHeaders), 
                this.params) {
                    const params = this.params.toString();
                    if (0 === params.length) this.urlWithParams = url; else {
                        const qIdx = url.indexOf("?");
                        this.urlWithParams = url + (-1 === qIdx ? "?" : qIdx < url.length - 1 ? "&" : "") + params;
                    }
                } else this.params = new HttpParams, this.urlWithParams = url;
            }
            serializeBody() {
                return null === this.body ? null : isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) || "string" == typeof this.body ? this.body : this.body instanceof HttpParams ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString();
            }
            detectContentTypeHeader() {
                return null === this.body ? null : isFormData(this.body) ? null : isBlob(this.body) ? this.body.type || null : isArrayBuffer(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof HttpParams ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || Array.isArray(this.body) ? "application/json" : null;
            }
            clone(update = {}) {
                const method = update.method || this.method, url = update.url || this.url, responseType = update.responseType || this.responseType, body = void 0 !== update.body ? update.body : this.body, withCredentials = void 0 !== update.withCredentials ? update.withCredentials : this.withCredentials, reportProgress = void 0 !== update.reportProgress ? update.reportProgress : this.reportProgress;
                let headers = update.headers || this.headers, params = update.params || this.params;
                return void 0 !== update.setHeaders && (headers = Object.keys(update.setHeaders).reduce((headers, name) => headers.set(name, update.setHeaders[name]), headers)), 
                update.setParams && (params = Object.keys(update.setParams).reduce((params, param) => params.set(param, update.setParams[param]), params)), 
                new HttpRequest(method, url, body, {
                    params: params,
                    headers: headers,
                    reportProgress: reportProgress,
                    responseType: responseType,
                    withCredentials: withCredentials
                });
            }
        }
        const HttpEventType = function() {
            var HttpEventType = {
                Sent: 0,
                UploadProgress: 1,
                ResponseHeader: 2,
                DownloadProgress: 3,
                Response: 4,
                User: 5
            };
            return HttpEventType[HttpEventType.Sent] = "Sent", HttpEventType[HttpEventType.UploadProgress] = "UploadProgress", 
            HttpEventType[HttpEventType.ResponseHeader] = "ResponseHeader", HttpEventType[HttpEventType.DownloadProgress] = "DownloadProgress", 
            HttpEventType[HttpEventType.Response] = "Response", HttpEventType[HttpEventType.User] = "User", 
            HttpEventType;
        }();
        class HttpResponseBase {
            constructor(init, defaultStatus = 200, defaultStatusText = "OK") {
                this.headers = init.headers || new HttpHeaders, this.status = void 0 !== init.status ? init.status : defaultStatus, 
                this.statusText = init.statusText || defaultStatusText, this.url = init.url || null, 
                this.ok = this.status >= 200 && this.status < 300;
            }
        }
        class HttpHeaderResponse extends HttpResponseBase {
            constructor(init = {}) {
                super(init), this.type = HttpEventType.ResponseHeader;
            }
            clone(update = {}) {
                return new HttpHeaderResponse({
                    headers: update.headers || this.headers,
                    status: void 0 !== update.status ? update.status : this.status,
                    statusText: update.statusText || this.statusText,
                    url: update.url || this.url || void 0
                });
            }
        }
        class HttpResponse extends HttpResponseBase {
            constructor(init = {}) {
                super(init), this.type = HttpEventType.Response, this.body = void 0 !== init.body ? init.body : null;
            }
            clone(update = {}) {
                return new HttpResponse({
                    body: void 0 !== update.body ? update.body : this.body,
                    headers: update.headers || this.headers,
                    status: void 0 !== update.status ? update.status : this.status,
                    statusText: update.statusText || this.statusText,
                    url: update.url || this.url || void 0
                });
            }
        }
        class HttpErrorResponse extends HttpResponseBase {
            constructor(init) {
                super(init, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, 
                this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${init.url || "(unknown url)"}` : `Http failure response for ${init.url || "(unknown url)"}: ${init.status} ${init.statusText}`, 
                this.error = init.error || null;
            }
        }
        function addBody(options, body) {
            return {
                body: body,
                headers: options.headers,
                observe: options.observe,
                params: options.params,
                reportProgress: options.reportProgress,
                responseType: options.responseType,
                withCredentials: options.withCredentials
            };
        }
        let HttpClient = (() => {
            class HttpClient {
                constructor(handler) {
                    this.handler = handler;
                }
                request(first, url, options = {}) {
                    let req;
                    if (first instanceof HttpRequest) req = first; else {
                        let headers = void 0;
                        headers = options.headers instanceof HttpHeaders ? options.headers : new HttpHeaders(options.headers);
                        let params = void 0;
                        options.params && (params = options.params instanceof HttpParams ? options.params : new HttpParams({
                            fromObject: options.params
                        })), req = new HttpRequest(first, url, void 0 !== options.body ? options.body : null, {
                            headers: headers,
                            params: params,
                            reportProgress: options.reportProgress,
                            responseType: options.responseType || "json",
                            withCredentials: options.withCredentials
                        });
                    }
                    const events$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(req).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)(req => this.handler.handle(req)));
                    if (first instanceof HttpRequest || "events" === options.observe) return events$;
                    const res$ = events$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)(event => event instanceof HttpResponse));
                    switch (options.observe || "body") {
                      case "body":
                        switch (req.responseType) {
                          case "arraybuffer":
                            return res$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)(res => {
                                if (null !== res.body && !(res.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer.");
                                return res.body;
                            }));

                          case "blob":
                            return res$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)(res => {
                                if (null !== res.body && !(res.body instanceof Blob)) throw new Error("Response is not a Blob.");
                                return res.body;
                            }));

                          case "text":
                            return res$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)(res => {
                                if (null !== res.body && "string" != typeof res.body) throw new Error("Response is not a string.");
                                return res.body;
                            }));

                          case "json":
                          default:
                            return res$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)(res => res.body));
                        }

                      case "response":
                        return res$;

                      default:
                        throw new Error(`Unreachable: unhandled observe type ${options.observe}}`);
                    }
                }
                delete(url, options = {}) {
                    return this.request("DELETE", url, options);
                }
                get(url, options = {}) {
                    return this.request("GET", url, options);
                }
                head(url, options = {}) {
                    return this.request("HEAD", url, options);
                }
                jsonp(url, callbackParam) {
                    return this.request("JSONP", url, {
                        params: (new HttpParams).append(callbackParam, "JSONP_CALLBACK"),
                        observe: "body",
                        responseType: "json"
                    });
                }
                options(url, options = {}) {
                    return this.request("OPTIONS", url, options);
                }
                patch(url, body, options = {}) {
                    return this.request("PATCH", url, addBody(options, body));
                }
                post(url, body, options = {}) {
                    return this.request("POST", url, addBody(options, body));
                }
                put(url, body, options = {}) {
                    return this.request("PUT", url, addBody(options, body));
                }
            }
            return HttpClient.ɵfac = function(t) {
                return new (t || HttpClient)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb(HttpHandler));
            }, HttpClient.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb({
                token: HttpClient,
                factory: function(t) {
                    return HttpClient.ɵfac(t);
                },
                providedIn: null
            }), HttpClient;
        })();
        class HttpInterceptorHandler {
            constructor(next, interceptor) {
                this.next = next, this.interceptor = interceptor;
            }
            handle(req) {
                return this.interceptor.intercept(req, this.next);
            }
        }
        const HTTP_INTERCEPTORS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.p("HTTP_INTERCEPTORS");
        let NoopInterceptor = (() => {
            class NoopInterceptor {
                intercept(req, next) {
                    return next.handle(req);
                }
            }
            return NoopInterceptor.ɵfac = function(t) {
                return new (t || NoopInterceptor);
            }, NoopInterceptor.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb({
                token: NoopInterceptor,
                factory: function(t) {
                    return NoopInterceptor.ɵfac(t);
                },
                providedIn: null
            }), NoopInterceptor;
        })();
        const XSSI_PREFIX = /^\)\]\}',?\n/;
        class XhrFactory {}
        let BrowserXhr = (() => {
            class BrowserXhr {
                constructor() {}
                build() {
                    return new XMLHttpRequest;
                }
            }
            return BrowserXhr.ɵfac = function(t) {
                return new (t || BrowserXhr);
            }, BrowserXhr.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb({
                token: BrowserXhr,
                factory: function(t) {
                    return BrowserXhr.ɵfac(t);
                },
                providedIn: null
            }), BrowserXhr;
        })(), HttpXhrBackend = (() => {
            class HttpXhrBackend {
                constructor(xhrFactory) {
                    this.xhrFactory = xhrFactory;
                }
                handle(req) {
                    if ("JSONP" === req.method) throw new Error("Attempted to construct Jsonp request without JsonpClientModule installed.");
                    return new rxjs__WEBPACK_IMPORTED_MODULE_2__.a(observer => {
                        const xhr = this.xhrFactory.build();
                        if (xhr.open(req.method, req.urlWithParams), req.withCredentials && (xhr.withCredentials = !0), 
                        req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(","))), 
                        req.headers.has("Accept") || xhr.setRequestHeader("Accept", "application/json, text/plain, */*"), 
                        !req.headers.has("Content-Type")) {
                            const detectedType = req.detectContentTypeHeader();
                            null !== detectedType && xhr.setRequestHeader("Content-Type", detectedType);
                        }
                        if (req.responseType) {
                            const responseType = req.responseType.toLowerCase();
                            xhr.responseType = "json" !== responseType ? responseType : "text";
                        }
                        const reqBody = req.serializeBody();
                        let headerResponse = null;
                        const partialFromXhr = () => {
                            if (null !== headerResponse) return headerResponse;
                            const status = 1223 === xhr.status ? 204 : xhr.status, statusText = xhr.statusText || "OK", headers = new HttpHeaders(xhr.getAllResponseHeaders()), url = function(xhr) {
                                return "responseURL" in xhr && xhr.responseURL ? xhr.responseURL : /^X-Request-URL:/m.test(xhr.getAllResponseHeaders()) ? xhr.getResponseHeader("X-Request-URL") : null;
                            }(xhr) || req.url;
                            return headerResponse = new HttpHeaderResponse({
                                headers: headers,
                                status: status,
                                statusText: statusText,
                                url: url
                            });
                        }, onLoad = () => {
                            let {headers: headers, status: status, statusText: statusText, url: url} = partialFromXhr(), body = null;
                            204 !== status && (body = void 0 === xhr.response ? xhr.responseText : xhr.response), 
                            0 === status && (status = body ? 200 : 0);
                            let ok = status >= 200 && status < 300;
                            if ("json" === req.responseType && "string" == typeof body) {
                                const originalBody = body;
                                body = body.replace(XSSI_PREFIX, "");
                                try {
                                    body = "" !== body ? JSON.parse(body) : null;
                                } catch (error) {
                                    body = originalBody, ok && (ok = !1, body = {
                                        error: error,
                                        text: body
                                    });
                                }
                            }
                            ok ? (observer.next(new HttpResponse({
                                body: body,
                                headers: headers,
                                status: status,
                                statusText: statusText,
                                url: url || void 0
                            })), observer.complete()) : observer.error(new HttpErrorResponse({
                                error: body,
                                headers: headers,
                                status: status,
                                statusText: statusText,
                                url: url || void 0
                            }));
                        }, onError = error => {
                            const {url: url} = partialFromXhr(), res = new HttpErrorResponse({
                                error: error,
                                status: xhr.status || 0,
                                statusText: xhr.statusText || "Unknown Error",
                                url: url || void 0
                            });
                            observer.error(res);
                        };
                        let sentHeaders = !1;
                        const onDownProgress = event => {
                            sentHeaders || (observer.next(partialFromXhr()), sentHeaders = !0);
                            let progressEvent = {
                                type: HttpEventType.DownloadProgress,
                                loaded: event.loaded
                            };
                            event.lengthComputable && (progressEvent.total = event.total), "text" === req.responseType && xhr.responseText && (progressEvent.partialText = xhr.responseText), 
                            observer.next(progressEvent);
                        }, onUpProgress = event => {
                            let progress = {
                                type: HttpEventType.UploadProgress,
                                loaded: event.loaded
                            };
                            event.lengthComputable && (progress.total = event.total), observer.next(progress);
                        };
                        return xhr.addEventListener("load", onLoad), xhr.addEventListener("error", onError), 
                        req.reportProgress && (xhr.addEventListener("progress", onDownProgress), null !== reqBody && xhr.upload && xhr.upload.addEventListener("progress", onUpProgress)), 
                        xhr.send(reqBody), observer.next({
                            type: HttpEventType.Sent
                        }), () => {
                            xhr.removeEventListener("error", onError), xhr.removeEventListener("load", onLoad), 
                            req.reportProgress && (xhr.removeEventListener("progress", onDownProgress), null !== reqBody && xhr.upload && xhr.upload.removeEventListener("progress", onUpProgress)), 
                            xhr.abort();
                        };
                    });
                }
            }
            return HttpXhrBackend.ɵfac = function(t) {
                return new (t || HttpXhrBackend)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb(XhrFactory));
            }, HttpXhrBackend.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb({
                token: HttpXhrBackend,
                factory: function(t) {
                    return HttpXhrBackend.ɵfac(t);
                },
                providedIn: null
            }), HttpXhrBackend;
        })();
        const XSRF_COOKIE_NAME = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.p("XSRF_COOKIE_NAME"), XSRF_HEADER_NAME = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.p("XSRF_HEADER_NAME");
        class HttpXsrfTokenExtractor {}
        let HttpXsrfCookieExtractor = (() => {
            class HttpXsrfCookieExtractor {
                constructor(doc, platform, cookieName) {
                    this.doc = doc, this.platform = platform, this.cookieName = cookieName, this.lastCookieString = "", 
                    this.lastToken = null, this.parseCount = 0;
                }
                getToken() {
                    if ("server" === this.platform) return null;
                    const cookieString = this.doc.cookie || "";
                    return cookieString !== this.lastCookieString && (this.parseCount++, this.lastToken = Object(_angular_common__WEBPACK_IMPORTED_MODULE_6__.w)(cookieString, this.cookieName), 
                    this.lastCookieString = cookieString), this.lastToken;
                }
            }
            return HttpXsrfCookieExtractor.ɵfac = function(t) {
                return new (t || HttpXsrfCookieExtractor)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb(_angular_common__WEBPACK_IMPORTED_MODULE_6__.d), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.A), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb(XSRF_COOKIE_NAME));
            }, HttpXsrfCookieExtractor.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb({
                token: HttpXsrfCookieExtractor,
                factory: function(t) {
                    return HttpXsrfCookieExtractor.ɵfac(t);
                },
                providedIn: null
            }), HttpXsrfCookieExtractor;
        })(), HttpXsrfInterceptor = (() => {
            class HttpXsrfInterceptor {
                constructor(tokenService, headerName) {
                    this.tokenService = tokenService, this.headerName = headerName;
                }
                intercept(req, next) {
                    const lcUrl = req.url.toLowerCase();
                    if ("GET" === req.method || "HEAD" === req.method || lcUrl.startsWith("http://") || lcUrl.startsWith("https://")) return next.handle(req);
                    const token = this.tokenService.getToken();
                    return null === token || req.headers.has(this.headerName) || (req = req.clone({
                        headers: req.headers.set(this.headerName, token)
                    })), next.handle(req);
                }
            }
            return HttpXsrfInterceptor.ɵfac = function(t) {
                return new (t || HttpXsrfInterceptor)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb(HttpXsrfTokenExtractor), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb(XSRF_HEADER_NAME));
            }, HttpXsrfInterceptor.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb({
                token: HttpXsrfInterceptor,
                factory: function(t) {
                    return HttpXsrfInterceptor.ɵfac(t);
                },
                providedIn: null
            }), HttpXsrfInterceptor;
        })(), HttpInterceptingHandler = (() => {
            class HttpInterceptingHandler {
                constructor(backend, injector) {
                    this.backend = backend, this.injector = injector, this.chain = null;
                }
                handle(req) {
                    if (null === this.chain) {
                        const interceptors = this.injector.get(HTTP_INTERCEPTORS, []);
                        this.chain = interceptors.reduceRight((next, interceptor) => new HttpInterceptorHandler(next, interceptor), this.backend);
                    }
                    return this.chain.handle(req);
                }
            }
            return HttpInterceptingHandler.ɵfac = function(t) {
                return new (t || HttpInterceptingHandler)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb(HttpBackend), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.q));
            }, HttpInterceptingHandler.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Lb({
                token: HttpInterceptingHandler,
                factory: function(t) {
                    return HttpInterceptingHandler.ɵfac(t);
                },
                providedIn: null
            }), HttpInterceptingHandler;
        })(), HttpClientXsrfModule = (() => {
            class HttpClientXsrfModule {
                static disable() {
                    return {
                        ngModule: HttpClientXsrfModule,
                        providers: [ {
                            provide: HttpXsrfInterceptor,
                            useClass: NoopInterceptor
                        } ]
                    };
                }
                static withOptions(options = {}) {
                    return {
                        ngModule: HttpClientXsrfModule,
                        providers: [ options.cookieName ? {
                            provide: XSRF_COOKIE_NAME,
                            useValue: options.cookieName
                        } : [], options.headerName ? {
                            provide: XSRF_HEADER_NAME,
                            useValue: options.headerName
                        } : [] ]
                    };
                }
            }
            return HttpClientXsrfModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Nb({
                type: HttpClientXsrfModule
            }), HttpClientXsrfModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Mb({
                factory: function(t) {
                    return new (t || HttpClientXsrfModule);
                },
                providers: [ HttpXsrfInterceptor, {
                    provide: HTTP_INTERCEPTORS,
                    useExisting: HttpXsrfInterceptor,
                    multi: !0
                }, {
                    provide: HttpXsrfTokenExtractor,
                    useClass: HttpXsrfCookieExtractor
                }, {
                    provide: XSRF_COOKIE_NAME,
                    useValue: "XSRF-TOKEN"
                }, {
                    provide: XSRF_HEADER_NAME,
                    useValue: "X-XSRF-TOKEN"
                } ]
            }), HttpClientXsrfModule;
        })(), HttpClientModule = (() => {
            class HttpClientModule {}
            return HttpClientModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Nb({
                type: HttpClientModule
            }), HttpClientModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Mb({
                factory: function(t) {
                    return new (t || HttpClientModule);
                },
                providers: [ HttpClient, {
                    provide: HttpHandler,
                    useClass: HttpInterceptingHandler
                }, HttpXhrBackend, {
                    provide: HttpBackend,
                    useExisting: HttpXhrBackend
                }, BrowserXhr, {
                    provide: XhrFactory,
                    useExisting: BrowserXhr
                } ],
                imports: [ [ HttpClientXsrfModule.withOptions({
                    cookieName: "XSRF-TOKEN",
                    headerName: "X-XSRF-TOKEN"
                }) ] ]
            }), HttpClientModule;
        })();
    },
    to4i: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        (function(__webpack__worker__0) {
            __webpack_require__.d(__webpack_exports__, "a", (function() {
                return SearchService;
            }));
            var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("jtHE"), rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("Nv8m"), rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("PqYM"), rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("SxV6"), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("bOdf"), rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("05l1"), app_shared_web_worker__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("hqch"), _angular_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("fXoL");
            let SearchService = (() => {
                class SearchService {
                    constructor(zone) {
                        this.zone = zone, this.searchesSubject = new rxjs__WEBPACK_IMPORTED_MODULE_0__.a(1);
                    }
                    initWorker(initDelay) {
                        const ready = this.ready = Object(rxjs__WEBPACK_IMPORTED_MODULE_1__.a)(Object(rxjs__WEBPACK_IMPORTED_MODULE_2__.a)(initDelay), this.searchesSubject.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)())).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)(() => {
                            const worker = new Worker(__webpack__worker__0, {});
                            return this.worker = app_shared_web_worker__WEBPACK_IMPORTED_MODULE_6__.a.create(worker, this.zone), 
                            this.worker.sendMessage("load-index");
                        }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.a)(1));
                        return ready.connect(), ready;
                    }
                    search(query) {
                        return this.searchesSubject.next(query), this.ready.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)(() => this.worker.sendMessage("query-index", query)));
                    }
                }
                return SearchService.ɵfac = function(t) {
                    return new (t || SearchService)(_angular_core__WEBPACK_IMPORTED_MODULE_7__.Zb(_angular_core__WEBPACK_IMPORTED_MODULE_7__.y));
                }, SearchService.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_7__.Lb({
                    token: SearchService,
                    factory: function(t) {
                        return SearchService.ɵfac(t);
                    },
                    providedIn: null
                }), SearchService;
            })();
        }).call(this, __webpack_require__("XQjc"));
    },
    u47x: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "c", (function() {
            return FocusKeyManager;
        })), __webpack_require__.d(__webpack_exports__, "e", (function() {
            return FocusTrapFactory;
        })), __webpack_require__.d(__webpack_exports__, "f", (function() {
            return LiveAnnouncer;
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return FocusMonitor;
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return CdkMonitorFocus;
        })), __webpack_require__.d(__webpack_exports__, "g", (function() {
            return isFakeMousedownFromScreenReader;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return A11yModule;
        }));
        var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ofXK"), _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("fXoL"), rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("XNiG"), rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("quSY"), rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("LRne"), _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("FtGj"), rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("vkgz"), rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("Kj3r"), rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("pLZG"), rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("lJxs"), rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("IzEk"), _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("8LU1"), _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("nLfN"), _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("GU7r");
        class ListKeyManager {
            constructor(_items) {
                this._items = _items, this._activeItemIndex = -1, this._activeItem = null, this._wrap = !1, 
                this._letterKeyStream = new rxjs__WEBPACK_IMPORTED_MODULE_2__.a, this._typeaheadSubscription = rxjs__WEBPACK_IMPORTED_MODULE_3__.a.EMPTY, 
                this._vertical = !0, this._allowedModifierKeys = [], this._skipPredicateFn = item => item.disabled, 
                this._pressedLetters = [], this.tabOut = new rxjs__WEBPACK_IMPORTED_MODULE_2__.a, 
                this.change = new rxjs__WEBPACK_IMPORTED_MODULE_2__.a, _items instanceof _angular_core__WEBPACK_IMPORTED_MODULE_1__.C && _items.changes.subscribe(newItems => {
                    if (this._activeItem) {
                        const newIndex = newItems.toArray().indexOf(this._activeItem);
                        newIndex > -1 && newIndex !== this._activeItemIndex && (this._activeItemIndex = newIndex);
                    }
                });
            }
            skipPredicate(predicate) {
                return this._skipPredicateFn = predicate, this;
            }
            withWrap(shouldWrap = !0) {
                return this._wrap = shouldWrap, this;
            }
            withVerticalOrientation(enabled = !0) {
                return this._vertical = enabled, this;
            }
            withHorizontalOrientation(direction) {
                return this._horizontal = direction, this;
            }
            withAllowedModifierKeys(keys) {
                return this._allowedModifierKeys = keys, this;
            }
            withTypeAhead(debounceInterval = 200) {
                if (this._items.length && this._items.some(item => "function" != typeof item.getLabel)) throw Error("ListKeyManager items in typeahead mode must implement the `getLabel` method.");
                return this._typeaheadSubscription.unsubscribe(), this._typeaheadSubscription = this._letterKeyStream.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.a)(keyCode => this._pressedLetters.push(keyCode)), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.a)(debounceInterval), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.a)(() => this._pressedLetters.length > 0), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.a)(() => this._pressedLetters.join(""))).subscribe(inputString => {
                    const items = this._getItemsArray();
                    for (let i = 1; i < items.length + 1; i++) {
                        const index = (this._activeItemIndex + i) % items.length, item = items[index];
                        if (!this._skipPredicateFn(item) && 0 === item.getLabel().toUpperCase().trim().indexOf(inputString)) {
                            this.setActiveItem(index);
                            break;
                        }
                    }
                    this._pressedLetters = [];
                }), this;
            }
            setActiveItem(item) {
                const previousIndex = this._activeItemIndex;
                this.updateActiveItem(item), this._activeItemIndex !== previousIndex && this.change.next(this._activeItemIndex);
            }
            onKeydown(event) {
                const keyCode = event.keyCode, isModifierAllowed = [ "altKey", "ctrlKey", "metaKey", "shiftKey" ].every(modifier => !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1);
                switch (keyCode) {
                  case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.k:
                    return void this.tabOut.next();

                  case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.b:
                    if (this._vertical && isModifierAllowed) {
                        this.setNextItemActive();
                        break;
                    }
                    return;

                  case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.l:
                    if (this._vertical && isModifierAllowed) {
                        this.setPreviousItemActive();
                        break;
                    }
                    return;

                  case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.i:
                    if (this._horizontal && isModifierAllowed) {
                        "rtl" === this._horizontal ? this.setPreviousItemActive() : this.setNextItemActive();
                        break;
                    }
                    return;

                  case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.g:
                    if (this._horizontal && isModifierAllowed) {
                        "rtl" === this._horizontal ? this.setNextItemActive() : this.setPreviousItemActive();
                        break;
                    }
                    return;

                  default:
                    return void ((isModifierAllowed || Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.o)(event, "shiftKey")) && (event.key && 1 === event.key.length ? this._letterKeyStream.next(event.key.toLocaleUpperCase()) : (keyCode >= _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.a && keyCode <= _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.m || keyCode >= _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.n && keyCode <= _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.h) && this._letterKeyStream.next(String.fromCharCode(keyCode))));
                }
                this._pressedLetters = [], event.preventDefault();
            }
            get activeItemIndex() {
                return this._activeItemIndex;
            }
            get activeItem() {
                return this._activeItem;
            }
            setFirstItemActive() {
                this._setActiveItemByIndex(0, 1);
            }
            setLastItemActive() {
                this._setActiveItemByIndex(this._items.length - 1, -1);
            }
            setNextItemActive() {
                this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);
            }
            setPreviousItemActive() {
                this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive() : this._setActiveItemByDelta(-1);
            }
            updateActiveItem(item) {
                const itemArray = this._getItemsArray(), index = "number" == typeof item ? item : itemArray.indexOf(item), activeItem = itemArray[index];
                this._activeItem = null == activeItem ? null : activeItem, this._activeItemIndex = index;
            }
            updateActiveItemIndex(index) {
                this.updateActiveItem(index);
            }
            _setActiveItemByDelta(delta) {
                this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);
            }
            _setActiveInWrapMode(delta) {
                const items = this._getItemsArray();
                for (let i = 1; i <= items.length; i++) {
                    const index = (this._activeItemIndex + delta * i + items.length) % items.length;
                    if (!this._skipPredicateFn(items[index])) return void this.setActiveItem(index);
                }
            }
            _setActiveInDefaultMode(delta) {
                this._setActiveItemByIndex(this._activeItemIndex + delta, delta);
            }
            _setActiveItemByIndex(index, fallbackDelta) {
                const items = this._getItemsArray();
                if (items[index]) {
                    for (;this._skipPredicateFn(items[index]); ) if (!items[index += fallbackDelta]) return;
                    this.setActiveItem(index);
                }
            }
            _getItemsArray() {
                return this._items instanceof _angular_core__WEBPACK_IMPORTED_MODULE_1__.C ? this._items.toArray() : this._items;
            }
        }
        class FocusKeyManager extends ListKeyManager {
            constructor() {
                super(...arguments), this._origin = "program";
            }
            setFocusOrigin(origin) {
                return this._origin = origin, this;
            }
            setActiveItem(item) {
                super.setActiveItem(item), this.activeItem && this.activeItem.focus(this._origin);
            }
        }
        let InteractivityChecker = (() => {
            class InteractivityChecker {
                constructor(_platform) {
                    this._platform = _platform;
                }
                isDisabled(element) {
                    return element.hasAttribute("disabled");
                }
                isVisible(element) {
                    return function(element) {
                        return !!(element.offsetWidth || element.offsetHeight || "function" == typeof element.getClientRects && element.getClientRects().length);
                    }(element) && "visible" === getComputedStyle(element).visibility;
                }
                isTabbable(element) {
                    if (!this._platform.isBrowser) return !1;
                    const frameElement = function(window) {
                        try {
                            return window.frameElement;
                        } catch (_a) {
                            return null;
                        }
                    }((node = element).ownerDocument && node.ownerDocument.defaultView || window);
                    var node;
                    if (frameElement) {
                        const frameType = frameElement && frameElement.nodeName.toLowerCase();
                        if (-1 === getTabIndexValue(frameElement)) return !1;
                        if ((this._platform.BLINK || this._platform.WEBKIT) && "object" === frameType) return !1;
                        if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) return !1;
                    }
                    let nodeName = element.nodeName.toLowerCase(), tabIndexValue = getTabIndexValue(element);
                    if (element.hasAttribute("contenteditable")) return -1 !== tabIndexValue;
                    if ("iframe" === nodeName) return !1;
                    if ("audio" === nodeName) {
                        if (!element.hasAttribute("controls")) return !1;
                        if (this._platform.BLINK) return !0;
                    }
                    if ("video" === nodeName) {
                        if (!element.hasAttribute("controls") && this._platform.TRIDENT) return !1;
                        if (this._platform.BLINK || this._platform.FIREFOX) return !0;
                    }
                    return ("object" !== nodeName || !this._platform.BLINK && !this._platform.WEBKIT) && !(this._platform.WEBKIT && this._platform.IOS && !function(element) {
                        let nodeName = element.nodeName.toLowerCase(), inputType = "input" === nodeName && element.type;
                        return "text" === inputType || "password" === inputType || "select" === nodeName || "textarea" === nodeName;
                    }(element)) && element.tabIndex >= 0;
                }
                isFocusable(element) {
                    return function(element) {
                        return !function(element) {
                            return function(element) {
                                return "input" == element.nodeName.toLowerCase();
                            }(element) && "hidden" == element.type;
                        }(element) && (function(element) {
                            let nodeName = element.nodeName.toLowerCase();
                            return "input" === nodeName || "select" === nodeName || "button" === nodeName || "textarea" === nodeName;
                        }(element) || function(element) {
                            return function(element) {
                                return "a" == element.nodeName.toLowerCase();
                            }(element) && element.hasAttribute("href");
                        }(element) || element.hasAttribute("contenteditable") || hasValidTabIndex(element));
                    }(element) && !this.isDisabled(element) && this.isVisible(element);
                }
            }
            return InteractivityChecker.ɵfac = function(t) {
                return new (t || InteractivityChecker)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__.a));
            }, InteractivityChecker.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb({
                token: InteractivityChecker,
                factory: function(t) {
                    return InteractivityChecker.ɵfac(t);
                },
                providedIn: "root"
            }), InteractivityChecker.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb)({
                factory: function() {
                    return new InteractivityChecker(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb)(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__.a));
                },
                token: InteractivityChecker,
                providedIn: "root"
            }), InteractivityChecker;
        })();
        function hasValidTabIndex(element) {
            if (!element.hasAttribute("tabindex") || void 0 === element.tabIndex) return !1;
            let tabIndex = element.getAttribute("tabindex");
            return "-32768" != tabIndex && !(!tabIndex || isNaN(parseInt(tabIndex, 10)));
        }
        function getTabIndexValue(element) {
            if (!hasValidTabIndex(element)) return null;
            const tabIndex = parseInt(element.getAttribute("tabindex") || "", 10);
            return isNaN(tabIndex) ? -1 : tabIndex;
        }
        class FocusTrap {
            constructor(_element, _checker, _ngZone, _document, deferAnchors = !1) {
                this._element = _element, this._checker = _checker, this._ngZone = _ngZone, this._document = _document, 
                this._hasAttached = !1, this.startAnchorListener = () => this.focusLastTabbableElement(), 
                this.endAnchorListener = () => this.focusFirstTabbableElement(), this._enabled = !0, 
                deferAnchors || this.attachAnchors();
            }
            get enabled() {
                return this._enabled;
            }
            set enabled(value) {
                this._enabled = value, this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(value, this._startAnchor), 
                this._toggleAnchorTabIndex(value, this._endAnchor));
            }
            destroy() {
                const startAnchor = this._startAnchor, endAnchor = this._endAnchor;
                startAnchor && (startAnchor.removeEventListener("focus", this.startAnchorListener), 
                startAnchor.parentNode && startAnchor.parentNode.removeChild(startAnchor)), endAnchor && (endAnchor.removeEventListener("focus", this.endAnchorListener), 
                endAnchor.parentNode && endAnchor.parentNode.removeChild(endAnchor)), this._startAnchor = this._endAnchor = null;
            }
            attachAnchors() {
                return !!this._hasAttached || (this._ngZone.runOutsideAngular(() => {
                    this._startAnchor || (this._startAnchor = this._createAnchor(), this._startAnchor.addEventListener("focus", this.startAnchorListener)), 
                    this._endAnchor || (this._endAnchor = this._createAnchor(), this._endAnchor.addEventListener("focus", this.endAnchorListener));
                }), this._element.parentNode && (this._element.parentNode.insertBefore(this._startAnchor, this._element), 
                this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling), 
                this._hasAttached = !0), this._hasAttached);
            }
            focusInitialElementWhenReady() {
                return new Promise(resolve => {
                    this._executeOnStable(() => resolve(this.focusInitialElement()));
                });
            }
            focusFirstTabbableElementWhenReady() {
                return new Promise(resolve => {
                    this._executeOnStable(() => resolve(this.focusFirstTabbableElement()));
                });
            }
            focusLastTabbableElementWhenReady() {
                return new Promise(resolve => {
                    this._executeOnStable(() => resolve(this.focusLastTabbableElement()));
                });
            }
            _getRegionBoundary(bound) {
                let markers = this._element.querySelectorAll(`[cdk-focus-region-${bound}], ` + `[cdkFocusRegion${bound}], ` + `[cdk-focus-${bound}]`);
                for (let i = 0; i < markers.length; i++) markers[i].hasAttribute(`cdk-focus-${bound}`) ? console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}', ` + `use 'cdkFocusRegion${bound}' instead. The deprecated ` + "attribute will be removed in 8.0.0.", markers[i]) : markers[i].hasAttribute(`cdk-focus-region-${bound}`) && console.warn(`Found use of deprecated attribute 'cdk-focus-region-${bound}', ` + `use 'cdkFocusRegion${bound}' instead. The deprecated attribute ` + "will be removed in 8.0.0.", markers[i]);
                return "start" == bound ? markers.length ? markers[0] : this._getFirstTabbableElement(this._element) : markers.length ? markers[markers.length - 1] : this._getLastTabbableElement(this._element);
            }
            focusInitialElement() {
                const redirectToElement = this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]");
                return redirectToElement ? (redirectToElement.hasAttribute("cdk-focus-initial") && console.warn("Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0", redirectToElement), 
                Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.W)() && !this._checker.isFocusable(redirectToElement) && console.warn("Element matching '[cdkFocusInitial]' is not focusable.", redirectToElement), 
                redirectToElement.focus(), !0) : this.focusFirstTabbableElement();
            }
            focusFirstTabbableElement() {
                const redirectToElement = this._getRegionBoundary("start");
                return redirectToElement && redirectToElement.focus(), !!redirectToElement;
            }
            focusLastTabbableElement() {
                const redirectToElement = this._getRegionBoundary("end");
                return redirectToElement && redirectToElement.focus(), !!redirectToElement;
            }
            hasAttached() {
                return this._hasAttached;
            }
            _getFirstTabbableElement(root) {
                if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) return root;
                let children = root.children || root.childNodes;
                for (let i = 0; i < children.length; i++) {
                    let tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(children[i]) : null;
                    if (tabbableChild) return tabbableChild;
                }
                return null;
            }
            _getLastTabbableElement(root) {
                if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) return root;
                let children = root.children || root.childNodes;
                for (let i = children.length - 1; i >= 0; i--) {
                    let tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(children[i]) : null;
                    if (tabbableChild) return tabbableChild;
                }
                return null;
            }
            _createAnchor() {
                const anchor = this._document.createElement("div");
                return this._toggleAnchorTabIndex(this._enabled, anchor), anchor.classList.add("cdk-visually-hidden"), 
                anchor.classList.add("cdk-focus-trap-anchor"), anchor.setAttribute("aria-hidden", "true"), 
                anchor;
            }
            _toggleAnchorTabIndex(isEnabled, anchor) {
                isEnabled ? anchor.setAttribute("tabindex", "0") : anchor.removeAttribute("tabindex");
            }
            _executeOnStable(fn) {
                this._ngZone.isStable ? fn() : this._ngZone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.a)(1)).subscribe(fn);
            }
        }
        let FocusTrapFactory = (() => {
            class FocusTrapFactory {
                constructor(_checker, _ngZone, _document) {
                    this._checker = _checker, this._ngZone = _ngZone, this._document = _document;
                }
                create(element, deferCaptureElements = !1) {
                    return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);
                }
            }
            return FocusTrapFactory.ɵfac = function(t) {
                return new (t || FocusTrapFactory)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(InteractivityChecker), _angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(_angular_core__WEBPACK_IMPORTED_MODULE_1__.y), _angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(_angular_common__WEBPACK_IMPORTED_MODULE_0__.d));
            }, FocusTrapFactory.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb({
                token: FocusTrapFactory,
                factory: function(t) {
                    return FocusTrapFactory.ɵfac(t);
                },
                providedIn: "root"
            }), FocusTrapFactory.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb)({
                factory: function() {
                    return new FocusTrapFactory(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb)(InteractivityChecker), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.y), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb)(_angular_common__WEBPACK_IMPORTED_MODULE_0__.d));
                },
                token: FocusTrapFactory,
                providedIn: "root"
            }), FocusTrapFactory;
        })();
        const LIVE_ANNOUNCER_ELEMENT_TOKEN = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.p("liveAnnouncerElement", {
            providedIn: "root",
            factory: function() {
                return null;
            }
        }), LIVE_ANNOUNCER_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.p("LIVE_ANNOUNCER_DEFAULT_OPTIONS");
        let LiveAnnouncer = (() => {
            class LiveAnnouncer {
                constructor(elementToken, _ngZone, _document, _defaultOptions) {
                    this._ngZone = _ngZone, this._defaultOptions = _defaultOptions, this._document = _document, 
                    this._liveElement = elementToken || this._createLiveElement();
                }
                announce(message, ...args) {
                    const defaultOptions = this._defaultOptions;
                    let politeness, duration;
                    return 1 === args.length && "number" == typeof args[0] ? duration = args[0] : [politeness, duration] = args, 
                    this.clear(), clearTimeout(this._previousTimeout), politeness || (politeness = defaultOptions && defaultOptions.politeness ? defaultOptions.politeness : "polite"), 
                    null == duration && defaultOptions && (duration = defaultOptions.duration), this._liveElement.setAttribute("aria-live", politeness), 
                    this._ngZone.runOutsideAngular(() => new Promise(resolve => {
                        clearTimeout(this._previousTimeout), this._previousTimeout = setTimeout(() => {
                            this._liveElement.textContent = message, resolve(), "number" == typeof duration && (this._previousTimeout = setTimeout(() => this.clear(), duration));
                        }, 100);
                    }));
                }
                clear() {
                    this._liveElement && (this._liveElement.textContent = "");
                }
                ngOnDestroy() {
                    clearTimeout(this._previousTimeout), this._liveElement && this._liveElement.parentNode && (this._liveElement.parentNode.removeChild(this._liveElement), 
                    this._liveElement = null);
                }
                _createLiveElement() {
                    const previousElements = this._document.getElementsByClassName("cdk-live-announcer-element"), liveEl = this._document.createElement("div");
                    for (let i = 0; i < previousElements.length; i++) previousElements[i].parentNode.removeChild(previousElements[i]);
                    return liveEl.classList.add("cdk-live-announcer-element"), liveEl.classList.add("cdk-visually-hidden"), 
                    liveEl.setAttribute("aria-atomic", "true"), liveEl.setAttribute("aria-live", "polite"), 
                    this._document.body.appendChild(liveEl), liveEl;
                }
            }
            return LiveAnnouncer.ɵfac = function(t) {
                return new (t || LiveAnnouncer)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), _angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(_angular_core__WEBPACK_IMPORTED_MODULE_1__.y), _angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(_angular_common__WEBPACK_IMPORTED_MODULE_0__.d), _angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(LIVE_ANNOUNCER_DEFAULT_OPTIONS, 8));
            }, LiveAnnouncer.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb({
                token: LiveAnnouncer,
                factory: function(t) {
                    return LiveAnnouncer.ɵfac(t);
                },
                providedIn: "root"
            }), LiveAnnouncer.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb)({
                factory: function() {
                    return new LiveAnnouncer(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb)(LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.y), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb)(_angular_common__WEBPACK_IMPORTED_MODULE_0__.d), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb)(LIVE_ANNOUNCER_DEFAULT_OPTIONS, 8));
                },
                token: LiveAnnouncer,
                providedIn: "root"
            }), LiveAnnouncer;
        })();
        const TOUCH_BUFFER_MS = 650, captureEventListenerOptions = Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__.e)({
            passive: !0,
            capture: !0
        });
        let FocusMonitor = (() => {
            class FocusMonitor {
                constructor(_ngZone, _platform) {
                    this._ngZone = _ngZone, this._platform = _platform, this._origin = null, this._windowFocused = !1, 
                    this._elementInfo = new Map, this._monitoredElementCount = 0, this._documentKeydownListener = () => {
                        this._lastTouchTarget = null, this._setOriginForCurrentEventQueue("keyboard");
                    }, this._documentMousedownListener = () => {
                        this._lastTouchTarget || this._setOriginForCurrentEventQueue("mouse");
                    }, this._documentTouchstartListener = event => {
                        null != this._touchTimeoutId && clearTimeout(this._touchTimeoutId), this._lastTouchTarget = event.composedPath ? event.composedPath()[0] : event.target, 
                        this._touchTimeoutId = setTimeout(() => this._lastTouchTarget = null, TOUCH_BUFFER_MS);
                    }, this._windowFocusListener = () => {
                        this._windowFocused = !0, this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = !1);
                    };
                }
                monitor(element, checkChildren = !1) {
                    if (!this._platform.isBrowser) return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__.a)(null);
                    const nativeElement = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_11__.d)(element);
                    if (this._elementInfo.has(nativeElement)) {
                        let cachedInfo = this._elementInfo.get(nativeElement);
                        return cachedInfo.checkChildren = checkChildren, cachedInfo.subject.asObservable();
                    }
                    let info = {
                        unlisten: () => {},
                        checkChildren: checkChildren,
                        subject: new rxjs__WEBPACK_IMPORTED_MODULE_2__.a
                    };
                    this._elementInfo.set(nativeElement, info), this._incrementMonitoredElementCount();
                    let focusListener = event => this._onFocus(event, nativeElement), blurListener = event => this._onBlur(event, nativeElement);
                    return this._ngZone.runOutsideAngular(() => {
                        nativeElement.addEventListener("focus", focusListener, !0), nativeElement.addEventListener("blur", blurListener, !0);
                    }), info.unlisten = () => {
                        nativeElement.removeEventListener("focus", focusListener, !0), nativeElement.removeEventListener("blur", blurListener, !0);
                    }, info.subject.asObservable();
                }
                stopMonitoring(element) {
                    const nativeElement = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_11__.d)(element), elementInfo = this._elementInfo.get(nativeElement);
                    elementInfo && (elementInfo.unlisten(), elementInfo.subject.complete(), this._setClasses(nativeElement), 
                    this._elementInfo.delete(nativeElement), this._decrementMonitoredElementCount());
                }
                focusVia(element, origin, options) {
                    const nativeElement = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_11__.d)(element);
                    this._setOriginForCurrentEventQueue(origin), "function" == typeof nativeElement.focus && nativeElement.focus(options);
                }
                ngOnDestroy() {
                    this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));
                }
                _toggleClass(element, className, shouldSet) {
                    shouldSet ? element.classList.add(className) : element.classList.remove(className);
                }
                _setClasses(element, origin) {
                    this._elementInfo.get(element) && (this._toggleClass(element, "cdk-focused", !!origin), 
                    this._toggleClass(element, "cdk-touch-focused", "touch" === origin), this._toggleClass(element, "cdk-keyboard-focused", "keyboard" === origin), 
                    this._toggleClass(element, "cdk-mouse-focused", "mouse" === origin), this._toggleClass(element, "cdk-program-focused", "program" === origin));
                }
                _setOriginForCurrentEventQueue(origin) {
                    this._ngZone.runOutsideAngular(() => {
                        this._origin = origin, this._originTimeoutId = setTimeout(() => this._origin = null, 1);
                    });
                }
                _wasCausedByTouch(event) {
                    let focusTarget = event.target;
                    return this._lastTouchTarget instanceof Node && focusTarget instanceof Node && (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));
                }
                _onFocus(event, element) {
                    const elementInfo = this._elementInfo.get(element);
                    if (!elementInfo || !elementInfo.checkChildren && element !== event.target) return;
                    let origin = this._origin;
                    origin || (origin = this._windowFocused && this._lastFocusOrigin ? this._lastFocusOrigin : this._wasCausedByTouch(event) ? "touch" : "program"), 
                    this._setClasses(element, origin), this._emitOrigin(elementInfo.subject, origin), 
                    this._lastFocusOrigin = origin;
                }
                _onBlur(event, element) {
                    const elementInfo = this._elementInfo.get(element);
                    !elementInfo || elementInfo.checkChildren && event.relatedTarget instanceof Node && element.contains(event.relatedTarget) || (this._setClasses(element), 
                    this._emitOrigin(elementInfo.subject, null));
                }
                _emitOrigin(subject, origin) {
                    this._ngZone.run(() => subject.next(origin));
                }
                _incrementMonitoredElementCount() {
                    1 == ++this._monitoredElementCount && this._platform.isBrowser && this._ngZone.runOutsideAngular(() => {
                        document.addEventListener("keydown", this._documentKeydownListener, captureEventListenerOptions), 
                        document.addEventListener("mousedown", this._documentMousedownListener, captureEventListenerOptions), 
                        document.addEventListener("touchstart", this._documentTouchstartListener, captureEventListenerOptions), 
                        window.addEventListener("focus", this._windowFocusListener);
                    });
                }
                _decrementMonitoredElementCount() {
                    --this._monitoredElementCount || (document.removeEventListener("keydown", this._documentKeydownListener, captureEventListenerOptions), 
                    document.removeEventListener("mousedown", this._documentMousedownListener, captureEventListenerOptions), 
                    document.removeEventListener("touchstart", this._documentTouchstartListener, captureEventListenerOptions), 
                    window.removeEventListener("focus", this._windowFocusListener), clearTimeout(this._windowFocusTimeoutId), 
                    clearTimeout(this._touchTimeoutId), clearTimeout(this._originTimeoutId));
                }
            }
            return FocusMonitor.ɵfac = function(t) {
                return new (t || FocusMonitor)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(_angular_core__WEBPACK_IMPORTED_MODULE_1__.y), _angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__.a));
            }, FocusMonitor.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb({
                token: FocusMonitor,
                factory: function(t) {
                    return FocusMonitor.ɵfac(t);
                },
                providedIn: "root"
            }), FocusMonitor.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb)({
                factory: function() {
                    return new FocusMonitor(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.y), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb)(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__.a));
                },
                token: FocusMonitor,
                providedIn: "root"
            }), FocusMonitor;
        })(), CdkMonitorFocus = (() => {
            class CdkMonitorFocus {
                constructor(_elementRef, _focusMonitor) {
                    this._elementRef = _elementRef, this._focusMonitor = _focusMonitor, this.cdkFocusChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.m, 
                    this._monitorSubscription = this._focusMonitor.monitor(this._elementRef, this._elementRef.nativeElement.hasAttribute("cdkMonitorSubtreeFocus")).subscribe(origin => this.cdkFocusChange.emit(origin));
                }
                ngOnDestroy() {
                    this._focusMonitor.stopMonitoring(this._elementRef), this._monitorSubscription.unsubscribe();
                }
            }
            return CdkMonitorFocus.ɵfac = function(t) {
                return new (t || CdkMonitorFocus)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_1__.k), _angular_core__WEBPACK_IMPORTED_MODULE_1__.Pb(FocusMonitor));
            }, CdkMonitorFocus.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Kb({
                type: CdkMonitorFocus,
                selectors: [ [ "", "cdkMonitorElementFocus", "" ], [ "", "cdkMonitorSubtreeFocus", "" ] ],
                outputs: {
                    cdkFocusChange: "cdkFocusChange"
                }
            }), CdkMonitorFocus;
        })();
        function isFakeMousedownFromScreenReader(event) {
            return 0 === event.buttons;
        }
        let A11yModule = (() => {
            class A11yModule {}
            return A11yModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Nb({
                type: A11yModule
            }), A11yModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Mb({
                factory: function(t) {
                    return new (t || A11yModule);
                },
                imports: [ [ _angular_common__WEBPACK_IMPORTED_MODULE_0__.c, _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__.b, _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_13__.c ] ]
            }), A11yModule;
        })();
    },
    vHPH: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return Logger;
        }));
        var _environments_environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("AytR"), _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("fXoL");
        let Logger = (() => {
            class Logger {
                constructor(errorHandler) {
                    this.errorHandler = errorHandler;
                }
                log(value, ...rest) {
                    _environments_environment__WEBPACK_IMPORTED_MODULE_0__.a.production || console.log(value, ...rest);
                }
                error(error) {
                    this.errorHandler.handleError(error);
                }
                warn(value, ...rest) {
                    console.warn(value, ...rest);
                }
            }
            return Logger.ɵfac = function(t) {
                return new (t || Logger)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.Zb(_angular_core__WEBPACK_IMPORTED_MODULE_1__.l));
            }, Logger.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__.Lb({
                token: Logger,
                factory: function(t) {
                    return Logger.ɵfac(t);
                },
                providedIn: null
            }), Logger;
        })();
    },
    vVVL: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return PrettyPrinter;
        }));
        var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("Cfvw"), rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("w1tV"), rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("lJxs"), rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("SxV6"), _angular_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("fXoL"), app_shared_logger_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("vHPH");
        let PrettyPrinter = (() => {
            class PrettyPrinter {
                constructor(logger) {
                    this.logger = logger, this.prettyPrintOne = Object(rxjs__WEBPACK_IMPORTED_MODULE_0__.a)(this.getPrettyPrintOne()).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.a)());
                }
                getPrettyPrintOne() {
                    const ppo = window.prettyPrintOne;
                    return ppo ? Promise.resolve(ppo) : __webpack_require__.e(1).then(__webpack_require__.t.bind(null, "Ue1H", 7)).then(() => window.prettyPrintOne, err => {
                        const msg = `Cannot get prettify.js from server: ${err.message}`;
                        return this.logger.error(new Error(msg)), () => {
                            throw new Error(msg);
                        };
                    });
                }
                formatCode(code, language, linenums) {
                    return this.prettyPrintOne.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.a)(ppo => {
                        try {
                            return ppo(code, language, linenums);
                        } catch (err) {
                            const msg = `Could not format code that begins '${code.substr(0, 50)}...'.`;
                            throw console.error(msg, err), new Error(msg);
                        }
                    }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.a)());
                }
            }
            return PrettyPrinter.ɵfac = function(t) {
                return new (t || PrettyPrinter)(_angular_core__WEBPACK_IMPORTED_MODULE_4__.Zb(app_shared_logger_service__WEBPACK_IMPORTED_MODULE_5__.a));
            }, PrettyPrinter.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_4__.Lb({
                token: PrettyPrinter,
                factory: function(t) {
                    return PrettyPrinter.ɵfac(t);
                },
                providedIn: null
            }), PrettyPrinter;
        })();
    },
    vkgz: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return tap;
        }));
        var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7o/Q"), _util_noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("KqfI"), _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("n6bG");
        function tap(nextOrObserver, error, complete) {
            return function(source) {
                return source.lift(new DoOperator(nextOrObserver, error, complete));
            };
        }
        class DoOperator {
            constructor(nextOrObserver, error, complete) {
                this.nextOrObserver = nextOrObserver, this.error = error, this.complete = complete;
            }
            call(subscriber, source) {
                return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
            }
        }
        class TapSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(destination, observerOrNext, error, complete) {
                super(destination), this._tapNext = _util_noop__WEBPACK_IMPORTED_MODULE_1__.a, this._tapError = _util_noop__WEBPACK_IMPORTED_MODULE_1__.a, 
                this._tapComplete = _util_noop__WEBPACK_IMPORTED_MODULE_1__.a, this._tapError = error || _util_noop__WEBPACK_IMPORTED_MODULE_1__.a, 
                this._tapComplete = complete || _util_noop__WEBPACK_IMPORTED_MODULE_1__.a, Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__.a)(observerOrNext) ? (this._context = this, 
                this._tapNext = observerOrNext) : observerOrNext && (this._context = observerOrNext, 
                this._tapNext = observerOrNext.next || _util_noop__WEBPACK_IMPORTED_MODULE_1__.a, 
                this._tapError = observerOrNext.error || _util_noop__WEBPACK_IMPORTED_MODULE_1__.a, 
                this._tapComplete = observerOrNext.complete || _util_noop__WEBPACK_IMPORTED_MODULE_1__.a);
            }
            _next(value) {
                try {
                    this._tapNext.call(this._context, value);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.next(value);
            }
            _error(err) {
                try {
                    this._tapError.call(this._context, err);
                } catch (err) {
                    return void this.destination.error(err);
                }
                this.destination.error(err);
            }
            _complete() {
                try {
                    this._tapComplete.call(this._context);
                } catch (err) {
                    return void this.destination.error(err);
                }
                return this.destination.complete();
            }
        }
    },
    vxfF: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__("8LU1");
        var core = __webpack_require__("fXoL"), Subject = __webpack_require__("XNiG"), of = __webpack_require__("LRne"), Observable = __webpack_require__("HDdC"), fromEvent = __webpack_require__("xgIS");
        __webpack_require__("3N8a"), __webpack_require__("IjjT"), __webpack_require__("7Hc7");
        var merge = __webpack_require__("VRyK"), auditTime = (__webpack_require__("/uUt"), 
        __webpack_require__("3UWI")), filter = __webpack_require__("pLZG"), takeUntil = __webpack_require__("1G5W");
        __webpack_require__("JX91"), __webpack_require__("7o/Q"), __webpack_require__("eIep"), 
        __webpack_require__("jtHE");
        var platform = __webpack_require__("nLfN"), bidi = __webpack_require__("cH1L");
        __webpack_require__.d(__webpack_exports__, "b", (function() {
            return scrolling_ScrollDispatcher;
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return scrolling_CdkScrollable;
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return scrolling_ScrollingModule;
        })), __webpack_require__.d(__webpack_exports__, "e", (function() {
            return scrolling_ViewportRuler;
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return VIEWPORT_RULER_PROVIDER;
        }));
        const DEFAULT_SCROLL_TIME = 20;
        let scrolling_ScrollDispatcher = (() => {
            class ScrollDispatcher {
                constructor(_ngZone, _platform) {
                    this._ngZone = _ngZone, this._platform = _platform, this._scrolled = new Subject.a, 
                    this._globalSubscription = null, this._scrolledCount = 0, this.scrollContainers = new Map;
                }
                register(scrollable) {
                    this.scrollContainers.has(scrollable) || this.scrollContainers.set(scrollable, scrollable.elementScrolled().subscribe(() => this._scrolled.next(scrollable)));
                }
                deregister(scrollable) {
                    const scrollableReference = this.scrollContainers.get(scrollable);
                    scrollableReference && (scrollableReference.unsubscribe(), this.scrollContainers.delete(scrollable));
                }
                scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {
                    return this._platform.isBrowser ? new Observable.a(observer => {
                        this._globalSubscription || this._addGlobalListener();
                        const subscription = auditTimeInMs > 0 ? this._scrolled.pipe(Object(auditTime.a)(auditTimeInMs)).subscribe(observer) : this._scrolled.subscribe(observer);
                        return this._scrolledCount++, () => {
                            subscription.unsubscribe(), this._scrolledCount--, this._scrolledCount || this._removeGlobalListener();
                        };
                    }) : Object(of.a)();
                }
                ngOnDestroy() {
                    this._removeGlobalListener(), this.scrollContainers.forEach((_, container) => this.deregister(container)), 
                    this._scrolled.complete();
                }
                ancestorScrolled(elementRef, auditTimeInMs) {
                    const ancestors = this.getAncestorScrollContainers(elementRef);
                    return this.scrolled(auditTimeInMs).pipe(Object(filter.a)(target => !target || ancestors.indexOf(target) > -1));
                }
                getAncestorScrollContainers(elementRef) {
                    const scrollingContainers = [];
                    return this.scrollContainers.forEach((_subscription, scrollable) => {
                        this._scrollableContainsElement(scrollable, elementRef) && scrollingContainers.push(scrollable);
                    }), scrollingContainers;
                }
                _scrollableContainsElement(scrollable, elementRef) {
                    let element = elementRef.nativeElement, scrollableElement = scrollable.getElementRef().nativeElement;
                    do {
                        if (element == scrollableElement) return !0;
                    } while (element = element.parentElement);
                    return !1;
                }
                _addGlobalListener() {
                    this._globalSubscription = this._ngZone.runOutsideAngular(() => Object(fromEvent.a)(window.document, "scroll").subscribe(() => this._scrolled.next()));
                }
                _removeGlobalListener() {
                    this._globalSubscription && (this._globalSubscription.unsubscribe(), this._globalSubscription = null);
                }
            }
            return ScrollDispatcher.ɵfac = function(t) {
                return new (t || ScrollDispatcher)(core.Zb(core.y), core.Zb(platform.a));
            }, ScrollDispatcher.ɵprov = core.Lb({
                token: ScrollDispatcher,
                factory: function(t) {
                    return ScrollDispatcher.ɵfac(t);
                },
                providedIn: "root"
            }), ScrollDispatcher.ngInjectableDef = Object(core.Lb)({
                factory: function() {
                    return new ScrollDispatcher(Object(core.Zb)(core.y), Object(core.Zb)(platform.a));
                },
                token: ScrollDispatcher,
                providedIn: "root"
            }), ScrollDispatcher;
        })(), scrolling_CdkScrollable = (() => {
            class CdkScrollable {
                constructor(elementRef, scrollDispatcher, ngZone, dir) {
                    this.elementRef = elementRef, this.scrollDispatcher = scrollDispatcher, this.ngZone = ngZone, 
                    this.dir = dir, this._destroyed = new Subject.a, this._elementScrolled = new Observable.a(observer => this.ngZone.runOutsideAngular(() => Object(fromEvent.a)(this.elementRef.nativeElement, "scroll").pipe(Object(takeUntil.a)(this._destroyed)).subscribe(observer)));
                }
                ngOnInit() {
                    this.scrollDispatcher.register(this);
                }
                ngOnDestroy() {
                    this.scrollDispatcher.deregister(this), this._destroyed.next(), this._destroyed.complete();
                }
                elementScrolled() {
                    return this._elementScrolled;
                }
                getElementRef() {
                    return this.elementRef;
                }
                scrollTo(options) {
                    const el = this.elementRef.nativeElement, isRtl = this.dir && "rtl" == this.dir.value;
                    options.left = null == options.left ? isRtl ? options.end : options.start : options.left, 
                    options.right = null == options.right ? isRtl ? options.start : options.end : options.right, 
                    null != options.bottom && (options.top = el.scrollHeight - el.clientHeight - options.bottom), 
                    isRtl && Object(platform.d)() != platform.c.NORMAL ? (null != options.left && (options.right = el.scrollWidth - el.clientWidth - options.left), 
                    Object(platform.d)() == platform.c.INVERTED ? options.left = options.right : Object(platform.d)() == platform.c.NEGATED && (options.left = options.right ? -options.right : options.right)) : null != options.right && (options.left = el.scrollWidth - el.clientWidth - options.right), 
                    this._applyScrollToOptions(options);
                }
                _applyScrollToOptions(options) {
                    const el = this.elementRef.nativeElement;
                    Object(platform.f)() ? el.scrollTo(options) : (null != options.top && (el.scrollTop = options.top), 
                    null != options.left && (el.scrollLeft = options.left));
                }
                measureScrollOffset(from) {
                    const el = this.elementRef.nativeElement;
                    if ("top" == from) return el.scrollTop;
                    if ("bottom" == from) return el.scrollHeight - el.clientHeight - el.scrollTop;
                    const isRtl = this.dir && "rtl" == this.dir.value;
                    return "start" == from ? from = isRtl ? "right" : "left" : "end" == from && (from = isRtl ? "left" : "right"), 
                    isRtl && Object(platform.d)() == platform.c.INVERTED ? "left" == from ? el.scrollWidth - el.clientWidth - el.scrollLeft : el.scrollLeft : isRtl && Object(platform.d)() == platform.c.NEGATED ? "left" == from ? el.scrollLeft + el.scrollWidth - el.clientWidth : -el.scrollLeft : "left" == from ? el.scrollLeft : el.scrollWidth - el.clientWidth - el.scrollLeft;
                }
            }
            return CdkScrollable.ɵfac = function(t) {
                return new (t || CdkScrollable)(core.Pb(core.k), core.Pb(scrolling_ScrollDispatcher), core.Pb(core.y), core.Pb(bidi.b, 8));
            }, CdkScrollable.ɵdir = core.Kb({
                type: CdkScrollable,
                selectors: [ [ "", "cdk-scrollable", "" ], [ "", "cdkScrollable", "" ] ]
            }), CdkScrollable;
        })(), scrolling_ScrollingModule = (() => {
            class ScrollingModule {}
            return ScrollingModule.ɵmod = core.Nb({
                type: ScrollingModule
            }), ScrollingModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || ScrollingModule);
                },
                imports: [ [ bidi.a, platform.b ], bidi.a ]
            }), ScrollingModule;
        })();
        const DEFAULT_RESIZE_TIME = 20;
        let scrolling_ViewportRuler = (() => {
            class ViewportRuler {
                constructor(_platform, ngZone) {
                    this._platform = _platform, ngZone.runOutsideAngular(() => {
                        this._change = _platform.isBrowser ? Object(merge.a)(Object(fromEvent.a)(window, "resize"), Object(fromEvent.a)(window, "orientationchange")) : Object(of.a)(), 
                        this._invalidateCache = this.change().subscribe(() => this._updateViewportSize());
                    });
                }
                ngOnDestroy() {
                    this._invalidateCache.unsubscribe();
                }
                getViewportSize() {
                    this._viewportSize || this._updateViewportSize();
                    const output = {
                        width: this._viewportSize.width,
                        height: this._viewportSize.height
                    };
                    return this._platform.isBrowser || (this._viewportSize = null), output;
                }
                getViewportRect() {
                    const scrollPosition = this.getViewportScrollPosition(), {width: width, height: height} = this.getViewportSize();
                    return {
                        top: scrollPosition.top,
                        left: scrollPosition.left,
                        bottom: scrollPosition.top + height,
                        right: scrollPosition.left + width,
                        height: height,
                        width: width
                    };
                }
                getViewportScrollPosition() {
                    if (!this._platform.isBrowser) return {
                        top: 0,
                        left: 0
                    };
                    const documentElement = document.documentElement, documentRect = documentElement.getBoundingClientRect();
                    return {
                        top: -documentRect.top || document.body.scrollTop || window.scrollY || documentElement.scrollTop || 0,
                        left: -documentRect.left || document.body.scrollLeft || window.scrollX || documentElement.scrollLeft || 0
                    };
                }
                change(throttleTime = DEFAULT_RESIZE_TIME) {
                    return throttleTime > 0 ? this._change.pipe(Object(auditTime.a)(throttleTime)) : this._change;
                }
                _updateViewportSize() {
                    this._viewportSize = this._platform.isBrowser ? {
                        width: window.innerWidth,
                        height: window.innerHeight
                    } : {
                        width: 0,
                        height: 0
                    };
                }
            }
            return ViewportRuler.ɵfac = function(t) {
                return new (t || ViewportRuler)(core.Zb(platform.a), core.Zb(core.y));
            }, ViewportRuler.ɵprov = core.Lb({
                token: ViewportRuler,
                factory: function(t) {
                    return ViewportRuler.ɵfac(t);
                },
                providedIn: "root"
            }), ViewportRuler.ngInjectableDef = Object(core.Lb)({
                factory: function() {
                    return new ViewportRuler(Object(core.Zb)(platform.a), Object(core.Zb)(core.y));
                },
                token: ViewportRuler,
                providedIn: "root"
            }), ViewportRuler;
        })();
        const VIEWPORT_RULER_PROVIDER = {
            provide: scrolling_ViewportRuler,
            deps: [ [ new core.z, new core.J, scrolling_ViewportRuler ], platform.a, core.y ],
            useFactory: function(parentRuler, platform, ngZone) {
                return parentRuler || new scrolling_ViewportRuler(platform, ngZone);
            }
        };
    },
    w1tV: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return share;
        }));
        var _multicast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("oB13"), _refCount__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("x+ZX"), _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("XNiG");
        function shareSubjectFactory() {
            return new _Subject__WEBPACK_IMPORTED_MODULE_2__.a;
        }
        function share() {
            return source => Object(_refCount__WEBPACK_IMPORTED_MODULE_1__.a)()(Object(_multicast__WEBPACK_IMPORTED_MODULE_0__.a)(shareSubjectFactory)(source));
        }
    },
    "x+ZX": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return refCount;
        }));
        var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7o/Q");
        function refCount() {
            return function(source) {
                return source.lift(new RefCountOperator(source));
            };
        }
        class RefCountOperator {
            constructor(connectable) {
                this.connectable = connectable;
            }
            call(subscriber, source) {
                const {connectable: connectable} = this;
                connectable._refCount++;
                const refCounter = new RefCountSubscriber(subscriber, connectable), subscription = source.subscribe(refCounter);
                return refCounter.closed || (refCounter.connection = connectable.connect()), subscription;
            }
        }
        class RefCountSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(destination, connectable) {
                super(destination), this.connectable = connectable;
            }
            _unsubscribe() {
                const {connectable: connectable} = this;
                if (!connectable) return void (this.connection = null);
                this.connectable = null;
                const refCount = connectable._refCount;
                if (refCount <= 0) return void (this.connection = null);
                if (connectable._refCount = refCount - 1, refCount > 1) return void (this.connection = null);
                const {connection: connection} = this, sharedConnection = connectable._connection;
                this.connection = null, !sharedConnection || connection && sharedConnection !== connection || sharedConnection.unsubscribe();
            }
        }
    },
    x4lQ: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return SelectComponent;
        }));
        var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("fXoL"), _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("ofXK");
        function SelectComponent_span_5_Template(rf, ctx) {
            if (1 & rf && _angular_core__WEBPACK_IMPORTED_MODULE_0__.Qb(0, "span"), 2 & rf) {
                const ctx_r41 = _angular_core__WEBPACK_IMPORTED_MODULE_0__.gc();
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Eb("symbol ", null == ctx_r41.selected ? null : ctx_r41.selected.value, "");
            }
        }
        function SelectComponent_ul_8_li_1_span_1_Template(rf, ctx) {
            if (1 & rf && _angular_core__WEBPACK_IMPORTED_MODULE_0__.Qb(0, "span"), 2 & rf) {
                const option_r44 = _angular_core__WEBPACK_IMPORTED_MODULE_0__.gc().$implicit;
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Eb("symbol ", option_r44.value, "");
            }
        }
        function SelectComponent_ul_8_li_1_Template(rf, ctx) {
            if (1 & rf) {
                const _r49 = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Wb();
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(0, "li", 6), _angular_core__WEBPACK_IMPORTED_MODULE_0__.cc("click", (function($event) {
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.uc(_r49);
                    const option_r44 = ctx.$implicit, i_r45 = ctx.index;
                    return _angular_core__WEBPACK_IMPORTED_MODULE_0__.gc(2).select(option_r44, i_r45);
                })), _angular_core__WEBPACK_IMPORTED_MODULE_0__.cc("keydown.enter", (function($event) {
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.uc(_r49);
                    const option_r44 = ctx.$implicit, i_r45 = ctx.index;
                    return _angular_core__WEBPACK_IMPORTED_MODULE_0__.gc(2).select(option_r44, i_r45);
                })), _angular_core__WEBPACK_IMPORTED_MODULE_0__.cc("keydown.space", (function($event) {
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.uc(_r49);
                    const option_r44 = ctx.$implicit, i_r45 = ctx.index;
                    return _angular_core__WEBPACK_IMPORTED_MODULE_0__.gc(2).select(option_r44, i_r45), 
                    $event.preventDefault();
                })), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Cc(1, SelectComponent_ul_8_li_1_span_1_Template, 1, 3, "span", 2), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(2, "span"), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ec(3), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb(), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb();
            }
            if (2 & rf) {
                const option_r44 = ctx.$implicit, ctx_r43 = _angular_core__WEBPACK_IMPORTED_MODULE_0__.gc(2);
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Fb("selected", option_r44 === ctx_r43.selected), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(1), _angular_core__WEBPACK_IMPORTED_MODULE_0__.lc("ngIf", ctx_r43.showSymbol), 
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(2), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Fc(option_r44.title);
            }
        }
        function SelectComponent_ul_8_Template(rf, ctx) {
            if (1 & rf && (_angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(0, "ul", 4), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Cc(1, SelectComponent_ul_8_li_1_Template, 4, 3, "li", 5), 
            _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb()), 2 & rf) {
                const ctx_r42 = _angular_core__WEBPACK_IMPORTED_MODULE_0__.gc();
                _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(1), _angular_core__WEBPACK_IMPORTED_MODULE_0__.lc("ngForOf", ctx_r42.options);
            }
        }
        let SelectComponent = (() => {
            class SelectComponent {
                constructor(hostElement) {
                    this.hostElement = hostElement, this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.m, 
                    this.showSymbol = !1, this.showOptions = !1;
                }
                ngOnInit() {
                    this.label = this.label || "";
                }
                toggleOptions() {
                    this.showOptions = !this.showOptions;
                }
                hideOptions() {
                    this.showOptions = !1;
                }
                select(option, index) {
                    this.selected = option, this.change.emit({
                        option: option,
                        index: index
                    }), this.hideOptions();
                }
                onClick(eventTarget) {
                    this.hostElement.nativeElement.contains(eventTarget) || this.hideOptions();
                }
                onKeyDown() {
                    this.hideOptions();
                }
            }
            return SelectComponent.ɵfac = function(t) {
                return new (t || SelectComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_0__.k));
            }, SelectComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Jb({
                type: SelectComponent,
                selectors: [ [ "aio-select" ] ],
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (_angular_core__WEBPACK_IMPORTED_MODULE_0__.cc("click", (function($event) {
                        return ctx.onClick($event.target);
                    }), !1, _angular_core__WEBPACK_IMPORTED_MODULE_0__.sc), _angular_core__WEBPACK_IMPORTED_MODULE_0__.cc("keydown.escape", (function($event) {
                        return ctx.onKeyDown();
                    }), !1, _angular_core__WEBPACK_IMPORTED_MODULE_0__.sc));
                },
                inputs: {
                    selected: "selected",
                    options: "options",
                    showSymbol: "showSymbol",
                    label: "label",
                    disabled: "disabled"
                },
                outputs: {
                    change: "change"
                },
                decls: 9,
                vars: 5,
                consts: [ [ 1, "form-select-menu" ], [ 1, "form-select-button", 3, "disabled", "click" ], [ 3, "class", 4, "ngIf" ], [ "class", "form-select-dropdown", 4, "ngIf" ], [ 1, "form-select-dropdown" ], [ "role", "button", "tabindex", "0", 3, "selected", "click", "keydown.enter", "keydown.space", 4, "ngFor", "ngForOf" ], [ "role", "button", "tabindex", "0", 3, "click", "keydown.enter", "keydown.space" ] ],
                template: function(rf, ctx) {
                    1 & rf && (_angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(0, "div", 0), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(1, "button", 1), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.cc("click", (function($event) {
                        return ctx.toggleOptions();
                    })), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(2, "span"), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(3, "strong"), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ec(4), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb(), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb(), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Cc(5, SelectComponent_span_5_Template, 1, 3, "span", 2), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(6, "span"), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ec(7), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb(), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb(), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.Cc(8, SelectComponent_ul_8_Template, 2, 1, "ul", 3), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.Tb()), 2 & rf && (_angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(1), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.lc("disabled", ctx.disabled), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(3), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.Fc(ctx.label), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(1), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.lc("ngIf", ctx.showSymbol), _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(2), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.Fc(null == ctx.selected ? null : ctx.selected.title), 
                    _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ab(1), _angular_core__WEBPACK_IMPORTED_MODULE_0__.lc("ngIf", ctx.showOptions));
                },
                directives: [ _angular_common__WEBPACK_IMPORTED_MODULE_1__.k, _angular_common__WEBPACK_IMPORTED_MODULE_1__.j ],
                encapsulation: 2
            }), SelectComponent;
        })();
    },
    xbPD: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return defaultIfEmpty;
        }));
        var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7o/Q");
        function defaultIfEmpty(defaultValue = null) {
            return source => source.lift(new DefaultIfEmptyOperator(defaultValue));
        }
        class DefaultIfEmptyOperator {
            constructor(defaultValue) {
                this.defaultValue = defaultValue;
            }
            call(subscriber, source) {
                return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
            }
        }
        class DefaultIfEmptySubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(destination, defaultValue) {
                super(destination), this.defaultValue = defaultValue, this.isEmpty = !0;
            }
            _next(value) {
                this.isEmpty = !1, this.destination.next(value);
            }
            _complete() {
                this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete();
            }
        }
    },
    xgIS: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return fromEvent;
        }));
        var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("HDdC"), _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("DH7j"), _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("n6bG"), _operators_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("lJxs");
        function fromEvent(target, eventName, options, resultSelector) {
            return Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__.a)(options) && (resultSelector = options, 
            options = void 0), resultSelector ? fromEvent(target, eventName, options).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_3__.a)(args => Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__.a)(args) ? resultSelector(...args) : resultSelector(args))) : new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(subscriber => {
                !function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
                    let unsubscribe;
                    if (function(sourceObj) {
                        return sourceObj && "function" == typeof sourceObj.addEventListener && "function" == typeof sourceObj.removeEventListener;
                    }(sourceObj)) {
                        const source = sourceObj;
                        sourceObj.addEventListener(eventName, handler, options), unsubscribe = () => source.removeEventListener(eventName, handler, options);
                    } else if (function(sourceObj) {
                        return sourceObj && "function" == typeof sourceObj.on && "function" == typeof sourceObj.off;
                    }(sourceObj)) {
                        const source = sourceObj;
                        sourceObj.on(eventName, handler), unsubscribe = () => source.off(eventName, handler);
                    } else if (function(sourceObj) {
                        return sourceObj && "function" == typeof sourceObj.addListener && "function" == typeof sourceObj.removeListener;
                    }(sourceObj)) {
                        const source = sourceObj;
                        sourceObj.addListener(eventName, handler), unsubscribe = () => source.removeListener(eventName, handler);
                    } else {
                        if (!sourceObj || !sourceObj.length) throw new TypeError("Invalid event target");
                        for (let i = 0, len = sourceObj.length; i < len; i++) setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
                    }
                    subscriber.add(unsubscribe);
                }(target, eventName, (function(e) {
                    subscriber.next(arguments.length > 1 ? Array.prototype.slice.call(arguments) : e);
                }), subscriber, options);
            });
        }
    },
    yCtX: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return fromArray;
        }));
        var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("HDdC"), _util_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("ngJS"), _scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("jZKg");
        function fromArray(input, scheduler) {
            return scheduler ? Object(_scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__.a)(input, scheduler) : new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(Object(_util_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__.a)(input));
        }
    },
    "z+Ro": function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        function isScheduler(value) {
            return value && "function" == typeof value.schedule;
        }
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return isScheduler;
        }));
    },
    z6cu: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return throwError;
        }));
        var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("HDdC");
        function throwError(error, scheduler) {
            return new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(scheduler ? subscriber => scheduler.schedule(dispatch, 0, {
                error: error,
                subscriber: subscriber
            }) : subscriber => subscriber.error(error));
        }
        function dispatch({error: error, subscriber: subscriber}) {
            subscriber.error(error);
        }
    },
    zUnb: function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        var core = __webpack_require__("fXoL"), environment = __webpack_require__("AytR"), platform_browser = __webpack_require__("jhN1"), http = __webpack_require__("tk/3"), animations = __webpack_require__("R1ws"), service_worker = __webpack_require__("Jho9"), common = __webpack_require__("ofXK"), fesm2015_button = __webpack_require__("bTqV"), icon = __webpack_require__("NFeN"), fesm2015_core = __webpack_require__("FKr1"), Subscription = __webpack_require__("quSY"), fromEvent = __webpack_require__("xgIS"), filter = __webpack_require__("pLZG");
        const _c0 = [ "primaryValueBar" ], _c1 = [ "role", "progressbar", "aria-valuemin", "0", "aria-valuemax", "100", 1, "mat-progress-bar" ];
        class MatProgressBarBase {
            constructor(_elementRef) {
                this._elementRef = _elementRef;
            }
        }
        const _MatProgressBarMixinBase = Object(fesm2015_core.f)(MatProgressBarBase, "primary"), MAT_PROGRESS_BAR_LOCATION = new core.p("mat-progress-bar-location", {
            providedIn: "root",
            factory: function() {
                const _document = Object(core.V)(common.d), _location = _document ? _document.location : null;
                return {
                    getPathname: () => _location ? _location.pathname + _location.search : ""
                };
            }
        });
        let progressbarId = 0, progress_bar_MatProgressBar = (() => {
            class MatProgressBar extends _MatProgressBarMixinBase {
                constructor(_elementRef, _ngZone, _animationMode, location) {
                    super(_elementRef), this._elementRef = _elementRef, this._ngZone = _ngZone, this._animationMode = _animationMode, 
                    this._isNoopAnimation = !1, this._value = 0, this._bufferValue = 0, this.animationEnd = new core.m, 
                    this._animationEndSubscription = Subscription.a.EMPTY, this.mode = "determinate", 
                    this.progressbarId = `mat-progress-bar-${progressbarId++}`;
                    const path = location ? location.getPathname().split("#")[0] : "";
                    this._rectangleFillValue = `url('${path}#${this.progressbarId}')`, this._isNoopAnimation = "NoopAnimations" === _animationMode;
                }
                get value() {
                    return this._value;
                }
                set value(v) {
                    this._value = clamp(v || 0), this._isNoopAnimation && this._emitAnimationEnd();
                }
                get bufferValue() {
                    return this._bufferValue;
                }
                set bufferValue(v) {
                    this._bufferValue = clamp(v || 0);
                }
                _primaryTransform() {
                    return {
                        transform: `scaleX(${this.value / 100})`
                    };
                }
                _bufferTransform() {
                    if ("buffer" === this.mode) return {
                        transform: `scaleX(${this.bufferValue / 100})`
                    };
                }
                ngAfterViewInit() {
                    this._isNoopAnimation || this._ngZone.runOutsideAngular(() => {
                        const element = this._primaryValueBar.nativeElement;
                        this._animationEndSubscription = Object(fromEvent.a)(element, "transitionend").pipe(Object(filter.a)(e => e.target === element)).subscribe(() => this._ngZone.run(() => this._emitAnimationEnd()));
                    });
                }
                ngOnDestroy() {
                    this._animationEndSubscription.unsubscribe();
                }
                _emitAnimationEnd() {
                    "determinate" !== this.mode && "buffer" !== this.mode || this.animationEnd.next({
                        value: this.value
                    });
                }
            }
            return MatProgressBar.ɵfac = function(t) {
                return new (t || MatProgressBar)(core.Pb(core.k), core.Pb(core.y), core.Pb(animations.a, 8), core.Pb(MAT_PROGRESS_BAR_LOCATION, 8));
            }, MatProgressBar.ɵcmp = core.Jb({
                type: MatProgressBar,
                selectors: [ [ "mat-progress-bar" ] ],
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && core.Jc(_c0, !0), 2 & rf && core.qc(_t = core.dc()) && (ctx._primaryValueBar = _t.first);
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (core.Bb(3), core.Ub(_c1)), 2 & rf && (core.Cb("aria-valuenow", "indeterminate" === ctx.mode || "query" === ctx.mode ? null : ctx.value)("mode", ctx.mode), 
                    core.Fb("_mat-animation-noopable", ctx._isNoopAnimation));
                },
                inputs: {
                    color: "color",
                    mode: "mode",
                    value: "value",
                    bufferValue: "bufferValue"
                },
                outputs: {
                    animationEnd: "animationEnd"
                },
                exportAs: [ "matProgressBar" ],
                features: [ core.xb ],
                decls: 9,
                vars: 4,
                consts: [ [ "width", "100%", "height", "4", "focusable", "false", 1, "mat-progress-bar-background", "mat-progress-bar-element" ], [ "x", "4", "y", "0", "width", "8", "height", "4", "patternUnits", "userSpaceOnUse", 3, "id" ], [ "cx", "2", "cy", "2", "r", "2" ], [ "width", "100%", "height", "100%" ], [ 1, "mat-progress-bar-buffer", "mat-progress-bar-element", 3, "ngStyle" ], [ 1, "mat-progress-bar-primary", "mat-progress-bar-fill", "mat-progress-bar-element", 3, "ngStyle" ], [ "primaryValueBar", "" ], [ 1, "mat-progress-bar-secondary", "mat-progress-bar-fill", "mat-progress-bar-element" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.fc(), core.Vb(0, "svg", 0), core.Vb(1, "defs"), core.Vb(2, "pattern", 1), 
                    core.Qb(3, "circle", 2), core.Tb(), core.Tb(), core.Qb(4, "rect", 3), core.Tb(), 
                    core.ec(), core.Qb(5, "div", 4), core.Qb(6, "div", 5, 6), core.Qb(8, "div", 7)), 
                    2 & rf && (core.Ab(2), core.lc("id", ctx.progressbarId), core.Ab(2), core.Cb("fill", ctx._rectangleFillValue), 
                    core.Ab(1), core.lc("ngStyle", ctx._bufferTransform()), core.Ab(1), core.lc("ngStyle", ctx._primaryTransform()));
                },
                directives: [ common.l ],
                styles: [ '.mat-progress-bar{display:block;height:4px;overflow:hidden;position:relative;transition:opacity 250ms linear;width:100%}._mat-animation-noopable.mat-progress-bar{transition:none;animation:none}.mat-progress-bar .mat-progress-bar-element,.mat-progress-bar .mat-progress-bar-fill::after{height:100%;position:absolute;width:100%}.mat-progress-bar .mat-progress-bar-background{width:calc(100% + 10px)}@media(-ms-high-contrast: active){.mat-progress-bar .mat-progress-bar-background{display:none}}.mat-progress-bar .mat-progress-bar-buffer{transform-origin:top left;transition:transform 250ms ease}@media(-ms-high-contrast: active){.mat-progress-bar .mat-progress-bar-buffer{border-top:solid 5px;opacity:.5}}.mat-progress-bar .mat-progress-bar-secondary{display:none}.mat-progress-bar .mat-progress-bar-fill{animation:none;transform-origin:top left;transition:transform 250ms ease}@media(-ms-high-contrast: active){.mat-progress-bar .mat-progress-bar-fill{border-top:solid 4px}}.mat-progress-bar .mat-progress-bar-fill::after{animation:none;content:"";display:inline-block;left:0}.mat-progress-bar[dir=rtl],[dir=rtl] .mat-progress-bar{transform:rotateY(180deg)}.mat-progress-bar[mode=query]{transform:rotateZ(180deg)}.mat-progress-bar[mode=query][dir=rtl],[dir=rtl] .mat-progress-bar[mode=query]{transform:rotateZ(180deg) rotateY(180deg)}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-fill,.mat-progress-bar[mode=query] .mat-progress-bar-fill{transition:none}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary,.mat-progress-bar[mode=query] .mat-progress-bar-primary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-translate 2000ms infinite linear;left:-145.166611%}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-primary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-scale 2000ms infinite linear}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary,.mat-progress-bar[mode=query] .mat-progress-bar-secondary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-translate 2000ms infinite linear;left:-54.888891%;display:block}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-secondary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-scale 2000ms infinite linear}.mat-progress-bar[mode=buffer] .mat-progress-bar-background{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-background-scroll 250ms infinite linear;display:block}.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-buffer,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-background{animation:none;transition:none}@keyframes mat-progress-bar-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(83.67142%)}100%{transform:translateX(200.611057%)}}@keyframes mat-progress-bar-primary-indeterminate-scale{0%{transform:scaleX(0.08)}36.65%{animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);transform:scaleX(0.08)}69.15%{animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);transform:scaleX(0.661479)}100%{transform:scaleX(0.08)}}@keyframes mat-progress-bar-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:translateX(37.651913%)}48.35%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:translateX(84.386165%)}100%{transform:translateX(160.277782%)}}@keyframes mat-progress-bar-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:scaleX(0.08)}19.15%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:scaleX(0.457104)}44.15%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:scaleX(0.72796)}100%{transform:scaleX(0.08)}}@keyframes mat-progress-bar-background-scroll{to{transform:translateX(-8px)}}/*# sourceMappingURL=progress-bar.css.map */\n' ],
                encapsulation: 2,
                changeDetection: 0
            }), MatProgressBar;
        })();
        function clamp(v, min = 0, max = 100) {
            return Math.max(min, Math.min(max, v));
        }
        let progress_bar_MatProgressBarModule = (() => {
            class MatProgressBarModule {}
            return MatProgressBarModule.ɵmod = core.Nb({
                type: MatProgressBarModule
            }), MatProgressBarModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || MatProgressBarModule);
                },
                imports: [ [ common.c, fesm2015_core.b ], fesm2015_core.b ]
            }), MatProgressBarModule;
        })();
        var platform = __webpack_require__("nLfN"), scrolling = __webpack_require__("vxfF"), a11y = __webpack_require__("u47x"), bidi = __webpack_require__("cH1L"), coercion = __webpack_require__("8LU1"), keycodes = __webpack_require__("FtGj"), Subject = __webpack_require__("XNiG"), merge = __webpack_require__("VRyK"), takeUntil = __webpack_require__("1G5W"), distinctUntilChanged = __webpack_require__("/uUt"), map = __webpack_require__("lJxs"), take = __webpack_require__("IzEk"), startWith = __webpack_require__("JX91"), debounceTime = __webpack_require__("Kj3r"), fesm2015_animations = __webpack_require__("R0Ic");
        const sidenav_c0 = [ 1, "mat-drawer-content" ], sidenav_c1 = [ "*" ], _c2 = [ "tabIndex", "-1", 1, "mat-drawer" ], _c3 = [ 1, "mat-drawer-container" ];
        function MatDrawerContainer_div_0_Template(rf, ctx) {
            if (1 & rf) {
                const _r6 = core.Wb();
                core.Vb(0, "div", 2), core.cc("click", (function($event) {
                    return core.uc(_r6), core.gc()._onBackdropClicked();
                })), core.Tb();
            }
            if (2 & rf) {
                const ctx_r3 = core.gc();
                core.Fb("mat-drawer-shown", ctx_r3._isShowingBackdrop());
            }
        }
        function MatDrawerContainer_mat_drawer_content_3_Template(rf, ctx) {
            1 & rf && (core.Vb(0, "mat-drawer-content"), core.jc(1, 2), core.Tb());
        }
        const _c4 = [ [ [ "mat-drawer" ] ], [ [ "mat-drawer-content" ] ], "*" ], _c5 = [ "mat-drawer", "mat-drawer-content", "*" ], _c6 = [ 1, "mat-drawer-content", "mat-sidenav-content" ], _c7 = [ "tabIndex", "-1", 1, "mat-drawer", "mat-sidenav" ], _c8 = [ 1, "mat-drawer-container", "mat-sidenav-container" ];
        function MatSidenavContainer_div_0_Template(rf, ctx) {
            if (1 & rf) {
                const _r10 = core.Wb();
                core.Vb(0, "div", 2), core.cc("click", (function($event) {
                    return core.uc(_r10), core.gc()._onBackdropClicked();
                })), core.Tb();
            }
            if (2 & rf) {
                const ctx_r7 = core.gc();
                core.Fb("mat-drawer-shown", ctx_r7._isShowingBackdrop());
            }
        }
        function MatSidenavContainer_mat_sidenav_content_3_Template(rf, ctx) {
            1 & rf && (core.Vb(0, "mat-sidenav-content", 3), core.jc(1, 2), core.Tb());
        }
        const _c9 = [ [ [ "mat-sidenav" ] ], [ [ "mat-sidenav-content" ] ], "*" ], _c10 = [ "mat-sidenav", "mat-sidenav-content", "*" ], matDrawerAnimations = {
            transformDrawer: Object(fesm2015_animations.j)("transform", [ Object(fesm2015_animations.g)("open, open-instant", Object(fesm2015_animations.h)({
                transform: "none",
                visibility: "visible"
            })), Object(fesm2015_animations.g)("void", Object(fesm2015_animations.h)({
                "box-shadow": "none",
                visibility: "hidden"
            })), Object(fesm2015_animations.i)("void => open-instant", Object(fesm2015_animations.e)("0ms")), Object(fesm2015_animations.i)("void <=> open, open-instant => void", Object(fesm2015_animations.e)("400ms cubic-bezier(0.25, 0.8, 0.25, 1)")) ])
        };
        function throwMatDuplicatedDrawerError(position) {
            throw Error(`A drawer was already declared for 'position="${position}"'`);
        }
        const MAT_DRAWER_DEFAULT_AUTOSIZE = new core.p("MAT_DRAWER_DEFAULT_AUTOSIZE", {
            providedIn: "root",
            factory: function() {
                return !1;
            }
        });
        let sidenav_MatDrawerContent = (() => {
            class MatDrawerContent extends scrolling.a {
                constructor(_changeDetectorRef, _container, elementRef, scrollDispatcher, ngZone) {
                    super(elementRef, scrollDispatcher, ngZone), this._changeDetectorRef = _changeDetectorRef, 
                    this._container = _container;
                }
                ngAfterContentInit() {
                    this._container._contentMarginChanges.subscribe(() => {
                        this._changeDetectorRef.markForCheck();
                    });
                }
            }
            return MatDrawerContent.ɵfac = function(t) {
                return new (t || MatDrawerContent)(core.Pb(core.h), core.Pb(Object(core.T)(() => sidenav_MatDrawerContainer)), core.Pb(core.k), core.Pb(scrolling.b), core.Pb(core.y));
            }, MatDrawerContent.ɵcmp = core.Jb({
                type: MatDrawerContent,
                selectors: [ [ "mat-drawer-content" ] ],
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (core.Bb(2), core.Ub(sidenav_c0)), 2 & rf && (core.Ac("margin-left", ctx._container._contentMargins.left, "px"), 
                    core.Ac("margin-right", ctx._container._contentMargins.right, "px"));
                },
                features: [ core.xb ],
                ngContentSelectors: sidenav_c1,
                decls: 1,
                vars: 0,
                template: function(rf, ctx) {
                    1 & rf && (core.kc(), core.jc(0));
                },
                encapsulation: 2,
                changeDetection: 0
            }), MatDrawerContent;
        })(), sidenav_MatDrawer = (() => {
            class MatDrawer {
                constructor(_elementRef, _focusTrapFactory, _focusMonitor, _platform, _ngZone, _doc) {
                    this._elementRef = _elementRef, this._focusTrapFactory = _focusTrapFactory, this._focusMonitor = _focusMonitor, 
                    this._platform = _platform, this._ngZone = _ngZone, this._doc = _doc, this._elementFocusedBeforeDrawerWasOpened = null, 
                    this._enableAnimations = !1, this._position = "start", this._mode = "over", this._disableClose = !1, 
                    this._autoFocus = !0, this._animationStarted = new Subject.a, this._animationEnd = new Subject.a, 
                    this._animationState = "void", this.openedChange = new core.m(!0), this._destroyed = new Subject.a, 
                    this.onPositionChanged = new core.m, this._modeChanged = new Subject.a, this._opened = !1, 
                    this.openedChange.subscribe(opened => {
                        opened ? (this._doc && (this._elementFocusedBeforeDrawerWasOpened = this._doc.activeElement), 
                        this._isFocusTrapEnabled && this._focusTrap && this._trapFocus()) : this._restoreFocus();
                    }), this._ngZone.runOutsideAngular(() => {
                        Object(fromEvent.a)(this._elementRef.nativeElement, "keydown").pipe(Object(filter.a)(event => event.keyCode === keycodes.e && !this.disableClose && !Object(keycodes.o)(event)), Object(takeUntil.a)(this._destroyed)).subscribe(event => this._ngZone.run(() => {
                            this.close(), event.stopPropagation(), event.preventDefault();
                        }));
                    }), this._animationEnd.pipe(Object(distinctUntilChanged.a)((x, y) => x.fromState === y.fromState && x.toState === y.toState)).subscribe(event => {
                        const {fromState: fromState, toState: toState} = event;
                        (0 === toState.indexOf("open") && "void" === fromState || "void" === toState && 0 === fromState.indexOf("open")) && this.openedChange.emit(this._opened);
                    });
                }
                get position() {
                    return this._position;
                }
                set position(value) {
                    (value = "end" === value ? "end" : "start") != this._position && (this._position = value, 
                    this.onPositionChanged.emit());
                }
                get mode() {
                    return this._mode;
                }
                set mode(value) {
                    this._mode = value, this._updateFocusTrapState(), this._modeChanged.next();
                }
                get disableClose() {
                    return this._disableClose;
                }
                set disableClose(value) {
                    this._disableClose = Object(coercion.b)(value);
                }
                get autoFocus() {
                    return this._autoFocus;
                }
                set autoFocus(value) {
                    this._autoFocus = Object(coercion.b)(value);
                }
                get _openedStream() {
                    return this.openedChange.pipe(Object(filter.a)(o => o), Object(map.a)(() => {}));
                }
                get openedStart() {
                    return this._animationStarted.pipe(Object(filter.a)(e => e.fromState !== e.toState && 0 === e.toState.indexOf("open")), Object(map.a)(() => {}));
                }
                get _closedStream() {
                    return this.openedChange.pipe(Object(filter.a)(o => !o), Object(map.a)(() => {}));
                }
                get closedStart() {
                    return this._animationStarted.pipe(Object(filter.a)(e => e.fromState !== e.toState && "void" === e.toState), Object(map.a)(() => {}));
                }
                get _isFocusTrapEnabled() {
                    return this.opened && "side" !== this.mode;
                }
                _trapFocus() {
                    this.autoFocus && this._focusTrap.focusInitialElementWhenReady().then(hasMovedFocus => {
                        hasMovedFocus || "function" != typeof this._elementRef.nativeElement.focus || this._elementRef.nativeElement.focus();
                    });
                }
                _restoreFocus() {
                    if (!this.autoFocus) return;
                    const activeEl = this._doc && this._doc.activeElement;
                    activeEl && this._elementRef.nativeElement.contains(activeEl) && (this._elementFocusedBeforeDrawerWasOpened instanceof HTMLElement ? this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened, this._openedVia) : this._elementRef.nativeElement.blur()), 
                    this._elementFocusedBeforeDrawerWasOpened = null, this._openedVia = null;
                }
                ngAfterContentInit() {
                    this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement), 
                    this._updateFocusTrapState();
                }
                ngAfterContentChecked() {
                    this._platform.isBrowser && (this._enableAnimations = !0);
                }
                ngOnDestroy() {
                    this._focusTrap && this._focusTrap.destroy(), this._animationStarted.complete(), 
                    this._animationEnd.complete(), this._modeChanged.complete(), this._destroyed.next(), 
                    this._destroyed.complete();
                }
                get opened() {
                    return this._opened;
                }
                set opened(value) {
                    this.toggle(Object(coercion.b)(value));
                }
                open(openedVia) {
                    return this.toggle(!0, openedVia);
                }
                close() {
                    return this.toggle(!1);
                }
                toggle(isOpen = !this.opened, openedVia = "program") {
                    return this._opened = isOpen, isOpen ? (this._animationState = this._enableAnimations ? "open" : "open-instant", 
                    this._openedVia = openedVia) : (this._animationState = "void", this._restoreFocus()), 
                    this._updateFocusTrapState(), new Promise(resolve => {
                        this.openedChange.pipe(Object(take.a)(1)).subscribe(open => resolve(open ? "open" : "close"));
                    });
                }
                get _width() {
                    return this._elementRef.nativeElement && this._elementRef.nativeElement.offsetWidth || 0;
                }
                _updateFocusTrapState() {
                    this._focusTrap && (this._focusTrap.enabled = this._isFocusTrapEnabled);
                }
                _animationStartListener(event) {
                    this._animationStarted.next(event);
                }
                _animationDoneListener(event) {
                    this._animationEnd.next(event);
                }
            }
            return MatDrawer.ɵfac = function(t) {
                return new (t || MatDrawer)(core.Pb(core.k), core.Pb(a11y.e), core.Pb(a11y.d), core.Pb(platform.a), core.Pb(core.y), core.Pb(common.d, 8));
            }, MatDrawer.ɵcmp = core.Jb({
                type: MatDrawer,
                selectors: [ [ "mat-drawer" ] ],
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (core.Bb(7), core.Gb("@transform.start", (function($event) {
                        return ctx._animationStartListener($event);
                    })), core.Gb("@transform.done", (function($event) {
                        return ctx._animationDoneListener($event);
                    })), core.Ub(_c2)), 2 & rf && (core.Cb("align", null), core.Ic("@transform", ctx._animationState), 
                    core.Fb("mat-drawer-end", "end" === ctx.position), core.Fb("mat-drawer-over", "over" === ctx.mode), 
                    core.Fb("mat-drawer-push", "push" === ctx.mode), core.Fb("mat-drawer-side", "side" === ctx.mode), 
                    core.Fb("mat-drawer-opened", ctx.opened));
                },
                inputs: {
                    position: "position",
                    mode: "mode",
                    disableClose: "disableClose",
                    autoFocus: "autoFocus",
                    opened: "opened"
                },
                outputs: {
                    openedChange: "openedChange",
                    onPositionChanged: "positionChanged",
                    _openedStream: "opened",
                    openedStart: "openedStart",
                    _closedStream: "closed",
                    closedStart: "closedStart"
                },
                exportAs: [ "matDrawer" ],
                ngContentSelectors: sidenav_c1,
                decls: 2,
                vars: 0,
                consts: [ [ 1, "mat-drawer-inner-container" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.kc(), core.Vb(0, "div", 0), core.jc(1), core.Tb());
                },
                encapsulation: 2,
                data: {
                    animation: [ matDrawerAnimations.transformDrawer ]
                },
                changeDetection: 0
            }), MatDrawer;
        })(), sidenav_MatDrawerContainer = (() => {
            class MatDrawerContainer {
                constructor(_dir, _element, _ngZone, _changeDetectorRef, viewportRuler, defaultAutosize = !1, _animationMode) {
                    this._dir = _dir, this._element = _element, this._ngZone = _ngZone, this._changeDetectorRef = _changeDetectorRef, 
                    this._animationMode = _animationMode, this.backdropClick = new core.m, this._destroyed = new Subject.a, 
                    this._doCheckSubject = new Subject.a, this._contentMargins = {
                        left: null,
                        right: null
                    }, this._contentMarginChanges = new Subject.a, _dir && _dir.change.pipe(Object(takeUntil.a)(this._destroyed)).subscribe(() => {
                        this._validateDrawers(), this.updateContentMargins();
                    }), viewportRuler.change().pipe(Object(takeUntil.a)(this._destroyed)).subscribe(() => this.updateContentMargins()), 
                    this._autosize = defaultAutosize;
                }
                get start() {
                    return this._start;
                }
                get end() {
                    return this._end;
                }
                get autosize() {
                    return this._autosize;
                }
                set autosize(value) {
                    this._autosize = Object(coercion.b)(value);
                }
                get hasBackdrop() {
                    return null == this._backdropOverride ? !this._start || "side" !== this._start.mode || !this._end || "side" !== this._end.mode : this._backdropOverride;
                }
                set hasBackdrop(value) {
                    this._backdropOverride = null == value ? null : Object(coercion.b)(value);
                }
                get scrollable() {
                    return this._userContent || this._content;
                }
                ngAfterContentInit() {
                    this._drawers.changes.pipe(Object(startWith.a)(null)).subscribe(() => {
                        this._validateDrawers(), this._drawers.forEach(drawer => {
                            this._watchDrawerToggle(drawer), this._watchDrawerPosition(drawer), this._watchDrawerMode(drawer);
                        }), (!this._drawers.length || this._isDrawerOpen(this._start) || this._isDrawerOpen(this._end)) && this.updateContentMargins(), 
                        this._changeDetectorRef.markForCheck();
                    }), this._doCheckSubject.pipe(Object(debounceTime.a)(10), Object(takeUntil.a)(this._destroyed)).subscribe(() => this.updateContentMargins());
                }
                ngOnDestroy() {
                    this._contentMarginChanges.complete(), this._doCheckSubject.complete(), this._destroyed.next(), 
                    this._destroyed.complete();
                }
                open() {
                    this._drawers.forEach(drawer => drawer.open());
                }
                close() {
                    this._drawers.forEach(drawer => drawer.close());
                }
                updateContentMargins() {
                    let left = 0, right = 0;
                    if (this._left && this._left.opened) if ("side" == this._left.mode) left += this._left._width; else if ("push" == this._left.mode) {
                        const width = this._left._width;
                        left += width, right -= width;
                    }
                    if (this._right && this._right.opened) if ("side" == this._right.mode) right += this._right._width; else if ("push" == this._right.mode) {
                        const width = this._right._width;
                        right += width, left -= width;
                    }
                    right = right || null, (left = left || null) === this._contentMargins.left && right === this._contentMargins.right || (this._contentMargins = {
                        left: left,
                        right: right
                    }, this._ngZone.run(() => this._contentMarginChanges.next(this._contentMargins)));
                }
                ngDoCheck() {
                    this._autosize && this._isPushed() && this._ngZone.runOutsideAngular(() => this._doCheckSubject.next());
                }
                _watchDrawerToggle(drawer) {
                    drawer._animationStarted.pipe(Object(filter.a)(event => event.fromState !== event.toState), Object(takeUntil.a)(this._drawers.changes)).subscribe(event => {
                        "open-instant" !== event.toState && "NoopAnimations" !== this._animationMode && this._element.nativeElement.classList.add("mat-drawer-transition"), 
                        this.updateContentMargins(), this._changeDetectorRef.markForCheck();
                    }), "side" !== drawer.mode && drawer.openedChange.pipe(Object(takeUntil.a)(this._drawers.changes)).subscribe(() => this._setContainerClass(drawer.opened));
                }
                _watchDrawerPosition(drawer) {
                    drawer && drawer.onPositionChanged.pipe(Object(takeUntil.a)(this._drawers.changes)).subscribe(() => {
                        this._ngZone.onMicrotaskEmpty.asObservable().pipe(Object(take.a)(1)).subscribe(() => {
                            this._validateDrawers();
                        });
                    });
                }
                _watchDrawerMode(drawer) {
                    drawer && drawer._modeChanged.pipe(Object(takeUntil.a)(Object(merge.a)(this._drawers.changes, this._destroyed))).subscribe(() => {
                        this.updateContentMargins(), this._changeDetectorRef.markForCheck();
                    });
                }
                _setContainerClass(isAdd) {
                    const classList = this._element.nativeElement.classList, className = "mat-drawer-container-has-open";
                    isAdd ? classList.add(className) : classList.remove(className);
                }
                _validateDrawers() {
                    this._start = this._end = null, this._drawers.forEach(drawer => {
                        "end" == drawer.position ? (null != this._end && throwMatDuplicatedDrawerError("end"), 
                        this._end = drawer) : (null != this._start && throwMatDuplicatedDrawerError("start"), 
                        this._start = drawer);
                    }), this._right = this._left = null, this._dir && "rtl" === this._dir.value ? (this._left = this._end, 
                    this._right = this._start) : (this._left = this._start, this._right = this._end);
                }
                _isPushed() {
                    return this._isDrawerOpen(this._start) && "over" != this._start.mode || this._isDrawerOpen(this._end) && "over" != this._end.mode;
                }
                _onBackdropClicked() {
                    this.backdropClick.emit(), this._closeModalDrawer();
                }
                _closeModalDrawer() {
                    [ this._start, this._end ].filter(drawer => drawer && !drawer.disableClose && this._canHaveBackdrop(drawer)).forEach(drawer => drawer.close());
                }
                _isShowingBackdrop() {
                    return this._isDrawerOpen(this._start) && this._canHaveBackdrop(this._start) || this._isDrawerOpen(this._end) && this._canHaveBackdrop(this._end);
                }
                _canHaveBackdrop(drawer) {
                    return "side" !== drawer.mode || !!this._backdropOverride;
                }
                _isDrawerOpen(drawer) {
                    return null != drawer && drawer.opened;
                }
            }
            return MatDrawerContainer.ɵfac = function(t) {
                return new (t || MatDrawerContainer)(core.Pb(bidi.b, 8), core.Pb(core.k), core.Pb(core.y), core.Pb(core.h), core.Pb(scrolling.e), core.Pb(MAT_DRAWER_DEFAULT_AUTOSIZE), core.Pb(animations.a, 8));
            }, MatDrawerContainer.ɵcmp = core.Jb({
                type: MatDrawerContainer,
                selectors: [ [ "mat-drawer-container" ] ],
                contentQueries: function(rf, ctx, dirIndex) {
                    var _t;
                    1 & rf && (core.Hb(dirIndex, sidenav_MatDrawerContent, !0), core.Hb(dirIndex, sidenav_MatDrawer, !1)), 
                    2 & rf && (core.qc(_t = core.dc()) && (ctx._content = _t.first), core.qc(_t = core.dc()) && (ctx._drawers = _t));
                },
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && core.Jc(sidenav_MatDrawerContent, !0), 2 & rf && core.qc(_t = core.dc()) && (ctx._userContent = _t.first);
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (core.Bb(1), core.Ub(_c3)), 2 & rf && core.Fb("mat-drawer-container-explicit-backdrop", ctx._backdropOverride);
                },
                inputs: {
                    autosize: "autosize",
                    hasBackdrop: "hasBackdrop"
                },
                outputs: {
                    backdropClick: "backdropClick"
                },
                exportAs: [ "matDrawerContainer" ],
                ngContentSelectors: _c5,
                decls: 4,
                vars: 2,
                consts: [ [ "class", "mat-drawer-backdrop", 3, "mat-drawer-shown", "click", 4, "ngIf" ], [ 4, "ngIf" ], [ 1, "mat-drawer-backdrop", 3, "click" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.kc(_c4), core.Cc(0, MatDrawerContainer_div_0_Template, 1, 1, "div", 0), 
                    core.jc(1), core.jc(2, 1), core.Cc(3, MatDrawerContainer_mat_drawer_content_3_Template, 2, 0, "mat-drawer-content", 1)), 
                    2 & rf && (core.lc("ngIf", ctx.hasBackdrop), core.Ab(3), core.lc("ngIf", !ctx._content));
                },
                directives: [ common.k, sidenav_MatDrawerContent ],
                styles: [ ".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}@media(-ms-high-contrast: active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}@media(-ms-high-contrast: active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media(-ms-high-contrast: active){[dir=rtl] .mat-drawer,.mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}/*# sourceMappingURL=drawer.css.map */\n" ],
                encapsulation: 2,
                changeDetection: 0
            }), MatDrawerContainer;
        })(), sidenav_MatSidenavContent = (() => {
            class MatSidenavContent extends sidenav_MatDrawerContent {
                constructor(changeDetectorRef, container, elementRef, scrollDispatcher, ngZone) {
                    super(changeDetectorRef, container, elementRef, scrollDispatcher, ngZone);
                }
            }
            return MatSidenavContent.ɵfac = function(t) {
                return new (t || MatSidenavContent)(core.Pb(core.h), core.Pb(Object(core.T)(() => sidenav_MatSidenavContainer)), core.Pb(core.k), core.Pb(scrolling.b), core.Pb(core.y));
            }, MatSidenavContent.ɵcmp = core.Jb({
                type: MatSidenavContent,
                selectors: [ [ "mat-sidenav-content" ] ],
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (core.Bb(2), core.Ub(_c6)), 2 & rf && (core.Ac("margin-left", ctx._container._contentMargins.left, "px"), 
                    core.Ac("margin-right", ctx._container._contentMargins.right, "px"));
                },
                features: [ core.xb ],
                ngContentSelectors: sidenav_c1,
                decls: 1,
                vars: 0,
                template: function(rf, ctx) {
                    1 & rf && (core.kc(), core.jc(0));
                },
                encapsulation: 2,
                changeDetection: 0
            }), MatSidenavContent;
        })(), sidenav_MatSidenav = (() => {
            class MatSidenav extends sidenav_MatDrawer {
                constructor() {
                    super(...arguments), this._fixedInViewport = !1, this._fixedTopGap = 0, this._fixedBottomGap = 0;
                }
                get fixedInViewport() {
                    return this._fixedInViewport;
                }
                set fixedInViewport(value) {
                    this._fixedInViewport = Object(coercion.b)(value);
                }
                get fixedTopGap() {
                    return this._fixedTopGap;
                }
                set fixedTopGap(value) {
                    this._fixedTopGap = Object(coercion.e)(value);
                }
                get fixedBottomGap() {
                    return this._fixedBottomGap;
                }
                set fixedBottomGap(value) {
                    this._fixedBottomGap = Object(coercion.e)(value);
                }
            }
            return MatSidenav.ɵfac = function(t) {
                return ɵMatSidenav_BaseFactory(t || MatSidenav);
            }, MatSidenav.ɵcmp = core.Jb({
                type: MatSidenav,
                selectors: [ [ "mat-sidenav" ] ],
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (core.Bb(9), core.Ub(_c7)), 2 & rf && (core.Cb("align", null), core.Ac("top", ctx.fixedInViewport ? ctx.fixedTopGap : null, "px"), 
                    core.Ac("bottom", ctx.fixedInViewport ? ctx.fixedBottomGap : null, "px"), core.Fb("mat-drawer-end", "end" === ctx.position), 
                    core.Fb("mat-drawer-over", "over" === ctx.mode), core.Fb("mat-drawer-push", "push" === ctx.mode), 
                    core.Fb("mat-drawer-side", "side" === ctx.mode), core.Fb("mat-drawer-opened", ctx.opened), 
                    core.Fb("mat-sidenav-fixed", ctx.fixedInViewport));
                },
                inputs: {
                    fixedInViewport: "fixedInViewport",
                    fixedTopGap: "fixedTopGap",
                    fixedBottomGap: "fixedBottomGap"
                },
                exportAs: [ "matSidenav" ],
                features: [ core.xb ],
                ngContentSelectors: sidenav_c1,
                decls: 2,
                vars: 0,
                consts: [ [ 1, "mat-drawer-inner-container" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.kc(), core.Vb(0, "div", 0), core.jc(1), core.Tb());
                },
                encapsulation: 2,
                data: {
                    animation: [ matDrawerAnimations.transformDrawer ]
                },
                changeDetection: 0
            }), MatSidenav;
        })();
        const ɵMatSidenav_BaseFactory = core.Xb(sidenav_MatSidenav);
        let sidenav_MatSidenavContainer = (() => {
            class MatSidenavContainer extends sidenav_MatDrawerContainer {}
            return MatSidenavContainer.ɵfac = function(t) {
                return ɵMatSidenavContainer_BaseFactory(t || MatSidenavContainer);
            }, MatSidenavContainer.ɵcmp = core.Jb({
                type: MatSidenavContainer,
                selectors: [ [ "mat-sidenav-container" ] ],
                contentQueries: function(rf, ctx, dirIndex) {
                    var _t;
                    1 & rf && (core.Hb(dirIndex, sidenav_MatSidenavContent, !0), core.Hb(dirIndex, sidenav_MatSidenav, !1)), 
                    2 & rf && (core.qc(_t = core.dc()) && (ctx._content = _t.first), core.qc(_t = core.dc()) && (ctx._drawers = _t));
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (core.Bb(1), core.Ub(_c8)), 2 & rf && core.Fb("mat-drawer-container-explicit-backdrop", ctx._backdropOverride);
                },
                exportAs: [ "matSidenavContainer" ],
                features: [ core.xb ],
                ngContentSelectors: _c10,
                decls: 4,
                vars: 2,
                consts: [ [ "class", "mat-drawer-backdrop", 3, "mat-drawer-shown", "click", 4, "ngIf" ], [ "cdkScrollable", "", 4, "ngIf" ], [ 1, "mat-drawer-backdrop", 3, "click" ], [ "cdkScrollable", "" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.kc(_c9), core.Cc(0, MatSidenavContainer_div_0_Template, 1, 1, "div", 0), 
                    core.jc(1), core.jc(2, 1), core.Cc(3, MatSidenavContainer_mat_sidenav_content_3_Template, 2, 0, "mat-sidenav-content", 1)), 
                    2 & rf && (core.lc("ngIf", ctx.hasBackdrop), core.Ab(3), core.lc("ngIf", !ctx._content));
                },
                directives: [ common.k, sidenav_MatSidenavContent, scrolling.a ],
                styles: [ ".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}@media(-ms-high-contrast: active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}@media(-ms-high-contrast: active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media(-ms-high-contrast: active){[dir=rtl] .mat-drawer,.mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}/*# sourceMappingURL=drawer.css.map */\n" ],
                encapsulation: 2,
                changeDetection: 0
            }), MatSidenavContainer;
        })();
        const ɵMatSidenavContainer_BaseFactory = core.Xb(sidenav_MatSidenavContainer);
        let sidenav_MatSidenavModule = (() => {
            class MatSidenavModule {}
            return MatSidenavModule.ɵmod = core.Nb({
                type: MatSidenavModule
            }), MatSidenavModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || MatSidenavModule);
                },
                imports: [ [ common.c, fesm2015_core.b, scrolling.c, platform.b ], fesm2015_core.b ]
            }), MatSidenavModule;
        })();
        const toolbar_c0 = [ 1, "mat-toolbar-row" ], toolbar_c1 = [ 1, "mat-toolbar" ], toolbar_c2 = [ "*", [ [ "mat-toolbar-row" ] ] ], toolbar_c3 = [ "*", "mat-toolbar-row" ];
        class MatToolbarBase {
            constructor(_elementRef) {
                this._elementRef = _elementRef;
            }
        }
        const _MatToolbarMixinBase = Object(fesm2015_core.f)(MatToolbarBase);
        let toolbar_MatToolbarRow = (() => {
            class MatToolbarRow {}
            return MatToolbarRow.ɵfac = function(t) {
                return new (t || MatToolbarRow);
            }, MatToolbarRow.ɵdir = core.Kb({
                type: MatToolbarRow,
                selectors: [ [ "mat-toolbar-row" ] ],
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && core.Ub(toolbar_c0);
                },
                exportAs: [ "matToolbarRow" ]
            }), MatToolbarRow;
        })(), toolbar_MatToolbar = (() => {
            class MatToolbar extends _MatToolbarMixinBase {
                constructor(elementRef, _platform, document) {
                    super(elementRef), this._platform = _platform, this._document = document;
                }
                ngAfterViewInit() {
                    Object(core.W)() && this._platform.isBrowser && (this._checkToolbarMixedModes(), 
                    this._toolbarRows.changes.subscribe(() => this._checkToolbarMixedModes()));
                }
                _checkToolbarMixedModes() {
                    this._toolbarRows.length && Array.from(this._elementRef.nativeElement.childNodes).filter(node => !(node.classList && node.classList.contains("mat-toolbar-row"))).filter(node => node.nodeType !== (this._document ? this._document.COMMENT_NODE : 8)).some(node => !(!node.textContent || !node.textContent.trim())) && function() {
                        throw Error("MatToolbar: Attempting to combine different toolbar modes. Either specify multiple `<mat-toolbar-row>` elements explicitly or just place content inside of a `<mat-toolbar>` for a single row.");
                    }();
                }
            }
            return MatToolbar.ɵfac = function(t) {
                return new (t || MatToolbar)(core.Pb(core.k), core.Pb(platform.a), core.Pb(common.d));
            }, MatToolbar.ɵcmp = core.Jb({
                type: MatToolbar,
                selectors: [ [ "mat-toolbar" ] ],
                contentQueries: function(rf, ctx, dirIndex) {
                    var _t;
                    1 & rf && core.Hb(dirIndex, toolbar_MatToolbarRow, !1), 2 & rf && core.qc(_t = core.dc()) && (ctx._toolbarRows = _t);
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (core.Bb(2), core.Ub(toolbar_c1)), 2 & rf && (core.Fb("mat-toolbar-multiple-rows", ctx._toolbarRows.length > 0), 
                    core.Fb("mat-toolbar-single-row", 0 === ctx._toolbarRows.length));
                },
                inputs: {
                    color: "color"
                },
                exportAs: [ "matToolbar" ],
                features: [ core.xb ],
                ngContentSelectors: toolbar_c3,
                decls: 2,
                vars: 0,
                template: function(rf, ctx) {
                    1 & rf && (core.kc(toolbar_c2), core.jc(0), core.jc(1, 1));
                },
                styles: [ "@media(-ms-high-contrast: active){.mat-toolbar{outline:solid 1px}}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}.mat-toolbar-multiple-rows{min-height:64px}.mat-toolbar-row,.mat-toolbar-single-row{height:64px}@media(max-width: 599px){.mat-toolbar-multiple-rows{min-height:56px}.mat-toolbar-row,.mat-toolbar-single-row{height:56px}}/*# sourceMappingURL=toolbar.css.map */\n" ],
                encapsulation: 2,
                changeDetection: 0
            }), MatToolbar;
        })(), toolbar_MatToolbarModule = (() => {
            class MatToolbarModule {}
            return MatToolbarModule.ɵmod = core.Nb({
                type: MatToolbarModule
            }), MatToolbarModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || MatToolbarModule);
                },
                imports: [ [ fesm2015_core.b ], fesm2015_core.b ]
            }), MatToolbarModule;
        })();
        const CurrentDateToken = new core.p("CurrentDate");
        function currentDateProvider() {
            return new Date;
        }
        var shared_window = __webpack_require__("GvZq");
        const notification_component_c0 = [ "*" ], LOCAL_STORAGE_NAMESPACE = "aio-notification/";
        let notification_component_NotificationComponent = (() => {
            class NotificationComponent {
                constructor(window, currentDate) {
                    this.window = window, this.currentDate = currentDate, this.dismissed = new core.m;
                }
                get localStorage() {
                    return this.window.localStorage;
                }
                ngOnInit() {
                    const previouslyHidden = "hide" === this.localStorage.getItem(LOCAL_STORAGE_NAMESPACE + this.notificationId), expired = this.currentDate > new Date(this.expirationDate);
                    this.showNotification = previouslyHidden || expired ? "hide" : "show";
                }
                contentClick() {
                    this.dismissOnContentClick && this.dismiss();
                }
                dismiss() {
                    this.localStorage.setItem(LOCAL_STORAGE_NAMESPACE + this.notificationId, "hide"), 
                    this.showNotification = "hide", this.dismissed.next();
                }
            }
            return NotificationComponent.ɵfac = function(t) {
                return new (t || NotificationComponent)(core.Pb(shared_window.a), core.Pb(CurrentDateToken));
            }, NotificationComponent.ɵcmp = core.Jb({
                type: NotificationComponent,
                selectors: [ [ "aio-notification" ] ],
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && core.Bb(1), 2 & rf && core.Ic("@hideAnimation", ctx.showNotification);
                },
                inputs: {
                    dismissOnContentClick: "dismissOnContentClick",
                    notificationId: "notificationId",
                    expirationDate: "expirationDate"
                },
                outputs: {
                    dismissed: "dismissed"
                },
                ngContentSelectors: notification_component_c0,
                decls: 4,
                vars: 0,
                consts: [ [ 1, "content", 3, "click", "keyup.enter" ], [ "mat-icon-button", "", "aria-label", "Close", 1, "close-button", 3, "click" ], [ "svgIcon", "close", "aria-label", "Dismiss notification" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.kc(), core.Vb(0, "span", 0), core.cc("click", (function($event) {
                        return ctx.contentClick();
                    })), core.cc("keyup.enter", (function($event) {
                        return ctx.contentClick();
                    })), core.jc(1), core.Tb(), core.Vb(2, "button", 1), core.cc("click", (function($event) {
                        return ctx.dismiss();
                    })), core.Qb(3, "mat-icon", 2), core.Tb());
                },
                directives: [ fesm2015_button.a, icon.a ],
                encapsulation: 2,
                data: {
                    animation: [ Object(fesm2015_animations.j)("hideAnimation", [ Object(fesm2015_animations.g)("show", Object(fesm2015_animations.h)({
                        height: "*"
                    })), Object(fesm2015_animations.g)("hide", Object(fesm2015_animations.h)({
                        height: 0
                    })), Object(fesm2015_animations.i)("show => hide", Object(fesm2015_animations.e)(250)) ]) ]
                }
            }), NotificationComponent;
        })();
        var location_service = __webpack_require__("/lUL");
        const search_box_component_c0 = [ "searchBox" ];
        let search_box_component_SearchBoxComponent = (() => {
            class SearchBoxComponent {
                constructor(locationService) {
                    this.locationService = locationService, this.searchDebounce = 300, this.searchSubject = new Subject.a, 
                    this.onSearch = this.searchSubject.pipe(Object(distinctUntilChanged.a)(), Object(debounceTime.a)(this.searchDebounce)), 
                    this.onFocus = new core.m;
                }
                ngAfterViewInit() {
                    const query = this.locationService.search().search;
                    query && (this.query = this.decodeQuery(query), this.doSearch());
                }
                doSearch() {
                    this.searchSubject.next(this.query);
                }
                doFocus() {
                    this.onFocus.emit(this.query);
                }
                focus() {
                    this.searchBox.nativeElement.focus();
                }
                decodeQuery(query) {
                    return query.replace(/\+/g, " ");
                }
                get query() {
                    return this.searchBox.nativeElement.value;
                }
                set query(value) {
                    this.searchBox.nativeElement.value = value;
                }
            }
            return SearchBoxComponent.ɵfac = function(t) {
                return new (t || SearchBoxComponent)(core.Pb(location_service.a));
            }, SearchBoxComponent.ɵcmp = core.Jb({
                type: SearchBoxComponent,
                selectors: [ [ "aio-search-box" ] ],
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && core.yc(search_box_component_c0, !0), 2 & rf && core.qc(_t = core.dc()) && (ctx.searchBox = _t.first);
                },
                outputs: {
                    onSearch: "onSearch",
                    onFocus: "onFocus"
                },
                decls: 2,
                vars: 0,
                consts: [ [ "type", "search", "aria-label", "search", "placeholder", "Search", 3, "input", "keyup", "focus", "click" ], [ "searchBox", "" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.Vb(0, "input", 0, 1), core.cc("input", (function($event) {
                        return ctx.doSearch();
                    })), core.cc("keyup", (function($event) {
                        return ctx.doSearch();
                    })), core.cc("focus", (function($event) {
                        return ctx.doFocus();
                    })), core.cc("click", (function($event) {
                        return ctx.doSearch();
                    })), core.Tb());
                },
                encapsulation: 2
            }), SearchBoxComponent;
        })();
        var ObjectUnsubscribedError = __webpack_require__("9ppp");
        class BehaviorSubject_BehaviorSubject extends Subject.a {
            constructor(_value) {
                super(), this._value = _value;
            }
            get value() {
                return this.getValue();
            }
            _subscribe(subscriber) {
                const subscription = super._subscribe(subscriber);
                return subscription && !subscription.closed && subscriber.next(this._value), subscription;
            }
            getValue() {
                if (this.hasError) throw this.thrownError;
                if (this.closed) throw new ObjectUnsubscribedError.a;
                return this._value;
            }
            next(value) {
                super.next(this._value = value);
            }
        }
        var combineLatest = __webpack_require__("itXk"), first = __webpack_require__("SxV6");
        let deployment_service_Deployment = (() => {
            class Deployment {
                constructor(location) {
                    this.location = location, this.mode = this.location.search().mode || environment.a.mode;
                }
            }
            return Deployment.ɵfac = function(t) {
                return new (t || Deployment)(core.Zb(location_service.a));
            }, Deployment.ɵprov = core.Lb({
                token: Deployment,
                factory: function(t) {
                    return Deployment.ɵfac(t);
                },
                providedIn: null
            }), Deployment;
        })();
        var document_service = __webpack_require__("jn67"), publishLast = __webpack_require__("qZ0a"), publishReplay = __webpack_require__("05l1");
        const navigationPath = document_service.a + "navigation.json";
        let navigation_service_NavigationService = (() => {
            class NavigationService {
                constructor(http, location) {
                    this.http = http, this.location = location;
                    const navigationInfo = this.fetchNavigationInfo();
                    this.navigationViews = this.getNavigationViews(navigationInfo), this.currentNodes = this.getCurrentNodes(this.navigationViews), 
                    this.versionInfo = this.getVersionInfo(navigationInfo);
                }
                fetchNavigationInfo() {
                    const navigationInfo = this.http.get(navigationPath).pipe(Object(publishLast.a)());
                    return navigationInfo.connect(), navigationInfo;
                }
                getVersionInfo(navigationInfo) {
                    const versionInfo = navigationInfo.pipe(Object(map.a)(response => response.__versionInfo), Object(publishLast.a)());
                    return versionInfo.connect(), versionInfo;
                }
                getNavigationViews(navigationInfo) {
                    const navigationViews = navigationInfo.pipe(Object(map.a)(response => {
                        const views = Object.assign({}, response);
                        return Object.keys(views).forEach(key => {
                            "_" === key[0] && delete views[key];
                        }), views;
                    }), Object(publishLast.a)());
                    return navigationViews.connect(), navigationViews;
                }
                getCurrentNodes(navigationViews) {
                    const currentNodes = Object(combineLatest.a)([ navigationViews.pipe(Object(map.a)(views => this.computeUrlToNavNodesMap(views))), this.location.currentPath ]).pipe(Object(map.a)(result => ({
                        navMap: result[0],
                        url: result[1]
                    })), Object(map.a)(result => {
                        const matchSpecialUrls = /^api/.exec(result.url);
                        return matchSpecialUrls && (result.url = matchSpecialUrls[0]), result.navMap.get(result.url) || {
                            "": {
                                view: "",
                                url: result.url,
                                nodes: []
                            }
                        };
                    }), Object(publishReplay.a)(1));
                    return currentNodes.connect(), currentNodes;
                }
                computeUrlToNavNodesMap(navigation) {
                    const navMap = new Map;
                    return Object.keys(navigation).forEach(view => navigation[view].forEach(node => this.walkNodes(view, navMap, node))), 
                    navMap;
                }
                ensureHasTooltip(node) {
                    const title = node.title;
                    null == node.tooltip && title && (node.tooltip = title + (/[a-zA-Z0-9]$/.test(title) ? "." : ""));
                }
                walkNodes(view, navMap, node, ancestors = []) {
                    const nodes = [ node, ...ancestors ], url = node.url;
                    if (this.ensureHasTooltip(node), url) {
                        const cleanedUrl = url.replace(/\/$/, "");
                        navMap.has(cleanedUrl) || navMap.set(cleanedUrl, {}), navMap.get(cleanedUrl)[view] = {
                            url: url,
                            view: view,
                            nodes: nodes
                        };
                    }
                    node.children && node.children.forEach(child => this.walkNodes(view, navMap, child, nodes));
                }
            }
            return NavigationService.ɵfac = function(t) {
                return new (t || NavigationService)(core.Zb(http.a), core.Zb(location_service.a));
            }, NavigationService.ɵprov = core.Lb({
                token: NavigationService,
                factory: function(t) {
                    return NavigationService.ɵfac(t);
                },
                providedIn: null
            }), NavigationService;
        })();
        var scroll_service = __webpack_require__("Faly"), search_service = __webpack_require__("to4i"), toc_service = __webpack_require__("TNhP");
        function NavItemComponent_div_0_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "div"), core.Vb(1, "a", 1), core.Vb(2, "span"), core.Ec(3), 
            core.Tb(), core.Tb(), core.Tb()), 2 & rf) {
                const ctx_r131 = core.gc();
                core.Ab(1), core.mc("href", ctx_r131.node.url, core.wc), core.mc("title", ctx_r131.node.tooltip), 
                core.lc("ngClass", ctx_r131.classes), core.Ab(2), core.Fc(ctx_r131.node.title);
            }
        }
        function NavItemComponent_div_1_a_1_Template(rf, ctx) {
            if (1 & rf) {
                const _r137 = core.Wb();
                core.Vb(0, "a", 6), core.cc("click", (function($event) {
                    return core.uc(_r137), core.gc(2).headerClicked();
                })), core.Vb(1, "span"), core.Ec(2), core.Tb(), core.Qb(3, "mat-icon", 7), core.Tb();
            }
            if (2 & rf) {
                const ctx_r133 = core.gc(2);
                core.mc("href", ctx_r133.node.url, core.wc), core.mc("title", ctx_r133.node.tooltip), 
                core.lc("ngClass", ctx_r133.classes), core.Ab(2), core.Fc(ctx_r133.node.title);
            }
        }
        function NavItemComponent_div_1_button_2_Template(rf, ctx) {
            if (1 & rf) {
                const _r139 = core.Wb();
                core.Vb(0, "button", 8), core.cc("click", (function($event) {
                    return core.uc(_r139), core.gc(2).headerClicked();
                })), core.Vb(1, "span"), core.Ec(2), core.Tb(), core.Qb(3, "mat-icon", 7), core.Tb();
            }
            if (2 & rf) {
                const ctx_r134 = core.gc(2);
                core.mc("title", ctx_r134.node.tooltip), core.lc("ngClass", ctx_r134.classes), core.Cb("aria-pressed", ctx_r134.isExpanded), 
                core.Ab(2), core.Fc(ctx_r134.node.title);
            }
        }
        function NavItemComponent_div_1_aio_nav_item_4_Template(rf, ctx) {
            if (1 & rf && core.Qb(0, "aio-nav-item", 9), 2 & rf) {
                const node_r140 = ctx.$implicit, ctx_r135 = core.gc(2);
                core.lc("level", ctx_r135.level + 1)("isWide", ctx_r135.isWide)("isParentExpanded", ctx_r135.isExpanded)("node", node_r140)("selectedNodes", ctx_r135.selectedNodes);
            }
        }
        function NavItemComponent_div_1_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "div"), core.Cc(1, NavItemComponent_div_1_a_1_Template, 4, 4, "a", 2), 
            core.Cc(2, NavItemComponent_div_1_button_2_Template, 4, 4, "button", 3), core.Vb(3, "div", 4), 
            core.Cc(4, NavItemComponent_div_1_aio_nav_item_4_Template, 1, 5, "aio-nav-item", 5), 
            core.Tb(), core.Tb()), 2 & rf) {
                const ctx_r132 = core.gc();
                core.Ab(1), core.lc("ngIf", null != ctx_r132.node.url), core.Ab(1), core.lc("ngIf", null == ctx_r132.node.url), 
                core.Ab(1), core.lc("ngClass", ctx_r132.classes), core.Ab(1), core.lc("ngForOf", ctx_r132.nodeChildren);
            }
        }
        let nav_item_component_NavItemComponent = (() => {
            class NavItemComponent {
                constructor() {
                    this.isWide = !1, this.level = 1, this.isParentExpanded = !0, this.isExpanded = !1, 
                    this.isSelected = !1;
                }
                ngOnChanges() {
                    if (this.nodeChildren = this.node && this.node.children ? this.node.children.filter(n => !n.hidden) : [], 
                    this.selectedNodes) {
                        const ix = this.selectedNodes.indexOf(this.node);
                        this.isSelected = -1 !== ix, this.isExpanded = this.isParentExpanded && (this.isSelected || this.isWide && this.isExpanded);
                    } else this.isSelected = !1;
                    this.setClasses();
                }
                setClasses() {
                    this.classes = {
                        ["level-" + this.level]: !0,
                        collapsed: !this.isExpanded,
                        expanded: this.isExpanded,
                        selected: this.isSelected
                    };
                }
                headerClicked() {
                    this.isExpanded = !this.isExpanded, this.setClasses();
                }
            }
            return NavItemComponent.ɵfac = function(t) {
                return new (t || NavItemComponent);
            }, NavItemComponent.ɵcmp = core.Jb({
                type: NavItemComponent,
                selectors: [ [ "aio-nav-item" ] ],
                inputs: {
                    isWide: "isWide",
                    level: "level",
                    node: "node",
                    isParentExpanded: "isParentExpanded",
                    selectedNodes: "selectedNodes"
                },
                features: [ core.yb() ],
                decls: 2,
                vars: 2,
                consts: [ [ 4, "ngIf" ], [ 1, "vertical-menu-item", 3, "href", "ngClass", "title" ], [ "class", "vertical-menu-item heading", 3, "href", "ngClass", "title", "click", 4, "ngIf" ], [ "type", "button", "class", "vertical-menu-item heading", 3, "ngClass", "title", "click", 4, "ngIf" ], [ 1, "heading-children", 3, "ngClass" ], [ 3, "level", "isWide", "isParentExpanded", "node", "selectedNodes", 4, "ngFor", "ngForOf" ], [ 1, "vertical-menu-item", "heading", 3, "href", "ngClass", "title", "click" ], [ "svgIcon", "keyboard_arrow_right", 1, "rotating-icon" ], [ "type", "button", 1, "vertical-menu-item", "heading", 3, "ngClass", "title", "click" ], [ 3, "level", "isWide", "isParentExpanded", "node", "selectedNodes" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.Cc(0, NavItemComponent_div_0_Template, 4, 4, "div", 0), core.Cc(1, NavItemComponent_div_1_Template, 5, 4, "div", 0)), 
                    2 & rf && (core.lc("ngIf", !ctx.node.children), core.Ab(1), core.lc("ngIf", ctx.node.children));
                },
                directives: [ common.k, common.i, common.j, icon.a, NavItemComponent ],
                encapsulation: 2
            }), NavItemComponent;
        })();
        function NavMenuComponent_aio_nav_item_0_Template(rf, ctx) {
            if (1 & rf && core.Qb(0, "aio-nav-item", 1), 2 & rf) {
                const node_r130 = ctx.$implicit, ctx_r129 = core.gc();
                core.lc("node", node_r130)("selectedNodes", null == ctx_r129.currentNode ? null : ctx_r129.currentNode.nodes)("isWide", ctx_r129.isWide);
            }
        }
        let nav_menu_component_NavMenuComponent = (() => {
            class NavMenuComponent {
                constructor() {
                    this.isWide = !1;
                }
                get filteredNodes() {
                    return this.nodes ? this.nodes.filter(n => !n.hidden) : [];
                }
            }
            return NavMenuComponent.ɵfac = function(t) {
                return new (t || NavMenuComponent);
            }, NavMenuComponent.ɵcmp = core.Jb({
                type: NavMenuComponent,
                selectors: [ [ "aio-nav-menu" ] ],
                inputs: {
                    currentNode: "currentNode",
                    isWide: "isWide",
                    nodes: "nodes"
                },
                decls: 1,
                vars: 1,
                consts: [ [ 3, "node", "selectedNodes", "isWide", 4, "ngFor", "ngForOf" ], [ 3, "node", "selectedNodes", "isWide" ] ],
                template: function(rf, ctx) {
                    1 & rf && core.Cc(0, NavMenuComponent_aio_nav_item_0_Template, 1, 3, "aio-nav-item", 0), 
                    2 & rf && core.lc("ngForOf", ctx.filteredNodes);
                },
                directives: [ common.j, nav_item_component_NavItemComponent ],
                encapsulation: 2
            }), NavMenuComponent;
        })();
        var select_component = __webpack_require__("x4lQ");
        function ModeBannerComponent_div_0_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "div", 1), core.Vb(1, "p"), core.Ec(2, "This is the "), 
            core.Vb(3, "strong"), core.Ec(4), core.Tb(), core.Ec(5, " Please visit "), core.Vb(6, "a", 2), 
            core.Ec(7, "angular.io"), core.Tb(), core.Ec(8, " to see documentation for the current version of Angular."), 
            core.Tb(), core.Tb()), 2 & rf) {
                const ctx_r122 = core.gc();
                core.Ab(4), core.Gc("archived documentation for Angular v", null == ctx_r122.version ? null : ctx_r122.version.major, ".");
            }
        }
        let mode_banner_component_ModeBannerComponent = (() => {
            class ModeBannerComponent {}
            return ModeBannerComponent.ɵfac = function(t) {
                return new (t || ModeBannerComponent);
            }, ModeBannerComponent.ɵcmp = core.Jb({
                type: ModeBannerComponent,
                selectors: [ [ "aio-mode-banner" ] ],
                inputs: {
                    mode: "mode",
                    version: "version"
                },
                decls: 1,
                vars: 1,
                consts: [ [ "class", "mode-banner alert archive-warning", 4, "ngIf" ], [ 1, "mode-banner", "alert", "archive-warning" ], [ "href", "https://angular.io/" ] ],
                template: function(rf, ctx) {
                    1 & rf && core.Cc(0, ModeBannerComponent_div_0_Template, 9, 1, "div", 0), 2 & rf && core.lc("ngIf", "archive" == ctx.mode);
                },
                directives: [ common.k ],
                encapsulation: 2
            }), ModeBannerComponent;
        })();
        var of = __webpack_require__("LRne"), asap = __webpack_require__("7Hc7"), Observable = __webpack_require__("HDdC"), timer = __webpack_require__("PqYM"), observeOn = __webpack_require__("pxpQ"), switchMap = __webpack_require__("eIep"), tap = __webpack_require__("vkgz"), catchError = __webpack_require__("JIr8"), logger_service = __webpack_require__("vHPH"), announcement_bar_module = __webpack_require__("5UAH"), api_list_module = __webpack_require__("dth9"), contributor_list_module = __webpack_require__("fPy6"), file_not_found_search_module = __webpack_require__("Afo1"), resource_list_module = __webpack_require__("6U+v"), toc_module = __webpack_require__("+1zh"), code_example_module = __webpack_require__("DzVX"), code_tabs_module = __webpack_require__("g5Zp"), live_example_module = __webpack_require__("m7ka");
        console.log(announcement_bar_module.AnnouncementBarModule), console.log(api_list_module.ApiListModule), 
        console.log(contributor_list_module.ContributorListModule), console.log(file_not_found_search_module.FileNotFoundSearchModule), 
        console.log(resource_list_module.ResourceListModule), console.log(toc_module.TocModule), 
        console.log(code_example_module.CodeExampleModule), console.log(code_tabs_module.CodeTabsModule), 
        console.log(live_example_module.LiveExampleModule);
        const ELEMENT_MODULE_LOAD_CALLBACKS_AS_ROUTES = [ {
            selector: "aio-announcement-bar",
            loadChildren: () => Promise.resolve().then(__webpack_require__.bind(null, "5UAH")).then(mod => mod.AnnouncementBarModule)
        }, {
            selector: "aio-api-list",
            loadChildren: () => Promise.resolve().then(__webpack_require__.bind(null, "dth9")).then(mod => mod.ApiListModule)
        }, {
            selector: "aio-contributor-list",
            loadChildren: () => Promise.resolve().then(__webpack_require__.bind(null, "fPy6")).then(mod => mod.ContributorListModule)
        }, {
            selector: "aio-file-not-found-search",
            loadChildren: () => Promise.resolve().then(__webpack_require__.bind(null, "Afo1")).then(mod => mod.FileNotFoundSearchModule)
        }, {
            selector: "aio-resource-list",
            loadChildren: () => Promise.resolve().then(__webpack_require__.bind(null, "6U+v")).then(mod => mod.ResourceListModule)
        }, {
            selector: "aio-toc",
            loadChildren: () => Promise.resolve().then(__webpack_require__.bind(null, "+1zh")).then(mod => mod.TocModule)
        }, {
            selector: "code-example",
            loadChildren: () => Promise.resolve().then(__webpack_require__.bind(null, "DzVX")).then(mod => mod.CodeExampleModule)
        }, {
            selector: "code-tabs",
            loadChildren: () => Promise.resolve().then(__webpack_require__.bind(null, "g5Zp")).then(mod => mod.CodeTabsModule)
        }, {
            selector: "live-example",
            loadChildren: () => Promise.resolve().then(__webpack_require__.bind(null, "m7ka")).then(mod => mod.LiveExampleModule)
        } ], ELEMENT_MODULE_LOAD_CALLBACKS_TOKEN = new core.p("aio/elements-map"), ELEMENT_MODULE_LOAD_CALLBACKS = new Map;
        ELEMENT_MODULE_LOAD_CALLBACKS_AS_ROUTES.forEach(route => {
            ELEMENT_MODULE_LOAD_CALLBACKS.set(route.selector, route.loadChildren);
        });
        var observable_from = __webpack_require__("Cfvw");
        const matches = (() => {
            const elProto = Element.prototype;
            return elProto.matches || elProto.matchesSelector || elProto.mozMatchesSelector || elProto.msMatchesSelector || elProto.oMatchesSelector || elProto.webkitMatchesSelector;
        })(), scheduler = {
            schedule(taskFn, delay) {
                const id = setTimeout(taskFn, delay);
                return (() => clearTimeout(id));
            },
            scheduleBeforeRender(taskFn) {
                if ("undefined" == typeof window) return scheduler.schedule(taskFn, 0);
                if (void 0 === window.requestAnimationFrame) return scheduler.schedule(taskFn, 16);
                const id = window.requestAnimationFrame(taskFn);
                return (() => window.cancelAnimationFrame(id));
            }
        };
        function findMatchingIndex(node, selectors, defaultIndex) {
            let matchingIndex = defaultIndex;
            return function(node) {
                return !!node && node.nodeType === Node.ELEMENT_NODE;
            }(node) && selectors.some((selector, i) => !("*" === selector || !function(element, selector) {
                return matches.call(element, selector);
            }(node, selector) || (matchingIndex = i, 0))), matchingIndex;
        }
        const DESTROY_DELAY = 10;
        class elements_ComponentNgElementStrategyFactory {
            constructor(component, injector) {
                this.component = component, this.injector = injector, this.componentFactory = injector.get(core.j).resolveComponentFactory(component);
            }
            create(injector) {
                return new elements_ComponentNgElementStrategy(this.componentFactory, injector);
            }
        }
        class elements_ComponentNgElementStrategy {
            constructor(componentFactory, injector) {
                this.componentFactory = componentFactory, this.injector = injector, this.inputChanges = null, 
                this.implementsOnChanges = !1, this.scheduledChangeDetectionFn = null, this.scheduledDestroyFn = null, 
                this.initialInputValues = new Map, this.uninitializedInputs = new Set;
            }
            connect(element) {
                if (null !== this.scheduledDestroyFn) return this.scheduledDestroyFn(), void (this.scheduledDestroyFn = null);
                this.componentRef || this.initializeComponent(element);
            }
            disconnect() {
                this.componentRef && null === this.scheduledDestroyFn && (this.scheduledDestroyFn = scheduler.schedule(() => {
                    this.componentRef && (this.componentRef.destroy(), this.componentRef = null);
                }, DESTROY_DELAY));
            }
            getInputValue(property) {
                return this.componentRef ? this.componentRef.instance[property] : this.initialInputValues.get(property);
            }
            setInputValue(property, value) {
                var value1, value2;
                this.componentRef ? (value1 = value) === (value2 = this.getInputValue(property)) || value1 != value1 && value2 != value2 || (this.recordInputChange(property, value), 
                this.componentRef.instance[property] = value, this.scheduleDetectChanges()) : this.initialInputValues.set(property, value);
            }
            initializeComponent(element) {
                const childInjector = core.q.create({
                    providers: [],
                    parent: this.injector
                }), projectableNodes = function(host, ngContentSelectors) {
                    const nodes = host.childNodes, projectableNodes = ngContentSelectors.map(() => []);
                    let wildcardIndex = -1;
                    ngContentSelectors.some((selector, i) => "*" === selector && (wildcardIndex = i, 
                    !0));
                    for (let i = 0, ii = nodes.length; i < ii; ++i) {
                        const node = nodes[i], ngContentIndex = findMatchingIndex(node, ngContentSelectors, wildcardIndex);
                        -1 !== ngContentIndex && projectableNodes[ngContentIndex].push(node);
                    }
                    return projectableNodes;
                }(element, this.componentFactory.ngContentSelectors);
                this.componentRef = this.componentFactory.create(childInjector, projectableNodes, element), 
                this.implementsOnChanges = "function" == typeof this.componentRef.instance.ngOnChanges, 
                this.initializeInputs(), this.initializeOutputs(), this.detectChanges(), this.injector.get(core.g).attachView(this.componentRef.hostView);
            }
            initializeInputs() {
                this.componentFactory.inputs.forEach(({propName: propName}) => {
                    this.initialInputValues.has(propName) ? this.setInputValue(propName, this.initialInputValues.get(propName)) : this.uninitializedInputs.add(propName);
                }), this.initialInputValues.clear();
            }
            initializeOutputs() {
                const eventEmitters = this.componentFactory.outputs.map(({propName: propName, templateName: templateName}) => this.componentRef.instance[propName].pipe(Object(map.a)(value => ({
                    name: templateName,
                    value: value
                }))));
                this.events = Object(merge.a)(...eventEmitters);
            }
            callNgOnChanges() {
                if (!this.implementsOnChanges || null === this.inputChanges) return;
                const inputChanges = this.inputChanges;
                this.inputChanges = null, this.componentRef.instance.ngOnChanges(inputChanges);
            }
            scheduleDetectChanges() {
                this.scheduledChangeDetectionFn || (this.scheduledChangeDetectionFn = scheduler.scheduleBeforeRender(() => {
                    this.scheduledChangeDetectionFn = null, this.detectChanges();
                }));
            }
            recordInputChange(property, currentValue) {
                if (this.componentRef && !this.implementsOnChanges) return;
                null === this.inputChanges && (this.inputChanges = {});
                const pendingChange = this.inputChanges[property];
                if (pendingChange) return void (pendingChange.currentValue = currentValue);
                const isFirstChange = this.uninitializedInputs.has(property);
                this.uninitializedInputs.delete(property);
                const previousValue = isFirstChange ? void 0 : this.getInputValue(property);
                this.inputChanges[property] = new core.I(previousValue, currentValue, isFirstChange);
            }
            detectChanges() {
                this.componentRef && (this.callNgOnChanges(), this.componentRef.changeDetectorRef.detectChanges());
            }
        }
        class NgElement extends HTMLElement {
            constructor() {
                super(...arguments), this.ngElementEventsSubscription = null;
            }
        }
        let elements_loader_ElementsLoader = (() => {
            class ElementsLoader {
                constructor(moduleRef, elementModulePaths, compiler) {
                    this.moduleRef = moduleRef, this.compiler = compiler, this.elementsLoading = new Map, 
                    this.elementsToLoad = new Map(elementModulePaths);
                }
                loadContainedCustomElements(element) {
                    const unregisteredSelectors = Array.from(this.elementsToLoad.keys()).filter(s => element.querySelector(s));
                    if (!unregisteredSelectors.length) return Object(of.a)(void 0);
                    const allRegistered = Promise.all(unregisteredSelectors.map(s => this.loadCustomElement(s)));
                    return Object(observable_from.a)(allRegistered.then(() => void 0));
                }
                loadCustomElement(selector) {
                    if (this.elementsLoading.has(selector)) return this.elementsLoading.get(selector);
                    if (this.elementsToLoad.has(selector)) {
                        const loadedAndRegistered = this.elementsToLoad.get(selector)().then(elementModuleOrFactory => elementModuleOrFactory instanceof core.u ? elementModuleOrFactory : this.compiler.compileModuleAsync(elementModuleOrFactory)).then(elementModuleFactory => {
                            const elementModuleRef = elementModuleFactory.create(this.moduleRef.injector), CustomElement = function(component, config) {
                                const inputs = function(component, injector) {
                                    return injector.get(core.j).resolveComponentFactory(component).inputs;
                                }(component, config.injector), strategyFactory = config.strategyFactory || new elements_ComponentNgElementStrategyFactory(component, config.injector), attributeToPropertyInputs = function(inputs) {
                                    const attributeToPropertyInputs = {};
                                    return inputs.forEach(({propName: propName, templateName: templateName}) => {
                                        attributeToPropertyInputs[function(input) {
                                            return input.replace(/[A-Z]/g, char => `-${char.toLowerCase()}`);
                                        }(templateName)] = propName;
                                    }), attributeToPropertyInputs;
                                }(inputs);
                                class NgElementImpl extends NgElement {
                                    constructor(injector) {
                                        super(), this.ngElementStrategy = strategyFactory.create(injector || config.injector);
                                    }
                                    attributeChangedCallback(attrName, oldValue, newValue, namespace) {
                                        this.ngElementStrategy || (this.ngElementStrategy = strategyFactory.create(config.injector)), 
                                        this.ngElementStrategy.setInputValue(attributeToPropertyInputs[attrName], newValue);
                                    }
                                    connectedCallback() {
                                        this.ngElementStrategy || (this.ngElementStrategy = strategyFactory.create(config.injector)), 
                                        this.ngElementStrategy.connect(this), this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe(e => {
                                            const customEvent = function(doc, name, detail) {
                                                if ("function" != typeof CustomEvent) {
                                                    const event = doc.createEvent("CustomEvent");
                                                    return event.initCustomEvent(name, !1, !1, detail), event;
                                                }
                                                return new CustomEvent(name, {
                                                    bubbles: !1,
                                                    cancelable: !1,
                                                    detail: detail
                                                });
                                            }(this.ownerDocument, e.name, e.value);
                                            this.dispatchEvent(customEvent);
                                        });
                                    }
                                    disconnectedCallback() {
                                        this.ngElementStrategy && this.ngElementStrategy.disconnect(), this.ngElementEventsSubscription && (this.ngElementEventsSubscription.unsubscribe(), 
                                        this.ngElementEventsSubscription = null);
                                    }
                                }
                                return NgElementImpl.observedAttributes = Object.keys(attributeToPropertyInputs), 
                                inputs.map(({propName: propName}) => propName).forEach(property => {
                                    Object.defineProperty(NgElementImpl.prototype, property, {
                                        get: function() {
                                            return this.ngElementStrategy.getInputValue(property);
                                        },
                                        set: function(newValue) {
                                            this.ngElementStrategy.setInputValue(property, newValue);
                                        },
                                        configurable: !0,
                                        enumerable: !0
                                    });
                                }), NgElementImpl;
                            }(elementModuleRef.instance.customElementComponent, {
                                injector: elementModuleRef.injector
                            });
                            return customElements.define(selector, CustomElement), customElements.whenDefined(selector);
                        }).then(() => {
                            this.elementsLoading.delete(selector), this.elementsToLoad.delete(selector);
                        }).catch(err => (this.elementsLoading.delete(selector), Promise.reject(err)));
                        return this.elementsLoading.set(selector, loadedAndRegistered), loadedAndRegistered;
                    }
                    return Promise.resolve();
                }
            }
            return ElementsLoader.ɵfac = function(t) {
                return new (t || ElementsLoader)(core.Zb(core.w), core.Zb(ELEMENT_MODULE_LOAD_CALLBACKS_TOKEN), core.Zb(core.i));
            }, ElementsLoader.ɵprov = core.Lb({
                token: ElementsLoader,
                factory: function(t) {
                    return ElementsLoader.ɵfac(t);
                },
                providedIn: null
            }), ElementsLoader;
        })();
        const NO_ANIMATIONS = "no-animations", initialDocViewerElement = document.querySelector("aio-doc-viewer"), initialDocViewerContent = initialDocViewerElement ? initialDocViewerElement.innerHTML : "";
        let doc_viewer_component_DocViewerComponent = (() => {
            class DocViewerComponent {
                constructor(elementRef, logger, titleService, metaService, tocService, elementsLoader) {
                    this.logger = logger, this.titleService = titleService, this.metaService = metaService, 
                    this.tocService = tocService, this.elementsLoader = elementsLoader, this.void$ = Object(of.a)(void 0), 
                    this.onDestroy$ = new core.m, this.docContents$ = new core.m, this.currViewContainer = document.createElement("div"), 
                    this.nextViewContainer = document.createElement("div"), this.docReady = new core.m, 
                    this.docRemoved = new core.m, this.docInserted = new core.m, this.docRendered = new core.m, 
                    this.hostElement = elementRef.nativeElement, this.hostElement.innerHTML = initialDocViewerContent, 
                    this.hostElement.firstElementChild && (this.currViewContainer = this.hostElement.firstElementChild), 
                    this.docContents$.pipe(Object(observeOn.b)(asap.a), Object(switchMap.a)(newDoc => this.render(newDoc)), Object(takeUntil.a)(this.onDestroy$)).subscribe();
                }
                set doc(newDoc) {
                    newDoc && this.docContents$.emit(newDoc);
                }
                ngOnDestroy() {
                    this.onDestroy$.emit();
                }
                prepareTitleAndToc(targetElem, docId) {
                    const titleEl = targetElem.querySelector("h1"), needsToc = !!titleEl && !/no-?toc/i.test(titleEl.className), embeddedToc = targetElem.querySelector("aio-toc.embedded");
                    return needsToc && !embeddedToc ? titleEl.insertAdjacentHTML("afterend", '<aio-toc class="embedded"></aio-toc>') : !needsToc && embeddedToc && null !== embeddedToc.parentNode && embeddedToc.parentNode.removeChild(embeddedToc), 
                    () => {
                        this.tocService.reset();
                        let title = "";
                        titleEl && (title = "string" == typeof titleEl.innerText ? titleEl.innerText : titleEl.textContent, 
                        needsToc && this.tocService.genToc(targetElem, docId)), this.titleService.setTitle(title ? `Angular - ${title}` : "Angular");
                    };
                }
                render(doc) {
                    let addTitleAndToc;
                    return this.setNoIndex(doc.id === document_service.e || doc.id === document_service.d), 
                    this.void$.pipe(Object(tap.a)(() => this.nextViewContainer.innerHTML = doc.contents || ""), Object(tap.a)(() => addTitleAndToc = this.prepareTitleAndToc(this.nextViewContainer, doc.id)), Object(switchMap.a)(() => this.elementsLoader.loadContainedCustomElements(this.nextViewContainer)), Object(tap.a)(() => this.docReady.emit()), Object(switchMap.a)(() => this.swapViews(addTitleAndToc)), Object(tap.a)(() => this.docRendered.emit()), Object(catchError.a)(err => {
                        const errorMessage = err instanceof Error ? err.stack : err;
                        return this.logger.error(new Error(`[DocViewer] Error preparing document '${doc.id}': ${errorMessage}`)), 
                        this.nextViewContainer.innerHTML = "", this.setNoIndex(!0), this.void$;
                    }));
                }
                setNoIndex(val) {
                    val ? this.metaService.addTag({
                        name: "robots",
                        content: "noindex"
                    }) : this.metaService.removeTag('name="robots"');
                }
                swapViews(onInsertedCb = (() => {})) {
                    const raf$ = new Observable.a(subscriber => {
                        const rafId = requestAnimationFrame(() => {
                            subscriber.next(), subscriber.complete();
                        });
                        return () => cancelAnimationFrame(rafId);
                    }), animateProp = (elem, prop, from, to, duration = 200) => {
                        const animationsDisabled = !DocViewerComponent.animationsEnabled || this.hostElement.classList.contains(NO_ANIMATIONS);
                        return "length" === prop || "parentRule" === prop ? this.void$ : (elem.style.transition = "", 
                        animationsDisabled ? this.void$.pipe(Object(tap.a)(() => elem.style[prop] = to)) : this.void$.pipe(Object(switchMap.a)(() => raf$), Object(tap.a)(() => elem.style[prop] = from), Object(switchMap.a)(() => raf$), Object(tap.a)(() => elem.style.transition = `all ${duration}ms ease-in-out`), Object(switchMap.a)(() => raf$), Object(tap.a)(() => elem.style[prop] = to), Object(switchMap.a)(() => Object(timer.a)((elem => {
                            const cssValue = getComputedStyle(elem).transitionDuration || "";
                            return 1e3 * Number(cssValue.replace(/s$/, ""));
                        })(elem))), Object(switchMap.a)(() => this.void$)));
                    };
                    let done$ = this.void$;
                    return this.currViewContainer.parentElement && (done$ = done$.pipe(Object(switchMap.a)(() => (elem => animateProp(elem, "opacity", "1", "0.1"))(this.currViewContainer)), Object(tap.a)(() => this.currViewContainer.parentElement.removeChild(this.currViewContainer)), Object(tap.a)(() => this.docRemoved.emit()))), 
                    done$.pipe(Object(tap.a)(() => this.hostElement.appendChild(this.nextViewContainer)), Object(tap.a)(() => onInsertedCb()), Object(tap.a)(() => this.docInserted.emit()), Object(switchMap.a)(() => (elem => animateProp(elem, "opacity", "0.1", "1"))(this.nextViewContainer)), Object(tap.a)(() => {
                        const prevViewContainer = this.currViewContainer;
                        this.currViewContainer = this.nextViewContainer, this.nextViewContainer = prevViewContainer, 
                        this.nextViewContainer.innerHTML = "";
                    }));
                }
            }
            return DocViewerComponent.animationsEnabled = !0, DocViewerComponent.ɵfac = function(t) {
                return new (t || DocViewerComponent)(core.Pb(core.k), core.Pb(logger_service.a), core.Pb(platform_browser.e), core.Pb(platform_browser.d), core.Pb(toc_service.a), core.Pb(elements_loader_ElementsLoader));
            }, DocViewerComponent.ɵcmp = core.Jb({
                type: DocViewerComponent,
                selectors: [ [ "aio-doc-viewer" ] ],
                inputs: {
                    doc: "doc"
                },
                outputs: {
                    docReady: "docReady",
                    docRemoved: "docRemoved",
                    docInserted: "docInserted",
                    docRendered: "docRendered"
                },
                decls: 0,
                vars: 0,
                template: function(rf, ctx) {},
                encapsulation: 2
            }), DocViewerComponent;
        })();
        function FooterComponent_div_1_li_4_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "li"), core.Vb(1, "a", 6), core.Ec(2), core.Tb(), core.Tb()), 
            2 & rf) {
                const item_r128 = ctx.$implicit;
                core.Ab(1), core.lc("href", item_r128.url, core.wc)("title", item_r128.tooltip || item_r128.title), 
                core.Ab(1), core.Fc(item_r128.title);
            }
        }
        function FooterComponent_div_1_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "div", 4), core.Vb(1, "h3"), core.Ec(2), core.Tb(), core.Vb(3, "ul"), 
            core.Cc(4, FooterComponent_div_1_li_4_Template, 3, 3, "li", 5), core.Tb(), core.Tb()), 
            2 & rf) {
                const node_r126 = ctx.$implicit;
                core.Ab(2), core.Fc(node_r126.title), core.Ab(2), core.lc("ngForOf", node_r126.children);
            }
        }
        let footer_component_FooterComponent = (() => {
            class FooterComponent {}
            return FooterComponent.ɵfac = function(t) {
                return new (t || FooterComponent);
            }, FooterComponent.ɵcmp = core.Jb({
                type: FooterComponent,
                selectors: [ [ "aio-footer" ] ],
                inputs: {
                    nodes: "nodes",
                    versionInfo: "versionInfo"
                },
                decls: 12,
                vars: 2,
                consts: [ [ 1, "grid-fluid" ], [ "class", "footer-block", 4, "ngFor", "ngForOf" ], [ "href", "license", "title", "License text" ], [ "href", "http://creativecommons.org/licenses/by/4.0/" ], [ 1, "footer-block" ], [ 4, "ngFor", "ngForOf" ], [ 1, "link", 3, "href", "title" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.Vb(0, "div", 0), core.Cc(1, FooterComponent_div_1_Template, 5, 2, "div", 1), 
                    core.Tb(), core.Vb(2, "p"), core.Ec(3, " Super-powered by Google ©2010-2019. Code licensed under an "), 
                    core.Vb(4, "a", 2), core.Ec(5, "MIT-style License"), core.Tb(), core.Ec(6, ". Documentation licensed under "), 
                    core.Vb(7, "a", 3), core.Ec(8, "CC BY 4.0"), core.Tb(), core.Ec(9, ".\n"), core.Tb(), 
                    core.Vb(10, "p"), core.Ec(11), core.Tb()), 2 & rf && (core.Ab(1), core.lc("ngForOf", ctx.nodes), 
                    core.Ab(10), core.Gc(" Version ", null == ctx.versionInfo ? null : ctx.versionInfo.full, ".\n"));
                },
                directives: [ common.j ],
                encapsulation: 2
            }), FooterComponent;
        })();
        function TopMenuComponent_li_1_Template(rf, ctx) {
            if (1 & rf && (core.Vb(0, "li"), core.Vb(1, "a", 2), core.Vb(2, "span", 3), core.Ec(3), 
            core.Tb(), core.Tb(), core.Tb()), 2 & rf) {
                const node_r124 = ctx.$implicit;
                core.Ab(1), core.lc("href", node_r124.url, core.wc)("title", node_r124.title), core.Ab(2), 
                core.Fc(node_r124.title);
            }
        }
        let top_menu_component_TopMenuComponent = (() => {
            class TopMenuComponent {}
            return TopMenuComponent.ɵfac = function(t) {
                return new (t || TopMenuComponent);
            }, TopMenuComponent.ɵcmp = core.Jb({
                type: TopMenuComponent,
                selectors: [ [ "aio-top-menu" ] ],
                inputs: {
                    nodes: "nodes"
                },
                decls: 2,
                vars: 1,
                consts: [ [ "role", "navigation" ], [ 4, "ngFor", "ngForOf" ], [ 1, "nav-link", 3, "href", "title" ], [ 1, "nav-link-inner" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.Vb(0, "ul", 0), core.Cc(1, TopMenuComponent_li_1_Template, 4, 3, "li", 1), 
                    core.Tb()), 2 & rf && (core.Ab(1), core.lc("ngForOf", ctx.nodes));
                },
                directives: [ common.j ],
                encapsulation: 2
            }), TopMenuComponent;
        })();
        var search_results_component = __webpack_require__("LwjS");
        const dt_component_c0 = [ "dt" ];
        let dt_component_DtComponent = (() => {
            class DtComponent {
                constructor() {
                    this.docChange = new core.m;
                }
                get text() {
                    return this.doc && this.doc.contents;
                }
                dtextSet() {
                    this.doc.contents = this.dt.nativeElement.value, this.docChange.emit(Object.assign({}, this.doc));
                }
            }
            return DtComponent.ɵfac = function(t) {
                return new (t || DtComponent);
            }, DtComponent.ɵcmp = core.Jb({
                type: DtComponent,
                selectors: [ [ "aio-dt" ] ],
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && core.yc(dt_component_c0, !0, core.k), 2 & rf && core.qc(_t = core.dc()) && (ctx.dt = _t.first);
                },
                inputs: {
                    doc: "doc"
                },
                outputs: {
                    docChange: "docChange"
                },
                decls: 7,
                vars: 1,
                consts: [ [ "rows", "10", "cols", "80", 3, "value" ], [ "dt", "" ], [ 3, "click" ] ],
                template: function(rf, ctx) {
                    1 & rf && (core.Vb(0, "div"), core.Qb(1, "hr"), core.Qb(2, "textarea", 0, 1), core.Qb(4, "br"), 
                    core.Vb(5, "button", 2), core.cc("click", (function($event) {
                        return ctx.dtextSet();
                    })), core.Ec(6, "Show change"), core.Tb(), core.Tb()), 2 & rf && (core.Ab(2), core.lc("value", ctx.text));
                },
                encapsulation: 2
            }), DtComponent;
        })(), lazy_custom_element_component_LazyCustomElementComponent = (() => {
            class LazyCustomElementComponent {
                constructor(elementRef, elementsLoader, logger) {
                    this.elementRef = elementRef, this.elementsLoader = elementsLoader, this.logger = logger, 
                    this.selector = "";
                }
                ngOnInit() {
                    this.selector && !/[^\w-]/.test(this.selector) ? (this.elementRef.nativeElement.innerHTML = `<${this.selector}></${this.selector}>`, 
                    this.elementsLoader.loadCustomElement(this.selector)) : this.logger.error(new Error(`Invalid selector for 'aio-lazy-ce': ${this.selector}`));
                }
            }
            return LazyCustomElementComponent.ɵfac = function(t) {
                return new (t || LazyCustomElementComponent)(core.Pb(core.k), core.Pb(elements_loader_ElementsLoader), core.Pb(logger_service.a));
            }, LazyCustomElementComponent.ɵcmp = core.Jb({
                type: LazyCustomElementComponent,
                selectors: [ [ "aio-lazy-ce" ] ],
                inputs: {
                    selector: "selector"
                },
                decls: 0,
                vars: 0,
                template: function(rf, ctx) {},
                encapsulation: 2
            }), LazyCustomElementComponent;
        })();
        const app_component_c0 = [ "searchBox", "searchResultsView" ];
        function AppComponent_div_1_Template(rf, ctx) {
            1 & rf && (core.Vb(0, "div", 38), core.Qb(1, "mat-progress-bar", 39), core.Tb());
        }
        function AppComponent_img_18_Template(rf, ctx) {
            1 & rf && core.Qb(0, "img", 40);
        }
        function AppComponent_img_19_Template(rf, ctx) {
            1 & rf && core.Qb(0, "img", 41);
        }
        function AppComponent_aio_top_menu_20_Template(rf, ctx) {
            if (1 & rf && core.Qb(0, "aio-top-menu", 42), 2 & rf) {
                const ctx_r4 = core.gc();
                core.lc("nodes", ctx_r4.topMenuNodes);
            }
        }
        function AppComponent_aio_search_results_28_Template(rf, ctx) {
            if (1 & rf) {
                const _r14 = core.Wb();
                core.Vb(0, "aio-search-results", 43, 44), core.cc("resultSelected", (function($event) {
                    return core.uc(_r14), core.gc().hideSearchResults();
                })), core.hc(2, "async"), core.Tb();
            }
            if (2 & rf) {
                const ctx_r6 = core.gc();
                core.lc("searchResults", core.ic(2, 1, ctx_r6.searchResults));
            }
        }
        function AppComponent_aio_nav_menu_32_Template(rf, ctx) {
            if (1 & rf && core.Qb(0, "aio-nav-menu", 27), 2 & rf) {
                const ctx_r8 = core.gc();
                core.lc("nodes", ctx_r8.topMenuNarrowNodes)("currentNode", null == ctx_r8.currentNodes ? null : ctx_r8.currentNodes.TopBarNarrow)("isWide", !1);
            }
        }
        function AppComponent_aio_dt_39_Template(rf, ctx) {
            if (1 & rf) {
                const _r16 = core.Wb();
                core.Vb(0, "aio-dt", 45), core.cc("docChange", (function($event) {
                    return core.uc(_r16), core.gc().currentDocument = $event;
                })), core.Tb();
            }
            if (2 & rf) {
                const ctx_r9 = core.gc();
                core.lc("doc", ctx_r9.currentDocument);
            }
        }
        function AppComponent_div_40_Template(rf, ctx) {
            if (1 & rf) {
                const _r18 = core.Wb();
                core.Vb(0, "div", 46), core.cc("wheel", (function($event) {
                    return core.uc(_r18), core.gc().restrainScrolling($event);
                })), core.Qb(1, "aio-lazy-ce", 47), core.Tb();
            }
            if (2 & rf) {
                const ctx_r10 = core.gc();
                core.Ac("max-height", ctx_r10.tocMaxHeight, "px");
            }
        }
        function AppComponent_div_43_Template(rf, ctx) {
            1 & rf && (core.Vb(0, "div", 48), core.Vb(1, "mat-icon"), core.Ec(2, " "), core.Tb(), 
            core.Tb());
        }
        const app_component_c1 = function(a0) {
            return {
                collapsed: a0
            };
        }, sideNavView = "SideNav";
        let app_component_AppComponent = (() => {
            class AppComponent {
                constructor(deployment, documentService, hostElement, locationService, navigationService, scrollService, searchService, tocService) {
                    this.deployment = deployment, this.documentService = documentService, this.hostElement = hostElement, 
                    this.locationService = locationService, this.navigationService = navigationService, 
                    this.scrollService = scrollService, this.searchService = searchService, this.tocService = tocService, 
                    this.currentNodes = {}, this.dtOn = !1, this.hostClasses = "", this.isStarting = !0, 
                    this.isTransitioning = !0, this.isFetching = !1, this.isSideBySide = !1, this.isSideNavDoc = !1, 
                    this.sideBySideWidth = 992, this.hasFloatingToc = !1, this.showFloatingToc = new BehaviorSubject_BehaviorSubject(!1), 
                    this.showFloatingTocWidth = 800, this.tocMaxHeightOffset = 0, this.showSearchResults = !1, 
                    this.notificationAnimating = !1;
                }
                get isOpened() {
                    return this.isSideBySide && this.isSideNavDoc;
                }
                get mode() {
                    return this.isSideBySide ? "side" : "over";
                }
                ngOnInit() {
                    "Worker" in window && this.searchService.initWorker(2e3), this.onResize(window.innerWidth), 
                    this.documentService.currentDocument.subscribe(doc => this.currentDocument = doc), 
                    this.locationService.currentPath.subscribe(path => {
                        path === this.currentPath ? this.scrollService.scroll() : (this.currentPath = path, 
                        clearTimeout(this.isFetchingTimeout), this.isFetchingTimeout = setTimeout(() => this.isFetching = !0, 200));
                    }), this.navigationService.currentNodes.subscribe(currentNodes => {
                        this.currentNodes = currentNodes, "archive" !== this.deployment.mode || currentNodes[sideNavView] || this.locationService.replace("docs");
                    }), Object(combineLatest.a)([ this.navigationService.versionInfo, this.navigationService.navigationViews.pipe(Object(map.a)(views => views.docVersions)) ]).subscribe(([versionInfo, versions]) => {
                        const computedVersions = [ {
                            title: "next",
                            url: "https://next.angular.io"
                        }, {
                            title: "stable",
                            url: "https://angular.io"
                        } ];
                        "archive" === this.deployment.mode && computedVersions.push({
                            title: `v${versionInfo.major}`
                        }), this.docVersions = [ ...computedVersions, ...versions ], this.currentDocVersion = this.docVersions.find(version => version.title === this.deployment.mode || version.title === `v${versionInfo.major}`), 
                        this.currentDocVersion.title += ` (v${versionInfo.raw})`;
                    }), this.navigationService.navigationViews.subscribe(views => {
                        this.footerNodes = views.Footer || [], this.sideNavNodes = views.SideNav || [], 
                        this.topMenuNodes = views.TopBar || [], this.topMenuNarrowNodes = views.TopBarNarrow || this.topMenuNodes;
                    }), this.navigationService.versionInfo.subscribe(vi => this.versionInfo = vi);
                    const hasNonEmptyToc = this.tocService.tocList.pipe(Object(map.a)(tocList => tocList.length > 0));
                    Object(combineLatest.a)([ hasNonEmptyToc, this.showFloatingToc ]).subscribe(([hasToc, showFloatingToc]) => this.hasFloatingToc = hasToc && showFloatingToc), 
                    Object(combineLatest.a)([ this.documentService.currentDocument, this.navigationService.currentNodes ]).pipe(Object(first.a)()).subscribe(() => this.updateShell());
                }
                onDocReady() {
                    this.isTransitioning = !0, clearTimeout(this.isFetchingTimeout), setTimeout(() => this.isFetching = !1, 500);
                }
                onDocRemoved() {
                    this.scrollService.removeStoredScrollInfo();
                }
                onDocInserted() {
                    setTimeout(() => this.updateShell()), this.scrollService.scrollAfterRender(500);
                }
                onDocRendered() {
                    this.isStarting && setTimeout(() => this.isStarting = !1, 100), this.isTransitioning = !1;
                }
                onDocVersionChange(versionIndex) {
                    const version = this.docVersions[versionIndex];
                    version.url && this.locationService.go(version.url);
                }
                onResize(width) {
                    this.isSideBySide = width >= this.sideBySideWidth, this.showFloatingToc.next(width > this.showFloatingTocWidth), 
                    this.isSideBySide && !this.isSideNavDoc && this.sidenav.toggle(!1);
                }
                onClick(eventTarget, button, ctrlKey, metaKey, altKey) {
                    if (this.searchElements.some(element => element.nativeElement.contains(eventTarget)) || this.hideSearchResults(), 
                    "FOOTER" === eventTarget.tagName && metaKey && altKey) return this.dtOn = !this.dtOn, 
                    !1;
                    let target = eventTarget;
                    for (;target && !(target instanceof HTMLAnchorElement); ) target = target.parentElement;
                    return !(target instanceof HTMLAnchorElement) || this.locationService.handleAnchorClick(target, button, ctrlKey, metaKey);
                }
                setPageId(id) {
                    this.pageId = "index" === id ? "home" : id.replace("/", "-");
                }
                setFolderId(id) {
                    this.folderId = "index" === id ? "home" : id.split("/", 1)[0];
                }
                notificationDismissed() {
                    this.notificationAnimating = !0, setTimeout(() => this.notificationAnimating = !1, 250), 
                    this.updateHostClasses();
                }
                updateHostClasses() {
                    const mode = `mode-${this.deployment.mode}`, sideNavOpen = `sidenav-${this.sidenav.opened ? "open" : "closed"}`, pageClass = `page-${this.pageId}`, folderClass = `folder-${this.folderId}`, viewClasses = Object.keys(this.currentNodes).map(view => `view-${view}`).join(" ");
                    this.hostClasses = [ mode, sideNavOpen, pageClass, folderClass, viewClasses, `aio-notification-${this.notification.showNotification}`, this.notificationAnimating ? "aio-notification-animating" : "" ].join(" ");
                }
                updateShell() {
                    this.updateSideNav(), this.setPageId(this.currentDocument.id), this.setFolderId(this.currentDocument.id), 
                    this.updateHostClasses();
                }
                updateSideNav() {
                    let openSideNav = this.sidenav.opened;
                    const isSideNavDoc = !!this.currentNodes[sideNavView];
                    this.isSideNavDoc !== isSideNavDoc && (openSideNav = this.isSideNavDoc = isSideNavDoc), 
                    this.sidenav.toggle(this.isSideBySide && openSideNav);
                }
                onScroll() {
                    if (!this.tocMaxHeightOffset) {
                        const el = this.hostElement.nativeElement, headerEl = el.querySelector(".app-toolbar"), footerEl = el.querySelector("footer");
                        headerEl && footerEl && (this.tocMaxHeightOffset = headerEl.clientHeight + footerEl.clientHeight + 24);
                    }
                    this.tocMaxHeight = (document.body.scrollHeight - window.pageYOffset - this.tocMaxHeightOffset).toFixed(2);
                }
                restrainScrolling(evt) {
                    const elem = evt.currentTarget, scrollTop = elem.scrollTop;
                    evt.deltaY < 0 ? scrollTop < 1 && evt.preventDefault() : elem.scrollHeight - elem.clientHeight - scrollTop < 1 && evt.preventDefault();
                }
                hideSearchResults() {
                    this.showSearchResults = !1;
                    const oldSearch = this.locationService.search();
                    void 0 !== oldSearch.search && this.locationService.setSearch("", Object.assign(Object.assign({}, oldSearch), {
                        search: void 0
                    }));
                }
                focusSearchBox() {
                    this.searchBox && this.searchBox.focus();
                }
                doSearch(query) {
                    this.searchResults = this.searchService.search(query), this.showSearchResults = !!query;
                }
                onKeyUp(key, keyCode) {
                    "/" !== key && 191 !== keyCode || this.focusSearchBox(), "Escape" !== key && 27 !== keyCode || this.showSearchResults && (this.hideSearchResults(), 
                    this.focusSearchBox());
                }
            }
            return AppComponent.ɵfac = function(t) {
                return new (t || AppComponent)(core.Pb(deployment_service_Deployment), core.Pb(document_service.c), core.Pb(core.k), core.Pb(location_service.a), core.Pb(navigation_service_NavigationService), core.Pb(scroll_service.a), core.Pb(search_service.a), core.Pb(toc_service.a));
            }, AppComponent.ɵcmp = core.Jb({
                type: AppComponent,
                selectors: [ [ "aio-shell" ] ],
                viewQuery: function(rf, ctx) {
                    var _t;
                    1 & rf && (core.yc(search_box_component_SearchBoxComponent, !0), core.yc(sidenav_MatSidenav, !0), 
                    core.yc(notification_component_NotificationComponent, !0), core.Jc(app_component_c0, !0, core.k)), 
                    2 & rf && (core.qc(_t = core.dc()) && (ctx.searchBox = _t.first), core.qc(_t = core.dc()) && (ctx.sidenav = _t.first), 
                    core.qc(_t = core.dc()) && (ctx.notification = _t.first), core.qc(_t = core.dc()) && (ctx.searchElements = _t));
                },
                hostBindings: function(rf, ctx, elIndex) {
                    1 & rf && (core.Bb(3), core.cc("resize", (function($event) {
                        return ctx.onResize($event.target.innerWidth);
                    }), !1, core.tc), core.cc("click", (function($event) {
                        return ctx.onClick($event.target, $event.button, $event.ctrlKey, $event.metaKey, $event.altKey);
                    })), core.cc("scroll", (function($event) {
                        return ctx.onScroll();
                    }), !1, core.tc), core.cc("keyup", (function($event) {
                        return ctx.onKeyUp($event.key, $event.which);
                    }), !1, core.sc)), 2 & rf && (core.Ic("@.disabled", ctx.isStarting), core.Db(ctx.hostClasses));
                },
                decls: 44,
                vars: 31,
                consts: [ [ "id", "top-of-page" ], [ "class", "progress-bar-container", 4, "ngIf" ], [ "color", "primary", 1, "app-toolbar", "no-print" ], [ 1, "notification-container" ], [ "notificationId", "survey-february-2019", "expirationDate", "2019-03-01", 3, "dismissOnContentClick", "dismissed" ], [ "href", "http://bit.ly/angular-survey-2019" ], [ "svgIcon", "insert_comment", "aria-label", "Announcement", 1, "icon" ], [ 1, "message" ], [ 1, "action-button" ], [ "mat-button", "", "title", "Docs menu", 1, "hamburger", 3, "click" ], [ "svgIcon", "menu" ], [ "href", "/", 1, "nav-link", "home", 3, "ngSwitch" ], [ "src", "assets/images/logos/angular/logo-nav@2x.png", "width", "150", "height", "40", "title", "Home", "alt", "Home", 4, "ngSwitchCase" ], [ "src", "assets/images/logos/angular/shield-large.svg", "width", "37", "height", "40", "title", "Home", "alt", "Home", 4, "ngSwitchDefault" ], [ 3, "nodes", 4, "ngIf" ], [ 1, "search-container", 3, "onSearch", "onFocus" ], [ "searchBox", "" ], [ 1, "toolbar-external-icons-container" ], [ "href", "https://twitter.com/angular", "title", "Twitter", "aria-label", "Angular on twitter" ], [ "svgIcon", "logos:twitter" ], [ "href", "https://github.com/angular/angular", "title", "GitHub", "aria-label", "Angular on github" ], [ "svgIcon", "logos:github" ], [ 3, "searchResults", "resultSelected", 4, "ngIf" ], [ "role", "main", 1, "sidenav-container" ], [ 1, "sidenav", 3, "ngClass", "mode", "opened", "openedChange" ], [ "sidenav", "" ], [ 3, "nodes", "currentNode", "isWide", 4, "ngIf" ], [ 3, "nodes", "currentNode", "isWide" ], [ 1, "doc-version" ], [ 3, "options", "selected", "change" ], [ "role", "main", 1, "sidenav-content", 3, "id" ], [ 3, "mode", "version" ], [ 3, "doc", "docReady", "docRemoved", "docInserted", "docRendered" ], [ 3, "doc", "docChange", 4, "ngIf" ], [ "class", "toc-container no-print", 3, "max-height", "wheel", 4, "ngIf" ], [ 1, "no-print" ], [ 3, "nodes", "versionInfo" ], [ "class", "cdk-visually-hidden", 4, "ngIf" ], [ 1, "progress-bar-container" ], [ "mode", "indeterminate", "color", "warn" ], [ "src", "assets/images/logos/angular/logo-nav@2x.png", "width", "150", "height", "40", "title", "Home", "alt", "Home" ], [ "src", "assets/images/logos/angular/shield-large.svg", "width", "37", "height", "40", "title", "Home", "alt", "Home" ], [ 3, "nodes" ], [ 3, "searchResults", "resultSelected" ], [ "searchResultsView", "" ], [ 3, "doc", "docChange" ], [ 1, "toc-container", "no-print", 3, "wheel" ], [ "selector", "aio-toc" ], [ 1, "cdk-visually-hidden" ] ],
                template: function(rf, ctx) {
                    if (1 & rf) {
                        const _r19 = core.Wb();
                        core.Qb(0, "div", 0), core.Cc(1, AppComponent_div_1_Template, 2, 0, "div", 1), core.Vb(2, "mat-toolbar", 2), 
                        core.Vb(3, "mat-toolbar-row", 3), core.Vb(4, "aio-notification", 4), core.cc("dismissed", (function($event) {
                            return ctx.notificationDismissed();
                        })), core.Vb(5, "a", 5), core.Qb(6, "mat-icon", 6), core.Vb(7, "span", 7), core.Ec(8, "Help Angular by taking a "), 
                        core.Vb(9, "b"), core.Ec(10, "1 minute survey"), core.Tb(), core.Ec(11, "!"), core.Tb(), 
                        core.Vb(12, "span", 8), core.Ec(13, "Go to survey"), core.Tb(), core.Tb(), core.Tb(), 
                        core.Tb(), core.Vb(14, "mat-toolbar-row"), core.Vb(15, "button", 9), core.cc("click", (function($event) {
                            return core.uc(_r19), core.rc(31).toggle();
                        })), core.Qb(16, "mat-icon", 10), core.Tb(), core.Vb(17, "a", 11), core.Cc(18, AppComponent_img_18_Template, 1, 0, "img", 12), 
                        core.Cc(19, AppComponent_img_19_Template, 1, 0, "img", 13), core.Tb(), core.Cc(20, AppComponent_aio_top_menu_20_Template, 1, 1, "aio-top-menu", 14), 
                        core.Vb(21, "aio-search-box", 15, 16), core.cc("onSearch", (function($event) {
                            return ctx.doSearch($event);
                        })), core.cc("onFocus", (function($event) {
                            return ctx.doSearch($event);
                        })), core.Tb(), core.Vb(23, "div", 17), core.Vb(24, "a", 18), core.Qb(25, "mat-icon", 19), 
                        core.Tb(), core.Vb(26, "a", 20), core.Qb(27, "mat-icon", 21), core.Tb(), core.Tb(), 
                        core.Tb(), core.Tb(), core.Cc(28, AppComponent_aio_search_results_28_Template, 3, 3, "aio-search-results", 22), 
                        core.Vb(29, "mat-sidenav-container", 23), core.Vb(30, "mat-sidenav", 24, 25), core.cc("openedChange", (function($event) {
                            return ctx.updateHostClasses();
                        })), core.Cc(32, AppComponent_aio_nav_menu_32_Template, 1, 3, "aio-nav-menu", 26), 
                        core.Qb(33, "aio-nav-menu", 27), core.Vb(34, "div", 28), core.Vb(35, "aio-select", 29), 
                        core.cc("change", (function($event) {
                            return ctx.onDocVersionChange($event.index);
                        })), core.Tb(), core.Tb(), core.Tb(), core.Vb(36, "main", 30), core.Qb(37, "aio-mode-banner", 31), 
                        core.Vb(38, "aio-doc-viewer", 32), core.cc("docReady", (function($event) {
                            return ctx.onDocReady();
                        })), core.cc("docRemoved", (function($event) {
                            return ctx.onDocRemoved();
                        })), core.cc("docInserted", (function($event) {
                            return ctx.onDocInserted();
                        })), core.cc("docRendered", (function($event) {
                            return ctx.onDocRendered();
                        })), core.Tb(), core.Cc(39, AppComponent_aio_dt_39_Template, 1, 1, "aio-dt", 33), 
                        core.Tb(), core.Tb(), core.Cc(40, AppComponent_div_40_Template, 2, 1, "div", 34), 
                        core.Vb(41, "footer", 35), core.Qb(42, "aio-footer", 36), core.Tb(), core.Cc(43, AppComponent_div_43_Template, 3, 0, "div", 37);
                    }
                    2 & rf && (core.Ab(1), core.lc("ngIf", ctx.isFetching), core.Ab(1), core.Fb("transitioning", ctx.isTransitioning), 
                    core.Ab(2), core.lc("dismissOnContentClick", !0), core.Ab(11), core.Fb("starting", ctx.isStarting), 
                    core.Ab(2), core.lc("ngSwitch", ctx.isSideBySide), core.Ab(1), core.lc("ngSwitchCase", !0), 
                    core.Ab(2), core.lc("ngIf", ctx.isSideBySide), core.Ab(8), core.lc("ngIf", ctx.showSearchResults), 
                    core.Ab(1), core.Fb("starting", ctx.isStarting), core.Fb("has-floating-toc", ctx.hasFloatingToc), 
                    core.Ab(1), core.lc("ngClass", core.oc(29, app_component_c1, !ctx.isSideBySide))("mode", ctx.mode)("opened", ctx.isOpened), 
                    core.Ab(2), core.lc("ngIf", !ctx.isSideBySide), core.Ab(1), core.lc("nodes", ctx.sideNavNodes)("currentNode", null == ctx.currentNodes ? null : ctx.currentNodes.SideNav)("isWide", ctx.isSideBySide), 
                    core.Ab(2), core.lc("options", ctx.docVersions)("selected", ctx.currentDocVersion), 
                    core.Ab(1), core.lc("id", ctx.pageId), core.Ab(1), core.lc("mode", ctx.deployment.mode)("version", ctx.versionInfo), 
                    core.Ab(1), core.Fb("no-animations", ctx.isStarting), core.lc("doc", ctx.currentDocument), 
                    core.Ab(1), core.lc("ngIf", ctx.dtOn), core.Ab(1), core.lc("ngIf", ctx.hasFloatingToc), 
                    core.Ab(2), core.lc("nodes", ctx.footerNodes)("versionInfo", ctx.versionInfo), core.Ab(1), 
                    core.lc("ngIf", !ctx.isStarting));
                },
                directives: [ common.k, toolbar_MatToolbar, toolbar_MatToolbarRow, notification_component_NotificationComponent, icon.a, fesm2015_button.a, common.m, common.n, common.o, search_box_component_SearchBoxComponent, sidenav_MatSidenavContainer, sidenav_MatSidenav, common.i, nav_menu_component_NavMenuComponent, select_component.a, mode_banner_component_ModeBannerComponent, doc_viewer_component_DocViewerComponent, footer_component_FooterComponent, progress_bar_MatProgressBar, top_menu_component_TopMenuComponent, search_results_component.a, dt_component_DtComponent, lazy_custom_element_component_LazyCustomElementComponent ],
                pipes: [ common.b ],
                encapsulation: 2
            }), AppComponent;
        })();
        const SVG_ICONS = new core.p("SvgIcons"), DEFAULT_NS = "$$default";
        let custom_icon_registry_CustomIconRegistry = (() => {
            class CustomIconRegistry extends icon.c {
                constructor(http, sanitizer, document, svgIcons) {
                    super(http, sanitizer, document), this.preloadedSvgElements = {
                        [DEFAULT_NS]: {}
                    }, this.loadSvgElements(svgIcons);
                }
                getNamedSvgIcon(iconName, namespace) {
                    const nsIconMap = this.preloadedSvgElements[namespace || DEFAULT_NS], preloadedElement = nsIconMap && nsIconMap[iconName];
                    return preloadedElement ? Object(of.a)(preloadedElement.cloneNode(!0)) : super.getNamedSvgIcon(iconName, namespace);
                }
                loadSvgElements(svgIcons) {
                    const div = document.createElement("DIV");
                    svgIcons.forEach(icon => {
                        const ns = icon.namespace || DEFAULT_NS, nsIconMap = this.preloadedSvgElements[ns] || (this.preloadedSvgElements[ns] = {});
                        div.innerHTML = icon.svgSource, nsIconMap[icon.name] = div.querySelector("svg");
                    });
                }
            }
            return CustomIconRegistry.ɵfac = function(t) {
                return new (t || CustomIconRegistry)(core.Zb(http.a), core.Zb(platform_browser.b), core.Zb(common.d, 8), core.Zb(SVG_ICONS));
            }, CustomIconRegistry.ɵprov = core.Lb({
                token: CustomIconRegistry,
                factory: function(t) {
                    return CustomIconRegistry.ɵfac(t);
                },
                providedIn: null
            }), CustomIconRegistry;
        })();
        var ga_service = __webpack_require__("4MUX");
        let reporting_error_handler_ReportingErrorHandler = (() => {
            class ReportingErrorHandler extends core.l {
                constructor(window) {
                    super(), this.window = window;
                }
                handleError(error) {
                    try {
                        super.handleError(error);
                    } catch (e) {
                        this.reportError(e);
                    }
                    this.reportError(error);
                }
                reportError(error) {
                    this.window.onerror && ("string" == typeof error ? this.window.onerror(error) : this.window.onerror(error.message, void 0, void 0, void 0, error));
                }
            }
            return ReportingErrorHandler.ɵfac = function(t) {
                return new (t || ReportingErrorHandler)(core.Zb(shared_window.a));
            }, ReportingErrorHandler.ɵprov = core.Lb({
                token: ReportingErrorHandler,
                factory: function(t) {
                    return ReportingErrorHandler.ɵfac(t);
                },
                providedIn: null
            }), ReportingErrorHandler;
        })();
        var scroll_spy_service = __webpack_require__("FiGy");
        __webpack_require__("sVev"), __webpack_require__("NXyV"), __webpack_require__("EY2u"), 
        __webpack_require__("0EUg"), __webpack_require__("7o/Q"), __webpack_require__("4I5i"), 
        __webpack_require__("XDbj"), __webpack_require__("xbPD"), __webpack_require__("SpAZ"), 
        __webpack_require__("5+tZ"), __webpack_require__("bOdf"), __webpack_require__("mCNh"), 
        __webpack_require__("nYR2"), __webpack_require__("bHdf");
        const ROUTES = new core.p("ROUTES");
        let custom_elements_module_CustomElementsModule = (() => {
            class CustomElementsModule {}
            return CustomElementsModule.ɵmod = core.Nb({
                type: CustomElementsModule
            }), CustomElementsModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || CustomElementsModule);
                },
                providers: [ elements_loader_ElementsLoader, {
                    provide: ELEMENT_MODULE_LOAD_CALLBACKS_TOKEN,
                    useValue: ELEMENT_MODULE_LOAD_CALLBACKS
                }, {
                    provide: ROUTES,
                    useValue: ELEMENT_MODULE_LOAD_CALLBACKS_AS_ROUTES,
                    multi: !0
                } ]
            }), CustomElementsModule;
        })();
        var shared_module = __webpack_require__("PCNd"), sw_updates_service = __webpack_require__("iL+y");
        let sw_updates_module_SwUpdatesModule = (() => {
            class SwUpdatesModule {}
            return SwUpdatesModule.ɵmod = core.Nb({
                type: SwUpdatesModule
            }), SwUpdatesModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || SwUpdatesModule);
                },
                providers: [ sw_updates_service.a ]
            }), SwUpdatesModule;
        })();
        const svgIconProviders = [ {
            provide: SVG_ICONS,
            useValue: {
                name: "close",
                svgSource: '<svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" /><path d="M0 0h24v24H0z" fill="none" /></svg>'
            },
            multi: !0
        }, {
            provide: SVG_ICONS,
            useValue: {
                name: "insert_comment",
                svgSource: '<svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z" /><path d="M0 0h24v24H0z" fill="none" /></svg>'
            },
            multi: !0
        }, {
            provide: SVG_ICONS,
            useValue: {
                name: "keyboard_arrow_right",
                svgSource: '<svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z" /></svg>'
            },
            multi: !0
        }, {
            provide: SVG_ICONS,
            useValue: {
                name: "menu",
                svgSource: '<svg focusable="false" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z" /></svg>'
            },
            multi: !0
        }, {
            provide: SVG_ICONS,
            useValue: {
                namespace: "logos",
                name: "github",
                svgSource: '<svg focusable="false" viewBox="0 0 51.8 50.4" xmlns="http://www.w3.org/2000/svg"><path d="M25.9,0.2C11.8,0.2,0.3,11.7,0.3,25.8c0,11.3,7.3,20.9,17.5,24.3c1.3,0.2,1.7-0.6,1.7-1.2c0-0.6,0-2.6,0-4.8c-7.1,1.5-8.6-3-8.6-3c-1.2-3-2.8-3.7-2.8-3.7c-2.3-1.6,0.2-1.6,0.2-1.6c2.6,0.2,3.9,2.6,3.9,2.6c2.3,3.9,6,2.8,7.5,2.1c0.2-1.7,0.9-2.8,1.6-3.4c-5.7-0.6-11.7-2.8-11.7-12.7c0-2.8,1-5.1,2.6-6.9c-0.3-0.7-1.1-3.3,0.3-6.8c0,0,2.1-0.7,7,2.6c2-0.6,4.2-0.9,6.4-0.9c2.2,0,4.4,0.3,6.4,0.9c4.9-3.3,7-2.6,7-2.6c1.4,3.5,0.5,6.1,0.3,6.8c1.6,1.8,2.6,4.1,2.6,6.9c0,9.8-6,12-11.7,12.6c0.9,0.8,1.7,2.4,1.7,4.7c0,3.4,0,6.2,0,7c0,0.7,0.5,1.5,1.8,1.2c10.2-3.4,17.5-13,17.5-24.3C51.5,11.7,40.1,0.2,25.9,0.2z" /></svg>'
            },
            multi: !0
        }, {
            provide: SVG_ICONS,
            useValue: {
                namespace: "logos",
                name: "twitter",
                svgSource: '<svg focusable="false" viewBox="0 0 50 59" xmlns="http://www.w3.org/2000/svg"><path d="M50,9.3c-1.8,0.8-3.8,1.4-5.9,1.6c2.1-1.3,3.7-3.3,4.5-5.7c-2,1.2-4.2,2-6.5,2.5c-1.9-2-4.5-3.2-7.5-3.2c-5.7,0-10.3,4.6-10.3,10.3c0,0.8,0.1,1.6,0.3,2.3C16.1,16.7,8.5,12.6,3.5,6.4c-0.9,1.5-1.4,3.3-1.4,5.2c0,3.6,1.8,6.7,4.6,8.5C5,20,3.4,19.6,2,18.8c0,0,0,0.1,0,0.1c0,5,3.5,9.1,8.2,10.1c-0.9,0.2-1.8,0.4-2.7,0.4c-0.7,0-1.3-0.1-1.9-0.2c1.3,4.1,5.1,7,9.6,7.1c-3.5,2.8-7.9,4.4-12.7,4.4c-0.8,0-1.6,0-2.4-0.1c4.5,2.9,9.9,4.6,15.7,4.6c18.9,0,29.2-15.6,29.2-29.2c0-0.4,0-0.9,0-1.3C46.9,13.2,48.6,11.4,50,9.3z" /></svg>'
            },
            multi: !0
        } ];
        let app_module_AppModule = (() => {
            class AppModule {}
            return AppModule.ɵmod = core.Nb({
                type: AppModule,
                bootstrap: [ app_component_AppComponent ]
            }), AppModule.ɵinj = core.Mb({
                factory: function(t) {
                    return new (t || AppModule);
                },
                providers: [ deployment_service_Deployment, document_service.c, {
                    provide: core.l,
                    useClass: reporting_error_handler_ReportingErrorHandler
                }, ga_service.a, logger_service.a, common.g, {
                    provide: common.h,
                    useClass: common.p
                }, location_service.a, {
                    provide: icon.c,
                    useClass: custom_icon_registry_CustomIconRegistry
                }, navigation_service_NavigationService, scroll_service.a, scroll_spy_service.a, search_service.a, svgIconProviders, toc_service.a, {
                    provide: CurrentDateToken,
                    useFactory: currentDateProvider
                }, {
                    provide: shared_window.a,
                    useFactory: shared_window.b
                } ],
                imports: [ [ platform_browser.a, animations.b, custom_elements_module_CustomElementsModule, http.b, fesm2015_button.b, icon.b, progress_bar_MatProgressBarModule, sidenav_MatSidenavModule, toolbar_MatToolbarModule, sw_updates_module_SwUpdatesModule, shared_module.a, service_worker.a.register("/ngsw-worker.js", {
                    enabled: environment.a.production
                }) ] ]
            }), AppModule;
        })();
        environment.a.production && Object(core.S)(), platform_browser.f().bootstrapModule(app_module_AppModule);
    },
    zn8P: function(module, exports) {
        function webpackEmptyAsyncContext(req) {
            return Promise.resolve().then((function() {
                var e = new Error("Cannot find module '" + req + "'");
                throw e.code = "MODULE_NOT_FOUND", e;
            }));
        }
        webpackEmptyAsyncContext.keys = function() {
            return [];
        }, webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext, module.exports = webpackEmptyAsyncContext, 
        webpackEmptyAsyncContext.id = "zn8P";
    }
}, [ [ 0, 0 ] ] ]);
//# sourceMappingURL=main.js.map